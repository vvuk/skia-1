/* automatically generated by rust-bindgen */

extern "C" {
    #[link_name = "?SkNO_RETURN_HINT@@YAXXZ"]
    pub fn SkNO_RETURN_HINT();
}
#[repr(C)]
#[derive(Debug)]
pub struct std___atomic_base<_ITp> {
    pub _M_i: std___atomic_base___int_type<_ITp>,
}
pub type std___atomic_base___int_type<_ITp> = _ITp;
#[repr(C)]
#[derive(Debug)]
pub struct std_atomic<_Tp> {
    pub _M_i: _Tp,
}
#[test]
fn __bindgen_test_layout_template_1() {
    assert_eq!(::std::mem::size_of::<std_atomic<::std::os::raw::c_uchar>>() ,
               1usize);
    assert_eq!(::std::mem::align_of::<std_atomic<::std::os::raw::c_uchar>>() ,
               1usize);
}
#[test]
fn __bindgen_test_layout_template_2() {
    assert_eq!(::std::mem::size_of::<std_atomic<::std::os::raw::c_int>>() ,
               1usize);
    assert_eq!(::std::mem::align_of::<std_atomic<::std::os::raw::c_int>>() ,
               1usize);
}
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    #[link_name = "?SkDebugf@@YAXQEBDZZ"]
    pub fn SkDebugf(format: *const ::std::os::raw::c_char);
}
/** 32 bit integer to hold a unicode value
*/
pub type SkUnichar = i32;
pub type SkScalar = f32;
/** \class SkString

    Light weight class for managing strings. Uses reference
    counting to make string assignments and copies very fast
    with no extra RAM cost. Assumes UTF8 encoding.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkString {
    pub fRec: *mut SkString_Rec,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkString_Rec {
    pub fLength: u32,
    pub fRefCnt: i32,
    pub fBeginningOfData: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SkString_Rec() {
    assert_eq!(::std::mem::size_of::<SkString_Rec>() , 12usize);
    assert_eq!(::std::mem::align_of::<SkString_Rec>() , 4usize);
}
impl Clone for SkString_Rec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "?gEmptyRec@SkString@@0URec@1@B"]
    pub static SkString_gEmptyRec: SkString_Rec;
}
#[test]
fn bindgen_test_layout_SkString() {
    assert_eq!(::std::mem::size_of::<SkString>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkString>() , 8usize);
}
extern "C" {
    #[link_name = "?equals@SkString@@QEBA_NAEBV1@@Z"]
    pub fn SkString_equals(this: *const SkString, arg1: *const SkString)
     -> bool;
}
extern "C" {
    #[link_name = "?equals@SkString@@QEBA_NQEBD@Z"]
    pub fn SkString_equals1(this: *const SkString,
                            text: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?equals@SkString@@QEBA_NQEBD_K@Z"]
    pub fn SkString_equals2(this: *const SkString,
                            text: *const ::std::os::raw::c_char, len: usize)
     -> bool;
}
extern "C" {
    #[link_name = "?writable_str@SkString@@QEAAPEADXZ"]
    pub fn SkString_writable_str(this: *mut SkString)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?reset@SkString@@QEAAXXZ"]
    pub fn SkString_reset(this: *mut SkString);
}
extern "C" {
    #[link_name = "?set@SkString@@QEAAXQEBD@Z"]
    pub fn SkString_set(this: *mut SkString,
                        text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?set@SkString@@QEAAXQEBD_K@Z"]
    pub fn SkString_set1(this: *mut SkString,
                         text: *const ::std::os::raw::c_char, len: usize);
}
extern "C" {
    #[link_name = "?setUTF16@SkString@@QEAAXQEBG@Z"]
    pub fn SkString_setUTF16(this: *mut SkString, arg1: *const u16);
}
extern "C" {
    #[link_name = "?setUTF16@SkString@@QEAAXQEBG_K@Z"]
    pub fn SkString_setUTF161(this: *mut SkString, arg1: *const u16,
                              len: usize);
}
extern "C" {
    #[link_name = "?insert@SkString@@QEAAX_KQEBD@Z"]
    pub fn SkString_insert(this: *mut SkString, offset: usize,
                           text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?insert@SkString@@QEAAX_KQEBD0@Z"]
    pub fn SkString_insert1(this: *mut SkString, offset: usize,
                            text: *const ::std::os::raw::c_char, len: usize);
}
extern "C" {
    #[link_name = "?insertUnichar@SkString@@QEAAX_KH@Z"]
    pub fn SkString_insertUnichar(this: *mut SkString, offset: usize,
                                  arg1: SkUnichar);
}
extern "C" {
    #[link_name = "?insertS32@SkString@@QEAAX_KH@Z"]
    pub fn SkString_insertS32(this: *mut SkString, offset: usize, value: i32);
}
extern "C" {
    #[link_name = "?insertS64@SkString@@QEAAX_K_JH@Z"]
    pub fn SkString_insertS64(this: *mut SkString, offset: usize, value: i64,
                              minDigits: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?insertU32@SkString@@QEAAX_KI@Z"]
    pub fn SkString_insertU32(this: *mut SkString, offset: usize, value: u32);
}
extern "C" {
    #[link_name = "?insertU64@SkString@@QEAAX_K0H@Z"]
    pub fn SkString_insertU64(this: *mut SkString, offset: usize, value: u64,
                              minDigits: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?insertHex@SkString@@QEAAX_KIH@Z"]
    pub fn SkString_insertHex(this: *mut SkString, offset: usize, value: u32,
                              minDigits: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?insertScalar@SkString@@QEAAX_KM@Z"]
    pub fn SkString_insertScalar(this: *mut SkString, offset: usize,
                                 arg1: SkScalar);
}
extern "C" {
    #[link_name = "?printf@SkString@@QEAAXQEBDZZ"]
    pub fn SkString_printf(this: *mut SkString,
                           format: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?appendf@SkString@@QEAAXQEBDZZ"]
    pub fn SkString_appendf(this: *mut SkString,
                            format: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?appendVAList@SkString@@QEAAXQEBDPEAD@Z"]
    pub fn SkString_appendVAList(this: *mut SkString,
                                 format: *const ::std::os::raw::c_char,
                                 arg1: va_list);
}
extern "C" {
    #[link_name = "?prependf@SkString@@QEAAXQEBDZZ"]
    pub fn SkString_prependf(this: *mut SkString,
                             format: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?prependVAList@SkString@@QEAAXQEBDPEAD@Z"]
    pub fn SkString_prependVAList(this: *mut SkString,
                                  format: *const ::std::os::raw::c_char,
                                  arg1: va_list);
}
extern "C" {
    #[link_name = "?remove@SkString@@QEAAX_K0@Z"]
    pub fn SkString_remove(this: *mut SkString, offset: usize, length: usize);
}
extern "C" {
    /**
     *  Swap contents between this and other. This function is guaranteed
     *  to never fail or throw.
     */
    #[link_name = "?swap@SkString@@QEAAXAEAV1@@Z"]
    pub fn SkString_swap(this: *mut SkString, other: *mut SkString);
}
impl SkString {
    #[inline]
    pub unsafe fn equals(&self, arg1: *const SkString) -> bool {
        SkString_equals(&*self, arg1)
    }
    #[inline]
    pub unsafe fn equals1(&self, text: *const ::std::os::raw::c_char)
     -> bool {
        SkString_equals1(&*self, text)
    }
    #[inline]
    pub unsafe fn equals2(&self, text: *const ::std::os::raw::c_char,
                          len: usize) -> bool {
        SkString_equals2(&*self, text, len)
    }
    #[inline]
    pub unsafe fn writable_str(&mut self) -> *mut ::std::os::raw::c_char {
        SkString_writable_str(&mut *self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) { SkString_reset(&mut *self) }
    #[inline]
    pub unsafe fn set(&mut self, text: *const ::std::os::raw::c_char) {
        SkString_set(&mut *self, text)
    }
    #[inline]
    pub unsafe fn set1(&mut self, text: *const ::std::os::raw::c_char,
                       len: usize) {
        SkString_set1(&mut *self, text, len)
    }
    #[inline]
    pub unsafe fn setUTF16(&mut self, arg1: *const u16) {
        SkString_setUTF16(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setUTF161(&mut self, arg1: *const u16, len: usize) {
        SkString_setUTF161(&mut *self, arg1, len)
    }
    #[inline]
    pub unsafe fn insert(&mut self, offset: usize,
                         text: *const ::std::os::raw::c_char) {
        SkString_insert(&mut *self, offset, text)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, offset: usize,
                          text: *const ::std::os::raw::c_char, len: usize) {
        SkString_insert1(&mut *self, offset, text, len)
    }
    #[inline]
    pub unsafe fn insertUnichar(&mut self, offset: usize, arg1: SkUnichar) {
        SkString_insertUnichar(&mut *self, offset, arg1)
    }
    #[inline]
    pub unsafe fn insertS32(&mut self, offset: usize, value: i32) {
        SkString_insertS32(&mut *self, offset, value)
    }
    #[inline]
    pub unsafe fn insertS64(&mut self, offset: usize, value: i64,
                            minDigits: ::std::os::raw::c_int) {
        SkString_insertS64(&mut *self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertU32(&mut self, offset: usize, value: u32) {
        SkString_insertU32(&mut *self, offset, value)
    }
    #[inline]
    pub unsafe fn insertU64(&mut self, offset: usize, value: u64,
                            minDigits: ::std::os::raw::c_int) {
        SkString_insertU64(&mut *self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertHex(&mut self, offset: usize, value: u32,
                            minDigits: ::std::os::raw::c_int) {
        SkString_insertHex(&mut *self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertScalar(&mut self, offset: usize, arg1: SkScalar) {
        SkString_insertScalar(&mut *self, offset, arg1)
    }
    #[inline]
    pub unsafe fn printf(&mut self,
                         format: *const ::std::os::raw::c_char) {
        SkString_printf(&mut *self, format)
    }
    #[inline]
    pub unsafe fn appendf(&mut self,
                          format: *const ::std::os::raw::c_char) {
        SkString_appendf(&mut *self, format)
    }
    #[inline]
    pub unsafe fn appendVAList(&mut self,
                               format: *const ::std::os::raw::c_char,
                               arg1: va_list) {
        SkString_appendVAList(&mut *self, format, arg1)
    }
    #[inline]
    pub unsafe fn prependf(&mut self,
                           format: *const ::std::os::raw::c_char) {
        SkString_prependf(&mut *self, format)
    }
    #[inline]
    pub unsafe fn prependVAList(&mut self,
                                format: *const ::std::os::raw::c_char,
                                arg1: va_list) {
        SkString_prependVAList(&mut *self, format, arg1)
    }
    #[inline]
    pub unsafe fn remove(&mut self, offset: usize, length: usize) {
        SkString_remove(&mut *self, offset, length)
    }
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkString) {
        SkString_swap(&mut *self, other)
    }
}
/**
 *  Fast type for unsigned 8 bits. Use for parameter passing and local
 *  variables, not for storage
 */
pub type U8CPU = ::std::os::raw::c_uint;
/**
 *  Fast type for signed 16 bits. Use for parameter passing and local variables,
 *  not for storage
 */
pub type S16CPU = ::std::os::raw::c_int;
/**
 *  Fast type for unsigned 16 bits. Use for parameter passing and local
 *  variables, not for storage
 */
pub type U16CPU = ::std::os::raw::c_uint;
/**
 *  Meant to be a small version of bool, for storage purposes. Will be 0 or 1
 */
pub type SkBool8 = u8;
extern "C" {
    /** Returns true if the value can be represented with signed 16bits
 */
    #[link_name = "?SkIsS16@@YA_NJ@Z"]
    pub fn SkIsS16(x: ::std::os::raw::c_long) -> bool;
}
extern "C" {
    /** Returns true if the value can be represented with unsigned 16bits
 */
    #[link_name = "?SkIsU16@@YA_NJ@Z"]
    pub fn SkIsU16(x: ::std::os::raw::c_long) -> bool;
}
extern "C" {
    #[link_name = "?SkLeftShift@@YAHHH@Z"]
    pub fn SkLeftShift(value: i32, shift: i32) -> i32;
}
extern "C" {
    #[link_name = "?SkLeftShift@@YA_J_JH@Z"]
    pub fn SkLeftShift1(value: i64, shift: i32) -> i64;
}
/** 16 bit unsigned integer to hold a glyph index
*/
pub type SkGlyphID = u16;
extern "C" {
    /** Faster than SkToBool for integral conditions. Returns 0 or 1
*/
    #[link_name = "?Sk32ToBool@@YAHI@Z"]
    pub fn Sk32ToBool(n: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkAbs32@@YAHH@Z"]
    pub fn SkAbs32(value: i32) -> i32;
}
extern "C" {
    #[link_name = "?SkMax32@@YAHHH@Z"]
    pub fn SkMax32(a: i32, b: i32) -> i32;
}
extern "C" {
    #[link_name = "?SkMin32@@YAHHH@Z"]
    pub fn SkMin32(a: i32, b: i32) -> i32;
}
extern "C" {
    #[link_name = "?SkSign32@@YAHH@Z"]
    pub fn SkSign32(a: i32) -> i32;
}
extern "C" {
    #[link_name = "?SkFastMin32@@YAHHH@Z"]
    pub fn SkFastMin32(value: i32, max: i32) -> i32;
}
#[repr(u8)]
/**
 *  Indicates whether an allocation should count against a cache budget.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkBudgeted { kNo = 0, kYes = 1, }
/** \class SkNoncopyable

SkNoncopyable is the base class for objects that do not want to
be copied. It hides its copy-constructor and its assignment-operator.
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkNoncopyable {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkNoncopyable() {
    assert_eq!(::std::mem::size_of::<SkNoncopyable>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkNoncopyable>() , 1usize);
}
impl Clone for SkNoncopyable {
    fn clone(&self) -> Self { *self }
}
/**
 *  Shared pointer class to wrap classes that support a ref()/unref() interface.
 *
 *  This can be used for classes inheriting from SkRefCnt, but it also works for other
 *  classes that match the interface, but have different internal choices: e.g. the hosted class
 *  may have its ref/unref be thread-safe, but that is not assumed/imposed by sk_sp.
 */
#[repr(C)]
#[derive(Debug)]
pub struct sk_sp<T> {
    pub fPtr: *mut T,
}
/** Supports safe bool idiom. Obsolete with explicit operator bool. */
pub type sk_sp_unspecified_bool_type<T> = *mut *mut T;
pub type sk_sp_element_type<T> = T;
/**
 *  SkData holds an immutable data buffer. Not only is the data immutable,
 *  but the actual ptr that is returned (by data() or bytes()) is guaranteed
 *  to always be the same for the life of this instance.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkData {
    pub fReleaseProc: SkData_ReleaseProc,
    pub fReleaseProcContext: *mut ::std::os::raw::c_void,
    pub fPtr: *mut ::std::os::raw::c_void,
    pub fSize: usize,
}
/**
     *  Function that, if provided, will be called when the SkData goes out
     *  of scope, allowing for custom allocation/freeing of the data's contents.
     */
pub type SkData_ReleaseProc =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *const ::std::os::raw::c_void,
                                               context:
                                                   *mut ::std::os::raw::c_void)>;
pub type SkData_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkData() {
    assert_eq!(::std::mem::size_of::<SkData>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkData>() , 1usize);
}
extern "C" {
    /**
     *  Helper to copy a range of the data into a caller-provided buffer.
     *  Returns the actual number of bytes copied, after clamping offset and
     *  length to the size of the data. If buffer is NULL, it is ignored, and
     *  only the computed number of bytes is returned.
     */
    #[link_name = "?copyRange@SkData@@QEBA_K_K0PEAX@Z"]
    pub fn SkData_copyRange(this: *const SkData, offset: usize, length: usize,
                            buffer: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    /**
     *  Returns true if these two objects have the same length and contents,
     *  effectively returning 0 == memcmp(...)
     */
    #[link_name = "?equals@SkData@@QEBA_NPEBV1@@Z"]
    pub fn SkData_equals(this: *const SkData, other: *const SkData) -> bool;
}
extern "C" {
    /**
     *  Create a new dataref by copying the specified data
     */
    #[link_name = "?MakeWithCopy@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_K@Z"]
    pub fn SkData_MakeWithCopy(data: *const ::std::os::raw::c_void,
                               length: usize) -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Create a new data with uninitialized contents. The caller should call writable_data()
     *  to write into the buffer, but this must be done before another ref() is made.
     */
    #[link_name = "?MakeUninitialized@SkData@@SA?AV?$sk_sp@VSkData@@@@_K@Z"]
    pub fn SkData_MakeUninitialized(length: usize) -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Create a new dataref by copying the specified c-string
     *  (a null-terminated array of bytes). The returned SkData will have size()
     *  equal to strlen(cstr) + 1. If cstr is NULL, it will be treated the same
     *  as "".
     */
    #[link_name = "?MakeWithCString@SkData@@SA?AV?$sk_sp@VSkData@@@@QEBD@Z"]
    pub fn SkData_MakeWithCString(cstr: *const ::std::os::raw::c_char)
     -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Create a new dataref, taking the ptr as is, and using the
     *  releaseproc to free it. The proc may be NULL.
     */
    #[link_name =
          "?MakeWithProc@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_KP6AX0PEAX@Z2@Z"]
    pub fn SkData_MakeWithProc(ptr: *const ::std::os::raw::c_void,
                               length: usize, proc_: SkData_ReleaseProc,
                               ctx: *mut ::std::os::raw::c_void)
     -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Create a new dataref from a pointer allocated by malloc. The Data object
     *  takes ownership of that allocation, and will handling calling sk_free.
     */
    #[link_name = "?MakeFromMalloc@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_K@Z"]
    pub fn SkData_MakeFromMalloc(data: *const ::std::os::raw::c_void,
                                 length: usize) -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Create a new dataref the file with the specified path.
     *  If the file cannot be opened, this returns NULL.
     */
    #[link_name = "?MakeFromFileName@SkData@@SA?AV?$sk_sp@VSkData@@@@QEBD@Z"]
    pub fn SkData_MakeFromFileName(path: *const ::std::os::raw::c_char)
     -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Create a new dataref from a stdio FILE.
     *  This does not take ownership of the FILE, nor close it.
     *  The caller is free to close the FILE at its convenience.
     *  The FILE must be open for reading only.
     *  Returns NULL on failure.
     */
    #[link_name =
          "?MakeFromFILE@SkData@@SA?AV?$sk_sp@VSkData@@@@PEAU_iobuf@@@Z"]
    pub fn SkData_MakeFromFILE(f: *mut FILE) -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Create a new dataref from a file descriptor.
     *  This does not take ownership of the file descriptor, nor close it.
     *  The caller is free to close the file descriptor at its convenience.
     *  The file descriptor must be open for reading only.
     *  Returns NULL on failure.
     */
    #[link_name = "?MakeFromFD@SkData@@SA?AV?$sk_sp@VSkData@@@@H@Z"]
    pub fn SkData_MakeFromFD(fd: ::std::os::raw::c_int) -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Attempt to read size bytes into a SkData. If the read succeeds, return the data,
     *  else return NULL. Either way the stream's cursor may have been changed as a result
     *  of calling read().
     */
    #[link_name =
          "?MakeFromStream@SkData@@SA?AV?$sk_sp@VSkData@@@@PEAVSkStream@@_K@Z"]
    pub fn SkData_MakeFromStream(arg1: *mut SkStream, size: usize)
     -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Create a new dataref using a subset of the data in the specified
     *  src dataref.
     */
    #[link_name = "?MakeSubset@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBV1@_K1@Z"]
    pub fn SkData_MakeSubset(src: *const SkData, offset: usize, length: usize)
     -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Returns a new empty dataref (or a reference to a shared empty dataref).
     *  New or shared, the caller must see that unref() is eventually called.
     */
    #[link_name = "?MakeEmpty@SkData@@SA?AV?$sk_sp@VSkData@@@@XZ"]
    pub fn SkData_MakeEmpty() -> sk_sp<SkData>;
}
impl SkData {
    #[inline]
    pub unsafe fn copyRange(&self, offset: usize, length: usize,
                            buffer: *mut ::std::os::raw::c_void) -> usize {
        SkData_copyRange(&*self, offset, length, buffer)
    }
    #[inline]
    pub unsafe fn equals(&self, other: *const SkData) -> bool {
        SkData_equals(&*self, other)
    }
    #[inline]
    pub unsafe fn MakeWithCopy(data: *const ::std::os::raw::c_void,
                               length: usize) -> sk_sp<SkData> {
        SkData_MakeWithCopy(data, length)
    }
    #[inline]
    pub unsafe fn MakeUninitialized(length: usize) -> sk_sp<SkData> {
        SkData_MakeUninitialized(length)
    }
    #[inline]
    pub unsafe fn MakeWithCString(cstr: *const ::std::os::raw::c_char)
     -> sk_sp<SkData> {
        SkData_MakeWithCString(cstr)
    }
    #[inline]
    pub unsafe fn MakeWithProc(ptr: *const ::std::os::raw::c_void,
                               length: usize, proc_: SkData_ReleaseProc,
                               ctx: *mut ::std::os::raw::c_void)
     -> sk_sp<SkData> {
        SkData_MakeWithProc(ptr, length, proc_, ctx)
    }
    #[inline]
    pub unsafe fn MakeFromMalloc(data: *const ::std::os::raw::c_void,
                                 length: usize) -> sk_sp<SkData> {
        SkData_MakeFromMalloc(data, length)
    }
    #[inline]
    pub unsafe fn MakeFromFileName(path: *const ::std::os::raw::c_char)
     -> sk_sp<SkData> {
        SkData_MakeFromFileName(path)
    }
    #[inline]
    pub unsafe fn MakeFromFILE(f: *mut FILE) -> sk_sp<SkData> {
        SkData_MakeFromFILE(f)
    }
    #[inline]
    pub unsafe fn MakeFromFD(fd: ::std::os::raw::c_int) -> sk_sp<SkData> {
        SkData_MakeFromFD(fd)
    }
    #[inline]
    pub unsafe fn MakeFromStream(arg1: *mut SkStream, size: usize)
     -> sk_sp<SkData> {
        SkData_MakeFromStream(arg1, size)
    }
    #[inline]
    pub unsafe fn MakeSubset(src: *const SkData, offset: usize, length: usize)
     -> sk_sp<SkData> {
        SkData_MakeSubset(src, offset, length)
    }
    #[inline]
    pub unsafe fn MakeEmpty() -> sk_sp<SkData> { SkData_MakeEmpty() }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPoint {
    pub fX: SkScalar,
    pub fY: SkScalar,
}
#[repr(i32)]
/**
     * The side of a point relative to a line. If the line is from a to b then
     * the values are consistent with the sign of (b-a) cross (pt-a)
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPoint_Side { kLeft_Side = -1, kOn_Side = 0, kRight_Side = 1, }
#[test]
fn bindgen_test_layout_SkPoint() {
    assert_eq!(::std::mem::size_of::<SkPoint>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkPoint>() , 4usize);
}
extern "C" {
    #[link_name = "?setIRectFan@SkPoint@@QEAAXHHHH_K@Z"]
    pub fn SkPoint_setIRectFan(this: *mut SkPoint, l: ::std::os::raw::c_int,
                               t: ::std::os::raw::c_int,
                               r: ::std::os::raw::c_int,
                               b: ::std::os::raw::c_int, stride: usize);
}
extern "C" {
    /** Set the point (vector) to be unit-length in the same direction as it
        already points.  If the point has a degenerate length (i.e. nearly 0)
        then set it to (0,0) and return false; otherwise return true.
    */
    #[link_name = "?normalize@SkPoint@@QEAA_NXZ"]
    pub fn SkPoint_normalize(this: *mut SkPoint) -> bool;
}
extern "C" {
    /** Set the point (vector) to be unit-length in the same direction as the
        x,y params. If the vector (x,y) has a degenerate length (i.e. nearly 0)
        then set it to (0,0) and return false, otherwise return true.
    */
    #[link_name = "?setNormalize@SkPoint@@QEAA_NMM@Z"]
    pub fn SkPoint_setNormalize(this: *mut SkPoint, x: SkScalar, y: SkScalar)
     -> bool;
}
extern "C" {
    /** Scale the point (vector) to have the specified length, and return that
        length. If the original length is degenerately small (nearly zero),
        set it to (0,0) and return false, otherwise return true.
    */
    #[link_name = "?setLength@SkPoint@@QEAA_NM@Z"]
    pub fn SkPoint_setLength(this: *mut SkPoint, length: SkScalar) -> bool;
}
extern "C" {
    /** Set the point (vector) to have the specified length in the same
     direction as (x,y). If the vector (x,y) has a degenerate length
     (i.e. nearly 0) then set it to (0,0) and return false, otherwise return true.
    */
    #[link_name = "?setLength@SkPoint@@QEAA_NMMM@Z"]
    pub fn SkPoint_setLength1(this: *mut SkPoint, x: SkScalar, y: SkScalar,
                              length: SkScalar) -> bool;
}
extern "C" {
    /** Same as setLength, but favoring speed over accuracy.
    */
    #[link_name = "?setLengthFast@SkPoint@@QEAA_NM@Z"]
    pub fn SkPoint_setLengthFast(this: *mut SkPoint, length: SkScalar)
     -> bool;
}
extern "C" {
    /** Same as setLength, but favoring speed over accuracy.
    */
    #[link_name = "?setLengthFast@SkPoint@@QEAA_NMMM@Z"]
    pub fn SkPoint_setLengthFast1(this: *mut SkPoint, x: SkScalar,
                                  y: SkScalar, length: SkScalar) -> bool;
}
extern "C" {
    /** Scale the point's coordinates by scale, writing the answer into dst.
        It is legal for dst == this.
    */
    #[link_name = "?scale@SkPoint@@QEBAXMPEAU1@@Z"]
    pub fn SkPoint_scale(this: *const SkPoint, scale: SkScalar,
                         dst: *mut SkPoint);
}
extern "C" {
    /** Rotate the point clockwise by 90 degrees, writing the answer into dst.
        It is legal for dst == this.
    */
    #[link_name = "?rotateCW@SkPoint@@QEBAXPEAU1@@Z"]
    pub fn SkPoint_rotateCW(this: *const SkPoint, dst: *mut SkPoint);
}
extern "C" {
    /** Rotate the point counter-clockwise by 90 degrees, writing the answer
        into dst. It is legal for dst == this.
    */
    #[link_name = "?rotateCCW@SkPoint@@QEBAXPEAU1@@Z"]
    pub fn SkPoint_rotateCCW(this: *const SkPoint, dst: *mut SkPoint);
}
extern "C" {
    /** Returns the euclidian distance from (0,0) to (x,y)
    */
    #[link_name = "?Length@SkPoint@@SAMMM@Z"]
    pub fn SkPoint_Length(x: SkScalar, y: SkScalar) -> SkScalar;
}
extern "C" {
    /** Normalize pt, returning its previous length. If the prev length is too
        small (degenerate), set pt to (0,0) and return 0. This uses the same
        tolerance as CanNormalize.

        Note that this method may be significantly more expensive than
        the non-static normalize(), because it has to return the previous length
        of the point.  If you don't need the previous length, call the
        non-static normalize() method instead.
     */
    #[link_name = "?Normalize@SkPoint@@SAMPEAU1@@Z"]
    pub fn SkPoint_Normalize(pt: *mut SkPoint) -> SkScalar;
}
extern "C" {
    /**
     * Returns the squared distance to the infinite line between two pts. Also
     * optionally returns the side of the line that the pt falls on (looking
     * along line from a to b)
     */
    #[link_name =
          "?distanceToLineBetweenSqd@SkPoint@@QEBAMAEBU1@0PEAW4Side@1@@Z"]
    pub fn SkPoint_distanceToLineBetweenSqd(this: *const SkPoint,
                                            a: *const SkPoint,
                                            b: *const SkPoint,
                                            side: *mut SkPoint_Side)
     -> SkScalar;
}
extern "C" {
    /**
     * Returns the squared distance to the line segment between pts a and b
     */
    #[link_name = "?distanceToLineSegmentBetweenSqd@SkPoint@@QEBAMAEBU1@0@Z"]
    pub fn SkPoint_distanceToLineSegmentBetweenSqd(this: *const SkPoint,
                                                   a: *const SkPoint,
                                                   b: *const SkPoint)
     -> SkScalar;
}
impl Clone for SkPoint {
    fn clone(&self) -> Self { *self }
}
impl SkPoint {
    #[inline]
    pub unsafe fn setIRectFan(&mut self, l: ::std::os::raw::c_int,
                              t: ::std::os::raw::c_int,
                              r: ::std::os::raw::c_int,
                              b: ::std::os::raw::c_int, stride: usize) {
        SkPoint_setIRectFan(&mut *self, l, t, r, b, stride)
    }
    #[inline]
    pub unsafe fn normalize(&mut self) -> bool {
        SkPoint_normalize(&mut *self)
    }
    #[inline]
    pub unsafe fn setNormalize(&mut self, x: SkScalar, y: SkScalar) -> bool {
        SkPoint_setNormalize(&mut *self, x, y)
    }
    #[inline]
    pub unsafe fn setLength(&mut self, length: SkScalar) -> bool {
        SkPoint_setLength(&mut *self, length)
    }
    #[inline]
    pub unsafe fn setLength1(&mut self, x: SkScalar, y: SkScalar,
                             length: SkScalar) -> bool {
        SkPoint_setLength1(&mut *self, x, y, length)
    }
    #[inline]
    pub unsafe fn setLengthFast(&mut self, length: SkScalar) -> bool {
        SkPoint_setLengthFast(&mut *self, length)
    }
    #[inline]
    pub unsafe fn setLengthFast1(&mut self, x: SkScalar, y: SkScalar,
                                 length: SkScalar) -> bool {
        SkPoint_setLengthFast1(&mut *self, x, y, length)
    }
    #[inline]
    pub unsafe fn scale(&self, scale: SkScalar, dst: *mut SkPoint) {
        SkPoint_scale(&*self, scale, dst)
    }
    #[inline]
    pub unsafe fn rotateCW(&self, dst: *mut SkPoint) {
        SkPoint_rotateCW(&*self, dst)
    }
    #[inline]
    pub unsafe fn rotateCCW(&self, dst: *mut SkPoint) {
        SkPoint_rotateCCW(&*self, dst)
    }
    #[inline]
    pub unsafe fn Length(x: SkScalar, y: SkScalar) -> SkScalar {
        SkPoint_Length(x, y)
    }
    #[inline]
    pub unsafe fn Normalize(pt: *mut SkPoint) -> SkScalar {
        SkPoint_Normalize(pt)
    }
    #[inline]
    pub unsafe fn distanceToLineBetweenSqd(&self, a: *const SkPoint,
                                           b: *const SkPoint,
                                           side: *mut SkPoint_Side)
     -> SkScalar {
        SkPoint_distanceToLineBetweenSqd(&*self, a, b, side)
    }
    #[inline]
    pub unsafe fn distanceToLineSegmentBetweenSqd(&self, a: *const SkPoint,
                                                  b: *const SkPoint)
     -> SkScalar {
        SkPoint_distanceToLineSegmentBetweenSqd(&*self, a, b)
    }
}
/** \struct SkRect
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRect {
    pub fLeft: SkScalar,
    pub fTop: SkScalar,
    pub fRight: SkScalar,
    pub fBottom: SkScalar,
}
#[test]
fn bindgen_test_layout_SkRect() {
    assert_eq!(::std::mem::size_of::<SkRect>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkRect>() , 4usize);
}
extern "C" {
    /** return the 4 points that enclose the rectangle (top-left, top-right, bottom-right,
        bottom-left). TODO: Consider adding param to control whether quad is CW or CCW.
     */
    #[link_name = "?toQuad@SkRect@@QEBAXQEAUSkPoint@@@Z"]
    pub fn SkRect_toQuad(this: *const SkRect, quad: *mut SkPoint);
}
extern "C" {
    /**
     *  Compute the bounds of the array of points, and set this rect to that
     *  bounds and return true... unless a non-finite value is encountered,
     *  in which case this rect is set to empty and false is returned.
     */
    #[link_name = "?setBoundsCheck@SkRect@@QEAA_NQEBUSkPoint@@H@Z"]
    pub fn SkRect_setBoundsCheck(this: *mut SkRect, pts: *const SkPoint,
                                 count: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /** If this rectangle intersects r, return true and set this rectangle to that
        intersection, otherwise return false and do not change this rectangle.
        If either rectangle is empty, do nothing and return false.
    */
    #[link_name = "?intersect@SkRect@@QEAA_NAEBU1@@Z"]
    pub fn SkRect_intersect(this: *mut SkRect, r: *const SkRect) -> bool;
}
extern "C" {
    /** If this rectangle intersects the rectangle specified by left, top, right, bottom,
        return true and set this rectangle to that intersection, otherwise return false
        and do not change this rectangle.
        If either rectangle is empty, do nothing and return false.
    */
    #[link_name = "?intersect@SkRect@@QEAA_NMMMM@Z"]
    pub fn SkRect_intersect1(this: *mut SkRect, left: SkScalar, top: SkScalar,
                             right: SkScalar, bottom: SkScalar) -> bool;
}
extern "C" {
    /**
     *  If rectangles a and b intersect, return true and set this rectangle to
     *  that intersection, otherwise return false and do not change this
     *  rectangle. If either rectangle is empty, do nothing and return false.
     */
    #[link_name = "?intersect@SkRect@@QEAA_NAEBU1@0@Z"]
    pub fn SkRect_intersect2(this: *mut SkRect, a: *const SkRect,
                             b: *const SkRect) -> bool;
}
extern "C" {
    /**
     *  Update this rectangle to enclose itself and the specified rectangle.
     *  If this rectangle is empty, just set it to the specified rectangle.
     *  If the specified rectangle is empty, do nothing.
     */
    #[link_name = "?join@SkRect@@QEAAXMMMM@Z"]
    pub fn SkRect_join(this: *mut SkRect, left: SkScalar, top: SkScalar,
                       right: SkScalar, bottom: SkScalar);
}
extern "C" {
    #[link_name = "?dump@SkRect@@QEBAX_N@Z"]
    pub fn SkRect_dump(this: *const SkRect, asHex: bool);
}
impl Clone for SkRect {
    fn clone(&self) -> Self { *self }
}
impl SkRect {
    #[inline]
    pub unsafe fn toQuad(&self, quad: *mut SkPoint) {
        SkRect_toQuad(&*self, quad)
    }
    #[inline]
    pub unsafe fn setBoundsCheck(&mut self, pts: *const SkPoint,
                                 count: ::std::os::raw::c_int) -> bool {
        SkRect_setBoundsCheck(&mut *self, pts, count)
    }
    #[inline]
    pub unsafe fn intersect(&mut self, r: *const SkRect) -> bool {
        SkRect_intersect(&mut *self, r)
    }
    #[inline]
    pub unsafe fn intersect1(&mut self, left: SkScalar, top: SkScalar,
                             right: SkScalar, bottom: SkScalar) -> bool {
        SkRect_intersect1(&mut *self, left, top, right, bottom)
    }
    #[inline]
    pub unsafe fn intersect2(&mut self, a: *const SkRect, b: *const SkRect)
     -> bool {
        SkRect_intersect2(&mut *self, a, b)
    }
    #[inline]
    pub unsafe fn join(&mut self, left: SkScalar, top: SkScalar,
                       right: SkScalar, bottom: SkScalar) {
        SkRect_join(&mut *self, left, top, right, bottom)
    }
    #[inline]
    pub unsafe fn dump(&self, asHex: bool) { SkRect_dump(&*self, asHex) }
}
pub const SkAlphaType_kLastEnum_SkAlphaType: SkAlphaType =
    SkAlphaType::kUnpremul_SkAlphaType;
#[repr(i32)]
/**
 *  Describes how to interpret the alpha component of a pixel.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkAlphaType {
    kUnknown_SkAlphaType = 0,
    kOpaque_SkAlphaType = 1,
    kPremul_SkAlphaType = 2,
    kUnpremul_SkAlphaType = 3,
}
/**
 *  Describe an image's dimensions and pixel type.
 *  Used for both src images and render-targets (surfaces).
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkImageInfo {
    pub fColorSpace: sk_sp<SkColorSpace>,
    pub fWidth: ::std::os::raw::c_int,
    pub fHeight: ::std::os::raw::c_int,
    pub fColorType: SkColorType,
    pub fAlphaType: SkAlphaType,
}
#[test]
fn bindgen_test_layout_SkImageInfo() {
    assert_eq!(::std::mem::size_of::<SkImageInfo>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkImageInfo>() , 1usize);
}
extern "C" {
    /**
     *  Create an ImageInfo marked as SRGB with N32 swizzle.
     */
    #[link_name = "?MakeS32@SkImageInfo@@SA?AU1@HHW4SkAlphaType@@@Z"]
    pub fn SkImageInfo_MakeS32(width: ::std::os::raw::c_int,
                               height: ::std::os::raw::c_int, at: SkAlphaType)
     -> SkImageInfo;
}
extern "C" {
    #[link_name = "?unflatten@SkImageInfo@@QEAAXAEAVSkReadBuffer@@@Z"]
    pub fn SkImageInfo_unflatten(this: *mut SkImageInfo,
                                 arg1: *mut SkReadBuffer);
}
extern "C" {
    #[link_name = "?flatten@SkImageInfo@@QEBAXAEAVSkWriteBuffer@@@Z"]
    pub fn SkImageInfo_flatten(this: *const SkImageInfo,
                               arg1: *mut SkWriteBuffer);
}
extern "C" {
    #[link_name = "?validate@SkImageInfo@@QEBAXXZ"]
    pub fn SkImageInfo_validate(this: *const SkImageInfo);
}
impl SkImageInfo {
    #[inline]
    pub unsafe fn MakeS32(width: ::std::os::raw::c_int,
                          height: ::std::os::raw::c_int, at: SkAlphaType)
     -> SkImageInfo {
        SkImageInfo_MakeS32(width, height, at)
    }
    #[inline]
    pub unsafe fn unflatten(&mut self, arg1: *mut SkReadBuffer) {
        SkImageInfo_unflatten(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn flatten(&self, arg1: *mut SkWriteBuffer) {
        SkImageInfo_flatten(&*self, arg1)
    }
    #[inline]
    pub unsafe fn validate(&self) { SkImageInfo_validate(&*self) }
}
///////////////////////////////////////////////////////////////////////////////
pub type SkISize = SkTSize<::std::os::raw::c_int>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkClipOp {
    kDifference_SkClipOp = 0,
    kIntersect_SkClipOp = 1,
    kUnion_SkClipOp = 2,
    kXOR_SkClipOp = 3,
    kReverseDifference_SkClipOp = 4,
    kReplace_SkClipOp = 5,
}
pub const SkBlendMode_kLastCoeffMode: SkBlendMode = SkBlendMode::kScreen;
pub const SkBlendMode_kLastSeparableMode: SkBlendMode =
    SkBlendMode::kMultiply;
pub const SkBlendMode_kLastMode: SkBlendMode = SkBlendMode::kLuminosity;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkBlendMode {
    kClear = 0,
    kSrc = 1,
    kDst = 2,
    kSrcOver = 3,
    kDstOver = 4,
    kSrcIn = 5,
    kDstIn = 6,
    kSrcOut = 7,
    kDstOut = 8,
    kSrcATop = 9,
    kDstATop = 10,
    kXor = 11,
    kPlus = 12,
    kModulate = 13,
    kScreen = 14,
    kOverlay = 15,
    kDarken = 16,
    kLighten = 17,
    kColorDodge = 18,
    kColorBurn = 19,
    kHardLight = 20,
    kSoftLight = 21,
    kDifference = 22,
    kExclusion = 23,
    kMultiply = 24,
    kHue = 25,
    kSaturation = 26,
    kColor = 27,
    kLuminosity = 28,
}
/** 32 bit ARGB color value, not premultiplied. The color components are always in
    a known order. This is different from SkPMColor, which has its bytes in a configuration
    dependent order, to match the format of kARGB32 bitmaps. SkColor is the type used to
    specify colors in SkPaint and in gradients.
*/
pub type SkColor = u32;
/**
 *  A compressed form of a rotation+scale matrix.
 *
 *  [ fSCos     -fSSin    fTx ]
 *  [ fSSin      fSCos    fTy ]
 *  [     0          0      1 ]
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRSXform {
    pub fSCos: SkScalar,
    pub fSSin: SkScalar,
    pub fTx: SkScalar,
    pub fTy: SkScalar,
}
#[test]
fn bindgen_test_layout_SkRSXform() {
    assert_eq!(::std::mem::size_of::<SkRSXform>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkRSXform>() , 4usize);
}
extern "C" {
    #[link_name = "?toQuad@SkRSXform@@QEBAXMMQEAUSkPoint@@@Z"]
    pub fn SkRSXform_toQuad(this: *const SkRSXform, width: SkScalar,
                            height: SkScalar, quad: *mut SkPoint);
}
impl Clone for SkRSXform {
    fn clone(&self) -> Self { *self }
}
impl SkRSXform {
    #[inline]
    pub unsafe fn toQuad(&self, width: SkScalar, height: SkScalar,
                         quad: *mut SkPoint) {
        SkRSXform_toQuad(&*self, width, height, quad)
    }
}
#[repr(C)]
pub struct SkCanvas__bindgen_vtable {
}
/** \class SkCanvas

    A Canvas encapsulates all of the state about drawing into a device (bitmap).
    This includes a reference to the device itself, and a stack of matrix/clip
    values. For any given draw call (e.g. drawRect), the geometry of the object
    being drawn is transformed by the concatenation of all the matrices in the
    stack. The transformed geometry is clipped by the intersection of all of
    the clips in the stack.

    While the Canvas holds the state of the drawing device, the state (style)
    of the object being drawn is held by the Paint, which is provided as a
    parameter to each of the draw() methods. The Paint holds attributes such as
    color, typeface, textSize, strokeWidth, shader (e.g. gradients, patterns),
    etc.
*/
#[repr(C)]
pub struct SkCanvas {
    pub vtable_: *const SkCanvas__bindgen_vtable,
    pub fClipStack: sk_sp<SkClipStack>,
    pub fMCStack: SkDeque,
    pub fMCRec: *mut SkCanvas_MCRec,
    pub fMCRecStorage: [isize; 512usize],
    pub fDeviceCMStorage: [isize; 22usize],
    pub fProps: SkSurfaceProps,
    pub fSaveCount: ::std::os::raw::c_int,
    pub fMetaData: *mut SkMetaData,
    pub fSurfaceBase: *mut SkSurface_Base,
    pub fDeviceCMDirty: bool,
    /**
     *  Keep track of the device clip bounds and if the matrix is scale-translate.  This allows
     *  us to do a fast quick reject in the common case.
     */
    pub fIsScaleTranslate: bool,
    pub fDeviceClipBounds: SkRect,
    pub fAllowSoftClip: bool,
    pub fAllowSimplifyClip: bool,
    pub fConservativeRasterClip: bool,
}
pub const SkCanvas_PrivateSaveLayerFlags_kDontClipToLayer_PrivateSaveLayerFlag:
          SkCanvas_PrivateSaveLayerFlags =
    SkCanvas_PrivateSaveLayerFlags(-2147483648);
impl ::std::ops::BitOr<SkCanvas_PrivateSaveLayerFlags> for
 SkCanvas_PrivateSaveLayerFlags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkCanvas_PrivateSaveLayerFlags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkCanvas_PrivateSaveLayerFlags(pub i32);
pub const SkCanvas_kIsOpaque_SaveLayerFlag: SkCanvas__bindgen_ty_1 =
    SkCanvas__bindgen_ty_1::kIsOpaque_SaveLayerFlag;
pub const SkCanvas_kPreserveLCDText_SaveLayerFlag: SkCanvas__bindgen_ty_1 =
    SkCanvas__bindgen_ty_1::kPreserveLCDText_SaveLayerFlag;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkCanvas__bindgen_ty_1 {
    kIsOpaque_SaveLayerFlag = 1,
    kPreserveLCDText_SaveLayerFlag = 2,
}
pub type SkCanvas_SaveLayerFlags = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkCanvas_SaveLayerRec {
    pub fBounds: *const SkRect,
    pub fPaint: *const SkPaint,
    pub fBackdrop: *const SkImageFilter,
    pub fSaveLayerFlags: SkCanvas_SaveLayerFlags,
}
#[test]
fn bindgen_test_layout_SkCanvas_SaveLayerRec() {
    assert_eq!(::std::mem::size_of::<SkCanvas_SaveLayerRec>() , 32usize);
    assert_eq!(::std::mem::align_of::<SkCanvas_SaveLayerRec>() , 8usize);
}
impl Clone for SkCanvas_SaveLayerRec {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkCanvas_PointMode {
    kPoints_PointMode = 0,
    kLines_PointMode = 1,
    kPolygon_PointMode = 2,
}
#[repr(i32)]
/**
     *  Controls the behavior at the edge of the src-rect, when specified in drawImageRect,
     *  trading off speed for exactness.
     *
     *  When filtering is enabled (in the Paint), skia may need to sample in a neighborhood around
     *  the pixels in the image. If there is a src-rect specified, it is intended to restrict the
     *  pixels that will be read. However, for performance reasons, some implementations may slow
     *  down if they cannot read 1-pixel past the src-rect boundary at times.
     *
     *  This enum allows the caller to specify if such a 1-pixel "slop" will be visually acceptable.
     *  If it is, the caller should pass kFast, and it may result in a faster draw. If the src-rect
     *  must be strictly respected, the caller should pass kStrict.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkCanvas_SrcRectConstraint {
    kStrict_SrcRectConstraint = 0,
    kFast_SrcRectConstraint = 1,
}
/**
     *  Specifies coordinates to divide a bitmap into (xCount*yCount) rects.
     *
     *  If the lattice divs or bounds are invalid, the entire lattice
     *  struct will be ignored on the draw call.
     */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkCanvas_Lattice {
    pub fXDivs: *const ::std::os::raw::c_int,
    pub fYDivs: *const ::std::os::raw::c_int,
    pub fFlags: *const SkCanvas_Lattice_Flags,
    pub fXCount: ::std::os::raw::c_int,
    pub fYCount: ::std::os::raw::c_int,
    pub fBounds: *const SkIRect,
}
pub const SkCanvas_Lattice_Flags_kTransparent_Flags: SkCanvas_Lattice_Flags =
    SkCanvas_Lattice_Flags(1);
impl ::std::ops::BitOr<SkCanvas_Lattice_Flags> for SkCanvas_Lattice_Flags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkCanvas_Lattice_Flags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkCanvas_Lattice_Flags(pub u8);
#[test]
fn bindgen_test_layout_SkCanvas_Lattice() {
    assert_eq!(::std::mem::size_of::<SkCanvas_Lattice>() , 40usize);
    assert_eq!(::std::mem::align_of::<SkCanvas_Lattice>() , 8usize);
}
impl Clone for SkCanvas_Lattice {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkCanvas_VertexMode {
    kTriangles_VertexMode = 0,
    kTriangleStrip_VertexMode = 1,
    kTriangleFan_VertexMode = 2,
}
pub type SkCanvas_ClipVisitor = SkCanvasClipVisitor;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkCanvas_SaveLayerStrategy {
    kFullLayer_SaveLayerStrategy = 0,
    kNoLayer_SaveLayerStrategy = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkCanvas_ClipEdgeStyle {
    kHard_ClipEdgeStyle = 0,
    kSoft_ClipEdgeStyle = 1,
}
/** After calling saveLayer(), there can be any number of devices that make
     up the top-most drawing area. LayerIter can be used to iterate through
     those devices. Note that the iterator is only valid until the next API
     call made on the canvas. Ownership of all pointers in the iterator stays
     with the canvas, so none of them should be modified or deleted.
     */
#[repr(C)]
pub struct SkCanvas_LayerIter {
    pub fStorage: [isize; 32usize],
    pub fImpl: *mut SkCanvas_LayerIter_SkDrawIter,
    pub fDefaultPaint: SkPaint,
    pub fDone: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkCanvas_LayerIter_SkDrawIter {
    pub _address: u8,
}
impl Clone for SkCanvas_LayerIter_SkDrawIter {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SkCanvas_LayerIter() {
    assert_eq!(::std::mem::size_of::<SkCanvas_LayerIter>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkCanvas_LayerIter>() , 1usize);
}
extern "C" {
    /** Cycle to the next device */
    #[link_name = "?next@LayerIter@SkCanvas@@QEAAXXZ"]
    pub fn SkCanvas_LayerIter_next(this: *mut SkCanvas_LayerIter);
}
extern "C" {
    #[link_name = "?device@LayerIter@SkCanvas@@QEBAPEAVSkBaseDevice@@XZ"]
    pub fn SkCanvas_LayerIter_device(this: *const SkCanvas_LayerIter)
     -> *mut SkBaseDevice;
}
extern "C" {
    #[link_name = "?matrix@LayerIter@SkCanvas@@QEBAAEBVSkMatrix@@XZ"]
    pub fn SkCanvas_LayerIter_matrix(this: *const SkCanvas_LayerIter)
     -> *const SkMatrix;
}
extern "C" {
    #[link_name = "?clip@LayerIter@SkCanvas@@QEBAAEBVSkRasterClip@@XZ"]
    pub fn SkCanvas_LayerIter_clip(this: *const SkCanvas_LayerIter)
     -> *const SkRasterClip;
}
extern "C" {
    #[link_name = "?paint@LayerIter@SkCanvas@@QEBAAEBVSkPaint@@XZ"]
    pub fn SkCanvas_LayerIter_paint(this: *const SkCanvas_LayerIter)
     -> *const SkPaint;
}
extern "C" {
    #[link_name = "?x@LayerIter@SkCanvas@@QEBAHXZ"]
    pub fn SkCanvas_LayerIter_x(this: *const SkCanvas_LayerIter)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?y@LayerIter@SkCanvas@@QEBAHXZ"]
    pub fn SkCanvas_LayerIter_y(this: *const SkCanvas_LayerIter)
     -> ::std::os::raw::c_int;
}
impl SkCanvas_LayerIter {
    #[inline]
    pub unsafe fn next(&mut self) { SkCanvas_LayerIter_next(&mut *self) }
    #[inline]
    pub unsafe fn device(&self) -> *mut SkBaseDevice {
        SkCanvas_LayerIter_device(&*self)
    }
    #[inline]
    pub unsafe fn matrix(&self) -> *const SkMatrix {
        SkCanvas_LayerIter_matrix(&*self)
    }
    #[inline]
    pub unsafe fn clip(&self) -> *const SkRasterClip {
        SkCanvas_LayerIter_clip(&*self)
    }
    #[inline]
    pub unsafe fn paint(&self) -> *const SkPaint {
        SkCanvas_LayerIter_paint(&*self)
    }
    #[inline]
    pub unsafe fn x(&self) -> ::std::os::raw::c_int {
        SkCanvas_LayerIter_x(&*self)
    }
    #[inline]
    pub unsafe fn y(&self) -> ::std::os::raw::c_int {
        SkCanvas_LayerIter_y(&*self)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkCanvas_ShaderOverrideOpacity {
    kNone_ShaderOverrideOpacity = 0,
    kOpaque_ShaderOverrideOpacity = 1,
    kNotOpaque_ShaderOverrideOpacity = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkCanvas_MCRec {
    pub _address: u8,
}
impl Clone for SkCanvas_MCRec {
    fn clone(&self) -> Self { *self }
}
pub const SkCanvas_kMCRecSize: SkCanvas__bindgen_ty_2 =
    SkCanvas__bindgen_ty_2::kMCRecSize;
pub const SkCanvas_kMCRecCount: SkCanvas__bindgen_ty_2 =
    SkCanvas__bindgen_ty_2::kMCRecCount;
pub const SkCanvas_kDeviceCMSize: SkCanvas__bindgen_ty_2 =
    SkCanvas__bindgen_ty_2::kDeviceCMSize;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkCanvas__bindgen_ty_2 {
    kMCRecSize = 128,
    kMCRecCount = 32,
    kDeviceCMSize = 176,
}
pub const SkCanvas_InitFlags_kDefault_InitFlags: SkCanvas_InitFlags =
    SkCanvas_InitFlags(0);
pub const SkCanvas_InitFlags_kConservativeRasterClip_InitFlag:
          SkCanvas_InitFlags =
    SkCanvas_InitFlags(1);
impl ::std::ops::BitOr<SkCanvas_InitFlags> for SkCanvas_InitFlags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkCanvas_InitFlags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkCanvas_InitFlags(pub i32);
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas_AutoValidateClip {
    pub fCanvas: *const SkCanvas,
}
#[test]
fn bindgen_test_layout_SkCanvas_AutoValidateClip() {
    assert_eq!(::std::mem::size_of::<SkCanvas_AutoValidateClip>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkCanvas_AutoValidateClip>() , 8usize);
}
pub type SkCanvas_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkCanvas() {
    assert_eq!(::std::mem::size_of::<SkCanvas>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkCanvas>() , 1usize);
}
extern "C" {
    /**
     *  Attempt to allocate raster canvas, matching the ImageInfo, that will draw directly into the
     *  specified pixels. To access the pixels after drawing to them, the caller should call
     *  flush() or call peekPixels(...).
     *
     *  On failure, return NULL. This can fail for several reasons:
     *  1. invalid ImageInfo (e.g. negative dimensions)
     *  2. unsupported ImageInfo for a canvas
     *      - kUnknown_SkColorType, kIndex_8_SkColorType
     *      - kUnknown_SkAlphaType
     *      - this list is not complete, so others may also be unsupported
     *
     *  Note: it is valid to request a supported ImageInfo, but with zero
     *  dimensions.
     */
    #[link_name = "?MakeRasterDirect@SkCanvas@@SAHAEBUSkImageInfo@@PEAX_K@Z"]
    pub fn SkCanvas_MakeRasterDirect(arg1: *const SkImageInfo,
                                     arg2: *mut ::std::os::raw::c_void,
                                     arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?getMetaData@SkCanvas@@QEAAAEAVSkMetaData@@XZ"]
    pub fn SkCanvas_getMetaData(this: *mut SkCanvas) -> *mut SkMetaData;
}
extern "C" {
    /**
     *  Return ImageInfo for this canvas. If the canvas is not backed by pixels
     *  (cpu or gpu), then the info's ColorType will be kUnknown_SkColorType.
     */
    #[link_name = "?imageInfo@SkCanvas@@QEBA?AUSkImageInfo@@XZ"]
    pub fn SkCanvas_imageInfo(this: *const SkCanvas) -> SkImageInfo;
}
extern "C" {
    /**
     *  If the canvas is backed by pixels (cpu or gpu), this writes a copy of the SurfaceProps
     *  for the canvas to the location supplied by the caller, and returns true. Otherwise,
     *  return false and leave the supplied props unchanged.
     */
    #[link_name = "?getProps@SkCanvas@@QEBA_NPEAVSkSurfaceProps@@@Z"]
    pub fn SkCanvas_getProps(this: *const SkCanvas, arg1: *mut SkSurfaceProps)
     -> bool;
}
extern "C" {
    /**
     *  Trigger the immediate execution of all pending draw operations. For the GPU
     *  backend this will resolve all rendering to the GPU surface backing the
     *  SkSurface that owns this canvas.
     */
    #[link_name = "?flush@SkCanvas@@QEAAXXZ"]
    pub fn SkCanvas_flush(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "?getDevice@SkCanvas@@IEBAPEAVSkBaseDevice@@XZ"]
    pub fn SkCanvas_getDevice(this: *const SkCanvas) -> *mut SkBaseDevice;
}
extern "C" {
    /**
     *  Create a new surface matching the specified info, one that attempts to
     *  be maximally compatible when used with this canvas. If there is no matching Surface type,
     *  NULL is returned.
     *
     *  If surfaceprops is specified, those are passed to the new surface, otherwise the new surface
     *  inherits the properties of the surface that owns this canvas. If this canvas has no parent
     *  surface, then the new surface is created with default properties.
     */
    #[link_name =
          "?makeSurface@SkCanvas@@QEAA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEBVSkSurfaceProps@@@Z"]
    pub fn SkCanvas_makeSurface(this: *mut SkCanvas, arg1: *const SkImageInfo,
                                arg2: *const SkSurfaceProps)
     -> sk_sp<SkSurface>;
}
extern "C" {
    /**
     * Return the GPU context of the device that is associated with the canvas.
     * For a canvas with non-GPU device, NULL is returned.
     */
    #[link_name = "?getGrContext@SkCanvas@@QEAAPEAVGrContext@@XZ"]
    pub fn SkCanvas_getGrContext(this: *mut SkCanvas) -> *mut GrContext;
}
extern "C" {
    /**
     *  If the canvas has writable pixels in its top layer (and is not recording to a picture
     *  or other non-raster target) and has direct access to its pixels (i.e. they are in
     *  local RAM) return the address of those pixels, and if not null,
     *  return the ImageInfo, rowBytes and origin. The returned address is only valid
     *  while the canvas object is in scope and unchanged. Any API calls made on
     *  canvas (or its parent surface if any) will invalidate the
     *  returned address (and associated information).
     *
     *  On failure, returns NULL and the info, rowBytes, and origin parameters are ignored.
     */
    #[link_name =
          "?accessTopLayerPixels@SkCanvas@@QEAAPEAXPEAUSkImageInfo@@PEA_KPEAUSkIPoint@@@Z"]
    pub fn SkCanvas_accessTopLayerPixels(this: *mut SkCanvas,
                                         info: *mut SkImageInfo,
                                         rowBytes: *mut usize,
                                         origin: *mut SkIPoint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
     *  If the canvas has readable pixels in its base layer (and is not recording to a picture
     *  or other non-raster target) and has direct access to its pixels (i.e. they are in
     *  local RAM) return true, and if not null, return in the pixmap parameter information about
     *  the pixels. The pixmap's pixel address is only valid
     *  while the canvas object is in scope and unchanged. Any API calls made on
     *  canvas (or its parent surface if any) will invalidate the pixel address
     *  (and associated information).
     *
     *  On failure, returns false and the pixmap parameter will be ignored.
     */
    #[link_name = "?peekPixels@SkCanvas@@QEAA_NPEAVSkPixmap@@@Z"]
    pub fn SkCanvas_peekPixels(this: *mut SkCanvas, arg1: *mut SkPixmap)
     -> bool;
}
extern "C" {
    /**
     *  Copy the pixels from the base-layer into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (SkImageInfo). The base-layer pixels are read
     *  starting at the specified (srcX,srcY) location in the coordinate system of the base-layer.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the base-layer. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the base-layer bounds.
     *  - If the requested colortype/alphatype cannot be converted from the base-layer's types.
     *  - If this canvas is not backed by pixels (e.g. picture or PDF)
     */
    #[link_name = "?readPixels@SkCanvas@@QEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
    pub fn SkCanvas_readPixels(this: *mut SkCanvas,
                               dstInfo: *const SkImageInfo,
                               dstPixels: *mut ::std::os::raw::c_void,
                               dstRowBytes: usize,
                               srcX: ::std::os::raw::c_int,
                               srcY: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
     *  Helper for calling readPixels(info). This call will check if bitmap has been allocated.
     *  If not, it will attempt to call allocPixels(). If this fails, it will return false. If not,
     *  it calls through to readPixels(info) and returns its result.
     */
    #[link_name = "?readPixels@SkCanvas@@QEAA_NPEAVSkBitmap@@HH@Z"]
    pub fn SkCanvas_readPixels1(this: *mut SkCanvas, bitmap: *mut SkBitmap,
                                srcX: ::std::os::raw::c_int,
                                srcY: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
     *  Helper for allocating pixels and then calling readPixels(info). The bitmap is resized
     *  to the intersection of srcRect and the base-layer bounds. On success, pixels will be
     *  allocated in bitmap and true returned. On failure, false is returned and bitmap will be
     *  set to empty.
     */
    #[link_name = "?readPixels@SkCanvas@@QEAA_NAEBUSkIRect@@PEAVSkBitmap@@@Z"]
    pub fn SkCanvas_readPixels2(this: *mut SkCanvas, srcRect: *const SkIRect,
                                bitmap: *mut SkBitmap) -> bool;
}
extern "C" {
    /**
     *  This method affects the pixels in the base-layer, and operates in pixel coordinates,
     *  ignoring the matrix and clip.
     *
     *  The specified ImageInfo and (x,y) offset specifies a rectangle: target.
     *
     *      target.setXYWH(x, y, info.width(), info.height());
     *
     *  Target is intersected with the bounds of the base-layer. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size), the "src" specified by info+pixels+rowBytes
     *  and the "dst" by the canvas' backend. Replace the dst pixels with the corresponding src
     *  pixels, performing any colortype/alphatype transformations needed (in the case where the
     *  src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If the src colortype/alphatype cannot be converted to the canvas' types
     *  - If this canvas is not backed by pixels (e.g. picture or PDF)
     */
    #[link_name = "?writePixels@SkCanvas@@QEAA_NAEBUSkImageInfo@@PEBX_KHH@Z"]
    pub fn SkCanvas_writePixels(this: *mut SkCanvas, arg1: *const SkImageInfo,
                                pixels: *const ::std::os::raw::c_void,
                                rowBytes: usize, x: ::std::os::raw::c_int,
                                y: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
     *  Helper for calling writePixels(info) by passing its pixels and rowbytes. If the bitmap
     *  is just wrapping a texture, returns false and does nothing.
     */
    #[link_name = "?writePixels@SkCanvas@@QEAA_NAEBVSkBitmap@@HH@Z"]
    pub fn SkCanvas_writePixels1(this: *mut SkCanvas, bitmap: *const SkBitmap,
                                 x: ::std::os::raw::c_int,
                                 y: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /** This call saves the current matrix, clip, and drawFilter, and pushes a
        copy onto a private stack. Subsequent calls to translate, scale,
        rotate, skew, concat or clipRect, clipPath, and setDrawFilter all
        operate on this copy.
        When the balancing call to restore() is made, the previous matrix, clip,
        and drawFilter are restored.

        @return The value to pass to restoreToCount() to balance this save()
    */
    #[link_name = "?save@SkCanvas@@QEAAHXZ"]
    pub fn SkCanvas_save(this: *mut SkCanvas) -> ::std::os::raw::c_int;
}
extern "C" {
    /** This behaves the same as save(), but in addition it allocates an
        offscreen bitmap. All drawing calls are directed there, and only when
        the balancing call to restore() is made is that offscreen transfered to
        the canvas (or the previous layer).
        @param bounds (may be null) This rect, if non-null, is used as a hint to
                      limit the size of the offscreen, and thus drawing may be
                      clipped to it, though that clipping is not guaranteed to
                      happen. If exact clipping is desired, use clipRect().
        @param paint (may be null) This is copied, and is applied to the
                     offscreen when restore() is called
        @return The value to pass to restoreToCount() to balance this save()
    */
    #[link_name = "?saveLayer@SkCanvas@@QEAAHPEBUSkRect@@PEBVSkPaint@@@Z"]
    pub fn SkCanvas_saveLayer(this: *mut SkCanvas, bounds: *const SkRect,
                              paint: *const SkPaint) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
     *  Temporary name.
     *  Will allow any requests for LCD text to be respected, so the caller must be careful to
     *  only draw on top of opaque sections of the layer to get good results.
     */
    #[link_name =
          "?saveLayerPreserveLCDTextRequests@SkCanvas@@QEAAHPEBUSkRect@@PEBVSkPaint@@@Z"]
    pub fn SkCanvas_saveLayerPreserveLCDTextRequests(this: *mut SkCanvas,
                                                     bounds: *const SkRect,
                                                     paint: *const SkPaint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** This behaves the same as save(), but in addition it allocates an
        offscreen bitmap. All drawing calls are directed there, and only when
        the balancing call to restore() is made is that offscreen transfered to
        the canvas (or the previous layer).
        @param bounds (may be null) This rect, if non-null, is used as a hint to
                      limit the size of the offscreen, and thus drawing may be
                      clipped to it, though that clipping is not guaranteed to
                      happen. If exact clipping is desired, use clipRect().
        @param alpha  This is applied to the offscreen when restore() is called.
        @return The value to pass to restoreToCount() to balance this save()
    */
    #[link_name = "?saveLayerAlpha@SkCanvas@@QEAAHPEBUSkRect@@I@Z"]
    pub fn SkCanvas_saveLayerAlpha(this: *mut SkCanvas, bounds: *const SkRect,
                                   alpha: U8CPU) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?saveLayer@SkCanvas@@QEAAHAEBUSaveLayerRec@1@@Z"]
    pub fn SkCanvas_saveLayer1(this: *mut SkCanvas,
                               arg1: *const SkCanvas_SaveLayerRec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** This call balances a previous call to save(), and is used to remove all
        modifications to the matrix/clip/drawFilter state since the last save
        call.
        It is an error to call restore() more times than save() was called.
    */
    #[link_name = "?restore@SkCanvas@@QEAAXXZ"]
    pub fn SkCanvas_restore(this: *mut SkCanvas);
}
extern "C" {
    /** Returns the number of matrix/clip states on the SkCanvas' private stack.
        This will equal # save() calls - # restore() calls + 1. The save count on
        a new canvas is 1.
    */
    #[link_name = "?getSaveCount@SkCanvas@@QEBAHXZ"]
    pub fn SkCanvas_getSaveCount(this: *const SkCanvas)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Efficient way to pop any calls to save() that happened after the save
        count reached saveCount. It is an error for saveCount to be greater than
        getSaveCount(). To pop all the way back to the initial matrix/clip context
        pass saveCount == 1.
        @param saveCount    The number of save() levels to restore from
    */
    #[link_name = "?restoreToCount@SkCanvas@@QEAAXH@Z"]
    pub fn SkCanvas_restoreToCount(this: *mut SkCanvas,
                                   saveCount: ::std::os::raw::c_int);
}
extern "C" {
    /** Preconcat the current matrix with the specified translation
        @param dx   The distance to translate in X
        @param dy   The distance to translate in Y
    */
    #[link_name = "?translate@SkCanvas@@QEAAXMM@Z"]
    pub fn SkCanvas_translate(this: *mut SkCanvas, dx: SkScalar,
                              dy: SkScalar);
}
extern "C" {
    /** Preconcat the current matrix with the specified scale.
        @param sx   The amount to scale in X
        @param sy   The amount to scale in Y
    */
    #[link_name = "?scale@SkCanvas@@QEAAXMM@Z"]
    pub fn SkCanvas_scale(this: *mut SkCanvas, sx: SkScalar, sy: SkScalar);
}
extern "C" {
    /** Preconcat the current matrix with the specified rotation about the origin.
        @param degrees  The amount to rotate, in degrees
    */
    #[link_name = "?rotate@SkCanvas@@QEAAXM@Z"]
    pub fn SkCanvas_rotate(this: *mut SkCanvas, degrees: SkScalar);
}
extern "C" {
    /** Preconcat the current matrix with the specified rotation about a given point.
        @param degrees  The amount to rotate, in degrees
        @param px  The x coordinate of the point to rotate about.
        @param py  The y coordinate of the point to rotate about.
    */
    #[link_name = "?rotate@SkCanvas@@QEAAXMMM@Z"]
    pub fn SkCanvas_rotate1(this: *mut SkCanvas, degrees: SkScalar,
                            px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Preconcat the current matrix with the specified skew.
        @param sx   The amount to skew in X
        @param sy   The amount to skew in Y
    */
    #[link_name = "?skew@SkCanvas@@QEAAXMM@Z"]
    pub fn SkCanvas_skew(this: *mut SkCanvas, sx: SkScalar, sy: SkScalar);
}
extern "C" {
    /** Preconcat the current matrix with the specified matrix.
        @param matrix   The matrix to preconcatenate with the current matrix
    */
    #[link_name = "?concat@SkCanvas@@QEAAXAEBVSkMatrix@@@Z"]
    pub fn SkCanvas_concat(this: *mut SkCanvas, matrix: *const SkMatrix);
}
extern "C" {
    /** Replace the current matrix with a copy of the specified matrix.
        @param matrix The matrix that will be copied into the current matrix.
    */
    #[link_name = "?setMatrix@SkCanvas@@QEAAXAEBVSkMatrix@@@Z"]
    pub fn SkCanvas_setMatrix(this: *mut SkCanvas, matrix: *const SkMatrix);
}
extern "C" {
    /** Helper for setMatrix(identity). Sets the current matrix to identity.
    */
    #[link_name = "?resetMatrix@SkCanvas@@QEAAXXZ"]
    pub fn SkCanvas_resetMatrix(this: *mut SkCanvas);
}
extern "C" {
    /**
     *  Modify the current clip with the specified rectangle.
     *  @param rect The rect to combine with the current clip
     *  @param op The region op to apply to the current clip
     *  @param doAntiAlias true if the clip should be antialiased
     */
    #[link_name = "?clipRect@SkCanvas@@QEAAXAEBUSkRect@@W4SkClipOp@@_N@Z"]
    pub fn SkCanvas_clipRect(this: *mut SkCanvas, rect: *const SkRect,
                             arg1: SkClipOp, doAntiAlias: bool);
}
extern "C" {
    /**
     *  Modify the current clip with the specified SkRRect.
     *  @param rrect The rrect to combine with the current clip
     *  @param op The region op to apply to the current clip
     *  @param doAntiAlias true if the clip should be antialiased
     */
    #[link_name = "?clipRRect@SkCanvas@@QEAAXAEBVSkRRect@@W4SkClipOp@@_N@Z"]
    pub fn SkCanvas_clipRRect(this: *mut SkCanvas, rrect: *const SkRRect,
                              op: SkClipOp, doAntiAlias: bool);
}
extern "C" {
    /**
     *  Modify the current clip with the specified path.
     *  @param path The path to combine with the current clip
     *  @param op The region op to apply to the current clip
     *  @param doAntiAlias true if the clip should be antialiased
     */
    #[link_name = "?clipPath@SkCanvas@@QEAAXAEBVSkPath@@W4SkClipOp@@_N@Z"]
    pub fn SkCanvas_clipPath(this: *mut SkCanvas, path: *const SkPath,
                             op: SkClipOp, doAntiAlias: bool);
}
extern "C" {
    /** Modify the current clip with the specified region. Note that unlike
        clipRect() and clipPath() which transform their arguments by the current
        matrix, clipRegion() assumes its argument is already in device
        coordinates, and so no transformation is performed.
        @param deviceRgn    The region to apply to the current clip
        @param op The region op to apply to the current clip
    */
    #[link_name = "?clipRegion@SkCanvas@@QEAAXAEBVSkRegion@@W4SkClipOp@@@Z"]
    pub fn SkCanvas_clipRegion(this: *mut SkCanvas,
                               deviceRgn: *const SkRegion, op: SkClipOp);
}
extern "C" {
    /** Return true if the specified rectangle, after being transformed by the
        current matrix, would lie completely outside of the current clip. Call
        this to check if an area you intend to draw into is clipped out (and
        therefore you can skip making the draw calls).
        @param rect the rect to compare with the current clip
        @return true if the rect (transformed by the canvas' matrix) does not
                     intersect with the canvas' clip
    */
    #[link_name = "?quickReject@SkCanvas@@QEBA_NAEBUSkRect@@@Z"]
    pub fn SkCanvas_quickReject(this: *const SkCanvas, rect: *const SkRect)
     -> bool;
}
extern "C" {
    /** Return true if the specified path, after being transformed by the
        current matrix, would lie completely outside of the current clip. Call
        this to check if an area you intend to draw into is clipped out (and
        therefore you can skip making the draw calls). Note, for speed it may
        return false even if the path itself might not intersect the clip
        (i.e. the bounds of the path intersects, but the path does not).
        @param path The path to compare with the current clip
        @return true if the path (transformed by the canvas' matrix) does not
                     intersect with the canvas' clip
    */
    #[link_name = "?quickReject@SkCanvas@@QEBA_NAEBVSkPath@@@Z"]
    pub fn SkCanvas_quickReject1(this: *const SkCanvas, path: *const SkPath)
     -> bool;
}
extern "C" {
    /** Fill the entire canvas' bitmap (restricted to the current clip) with the
        specified ARGB color, using the specified mode.
        @param a    the alpha component (0..255) of the color to fill the canvas
        @param r    the red component (0..255) of the color to fill the canvas
        @param g    the green component (0..255) of the color to fill the canvas
        @param b    the blue component (0..255) of the color to fill the canvas
        @param mode the mode to apply the color in (defaults to SrcOver)
    */
    #[link_name = "?drawARGB@SkCanvas@@QEAAXIIIIW4SkBlendMode@@@Z"]
    pub fn SkCanvas_drawARGB(this: *mut SkCanvas, a: U8CPU, r: U8CPU,
                             g: U8CPU, b: U8CPU, mode: SkBlendMode);
}
extern "C" {
    /** Fill the entire canvas' bitmap (restricted to the current clip) with the
        specified color and mode.
        @param color    the color to draw with
        @param mode the mode to apply the color in (defaults to SrcOver)
    */
    #[link_name = "?drawColor@SkCanvas@@QEAAXIW4SkBlendMode@@@Z"]
    pub fn SkCanvas_drawColor(this: *mut SkCanvas, color: SkColor,
                              mode: SkBlendMode);
}
extern "C" {
    /**
     *  Fill the entire canvas (restricted to the current clip) with the
     *  specified paint.
     *  @param paint    The paint used to fill the canvas
     */
    #[link_name = "?drawPaint@SkCanvas@@QEAAXAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawPaint(this: *mut SkCanvas, paint: *const SkPaint);
}
extern "C" {
    /** Draw a series of points, interpreted based on the PointMode mode. For
        all modes, the count parameter is interpreted as the total number of
        points. For kLine mode, count/2 line segments are drawn.
        For kPoint mode, each point is drawn centered at its coordinate, and its
        size is specified by the paint's stroke-width. It draws as a square,
        unless the paint's cap-type is round, in which the points are drawn as
        circles.
        For kLine mode, each pair of points is drawn as a line segment,
        respecting the paint's settings for cap/join/width.
        For kPolygon mode, the entire array is drawn as a series of connected
        line segments.
        Note that, while similar, kLine and kPolygon modes draw slightly
        differently than the equivalent path built with a series of moveto,
        lineto calls, in that the path will draw all of its contours at once,
        with no interactions if contours intersect each other (think XOR
        xfermode). drawPoints always draws each element one at a time.
        @param mode     PointMode specifying how to draw the array of points.
        @param count    The number of points in the array
        @param pts      Array of points to draw
        @param paint    The paint used to draw the points
    */
    #[link_name =
          "?drawPoints@SkCanvas@@QEAAXW4PointMode@1@_KQEBUSkPoint@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawPoints(this: *mut SkCanvas, mode: SkCanvas_PointMode,
                               count: usize, pts: *const SkPoint,
                               paint: *const SkPaint);
}
extern "C" {
    /** Helper method for drawing a single point. See drawPoints() for a more
        details.
    */
    #[link_name = "?drawPoint@SkCanvas@@QEAAXMMAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawPoint(this: *mut SkCanvas, x: SkScalar, y: SkScalar,
                              paint: *const SkPaint);
}
extern "C" {
    /** Draws a single pixel in the specified color.
        @param x        The X coordinate of which pixel to draw
        @param y        The Y coordiante of which pixel to draw
        @param color    The color to draw
    */
    #[link_name = "?drawPoint@SkCanvas@@QEAAXMMI@Z"]
    pub fn SkCanvas_drawPoint1(this: *mut SkCanvas, x: SkScalar, y: SkScalar,
                               color: SkColor);
}
extern "C" {
    /** Draw a line segment with the specified start and stop x,y coordinates,
        using the specified paint. NOTE: since a line is always "framed", the
        paint's Style is ignored.
        @param x0    The x-coordinate of the start point of the line
        @param y0    The y-coordinate of the start point of the line
        @param x1    The x-coordinate of the end point of the line
        @param y1    The y-coordinate of the end point of the line
        @param paint The paint used to draw the line
    */
    #[link_name = "?drawLine@SkCanvas@@QEAAXMMMMAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawLine(this: *mut SkCanvas, x0: SkScalar, y0: SkScalar,
                             x1: SkScalar, y1: SkScalar,
                             paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified rectangle using the specified paint. The rectangle
        will be filled or stroked based on the Style in the paint.
        @param rect     The rect to be drawn
        @param paint    The paint used to draw the rect
    */
    #[link_name = "?drawRect@SkCanvas@@QEAAXAEBUSkRect@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawRect(this: *mut SkCanvas, rect: *const SkRect,
                             paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified rectangle using the specified paint. The rectangle
        will be filled or framed based on the Style in the paint.
        @param left     The left side of the rectangle to be drawn
        @param top      The top side of the rectangle to be drawn
        @param right    The right side of the rectangle to be drawn
        @param bottom   The bottom side of the rectangle to be drawn
        @param paint    The paint used to draw the rect
    */
    #[link_name = "?drawRectCoords@SkCanvas@@QEAAXMMMMAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawRectCoords(this: *mut SkCanvas, left: SkScalar,
                                   top: SkScalar, right: SkScalar,
                                   bottom: SkScalar, paint: *const SkPaint);
}
extern "C" {
    /** Draw the outline of the specified region using the specified paint.
        @param region   The region to be drawn
        @param paint    The paint used to draw the region
    */
    #[link_name = "?drawRegion@SkCanvas@@QEAAXAEBVSkRegion@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawRegion(this: *mut SkCanvas, region: *const SkRegion,
                               paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified oval using the specified paint. The oval will be
        filled or framed based on the Style in the paint.
        @param oval     The rectangle bounds of the oval to be drawn
        @param paint    The paint used to draw the oval
    */
    #[link_name = "?drawOval@SkCanvas@@QEAAXAEBUSkRect@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawOval(this: *mut SkCanvas, oval: *const SkRect,
                             arg1: *const SkPaint);
}
extern "C" {
    /**
     *  Draw the specified RRect using the specified paint The rrect will be filled or stroked
     *  based on the Style in the paint.
     *
     *  @param rrect    The round-rect to draw
     *  @param paint    The paint used to draw the round-rect
     */
    #[link_name = "?drawRRect@SkCanvas@@QEAAXAEBVSkRRect@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawRRect(this: *mut SkCanvas, rrect: *const SkRRect,
                              paint: *const SkPaint);
}
extern "C" {
    /**
     *  Draw the annulus formed by the outer and inner rrects. The results
     *  are undefined if the outer does not contain the inner.
     */
    #[link_name = "?drawDRRect@SkCanvas@@QEAAXAEBVSkRRect@@0AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawDRRect(this: *mut SkCanvas, outer: *const SkRRect,
                               inner: *const SkRRect, arg1: *const SkPaint);
}
extern "C" {
    /** Draw the specified circle using the specified paint. If radius is <= 0,
        then nothing will be drawn. The circle will be filled
        or framed based on the Style in the paint.
        @param cx       The x-coordinate of the center of the cirle to be drawn
        @param cy       The y-coordinate of the center of the cirle to be drawn
        @param radius   The radius of the cirle to be drawn
        @param paint    The paint used to draw the circle
    */
    #[link_name = "?drawCircle@SkCanvas@@QEAAXMMMAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawCircle(this: *mut SkCanvas, cx: SkScalar,
                               cy: SkScalar, radius: SkScalar,
                               paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified arc, which will be scaled to fit inside the
        specified oval. Sweep angles are not treated as modulo 360 and thus can
        exceed a full sweep of the oval. Note that this differs slightly from
        SkPath::arcTo, which treats the sweep angle mod 360. If the oval is empty
        or the sweep angle is zero nothing is drawn. If useCenter is true the oval
        center is inserted into the implied path before the arc and the path is
        closed back to the, center forming a wedge. Otherwise, the implied path
        contains just the arc and is not closed.
        @param oval The bounds of oval used to define the shape of the arc.
        @param startAngle Starting angle (in degrees) where the arc begins
        @param sweepAngle Sweep angle (in degrees) measured clockwise.
        @param useCenter true means include the center of the oval.
        @param paint    The paint used to draw the arc
    */
    #[link_name = "?drawArc@SkCanvas@@QEAAXAEBUSkRect@@MM_NAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawArc(this: *mut SkCanvas, oval: *const SkRect,
                            startAngle: SkScalar, sweepAngle: SkScalar,
                            useCenter: bool, paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified round-rect using the specified paint. The round-rect
        will be filled or framed based on the Style in the paint.
        @param rect     The rectangular bounds of the roundRect to be drawn
        @param rx       The x-radius of the oval used to round the corners
        @param ry       The y-radius of the oval used to round the corners
        @param paint    The paint used to draw the roundRect
    */
    #[link_name =
          "?drawRoundRect@SkCanvas@@QEAAXAEBUSkRect@@MMAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawRoundRect(this: *mut SkCanvas, rect: *const SkRect,
                                  rx: SkScalar, ry: SkScalar,
                                  paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified path using the specified paint. The path will be
        filled or framed based on the Style in the paint.
        @param path     The path to be drawn
        @param paint    The paint used to draw the path
    */
    #[link_name = "?drawPath@SkCanvas@@QEAAXAEBVSkPath@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawPath(this: *mut SkCanvas, path: *const SkPath,
                             paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified image, with its top/left corner at (x,y), using the
        specified paint, transformed by the current matrix.

        @param image    The image to be drawn
        @param left     The position of the left side of the image being drawn
        @param top      The position of the top side of the image being drawn
        @param paint    The paint used to draw the image, or NULL
     */
    #[link_name = "?drawImage@SkCanvas@@QEAAXPEBVSkImage@@MMPEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawImage(this: *mut SkCanvas, image: *const SkImage,
                              left: SkScalar, top: SkScalar,
                              paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified image, scaling and translating so that it fills the specified
     *  dst rect. If the src rect is non-null, only that subset of the image is transformed
     *  and drawn.
     *
     *  @param image      The image to be drawn
     *  @param src        Optional: specify the subset of the image to be drawn
     *  @param dst        The destination rectangle where the scaled/translated
     *                    image will be drawn
     *  @param paint      The paint used to draw the image, or NULL
     *  @param constraint Control the tradeoff between speed and exactness w.r.t. the src-rect.
     */
    #[link_name =
          "?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkRect@@1PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
    pub fn SkCanvas_drawImageRect(this: *mut SkCanvas, image: *const SkImage,
                                  src: *const SkRect, dst: *const SkRect,
                                  paint: *const SkPaint,
                                  constraint: SkCanvas_SrcRectConstraint);
}
extern "C" {
    #[link_name =
          "?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
    pub fn SkCanvas_drawImageRect1(this: *mut SkCanvas, image: *const SkImage,
                                   isrc: *const SkIRect, dst: *const SkRect,
                                   paint: *const SkPaint,
                                   arg1: SkCanvas_SrcRectConstraint);
}
extern "C" {
    #[link_name =
          "?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
    pub fn SkCanvas_drawImageRect2(this: *mut SkCanvas, image: *const SkImage,
                                   dst: *const SkRect, paint: *const SkPaint,
                                   arg1: SkCanvas_SrcRectConstraint);
}
extern "C" {
    /**
     *  Draw the image stretched differentially to fit into dst.
     *  center is a rect within the image, and logically divides the image
     *  into 9 sections (3x3). For example, if the middle pixel of a [5x5]
     *  image is the "center", then the center-rect should be [2, 2, 3, 3].
     *
     *  If the dst is >= the image size, then...
     *  - The 4 corners are not stretched at all.
     *  - The sides are stretched in only one axis.
     *  - The center is stretched in both axes.
     * Else, for each axis where dst < image,
     *  - The corners shrink proportionally
     *  - The sides (along the shrink axis) and center are not drawn
     */
    #[link_name =
          "?drawImageNine@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawImageNine(this: *mut SkCanvas, arg1: *const SkImage,
                                  center: *const SkIRect, dst: *const SkRect,
                                  paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified bitmap, with its top/left corner at (x,y), using the
        specified paint, transformed by the current matrix. Note: if the paint
        contains a maskfilter that generates a mask which extends beyond the
        bitmap's original width/height, then the bitmap will be drawn as if it
        were in a Shader with CLAMP mode. Thus the color outside of the original
        width/height will be the edge color replicated.

        If a shader is present on the paint it will be ignored, except in the
        case where the bitmap is kAlpha_8_SkColorType. In that case, the color is
        generated by the shader.

        @param bitmap   The bitmap to be drawn
        @param left     The position of the left side of the bitmap being drawn
        @param top      The position of the top side of the bitmap being drawn
        @param paint    The paint used to draw the bitmap, or NULL
    */
    #[link_name =
          "?drawBitmap@SkCanvas@@QEAAXAEBVSkBitmap@@MMPEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawBitmap(this: *mut SkCanvas, bitmap: *const SkBitmap,
                               left: SkScalar, top: SkScalar,
                               paint: *const SkPaint);
}
extern "C" {
    /** Draw the specified bitmap, scaling and translating so that it fills the specified
     *  dst rect. If the src rect is non-null, only that subset of the bitmap is transformed
     *  and drawn.
     *
     *  @param bitmap     The bitmap to be drawn
     *  @param src        Optional: specify the subset of the bitmap to be drawn
     *  @param dst        The destination rectangle where the scaled/translated
     *                    bitmap will be drawn
     *  @param paint      The paint used to draw the bitmap, or NULL
     *  @param constraint Control the tradeoff between speed and exactness w.r.t. the src-rect.
     */
    #[link_name =
          "?drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkRect@@1PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
    pub fn SkCanvas_drawBitmapRect(this: *mut SkCanvas,
                                   bitmap: *const SkBitmap,
                                   src: *const SkRect, dst: *const SkRect,
                                   paint: *const SkPaint,
                                   arg1: SkCanvas_SrcRectConstraint);
}
extern "C" {
    #[link_name =
          "?drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
    pub fn SkCanvas_drawBitmapRect1(this: *mut SkCanvas,
                                    bitmap: *const SkBitmap,
                                    isrc: *const SkIRect, dst: *const SkRect,
                                    paint: *const SkPaint,
                                    arg1: SkCanvas_SrcRectConstraint);
}
extern "C" {
    #[link_name =
          "?drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
    pub fn SkCanvas_drawBitmapRect2(this: *mut SkCanvas,
                                    bitmap: *const SkBitmap,
                                    dst: *const SkRect, paint: *const SkPaint,
                                    arg1: SkCanvas_SrcRectConstraint);
}
extern "C" {
    /**
     *  Draw the bitmap stretched or shrunk differentially to fit into dst.
     *  center is a rect within the bitmap, and logically divides the bitmap
     *  into 9 sections (3x3). For example, if the middle pixel of a [5x5]
     *  bitmap is the "center", then the center-rect should be [2, 2, 3, 3].
     *
     *  If the dst is >= the bitmap size, then...
     *  - The 4 corners are not stretched at all.
     *  - The sides are stretched in only one axis.
     *  - The center is stretched in both axes.
     * Else, for each axis where dst < bitmap,
     *  - The corners shrink proportionally
     *  - The sides (along the shrink axis) and center are not drawn
     */
    #[link_name =
          "?drawBitmapNine@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawBitmapNine(this: *mut SkCanvas,
                                   bitmap: *const SkBitmap,
                                   center: *const SkIRect, dst: *const SkRect,
                                   paint: *const SkPaint);
}
extern "C" {
    /**
     *  Draw the bitmap stretched or shrunk differentially to fit into dst.
     *
     *  Moving horizontally across the bitmap, alternating rects will be "scalable"
     *  (in the x-dimension) to fit into dst or must be left "fixed".  The first rect
     *  is treated as "fixed", but it's possible to specify an empty first rect by
     *  making lattice.fXDivs[0] = 0.
     *
     *  The scale factor for all "scalable" rects will be the same, and may be greater
     *  than or less than 1 (meaning we can stretch or shrink).  If the number of
     *  "fixed" pixels is greater than the width of the dst, we will collapse all of
     *  the "scalable" regions and appropriately downscale the "fixed" regions.
     *
     *  The same interpretation also applies to the y-dimension.
     */
    #[link_name =
          "?drawBitmapLattice@SkCanvas@@QEAAXAEBVSkBitmap@@AEBULattice@1@AEBUSkRect@@PEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawBitmapLattice(this: *mut SkCanvas,
                                      bitmap: *const SkBitmap,
                                      lattice: *const SkCanvas_Lattice,
                                      dst: *const SkRect,
                                      paint: *const SkPaint);
}
extern "C" {
    #[link_name =
          "?drawImageLattice@SkCanvas@@QEAAXPEBVSkImage@@AEBULattice@1@AEBUSkRect@@PEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawImageLattice(this: *mut SkCanvas,
                                     image: *const SkImage,
                                     lattice: *const SkCanvas_Lattice,
                                     dst: *const SkRect,
                                     paint: *const SkPaint);
}
extern "C" {
    /** Draw the text, with origin at (x,y), using the specified paint.
        The origin is interpreted based on the Align setting in the paint.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param x        The x-coordinate of the origin of the text being drawn
        @param y        The y-coordinate of the origin of the text being drawn
        @param paint    The paint used for the text (e.g. color, size, style)
    */
    #[link_name = "?drawText@SkCanvas@@QEAAXPEBX_KMMAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawText(this: *mut SkCanvas,
                             text: *const ::std::os::raw::c_void,
                             byteLength: usize, x: SkScalar, y: SkScalar,
                             paint: *const SkPaint);
}
extern "C" {
    /** Draw the text, with each character/glyph origin specified by the pos[]
        array. The origin is interpreted by the Align setting in the paint.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param pos      Array of positions, used to position each character
        @param paint    The paint used for the text (e.g. color, size, style)
        */
    #[link_name =
          "?drawPosText@SkCanvas@@QEAAXPEBX_KQEBUSkPoint@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawPosText(this: *mut SkCanvas,
                                text: *const ::std::os::raw::c_void,
                                byteLength: usize, pos: *const SkPoint,
                                paint: *const SkPaint);
}
extern "C" {
    /** Draw the text, with each character/glyph origin specified by the x
        coordinate taken from the xpos[] array, and the y from the constY param.
        The origin is interpreted by the Align setting in the paint.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param xpos     Array of x-positions, used to position each character
        @param constY   The shared Y coordinate for all of the positions
        @param paint    The paint used for the text (e.g. color, size, style)
        */
    #[link_name = "?drawPosTextH@SkCanvas@@QEAAXPEBX_KQEBMMAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawPosTextH(this: *mut SkCanvas,
                                 text: *const ::std::os::raw::c_void,
                                 byteLength: usize, xpos: *const SkScalar,
                                 constY: SkScalar, paint: *const SkPaint);
}
extern "C" {
    /** Draw the text, with origin at (x,y), using the specified paint, along
        the specified path. The paint's Align setting determins where along the
        path to start the text.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param path         The path the text should follow for its baseline
        @param hOffset      The distance along the path to add to the text's
                            starting position
        @param vOffset      The distance above(-) or below(+) the path to
                            position the text
        @param paint        The paint used for the text
    */
    #[link_name =
          "?drawTextOnPathHV@SkCanvas@@QEAAXPEBX_KAEBVSkPath@@MMAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawTextOnPathHV(this: *mut SkCanvas,
                                     text: *const ::std::os::raw::c_void,
                                     byteLength: usize, path: *const SkPath,
                                     hOffset: SkScalar, vOffset: SkScalar,
                                     paint: *const SkPaint);
}
extern "C" {
    /** Draw the text, with origin at (x,y), using the specified paint, along
        the specified path. The paint's Align setting determins where along the
        path to start the text.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param path         The path the text should follow for its baseline
        @param matrix       (may be null) Applied to the text before it is
                            mapped onto the path
        @param paint        The paint used for the text
        */
    #[link_name =
          "?drawTextOnPath@SkCanvas@@QEAAXPEBX_KAEBVSkPath@@PEBVSkMatrix@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawTextOnPath(this: *mut SkCanvas,
                                   text: *const ::std::os::raw::c_void,
                                   byteLength: usize, path: *const SkPath,
                                   matrix: *const SkMatrix,
                                   paint: *const SkPaint);
}
extern "C" {
    /**
     *  Draw the text with each character/glyph individually transformed by its xform.
     *  If cullRect is not null, it is a conservative bounds of what will be drawn
     *  taking into account the xforms and the paint, and will be used to accelerate culling.
     */
    #[link_name =
          "?drawTextRSXform@SkCanvas@@QEAAXPEBX_KQEBUSkRSXform@@PEBUSkRect@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawTextRSXform(this: *mut SkCanvas,
                                    text: *const ::std::os::raw::c_void,
                                    byteLength: usize, arg1: *const SkRSXform,
                                    cullRect: *const SkRect,
                                    paint: *const SkPaint);
}
extern "C" {
    /** Draw the text blob, offset by (x,y), using the specified paint.
        @param blob     The text blob to be drawn
        @param x        The x-offset of the text being drawn
        @param y        The y-offset of the text being drawn
        @param paint    The paint used for the text (e.g. color, size, style)
    */
    #[link_name =
          "?drawTextBlob@SkCanvas@@QEAAXPEBVSkTextBlob@@MMAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawTextBlob(this: *mut SkCanvas, blob: *const SkTextBlob,
                                 x: SkScalar, y: SkScalar,
                                 paint: *const SkPaint);
}
extern "C" {
    /**
     *  Draw the picture into this canvas.
     *
     *  If matrix is non-null, apply that matrix to the CTM when drawing this picture. This is
     *  logically equivalent to
     *      save/concat/drawPicture/restore
     *
     *  If paint is non-null, draw the picture into a temporary buffer, and then apply the paint's
     *  alpha/colorfilter/imagefilter/xfermode to that buffer as it is drawn to the canvas.
     *  This is logically equivalent to
     *      saveLayer(paint)/drawPicture/restore
     */
    #[link_name =
          "?drawPicture@SkCanvas@@QEAAXPEBVSkPicture@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawPicture(this: *mut SkCanvas, arg1: *const SkPicture,
                                matrix: *const SkMatrix,
                                paint: *const SkPaint);
}
extern "C" {
    /** Draw the array of vertices, interpreted as triangles (based on mode).

        If both textures and vertex-colors are NULL, it strokes hairlines with
        the paint's color. This behavior is a useful debugging mode to visualize
        the mesh.

        @param vmode How to interpret the array of vertices
        @param vertexCount The number of points in the vertices array (and
                    corresponding texs and colors arrays if non-null)
        @param vertices Array of vertices for the mesh
        @param texs May be null. If not null, specifies the coordinate
                    in _texture_ space (not uv space) for each vertex.
        @param colors May be null. If not null, specifies a color for each
                      vertex, to be interpolated across the triangle.
        @param mode Used if both texs and colors are present. In this
                    case the colors are combined with the texture using mode,
                    before being drawn using the paint. 
        @param indices If not null, array of indices to reference into the
                    vertex (texs, colors) array.
        @param indexCount number of entries in the indices array (if not null)
        @param paint Specifies the shader/texture if present.
    */
    #[link_name =
          "?drawVertices@SkCanvas@@QEAAXW4VertexMode@1@HQEBUSkPoint@@1QEBIW4SkBlendMode@@QEBGHAEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawVertices(this: *mut SkCanvas,
                                 vmode: SkCanvas_VertexMode,
                                 vertexCount: ::std::os::raw::c_int,
                                 vertices: *const SkPoint,
                                 texs: *const SkPoint, colors: *const SkColor,
                                 mode: SkBlendMode, indices: *const u16,
                                 indexCount: ::std::os::raw::c_int,
                                 paint: *const SkPaint);
}
extern "C" {
    /**
     Draw a cubic coons patch

     @param cubic specifies the 4 bounding cubic bezier curves of a patch with clockwise order
                    starting at the top left corner.
     @param colors specifies the colors for the corners which will be bilerp across the patch,
                    their order is clockwise starting at the top left corner.
     @param texCoords specifies the texture coordinates that will be bilerp across the patch,
                    their order is the same as the colors.
     @param mode specifies how are the colors and the textures combined if both of them are
                    present.
     @param paint Specifies the shader/texture if present.
     */
    #[link_name =
          "?drawPatch@SkCanvas@@QEAAXQEBUSkPoint@@QEBI0W4SkBlendMode@@AEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawPatch(this: *mut SkCanvas, cubics: *mut SkPoint,
                              colors: *mut SkColor, texCoords: *mut SkPoint,
                              mode: SkBlendMode, paint: *const SkPaint);
}
extern "C" {
    /**
     *  Draw a set of sprites from the atlas. Each is specified by a tex rectangle in the
     *  coordinate space of the atlas, and a corresponding xform which transforms the tex rectangle
     *  into a quad.
     *
     *      xform maps [0, 0, tex.width, tex.height] -> quad
     *
     *  The color array is optional. When specified, each color modulates the pixels in its
     *  corresponding quad (via the specified SkBlendMode).
     *
     *  The cullRect is optional. When specified, it must be a conservative bounds of all of the
     *  resulting transformed quads, allowing the canvas to skip drawing if the cullRect does not
     *  intersect the current clip.
     *
     *  The paint is optional. If specified, its antialiasing, alpha, color-filter, image-filter
     *  and blendmode are used to affect each of the quads.
     */
    #[link_name =
          "?drawAtlas@SkCanvas@@QEAAXPEBVSkImage@@QEBUSkRSXform@@QEBUSkRect@@QEBIHW4SkBlendMode@@PEBU4@PEBVSkPaint@@@Z"]
    pub fn SkCanvas_drawAtlas(this: *mut SkCanvas, atlas: *const SkImage,
                              xform: *const SkRSXform, tex: *const SkRect,
                              colors: *const SkColor,
                              count: ::std::os::raw::c_int, arg1: SkBlendMode,
                              cullRect: *const SkRect, paint: *const SkPaint);
}
extern "C" {
    /**
     *  Draw the contents of this drawable into the canvas. If the canvas is async
     *  (e.g. it is recording into a picture) then the drawable will be referenced instead,
     *  to have its draw() method called when the picture is finalized.
     *
     *  If the intent is to force the contents of the drawable into this canvas immediately,
     *  then drawable->draw(canvas) may be called.
     */
    #[link_name =
          "?drawDrawable@SkCanvas@@QEAAXPEAVSkDrawable@@PEBVSkMatrix@@@Z"]
    pub fn SkCanvas_drawDrawable(this: *mut SkCanvas,
                                 drawable: *mut SkDrawable,
                                 arg1: *const SkMatrix);
}
extern "C" {
    #[link_name = "?drawDrawable@SkCanvas@@QEAAXPEAVSkDrawable@@MM@Z"]
    pub fn SkCanvas_drawDrawable1(this: *mut SkCanvas, arg1: *mut SkDrawable,
                                  x: SkScalar, y: SkScalar);
}
extern "C" {
    /**
     *  Send an "annotation" to the canvas. The annotation is a key/value pair, where the key is
     *  a null-terminated utf8 string, and the value is a blob of data stored in an SkData
     *  (which may be null). The annotation is associated with the specified rectangle.
     *
     *  The caller still retains its ownership of the data (if any).
     *
     *  Note: on may canvas types, this information is ignored, but some canvases (e.g. recording
     *  a picture or drawing to a PDF document) will pass on this information.
     */
    #[link_name =
          "?drawAnnotation@SkCanvas@@QEAAXAEBUSkRect@@QEBDPEAVSkData@@@Z"]
    pub fn SkCanvas_drawAnnotation(this: *mut SkCanvas, arg1: *const SkRect,
                                   key: *const ::std::os::raw::c_char,
                                   value: *mut SkData);
}
extern "C" {
    /** Return the current matrix on the canvas.
        This does not account for the translate in any of the devices.
        @return The current matrix on the canvas.
    */
    #[link_name = "?getTotalMatrix@SkCanvas@@QEBAAEBVSkMatrix@@XZ"]
    pub fn SkCanvas_getTotalMatrix(this: *const SkCanvas) -> *const SkMatrix;
}
extern "C" {
    /**
     *  Replays the clip operations, back to front, that have been applied to
     *  the canvas, calling the appropriate method on the visitor for each
     *  clip. All clips have already been transformed into device space.
     */
    #[link_name = "?replayClips@SkCanvas@@QEBAXPEAVSkCanvasClipVisitor@@@Z"]
    pub fn SkCanvas_replayClips(this: *const SkCanvas,
                                arg1: *mut SkCanvas_ClipVisitor);
}
extern "C" {
    ///////////////////////////////////////////////////////////////////////////
    #[link_name =
          "?internal_private_accessTopLayerRenderTargetContext@SkCanvas@@QEAAPEAVGrRenderTargetContext@@XZ"]
    pub fn SkCanvas_internal_private_accessTopLayerRenderTargetContext(this:
                                                                           *mut SkCanvas)
     -> *mut GrRenderTargetContext;
}
extern "C" {
    #[link_name =
          "?Internal_Private_SetIgnoreSaveLayerBounds@SkCanvas@@SAX_N@Z"]
    pub fn SkCanvas_Internal_Private_SetIgnoreSaveLayerBounds(arg1: bool);
}
extern "C" {
    #[link_name =
          "?Internal_Private_GetIgnoreSaveLayerBounds@SkCanvas@@SA_NXZ"]
    pub fn SkCanvas_Internal_Private_GetIgnoreSaveLayerBounds() -> bool;
}
extern "C" {
    #[link_name =
          "?Internal_Private_SetTreatSpriteAsBitmap@SkCanvas@@SAX_N@Z"]
    pub fn SkCanvas_Internal_Private_SetTreatSpriteAsBitmap(arg1: bool);
}
extern "C" {
    #[link_name = "?Internal_Private_GetTreatSpriteAsBitmap@SkCanvas@@SA_NXZ"]
    pub fn SkCanvas_Internal_Private_GetTreatSpriteAsBitmap() -> bool;
}
extern "C" {
    #[link_name =
          "?legacy_drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@PEBUSkRect@@AEBU3@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
    pub fn SkCanvas_legacy_drawImageRect(this: *mut SkCanvas,
                                         image: *const SkImage,
                                         src: *const SkRect,
                                         dst: *const SkRect,
                                         paint: *const SkPaint,
                                         constraint:
                                             SkCanvas_SrcRectConstraint);
}
extern "C" {
    #[link_name =
          "?legacy_drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@PEBUSkRect@@AEBU3@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
    pub fn SkCanvas_legacy_drawBitmapRect(this: *mut SkCanvas,
                                          bitmap: *const SkBitmap,
                                          src: *const SkRect,
                                          dst: *const SkRect,
                                          paint: *const SkPaint,
                                          constraint:
                                              SkCanvas_SrcRectConstraint);
}
extern "C" {
    /**
     * Returns CTM and clip bounds, translated from canvas coordinates to top layer coordinates.
     */
    #[link_name =
          "?temporary_internal_describeTopLayer@SkCanvas@@QEAAXPEAVSkMatrix@@PEAUSkIRect@@@Z"]
    pub fn SkCanvas_temporary_internal_describeTopLayer(this: *mut SkCanvas,
                                                        matrix: *mut SkMatrix,
                                                        clip_bounds:
                                                            *mut SkIRect);
}
extern "C" {
    #[link_name =
          "?clipRectBounds@SkCanvas@@IEAA_NPEBUSkRect@@IPEAUSkIRect@@PEBVSkImageFilter@@@Z"]
    pub fn SkCanvas_clipRectBounds(this: *mut SkCanvas, bounds: *const SkRect,
                                   arg1: SkCanvas_SaveLayerFlags,
                                   intersection: *mut SkIRect,
                                   imageFilter: *const SkImageFilter) -> bool;
}
impl SkCanvas {
    #[inline]
    pub unsafe fn MakeRasterDirect(arg1: *const SkImageInfo,
                                   arg2: *mut ::std::os::raw::c_void,
                                   arg3: usize) -> ::std::os::raw::c_int {
        SkCanvas_MakeRasterDirect(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn getMetaData(&mut self) -> *mut SkMetaData {
        SkCanvas_getMetaData(&mut *self)
    }
    #[inline]
    pub unsafe fn imageInfo(&self) -> SkImageInfo {
        SkCanvas_imageInfo(&*self)
    }
    #[inline]
    pub unsafe fn getProps(&self, arg1: *mut SkSurfaceProps) -> bool {
        SkCanvas_getProps(&*self, arg1)
    }
    #[inline]
    pub unsafe fn flush(&mut self) { SkCanvas_flush(&mut *self) }
    #[inline]
    pub unsafe fn getDevice(&self) -> *mut SkBaseDevice {
        SkCanvas_getDevice(&*self)
    }
    #[inline]
    pub unsafe fn makeSurface(&mut self, arg1: *const SkImageInfo,
                              arg2: *const SkSurfaceProps)
     -> sk_sp<SkSurface> {
        SkCanvas_makeSurface(&mut *self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getGrContext(&mut self) -> *mut GrContext {
        SkCanvas_getGrContext(&mut *self)
    }
    #[inline]
    pub unsafe fn accessTopLayerPixels(&mut self, info: *mut SkImageInfo,
                                       rowBytes: *mut usize,
                                       origin: *mut SkIPoint)
     -> *mut ::std::os::raw::c_void {
        SkCanvas_accessTopLayerPixels(&mut *self, info, rowBytes, origin)
    }
    #[inline]
    pub unsafe fn peekPixels(&mut self, arg1: *mut SkPixmap) -> bool {
        SkCanvas_peekPixels(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn readPixels(&mut self, dstInfo: *const SkImageInfo,
                             dstPixels: *mut ::std::os::raw::c_void,
                             dstRowBytes: usize, srcX: ::std::os::raw::c_int,
                             srcY: ::std::os::raw::c_int) -> bool {
        SkCanvas_readPixels(&mut *self, dstInfo, dstPixels, dstRowBytes, srcX,
                            srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(&mut self, bitmap: *mut SkBitmap,
                              srcX: ::std::os::raw::c_int,
                              srcY: ::std::os::raw::c_int) -> bool {
        SkCanvas_readPixels1(&mut *self, bitmap, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels2(&mut self, srcRect: *const SkIRect,
                              bitmap: *mut SkBitmap) -> bool {
        SkCanvas_readPixels2(&mut *self, srcRect, bitmap)
    }
    #[inline]
    pub unsafe fn writePixels(&mut self, arg1: *const SkImageInfo,
                              pixels: *const ::std::os::raw::c_void,
                              rowBytes: usize, x: ::std::os::raw::c_int,
                              y: ::std::os::raw::c_int) -> bool {
        SkCanvas_writePixels(&mut *self, arg1, pixels, rowBytes, x, y)
    }
    #[inline]
    pub unsafe fn writePixels1(&mut self, bitmap: *const SkBitmap,
                               x: ::std::os::raw::c_int,
                               y: ::std::os::raw::c_int) -> bool {
        SkCanvas_writePixels1(&mut *self, bitmap, x, y)
    }
    #[inline]
    pub unsafe fn save(&mut self) -> ::std::os::raw::c_int {
        SkCanvas_save(&mut *self)
    }
    #[inline]
    pub unsafe fn saveLayer(&mut self, bounds: *const SkRect,
                            paint: *const SkPaint) -> ::std::os::raw::c_int {
        SkCanvas_saveLayer(&mut *self, bounds, paint)
    }
    #[inline]
    pub unsafe fn saveLayerPreserveLCDTextRequests(&mut self,
                                                   bounds: *const SkRect,
                                                   paint: *const SkPaint)
     -> ::std::os::raw::c_int {
        SkCanvas_saveLayerPreserveLCDTextRequests(&mut *self, bounds, paint)
    }
    #[inline]
    pub unsafe fn saveLayerAlpha(&mut self, bounds: *const SkRect,
                                 alpha: U8CPU) -> ::std::os::raw::c_int {
        SkCanvas_saveLayerAlpha(&mut *self, bounds, alpha)
    }
    #[inline]
    pub unsafe fn saveLayer1(&mut self, arg1: *const SkCanvas_SaveLayerRec)
     -> ::std::os::raw::c_int {
        SkCanvas_saveLayer1(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn restore(&mut self) { SkCanvas_restore(&mut *self) }
    #[inline]
    pub unsafe fn getSaveCount(&self) -> ::std::os::raw::c_int {
        SkCanvas_getSaveCount(&*self)
    }
    #[inline]
    pub unsafe fn restoreToCount(&mut self,
                                 saveCount: ::std::os::raw::c_int) {
        SkCanvas_restoreToCount(&mut *self, saveCount)
    }
    #[inline]
    pub unsafe fn translate(&mut self, dx: SkScalar, dy: SkScalar) {
        SkCanvas_translate(&mut *self, dx, dy)
    }
    #[inline]
    pub unsafe fn scale(&mut self, sx: SkScalar, sy: SkScalar) {
        SkCanvas_scale(&mut *self, sx, sy)
    }
    #[inline]
    pub unsafe fn rotate(&mut self, degrees: SkScalar) {
        SkCanvas_rotate(&mut *self, degrees)
    }
    #[inline]
    pub unsafe fn rotate1(&mut self, degrees: SkScalar, px: SkScalar,
                          py: SkScalar) {
        SkCanvas_rotate1(&mut *self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn skew(&mut self, sx: SkScalar, sy: SkScalar) {
        SkCanvas_skew(&mut *self, sx, sy)
    }
    #[inline]
    pub unsafe fn concat(&mut self, matrix: *const SkMatrix) {
        SkCanvas_concat(&mut *self, matrix)
    }
    #[inline]
    pub unsafe fn setMatrix(&mut self, matrix: *const SkMatrix) {
        SkCanvas_setMatrix(&mut *self, matrix)
    }
    #[inline]
    pub unsafe fn resetMatrix(&mut self) { SkCanvas_resetMatrix(&mut *self) }
    #[inline]
    pub unsafe fn clipRect(&mut self, rect: *const SkRect, arg1: SkClipOp,
                           doAntiAlias: bool) {
        SkCanvas_clipRect(&mut *self, rect, arg1, doAntiAlias)
    }
    #[inline]
    pub unsafe fn clipRRect(&mut self, rrect: *const SkRRect, op: SkClipOp,
                            doAntiAlias: bool) {
        SkCanvas_clipRRect(&mut *self, rrect, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn clipPath(&mut self, path: *const SkPath, op: SkClipOp,
                           doAntiAlias: bool) {
        SkCanvas_clipPath(&mut *self, path, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn clipRegion(&mut self, deviceRgn: *const SkRegion,
                             op: SkClipOp) {
        SkCanvas_clipRegion(&mut *self, deviceRgn, op)
    }
    #[inline]
    pub unsafe fn quickReject(&self, rect: *const SkRect) -> bool {
        SkCanvas_quickReject(&*self, rect)
    }
    #[inline]
    pub unsafe fn quickReject1(&self, path: *const SkPath) -> bool {
        SkCanvas_quickReject1(&*self, path)
    }
    #[inline]
    pub unsafe fn drawARGB(&mut self, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU,
                           mode: SkBlendMode) {
        SkCanvas_drawARGB(&mut *self, a, r, g, b, mode)
    }
    #[inline]
    pub unsafe fn drawColor(&mut self, color: SkColor, mode: SkBlendMode) {
        SkCanvas_drawColor(&mut *self, color, mode)
    }
    #[inline]
    pub unsafe fn drawPaint(&mut self, paint: *const SkPaint) {
        SkCanvas_drawPaint(&mut *self, paint)
    }
    #[inline]
    pub unsafe fn drawPoints(&mut self, mode: SkCanvas_PointMode,
                             count: usize, pts: *const SkPoint,
                             paint: *const SkPaint) {
        SkCanvas_drawPoints(&mut *self, mode, count, pts, paint)
    }
    #[inline]
    pub unsafe fn drawPoint(&mut self, x: SkScalar, y: SkScalar,
                            paint: *const SkPaint) {
        SkCanvas_drawPoint(&mut *self, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawPoint1(&mut self, x: SkScalar, y: SkScalar,
                             color: SkColor) {
        SkCanvas_drawPoint1(&mut *self, x, y, color)
    }
    #[inline]
    pub unsafe fn drawLine(&mut self, x0: SkScalar, y0: SkScalar,
                           x1: SkScalar, y1: SkScalar,
                           paint: *const SkPaint) {
        SkCanvas_drawLine(&mut *self, x0, y0, x1, y1, paint)
    }
    #[inline]
    pub unsafe fn drawRect(&mut self, rect: *const SkRect,
                           paint: *const SkPaint) {
        SkCanvas_drawRect(&mut *self, rect, paint)
    }
    #[inline]
    pub unsafe fn drawRectCoords(&mut self, left: SkScalar, top: SkScalar,
                                 right: SkScalar, bottom: SkScalar,
                                 paint: *const SkPaint) {
        SkCanvas_drawRectCoords(&mut *self, left, top, right, bottom, paint)
    }
    #[inline]
    pub unsafe fn drawRegion(&mut self, region: *const SkRegion,
                             paint: *const SkPaint) {
        SkCanvas_drawRegion(&mut *self, region, paint)
    }
    #[inline]
    pub unsafe fn drawOval(&mut self, oval: *const SkRect,
                           arg1: *const SkPaint) {
        SkCanvas_drawOval(&mut *self, oval, arg1)
    }
    #[inline]
    pub unsafe fn drawRRect(&mut self, rrect: *const SkRRect,
                            paint: *const SkPaint) {
        SkCanvas_drawRRect(&mut *self, rrect, paint)
    }
    #[inline]
    pub unsafe fn drawDRRect(&mut self, outer: *const SkRRect,
                             inner: *const SkRRect, arg1: *const SkPaint) {
        SkCanvas_drawDRRect(&mut *self, outer, inner, arg1)
    }
    #[inline]
    pub unsafe fn drawCircle(&mut self, cx: SkScalar, cy: SkScalar,
                             radius: SkScalar, paint: *const SkPaint) {
        SkCanvas_drawCircle(&mut *self, cx, cy, radius, paint)
    }
    #[inline]
    pub unsafe fn drawArc(&mut self, oval: *const SkRect,
                          startAngle: SkScalar, sweepAngle: SkScalar,
                          useCenter: bool, paint: *const SkPaint) {
        SkCanvas_drawArc(&mut *self, oval, startAngle, sweepAngle, useCenter,
                         paint)
    }
    #[inline]
    pub unsafe fn drawRoundRect(&mut self, rect: *const SkRect, rx: SkScalar,
                                ry: SkScalar, paint: *const SkPaint) {
        SkCanvas_drawRoundRect(&mut *self, rect, rx, ry, paint)
    }
    #[inline]
    pub unsafe fn drawPath(&mut self, path: *const SkPath,
                           paint: *const SkPaint) {
        SkCanvas_drawPath(&mut *self, path, paint)
    }
    #[inline]
    pub unsafe fn drawImage(&mut self, image: *const SkImage, left: SkScalar,
                            top: SkScalar, paint: *const SkPaint) {
        SkCanvas_drawImage(&mut *self, image, left, top, paint)
    }
    #[inline]
    pub unsafe fn drawImageRect(&mut self, image: *const SkImage,
                                src: *const SkRect, dst: *const SkRect,
                                paint: *const SkPaint,
                                constraint: SkCanvas_SrcRectConstraint) {
        SkCanvas_drawImageRect(&mut *self, image, src, dst, paint, constraint)
    }
    #[inline]
    pub unsafe fn drawImageRect1(&mut self, image: *const SkImage,
                                 isrc: *const SkIRect, dst: *const SkRect,
                                 paint: *const SkPaint,
                                 arg1: SkCanvas_SrcRectConstraint) {
        SkCanvas_drawImageRect1(&mut *self, image, isrc, dst, paint, arg1)
    }
    #[inline]
    pub unsafe fn drawImageRect2(&mut self, image: *const SkImage,
                                 dst: *const SkRect, paint: *const SkPaint,
                                 arg1: SkCanvas_SrcRectConstraint) {
        SkCanvas_drawImageRect2(&mut *self, image, dst, paint, arg1)
    }
    #[inline]
    pub unsafe fn drawImageNine(&mut self, arg1: *const SkImage,
                                center: *const SkIRect, dst: *const SkRect,
                                paint: *const SkPaint) {
        SkCanvas_drawImageNine(&mut *self, arg1, center, dst, paint)
    }
    #[inline]
    pub unsafe fn drawBitmap(&mut self, bitmap: *const SkBitmap,
                             left: SkScalar, top: SkScalar,
                             paint: *const SkPaint) {
        SkCanvas_drawBitmap(&mut *self, bitmap, left, top, paint)
    }
    #[inline]
    pub unsafe fn drawBitmapRect(&mut self, bitmap: *const SkBitmap,
                                 src: *const SkRect, dst: *const SkRect,
                                 paint: *const SkPaint,
                                 arg1: SkCanvas_SrcRectConstraint) {
        SkCanvas_drawBitmapRect(&mut *self, bitmap, src, dst, paint, arg1)
    }
    #[inline]
    pub unsafe fn drawBitmapRect1(&mut self, bitmap: *const SkBitmap,
                                  isrc: *const SkIRect, dst: *const SkRect,
                                  paint: *const SkPaint,
                                  arg1: SkCanvas_SrcRectConstraint) {
        SkCanvas_drawBitmapRect1(&mut *self, bitmap, isrc, dst, paint, arg1)
    }
    #[inline]
    pub unsafe fn drawBitmapRect2(&mut self, bitmap: *const SkBitmap,
                                  dst: *const SkRect, paint: *const SkPaint,
                                  arg1: SkCanvas_SrcRectConstraint) {
        SkCanvas_drawBitmapRect2(&mut *self, bitmap, dst, paint, arg1)
    }
    #[inline]
    pub unsafe fn drawBitmapNine(&mut self, bitmap: *const SkBitmap,
                                 center: *const SkIRect, dst: *const SkRect,
                                 paint: *const SkPaint) {
        SkCanvas_drawBitmapNine(&mut *self, bitmap, center, dst, paint)
    }
    #[inline]
    pub unsafe fn drawBitmapLattice(&mut self, bitmap: *const SkBitmap,
                                    lattice: *const SkCanvas_Lattice,
                                    dst: *const SkRect,
                                    paint: *const SkPaint) {
        SkCanvas_drawBitmapLattice(&mut *self, bitmap, lattice, dst, paint)
    }
    #[inline]
    pub unsafe fn drawImageLattice(&mut self, image: *const SkImage,
                                   lattice: *const SkCanvas_Lattice,
                                   dst: *const SkRect,
                                   paint: *const SkPaint) {
        SkCanvas_drawImageLattice(&mut *self, image, lattice, dst, paint)
    }
    #[inline]
    pub unsafe fn drawText(&mut self, text: *const ::std::os::raw::c_void,
                           byteLength: usize, x: SkScalar, y: SkScalar,
                           paint: *const SkPaint) {
        SkCanvas_drawText(&mut *self, text, byteLength, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawPosText(&mut self, text: *const ::std::os::raw::c_void,
                              byteLength: usize, pos: *const SkPoint,
                              paint: *const SkPaint) {
        SkCanvas_drawPosText(&mut *self, text, byteLength, pos, paint)
    }
    #[inline]
    pub unsafe fn drawPosTextH(&mut self, text: *const ::std::os::raw::c_void,
                               byteLength: usize, xpos: *const SkScalar,
                               constY: SkScalar, paint: *const SkPaint) {
        SkCanvas_drawPosTextH(&mut *self, text, byteLength, xpos, constY,
                              paint)
    }
    #[inline]
    pub unsafe fn drawTextOnPathHV(&mut self,
                                   text: *const ::std::os::raw::c_void,
                                   byteLength: usize, path: *const SkPath,
                                   hOffset: SkScalar, vOffset: SkScalar,
                                   paint: *const SkPaint) {
        SkCanvas_drawTextOnPathHV(&mut *self, text, byteLength, path, hOffset,
                                  vOffset, paint)
    }
    #[inline]
    pub unsafe fn drawTextOnPath(&mut self,
                                 text: *const ::std::os::raw::c_void,
                                 byteLength: usize, path: *const SkPath,
                                 matrix: *const SkMatrix,
                                 paint: *const SkPaint) {
        SkCanvas_drawTextOnPath(&mut *self, text, byteLength, path, matrix,
                                paint)
    }
    #[inline]
    pub unsafe fn drawTextRSXform(&mut self,
                                  text: *const ::std::os::raw::c_void,
                                  byteLength: usize, arg1: *const SkRSXform,
                                  cullRect: *const SkRect,
                                  paint: *const SkPaint) {
        SkCanvas_drawTextRSXform(&mut *self, text, byteLength, arg1, cullRect,
                                 paint)
    }
    #[inline]
    pub unsafe fn drawTextBlob(&mut self, blob: *const SkTextBlob,
                               x: SkScalar, y: SkScalar,
                               paint: *const SkPaint) {
        SkCanvas_drawTextBlob(&mut *self, blob, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawPicture(&mut self, arg1: *const SkPicture,
                              matrix: *const SkMatrix,
                              paint: *const SkPaint) {
        SkCanvas_drawPicture(&mut *self, arg1, matrix, paint)
    }
    #[inline]
    pub unsafe fn drawVertices(&mut self, vmode: SkCanvas_VertexMode,
                               vertexCount: ::std::os::raw::c_int,
                               vertices: *const SkPoint, texs: *const SkPoint,
                               colors: *const SkColor, mode: SkBlendMode,
                               indices: *const u16,
                               indexCount: ::std::os::raw::c_int,
                               paint: *const SkPaint) {
        SkCanvas_drawVertices(&mut *self, vmode, vertexCount, vertices, texs,
                              colors, mode, indices, indexCount, paint)
    }
    #[inline]
    pub unsafe fn drawPatch(&mut self, cubics: *mut SkPoint,
                            colors: *mut SkColor, texCoords: *mut SkPoint,
                            mode: SkBlendMode, paint: *const SkPaint) {
        SkCanvas_drawPatch(&mut *self, cubics, colors, texCoords, mode, paint)
    }
    #[inline]
    pub unsafe fn drawAtlas(&mut self, atlas: *const SkImage,
                            xform: *const SkRSXform, tex: *const SkRect,
                            colors: *const SkColor,
                            count: ::std::os::raw::c_int, arg1: SkBlendMode,
                            cullRect: *const SkRect, paint: *const SkPaint) {
        SkCanvas_drawAtlas(&mut *self, atlas, xform, tex, colors, count, arg1,
                           cullRect, paint)
    }
    #[inline]
    pub unsafe fn drawDrawable(&mut self, drawable: *mut SkDrawable,
                               arg1: *const SkMatrix) {
        SkCanvas_drawDrawable(&mut *self, drawable, arg1)
    }
    #[inline]
    pub unsafe fn drawDrawable1(&mut self, arg1: *mut SkDrawable, x: SkScalar,
                                y: SkScalar) {
        SkCanvas_drawDrawable1(&mut *self, arg1, x, y)
    }
    #[inline]
    pub unsafe fn drawAnnotation(&mut self, arg1: *const SkRect,
                                 key: *const ::std::os::raw::c_char,
                                 value: *mut SkData) {
        SkCanvas_drawAnnotation(&mut *self, arg1, key, value)
    }
    #[inline]
    pub unsafe fn getTotalMatrix(&self) -> *const SkMatrix {
        SkCanvas_getTotalMatrix(&*self)
    }
    #[inline]
    pub unsafe fn replayClips(&self, arg1: *mut SkCanvas_ClipVisitor) {
        SkCanvas_replayClips(&*self, arg1)
    }
    #[inline]
    pub unsafe fn internal_private_accessTopLayerRenderTargetContext(&mut self)
     -> *mut GrRenderTargetContext {
        SkCanvas_internal_private_accessTopLayerRenderTargetContext(&mut *self)
    }
    #[inline]
    pub unsafe fn Internal_Private_SetIgnoreSaveLayerBounds(arg1: bool) {
        SkCanvas_Internal_Private_SetIgnoreSaveLayerBounds(arg1)
    }
    #[inline]
    pub unsafe fn Internal_Private_GetIgnoreSaveLayerBounds() -> bool {
        SkCanvas_Internal_Private_GetIgnoreSaveLayerBounds()
    }
    #[inline]
    pub unsafe fn Internal_Private_SetTreatSpriteAsBitmap(arg1: bool) {
        SkCanvas_Internal_Private_SetTreatSpriteAsBitmap(arg1)
    }
    #[inline]
    pub unsafe fn Internal_Private_GetTreatSpriteAsBitmap() -> bool {
        SkCanvas_Internal_Private_GetTreatSpriteAsBitmap()
    }
    #[inline]
    pub unsafe fn legacy_drawImageRect(&mut self, image: *const SkImage,
                                       src: *const SkRect, dst: *const SkRect,
                                       paint: *const SkPaint,
                                       constraint:
                                           SkCanvas_SrcRectConstraint) {
        SkCanvas_legacy_drawImageRect(&mut *self, image, src, dst, paint,
                                      constraint)
    }
    #[inline]
    pub unsafe fn legacy_drawBitmapRect(&mut self, bitmap: *const SkBitmap,
                                        src: *const SkRect,
                                        dst: *const SkRect,
                                        paint: *const SkPaint,
                                        constraint:
                                            SkCanvas_SrcRectConstraint) {
        SkCanvas_legacy_drawBitmapRect(&mut *self, bitmap, src, dst, paint,
                                       constraint)
    }
    #[inline]
    pub unsafe fn temporary_internal_describeTopLayer(&mut self,
                                                      matrix: *mut SkMatrix,
                                                      clip_bounds:
                                                          *mut SkIRect) {
        SkCanvas_temporary_internal_describeTopLayer(&mut *self, matrix,
                                                     clip_bounds)
    }
    #[inline]
    pub unsafe fn clipRectBounds(&mut self, bounds: *const SkRect,
                                 arg1: SkCanvas_SaveLayerFlags,
                                 intersection: *mut SkIRect,
                                 imageFilter: *const SkImageFilter) -> bool {
        SkCanvas_clipRectBounds(&mut *self, bounds, arg1, intersection,
                                imageFilter)
    }
}
extern "C" {
    /**
 *  Annotate the canvas by associating the specified URL with the
 *  specified rectangle (in local coordinates, just like drawRect).
 *
 *  If the backend of this canvas does not support annotations, this call is
 *  safely ignored.
 *
 *  The caller is responsible for managing its ownership of the SkData.
 */
    #[link_name =
          "?SkAnnotateRectWithURL@@YAXPEAVSkCanvas@@AEBUSkRect@@PEAVSkData@@@Z"]
    pub fn SkAnnotateRectWithURL(arg1: *mut SkCanvas, arg2: *const SkRect,
                                 arg3: *mut SkData);
}
extern "C" {
    /**
 *  Annotate the canvas by associating a name with the specified point.
 *
 *  If the backend of this canvas does not support annotations, this call is
 *  safely ignored.
 *
 *  The caller is responsible for managing its ownership of the SkData.
 */
    #[link_name =
          "?SkAnnotateNamedDestination@@YAXPEAVSkCanvas@@AEBUSkPoint@@PEAVSkData@@@Z"]
    pub fn SkAnnotateNamedDestination(arg1: *mut SkCanvas,
                                      arg2: *const SkPoint,
                                      arg3: *mut SkData);
}
extern "C" {
    /**
 *  Annotate the canvas by making the specified rectangle link to a named
 *  destination.
 *
 *  If the backend of this canvas does not support annotations, this call is
 *  safely ignored.
 *
 *  The caller is responsible for managing its ownership of the SkData.
 */
    #[link_name =
          "?SkAnnotateLinkToDestination@@YAXPEAVSkCanvas@@AEBUSkRect@@PEAVSkData@@@Z"]
    pub fn SkAnnotateLinkToDestination(arg1: *mut SkCanvas,
                                       arg2: *const SkRect,
                                       arg3: *mut SkData);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkBBoxHierarchy {
    pub _address: u8,
}
impl Clone for SkBBoxHierarchy {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct SkBBHFactory__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBBHFactory {
    pub vtable_: *const SkBBHFactory__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkBBHFactory() {
    assert_eq!(::std::mem::size_of::<SkBBHFactory>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkBBHFactory>() , 8usize);
}
extern "C" {
    /** Convert a sign-bit int (i.e. float interpreted as int) into a 2s compliement
    int. This also converts -0 (0x80000000) to 0. Doing this to a float allows
    it to be compared using normal C operators (<, <=, etc.)
*/
    #[link_name = "?SkSignBitTo2sCompliment@@YAHH@Z"]
    pub fn SkSignBitTo2sCompliment(x: i32) -> i32;
}
extern "C" {
    /** Convert a 2s compliment int to a sign-bit (i.e. int interpreted as float).
    This undoes the result of SkSignBitTo2sCompliment().
 */
    #[link_name = "?Sk2sComplimentToSignBit@@YAHH@Z"]
    pub fn Sk2sComplimentToSignBit(x: i32) -> i32;
}
extern "C" {
    #[link_name = "?SkFloat2Bits@@YAHM@Z"]
    pub fn SkFloat2Bits(x: f32) -> i32;
}
extern "C" {
    #[link_name = "?SkBits2Float@@YAMH@Z"]
    pub fn SkBits2Float(floatAsBits: i32) -> f32;
}
extern "C" {
    /** Return the float as a 2s compliment int. Just to be used to compare floats
    to each other or against positive float-bit-constants (like 0). This does
    not return the int equivalent of the float, just something cheaper for
    compares-only.
 */
    #[link_name = "?SkFloatAs2sCompliment@@YAHM@Z"]
    pub fn SkFloatAs2sCompliment(x: f32) -> i32;
}
extern "C" {
    /** Return the 2s compliment int as a float. This undos the result of
    SkFloatAs2sCompliment
 */
    #[link_name = "?Sk2sComplimentAsFloat@@YAMH@Z"]
    pub fn Sk2sComplimentAsFloat(x: i32) -> f32;
}
extern "C" {
    /** Return the floor of the float as an int.
    If the value is out of range, or NaN, return +/- SK_MaxS32
*/
    #[link_name = "?SkFloatToIntFloor@@YAHM@Z"]
    pub fn SkFloatToIntFloor(x: f32) -> i32;
}
extern "C" {
    /** Return the float rounded to an int.
    If the value is out of range, or NaN, return +/- SK_MaxS32
*/
    #[link_name = "?SkFloatToIntRound@@YAHM@Z"]
    pub fn SkFloatToIntRound(x: f32) -> i32;
}
extern "C" {
    /** Return the ceiling of the float as an int.
    If the value is out of range, or NaN, return +/- SK_MaxS32
*/
    #[link_name = "?SkFloatToIntCeil@@YAHM@Z"]
    pub fn SkFloatToIntCeil(x: f32) -> i32;
}
extern "C" {
    #[link_name = "?SkScalarIsNaN@@YA_NM@Z"]
    pub fn SkScalarIsNaN(x: SkScalar) -> bool;
}
extern "C" {
    /** Returns true if x is not NaN and not infinite
 */
    #[link_name = "?SkScalarIsFinite@@YA_NM@Z"]
    pub fn SkScalarIsFinite(x: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "?SkScalarsAreFinite@@YA_NMM@Z"]
    pub fn SkScalarsAreFinite(a: SkScalar, b: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "?SkScalarsAreFinite@@YA_NQEBMH@Z"]
    pub fn SkScalarsAreFinite1(array: *const SkScalar,
                               count: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
 *  Variant of SkScalarRoundToInt, that performs the rounding step (adding 0.5) explicitly using
 *  double, to avoid possibly losing the low bit(s) of the answer before calling floor().
 *
 *  This routine will likely be slower than SkScalarRoundToInt(), and should only be used when the
 *  extra precision is known to be valuable.
 *
 *  In particular, this catches the following case:
 *      SkScalar x = 0.49999997;
 *      int ix = SkScalarRoundToInt(x);
 *      SkASSERT(0 == ix);    // <--- fails
 *      ix = SkDScalarRoundToInt(x);
 *      SkASSERT(0 == ix);    // <--- succeeds
 */
    #[link_name = "?SkDScalarRoundToInt@@YAHM@Z"]
    pub fn SkDScalarRoundToInt(x: SkScalar) -> ::std::os::raw::c_int;
}
extern "C" {
    /** Returns the fractional part of the scalar. */
    #[link_name = "?SkScalarFraction@@YAMM@Z"]
    pub fn SkScalarFraction(x: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "?SkScalarClampMax@@YAMMM@Z"]
    pub fn SkScalarClampMax(x: SkScalar, max: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "?SkScalarPin@@YAMMMM@Z"]
    pub fn SkScalarPin(x: SkScalar, min: SkScalar, max: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "?SkScalarSinCos@@YAMMPEAM@Z"]
    pub fn SkScalarSinCos(radians: SkScalar, cosValue: *mut SkScalar)
     -> SkScalar;
}
extern "C" {
    #[link_name = "?SkScalarSquare@@YAMM@Z"]
    pub fn SkScalarSquare(x: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "?SkMaxScalar@@YAMMM@Z"]
    pub fn SkMaxScalar(a: SkScalar, b: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "?SkMinScalar@@YAMMM@Z"]
    pub fn SkMinScalar(a: SkScalar, b: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "?SkScalarIsInt@@YA_NM@Z"]
    pub fn SkScalarIsInt(x: SkScalar) -> bool;
}
extern "C" {
    /**
 *  Returns -1 || 0 || 1 depending on the sign of value:
 *  -1 if x < 0
 *   0 if x == 0
 *   1 if x > 0
 */
    #[link_name = "?SkScalarSignAsInt@@YAHM@Z"]
    pub fn SkScalarSignAsInt(x: SkScalar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkScalarSignAsScalar@@YAMM@Z"]
    pub fn SkScalarSignAsScalar(x: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "?SkScalarNearlyZero@@YA_NMM@Z"]
    pub fn SkScalarNearlyZero(x: SkScalar, tolerance: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "?SkScalarNearlyEqual@@YA_NMMM@Z"]
    pub fn SkScalarNearlyEqual(x: SkScalar, y: SkScalar, tolerance: SkScalar)
     -> bool;
}
extern "C" {
    /** Linearly interpolate between A and B, based on t.
    If t is 0, return A
    If t is 1, return B
    else interpolate.
    t must be [0..SK_Scalar1]
*/
    #[link_name = "?SkScalarInterp@@YAMMMM@Z"]
    pub fn SkScalarInterp(A: SkScalar, B: SkScalar, t: SkScalar) -> SkScalar;
}
extern "C" {
    /** Interpolate along the function described by (keys[length], values[length])
    for the passed searchKey.  SearchKeys outside the range keys[0]-keys[Length]
    clamp to the min or max value.  This function was inspired by a desire
    to change the multiplier for thickness in fakeBold; therefore it assumes
    the number of pairs (length) will be small, and a linear search is used.
    Repeated keys are allowed for discontinuous functions (so long as keys is
    monotonically increasing), and if key is the value of a repeated scalar in
    keys, the first one will be used.  However, that may change if a binary
    search is used.
*/
    #[link_name = "?SkScalarInterpFunc@@YAMMQEBM0H@Z"]
    pub fn SkScalarInterpFunc(searchKey: SkScalar, keys: *const SkScalar,
                              values: *const SkScalar,
                              length: ::std::os::raw::c_int) -> SkScalar;
}
extern "C" {
    #[link_name = "?SkScalarsEqual@@YA_NQEBM0H@Z"]
    pub fn SkScalarsEqual(a: *const SkScalar, b: *const SkScalar,
                          n: ::std::os::raw::c_int) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPoint3 {
    pub fX: SkScalar,
    pub fY: SkScalar,
    pub fZ: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPoint3() {
    assert_eq!(::std::mem::size_of::<SkPoint3>() , 12usize);
    assert_eq!(::std::mem::align_of::<SkPoint3>() , 4usize);
}
extern "C" {
    /** Returns the Euclidian distance from (0,0,0) to (x,y,z)
    */
    #[link_name = "?Length@SkPoint3@@SAMMMM@Z"]
    pub fn SkPoint3_Length(x: SkScalar, y: SkScalar, z: SkScalar) -> SkScalar;
}
extern "C" {
    /** Set the point (vector) to be unit-length in the same direction as it
        already points.  If the point has a degenerate length (i.e., nearly 0)
        then set it to (0,0,0) and return false; otherwise return true.
    */
    #[link_name = "?normalize@SkPoint3@@QEAA_NXZ"]
    pub fn SkPoint3_normalize(this: *mut SkPoint3) -> bool;
}
impl Clone for SkPoint3 {
    fn clone(&self) -> Self { *self }
}
impl SkPoint3 {
    #[inline]
    pub unsafe fn Length(x: SkScalar, y: SkScalar, z: SkScalar) -> SkScalar {
        SkPoint3_Length(x, y, z)
    }
    #[inline]
    pub unsafe fn normalize(&mut self) -> bool {
        SkPoint3_normalize(&mut *self)
    }
}
pub type SkVector3 = SkPoint3;
pub type SkColor3f = SkPoint3;
/** 8-bit type for an alpha value. 0xFF is 100% opaque, 0x00 is 100% transparent.
*/
pub type SkAlpha = u8;
extern "C" {
    /** Return a SkColor value from 8 bit component values
*/
    #[link_name = "?SkColorSetARGBInline@@YAIIIII@Z"]
    pub fn SkColorSetARGBInline(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU)
     -> SkColor;
}
extern "C" {
    #[link_name = "?SkColorSetA@@YAIII@Z"]
    pub fn SkColorSetA(c: SkColor, a: U8CPU) -> SkColor;
}
extern "C" {
    /** Convert RGB components to HSV.
        hsv[0] is Hue [0 .. 360)
        hsv[1] is Saturation [0...1]
        hsv[2] is Value [0...1]
    @param red  red component value [0..255]
    @param green  green component value [0..255]
    @param blue  blue component value [0..255]
    @param hsv  3 element array which holds the resulting HSV components.
*/
    #[link_name = "?SkRGBToHSV@@YAXIIIQEAM@Z"]
    pub fn SkRGBToHSV(red: U8CPU, green: U8CPU, blue: U8CPU,
                      hsv: *mut SkScalar);
}
extern "C" {
    /** Convert the argb color to its HSV components.
        hsv[0] is Hue [0 .. 360)
        hsv[1] is Saturation [0...1]
        hsv[2] is Value [0...1]
    @param color the argb color to convert. Note: the alpha component is ignored.
    @param hsv  3 element array which holds the resulting HSV components.
*/
    #[link_name = "?SkColorToHSV@@YAXIQEAM@Z"]
    pub fn SkColorToHSV(color: SkColor, hsv: *mut SkScalar);
}
extern "C" {
    /** Convert HSV components to an ARGB color. The alpha component is passed through unchanged.
        hsv[0] is Hue [0 .. 360)
        hsv[1] is Saturation [0...1]
        hsv[2] is Value [0...1]
    If hsv values are out of range, they are pinned.
    @param alpha the alpha component of the returned argb color.
    @param hsv  3 element array which holds the input HSV components.
    @return the resulting argb color
*/
    #[link_name = "?SkHSVToColor@@YAIIQEBM@Z"]
    pub fn SkHSVToColor(alpha: U8CPU, hsv: *mut SkScalar) -> SkColor;
}
extern "C" {
    /** Convert HSV components to an ARGB color. The alpha component set to 0xFF.
        hsv[0] is Hue [0 .. 360)
        hsv[1] is Saturation [0...1]
        hsv[2] is Value [0...1]
    If hsv values are out of range, they are pinned.
    @param hsv  3 element array which holds the input HSV components.
    @return the resulting argb color
*/
    #[link_name = "?SkHSVToColor@@YAIQEBM@Z"]
    pub fn SkHSVToColor1(hsv: *mut SkScalar) -> SkColor;
}
/** 32 bit ARGB color value, premultiplied. The byte order for this value is
    configuration dependent, matching the format of kARGB32 bitmaps. This is different
    from SkColor, which is nonpremultiplied, and is always in the same byte order.
*/
pub type SkPMColor = u32;
extern "C" {
    /** Return a SkPMColor value from unpremultiplied 8 bit component values
*/
    #[link_name = "?SkPreMultiplyARGB@@YAIIIII@Z"]
    pub fn SkPreMultiplyARGB(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU)
     -> SkPMColor;
}
extern "C" {
    /** Return a SkPMColor value from a SkColor value. This is done by multiplying the color
    components by the color's alpha, and by arranging the bytes in a configuration
    dependent order, to match the format of kARGB32 bitmaps.
*/
    #[link_name = "?SkPreMultiplyColor@@YAII@Z"]
    pub fn SkPreMultiplyColor(c: SkColor) -> SkPMColor;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPM4f {
    pub _address: u8,
}
impl Clone for SkPM4f {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkColor4f {
    pub fR: f32,
    pub fG: f32,
    pub fB: f32,
    pub fA: f32,
}
#[test]
fn bindgen_test_layout_SkColor4f() {
    assert_eq!(::std::mem::size_of::<SkColor4f>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkColor4f>() , 4usize);
}
extern "C" {
    #[link_name = "?Pin@SkColor4f@@SA?AU1@MMMM@Z"]
    pub fn SkColor4f_Pin(r: f32, g: f32, b: f32, a: f32) -> SkColor4f;
}
extern "C" {
    /** Convert to SkColor4f, assuming SkColor is sRGB */
    #[link_name = "?FromColor@SkColor4f@@SA?AU1@I@Z"]
    pub fn SkColor4f_FromColor(arg1: SkColor) -> SkColor4f;
}
extern "C" {
    #[link_name = "?FromColor3f@SkColor4f@@SA?AU1@USkPoint3@@M@Z"]
    pub fn SkColor4f_FromColor3f(arg1: SkColor3f, a: f32) -> SkColor4f;
}
extern "C" {
    #[link_name = "?toSkColor@SkColor4f@@QEBAIXZ"]
    pub fn SkColor4f_toSkColor(this: *const SkColor4f) -> SkColor;
}
extern "C" {
    #[link_name = "?premul@SkColor4f@@QEBA?AUSkPM4f@@XZ"]
    pub fn SkColor4f_premul(this: *const SkColor4f) -> SkPM4f;
}
impl Clone for SkColor4f {
    fn clone(&self) -> Self { *self }
}
impl SkColor4f {
    #[inline]
    pub unsafe fn Pin(r: f32, g: f32, b: f32, a: f32) -> SkColor4f {
        SkColor4f_Pin(r, g, b, a)
    }
    #[inline]
    pub unsafe fn FromColor(arg1: SkColor) -> SkColor4f {
        SkColor4f_FromColor(arg1)
    }
    #[inline]
    pub unsafe fn FromColor3f(arg1: SkColor3f, a: f32) -> SkColor4f {
        SkColor4f_FromColor3f(arg1, a)
    }
    #[inline]
    pub unsafe fn toSkColor(&self) -> SkColor { SkColor4f_toSkColor(&*self) }
    #[inline]
    pub unsafe fn premul(&self) -> SkPM4f { SkColor4f_premul(&*self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkOnce {
    pub fState: std_atomic<::std::os::raw::c_uchar>,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkOnce_State { NotStarted = 0, Claimed = 1, Done = 2, }
#[test]
fn bindgen_test_layout_SkOnce() {
    assert_eq!(::std::mem::size_of::<SkOnce>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkOnce>() , 1usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _iobuf {
    pub _ptr: *mut ::std::os::raw::c_char,
    pub _cnt: ::std::os::raw::c_int,
    pub _base: *mut ::std::os::raw::c_char,
    pub _flag: ::std::os::raw::c_int,
    pub _file: ::std::os::raw::c_int,
    pub _charbuf: ::std::os::raw::c_int,
    pub _bufsiz: ::std::os::raw::c_int,
    pub _tmpfname: *mut ::std::os::raw::c_char,
}
impl Clone for _iobuf {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _iobuf;
#[repr(C)]
pub struct SkRefCntBase__bindgen_vtable {
}
/** \class SkRefCntBase

    SkRefCntBase is the base class for objects that may be shared by multiple
    objects. When an existing owner wants to share a reference, it calls ref().
    When an owner wants to release its reference, it calls unref(). When the
    shared object's reference count goes to zero as the result of an unref()
    call, its (virtual) destructor is called. It is an error for the
    destructor to be called explicitly (or via the object going out of scope on
    the stack or calling delete) if getRefCnt() > 1.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkRefCntBase {
    pub vtable_: *const SkRefCntBase__bindgen_vtable,
    pub fRefCnt: std_atomic<::std::os::raw::c_int>,
}
pub type SkRefCntBase_INHERITED = SkNoncopyable;
#[test]
fn bindgen_test_layout_SkRefCntBase() {
    assert_eq!(::std::mem::size_of::<SkRefCntBase>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkRefCntBase>() , 1usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRefCnt {
    pub _base: SkRefCntBase,
}
#[test]
fn bindgen_test_layout_SkRefCnt() {
    assert_eq!(::std::mem::size_of::<SkRefCnt>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkRefCnt>() , 1usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkReadBuffer {
    pub _address: u8,
}
impl Clone for SkReadBuffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct SkWriteBuffer__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkWriteBuffer {
    pub vtable_: *const SkWriteBuffer__bindgen_vtable,
    pub fDeduper: *mut SkDeduper,
}
#[test]
fn bindgen_test_layout_SkWriteBuffer() {
    assert_eq!(::std::mem::size_of::<SkWriteBuffer>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkWriteBuffer>() , 8usize);
}
/** \class SkFlattenable

 SkFlattenable is the base class for objects that need to be flattened
 into a data stream for either transport or as part of the key to the
 font cache.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkFlattenable {
    pub _base: SkRefCnt,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkFlattenable_Type {
    kSkColorFilter_Type = 0,
    kSkDrawable_Type = 1,
    kSkDrawLooper_Type = 2,
    kSkImageFilter_Type = 3,
    kSkMaskFilter_Type = 4,
    kSkPathEffect_Type = 5,
    kSkPixelRef_Type = 6,
    kSkRasterizer_Type = 7,
    kSkShader_Type = 8,
    kSkUnused_Type = 9,
    kSkXfermode_Type = 10,
    kSkNormalSource_Type = 11,
}
pub type SkFlattenable_Factory =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SkReadBuffer)
                              -> sk_sp<SkFlattenable>>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkFlattenable_PrivateInitializer {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkFlattenable_PrivateInitializer() {
    assert_eq!(::std::mem::size_of::<SkFlattenable_PrivateInitializer>() ,
               1usize);
    assert_eq!(::std::mem::align_of::<SkFlattenable_PrivateInitializer>() ,
               1usize);
}
extern "C" {
    #[link_name = "?InitCore@PrivateInitializer@SkFlattenable@@SAXXZ"]
    pub fn SkFlattenable_PrivateInitializer_InitCore();
}
extern "C" {
    #[link_name = "?InitEffects@PrivateInitializer@SkFlattenable@@SAXXZ"]
    pub fn SkFlattenable_PrivateInitializer_InitEffects();
}
impl Clone for SkFlattenable_PrivateInitializer {
    fn clone(&self) -> Self { *self }
}
impl SkFlattenable_PrivateInitializer {
    #[inline]
    pub unsafe fn InitCore() { SkFlattenable_PrivateInitializer_InitCore() }
    #[inline]
    pub unsafe fn InitEffects() {
        SkFlattenable_PrivateInitializer_InitEffects()
    }
}
pub type SkFlattenable_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkFlattenable() {
    assert_eq!(::std::mem::size_of::<SkFlattenable>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkFlattenable>() , 1usize);
}
extern "C" {
    #[link_name =
          "?NameToFactory@SkFlattenable@@SAP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@ZQEBD@Z"]
    pub fn SkFlattenable_NameToFactory(name: *const ::std::os::raw::c_char)
     -> SkFlattenable_Factory;
}
extern "C" {
    #[link_name =
          "?FactoryToName@SkFlattenable@@SAPEBDP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@Z@Z"]
    pub fn SkFlattenable_FactoryToName(arg1: SkFlattenable_Factory)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?NameToType@SkFlattenable@@SA_NQEBDPEAW4Type@1@@Z"]
    pub fn SkFlattenable_NameToType(name: *const ::std::os::raw::c_char,
                                    type_: *mut SkFlattenable_Type) -> bool;
}
extern "C" {
    #[link_name =
          "?Register@SkFlattenable@@SAXQEBDP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@ZW4Type@1@@Z"]
    pub fn SkFlattenable_Register(name: *const ::std::os::raw::c_char,
                                  arg1: SkFlattenable_Factory,
                                  arg2: SkFlattenable_Type);
}
impl SkFlattenable {
    #[inline]
    pub unsafe fn NameToFactory(name: *const ::std::os::raw::c_char)
     -> SkFlattenable_Factory {
        SkFlattenable_NameToFactory(name)
    }
    #[inline]
    pub unsafe fn FactoryToName(arg1: SkFlattenable_Factory)
     -> *const ::std::os::raw::c_char {
        SkFlattenable_FactoryToName(arg1)
    }
    #[inline]
    pub unsafe fn NameToType(name: *const ::std::os::raw::c_char,
                             type_: *mut SkFlattenable_Type) -> bool {
        SkFlattenable_NameToType(name, type_)
    }
    #[inline]
    pub unsafe fn Register(name: *const ::std::os::raw::c_char,
                           arg1: SkFlattenable_Factory,
                           arg2: SkFlattenable_Type) {
        SkFlattenable_Register(name, arg1, arg2)
    }
}
extern "C" {
    /**
 *  Computes numer1 * numer2 / denom in full 64 intermediate precision.
 *  It is an error for denom to be 0. There is no special handling if
 *  the result overflows 32bits.
 */
    #[link_name = "?SkMulDiv@@YAHHHH@Z"]
    pub fn SkMulDiv(numer1: i32, numer2: i32, denom: i32) -> i32;
}
extern "C" {
    /**
 *  Return the integer square root of value, with a bias of bitBias
 */
    #[link_name = "?SkSqrtBits@@YAHHH@Z"]
    pub fn SkSqrtBits(value: i32, bitBias: ::std::os::raw::c_int) -> i32;
}
extern "C" {
    /**
 *  Returns (value < 0 ? 0 : value) efficiently (i.e. no compares or branches)
 */
    #[link_name = "?SkClampPos@@YAHH@Z"]
    pub fn SkClampPos(value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /** Given an integer and a positive (max) integer, return the value
 *  pinned against 0 and max, inclusive.
 *  @param value    The value we want returned pinned between [0...max]
 *  @param max      The positive max value
 *  @return 0 if value < 0, max if value > max, else value
 */
    #[link_name = "?SkClampMax@@YAHHH@Z"]
    pub fn SkClampMax(value: ::std::os::raw::c_int,
                      max: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *  Return a*b/((1 << shift) - 1), rounding any fractional bits.
 *  Only valid if a and b are unsigned and <= 32767 and shift is > 0 and <= 8
 */
    #[link_name = "?SkMul16ShiftRound@@YAIIIH@Z"]
    pub fn SkMul16ShiftRound(a: U16CPU, b: U16CPU,
                             shift: ::std::os::raw::c_int)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 *  Return a*b/255, rounding any fractional bits.
 *  Only valid if a and b are unsigned and <= 32767.
 */
    #[link_name = "?SkMulDiv255Round@@YAIII@Z"]
    pub fn SkMulDiv255Round(a: U16CPU, b: U16CPU) -> U8CPU;
}
/** \struct SkIPoint

    SkIPoint holds two 32 bit integer coordinates
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkIPoint {
    pub fX: i32,
    pub fY: i32,
}
#[test]
fn bindgen_test_layout_SkIPoint() {
    assert_eq!(::std::mem::size_of::<SkIPoint>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkIPoint>() , 4usize);
}
extern "C" {
    /** Rotate the point clockwise, writing the new point into dst
        It is legal for dst == this
    */
    #[link_name = "?rotateCW@SkIPoint@@QEBAXPEAU1@@Z"]
    pub fn SkIPoint_rotateCW(this: *const SkIPoint, dst: *mut SkIPoint);
}
extern "C" {
    /** Rotate the point counter-clockwise, writing the new point into dst.
        It is legal for dst == this
    */
    #[link_name = "?rotateCCW@SkIPoint@@QEBAXPEAU1@@Z"]
    pub fn SkIPoint_rotateCCW(this: *const SkIPoint, dst: *mut SkIPoint);
}
impl Clone for SkIPoint {
    fn clone(&self) -> Self { *self }
}
impl SkIPoint {
    #[inline]
    pub unsafe fn rotateCW(&self, dst: *mut SkIPoint) {
        SkIPoint_rotateCW(&*self, dst)
    }
    #[inline]
    pub unsafe fn rotateCCW(&self, dst: *mut SkIPoint) {
        SkIPoint_rotateCCW(&*self, dst)
    }
}
pub type SkVector = SkPoint;
extern "C" {
    #[link_name = "?SkPointsAreFinite@@YA_NQEBUSkPoint@@H@Z"]
    pub fn SkPointsAreFinite(array: *const SkPoint,
                             count: ::std::os::raw::c_int) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTSize<T> {
    pub fWidth: T,
    pub fHeight: T,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkSize {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkSize() {
    assert_eq!(::std::mem::size_of::<SkSize>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkSize>() , 1usize);
}
impl Clone for SkSize {
    fn clone(&self) -> Self { *self }
}
/** \struct SkIRect

    SkIRect holds four 32 bit integer coordinates for a rectangle
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkIRect {
    pub fLeft: i32,
    pub fTop: i32,
    pub fRight: i32,
    pub fBottom: i32,
}
#[test]
fn bindgen_test_layout_SkIRect() {
    assert_eq!(::std::mem::size_of::<SkIRect>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkIRect>() , 4usize);
}
extern "C" {
    /** Returns true if the specified rectangle r is inside or equal to this rectangle.
    */
    #[link_name = "?contains@SkIRect@@QEBA_NAEBUSkRect@@@Z"]
    pub fn SkIRect_contains(this: *const SkIRect, r: *const SkRect) -> bool;
}
extern "C" {
    /** Update this rectangle to enclose itself and the specified rectangle.
        If this rectangle is empty, just set it to the specified rectangle. If the specified
        rectangle is empty, do nothing.
    */
    #[link_name = "?join@SkIRect@@QEAAXHHHH@Z"]
    pub fn SkIRect_join(this: *mut SkIRect, left: i32, top: i32, right: i32,
                        bottom: i32);
}
extern "C" {
    /** Swap top/bottom or left/right if there are flipped.
        This can be called if the edges are computed separately,
        and may have crossed over each other.
        When this returns, left <= right && top <= bottom
    */
    #[link_name = "?sort@SkIRect@@QEAAXXZ"]
    pub fn SkIRect_sort(this: *mut SkIRect);
}
impl Clone for SkIRect {
    fn clone(&self) -> Self { *self }
}
impl SkIRect {
    #[inline]
    pub unsafe fn contains(&self, r: *const SkRect) -> bool {
        SkIRect_contains(&*self, r)
    }
    #[inline]
    pub unsafe fn join(&mut self, left: i32, top: i32, right: i32,
                       bottom: i32) {
        SkIRect_join(&mut *self, left, top, right, bottom)
    }
    #[inline]
    pub unsafe fn sort(&mut self) { SkIRect_sort(&mut *self) }
}
/** \class SkMatrix

    The SkMatrix class holds a 3x3 matrix for transforming coordinates.
    SkMatrix does not have a constructor, so it must be explicitly initialized
    using either reset() - to construct an identity matrix, or one of the set
    functions (e.g. setTranslate, setRotate, etc.).
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkMatrix {
    pub fMat: [SkScalar; 9usize],
    pub fTypeMask: u32,
}
#[repr(i32)]
/** Enum of bit fields for the mask return by getType().
        Use this to identify the complexity of the matrix.
    */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix_TypeMask {
    kIdentity_Mask = 0,
    kTranslate_Mask = 1,
    kScale_Mask = 2,
    kAffine_Mask = 4,
    kPerspective_Mask = 8,
}
pub const SkMatrix_kMScaleX: SkMatrix__bindgen_ty_1 =
    SkMatrix__bindgen_ty_1::kMScaleX;
pub const SkMatrix_kMSkewX: SkMatrix__bindgen_ty_1 =
    SkMatrix__bindgen_ty_1::kMSkewX;
pub const SkMatrix_kMTransX: SkMatrix__bindgen_ty_1 =
    SkMatrix__bindgen_ty_1::kMTransX;
pub const SkMatrix_kMSkewY: SkMatrix__bindgen_ty_1 =
    SkMatrix__bindgen_ty_1::kMSkewY;
pub const SkMatrix_kMScaleY: SkMatrix__bindgen_ty_1 =
    SkMatrix__bindgen_ty_1::kMScaleY;
pub const SkMatrix_kMTransY: SkMatrix__bindgen_ty_1 =
    SkMatrix__bindgen_ty_1::kMTransY;
pub const SkMatrix_kMPersp0: SkMatrix__bindgen_ty_1 =
    SkMatrix__bindgen_ty_1::kMPersp0;
pub const SkMatrix_kMPersp1: SkMatrix__bindgen_ty_1 =
    SkMatrix__bindgen_ty_1::kMPersp1;
pub const SkMatrix_kMPersp2: SkMatrix__bindgen_ty_1 =
    SkMatrix__bindgen_ty_1::kMPersp2;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix__bindgen_ty_1 {
    kMScaleX = 0,
    kMSkewX = 1,
    kMTransX = 2,
    kMSkewY = 3,
    kMScaleY = 4,
    kMTransY = 5,
    kMPersp0 = 6,
    kMPersp1 = 7,
    kMPersp2 = 8,
}
pub const SkMatrix_kAScaleX: SkMatrix__bindgen_ty_2 =
    SkMatrix__bindgen_ty_2::kAScaleX;
pub const SkMatrix_kASkewY: SkMatrix__bindgen_ty_2 =
    SkMatrix__bindgen_ty_2::kASkewY;
pub const SkMatrix_kASkewX: SkMatrix__bindgen_ty_2 =
    SkMatrix__bindgen_ty_2::kASkewX;
pub const SkMatrix_kAScaleY: SkMatrix__bindgen_ty_2 =
    SkMatrix__bindgen_ty_2::kAScaleY;
pub const SkMatrix_kATransX: SkMatrix__bindgen_ty_2 =
    SkMatrix__bindgen_ty_2::kATransX;
pub const SkMatrix_kATransY: SkMatrix__bindgen_ty_2 =
    SkMatrix__bindgen_ty_2::kATransY;
#[repr(i32)]
/** Affine arrays are in column major order
        because that's how PDF and XPS like it.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix__bindgen_ty_2 {
    kAScaleX = 0,
    kASkewY = 1,
    kASkewX = 2,
    kAScaleY = 3,
    kATransX = 4,
    kATransY = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix_ScaleToFit {
    kFill_ScaleToFit = 0,
    kStart_ScaleToFit = 1,
    kCenter_ScaleToFit = 2,
    kEnd_ScaleToFit = 3,
}
pub type SkMatrix_MapXYProc =
    ::std::option::Option<unsafe extern "C" fn(mat: *const SkMatrix,
                                               x: SkScalar, y: SkScalar,
                                               result: *mut SkPoint)>;
pub type SkMatrix_MapPtsProc =
    ::std::option::Option<unsafe extern "C" fn(mat: *const SkMatrix,
                                               dst: *mut SkPoint,
                                               src: *const SkPoint,
                                               count: ::std::os::raw::c_int)>;
pub const SkMatrix_kMaxFlattenSize: SkMatrix__bindgen_ty_3 =
    SkMatrix__bindgen_ty_3::kMaxFlattenSize;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix__bindgen_ty_3 { kMaxFlattenSize = 40, }
pub const SkMatrix_kRectStaysRect_Mask: SkMatrix__bindgen_ty_4 =
    SkMatrix__bindgen_ty_4::kRectStaysRect_Mask;
pub const SkMatrix_kOnlyPerspectiveValid_Mask: SkMatrix__bindgen_ty_4 =
    SkMatrix__bindgen_ty_4::kOnlyPerspectiveValid_Mask;
pub const SkMatrix_kUnknown_Mask: SkMatrix__bindgen_ty_4 =
    SkMatrix__bindgen_ty_4::kUnknown_Mask;
pub const SkMatrix_kORableMasks: SkMatrix__bindgen_ty_4 =
    SkMatrix__bindgen_ty_4::kORableMasks;
pub const SkMatrix_kAllMasks: SkMatrix__bindgen_ty_4 =
    SkMatrix__bindgen_ty_4::kAllMasks;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix__bindgen_ty_4 {
    kRectStaysRect_Mask = 16,
    kOnlyPerspectiveValid_Mask = 64,
    kUnknown_Mask = 128,
    kORableMasks = 15,
    kAllMasks = 31,
}
extern "C" {
    #[link_name = "?gMapXYProcs@SkMatrix@@0QBQ6AXAEBV1@MMPEAUSkPoint@@@ZB"]
    pub static mut SkMatrix_gMapXYProcs: *const SkMatrix_MapXYProc;
}
extern "C" {
    #[link_name =
          "?gMapPtsProcs@SkMatrix@@0QBQ6AXAEBV1@QEAUSkPoint@@QEBU2@H@ZB"]
    pub static mut SkMatrix_gMapPtsProcs: *const SkMatrix_MapPtsProc;
}
#[test]
fn bindgen_test_layout_SkMatrix() {
    assert_eq!(::std::mem::size_of::<SkMatrix>() , 40usize);
    assert_eq!(::std::mem::align_of::<SkMatrix>() , 4usize);
}
extern "C" {
    /** Returns true if the matrix contains only translation, rotation/reflection or uniform scale
        Returns false if other transformation types are included or is degenerate
     */
    #[link_name = "?isSimilarity@SkMatrix@@QEBA_NM@Z"]
    pub fn SkMatrix_isSimilarity(this: *const SkMatrix, tol: SkScalar)
     -> bool;
}
extern "C" {
    /** Returns true if the matrix contains only translation, rotation/reflection or scale
        (non-uniform scale is allowed).
        Returns false if other transformation types are included or is degenerate
     */
    #[link_name = "?preservesRightAngles@SkMatrix@@QEBA_NM@Z"]
    pub fn SkMatrix_preservesRightAngles(this: *const SkMatrix, tol: SkScalar)
     -> bool;
}
extern "C" {
    /**
     *  Set this matrix to the 9 scalars from the buffer, in the same order as the kMScaleX
     *  enum... scalex, skewx, transx, skewy, scaley, transy, persp0, persp1, persp2
     *
     *  Note: calling set9 followed by get9 may not return the exact same values. Since the matrix
     *  is used to map non-homogeneous coordinates, it is free to rescale the 9 values as needed.
     */
    #[link_name = "?set9@SkMatrix@@QEAAXQEBM@Z"]
    pub fn SkMatrix_set9(this: *mut SkMatrix, buffer: *mut SkScalar);
}
extern "C" {
    /** Set the matrix to identity
    */
    #[link_name = "?reset@SkMatrix@@QEAAXXZ"]
    pub fn SkMatrix_reset(this: *mut SkMatrix);
}
extern "C" {
    /** Set the matrix to translate by (dx, dy).
    */
    #[link_name = "?setTranslate@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_setTranslate(this: *mut SkMatrix, dx: SkScalar,
                                 dy: SkScalar);
}
extern "C" {
    /** Set the matrix to scale by sx and sy, with a pivot point at (px, py).
        The pivot point is the coordinate that should remain unchanged by the
        specified transformation.
    */
    #[link_name = "?setScale@SkMatrix@@QEAAXMMMM@Z"]
    pub fn SkMatrix_setScale(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar,
                             px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Set the matrix to scale by sx and sy.
    */
    #[link_name = "?setScale@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_setScale1(this: *mut SkMatrix, sx: SkScalar,
                              sy: SkScalar);
}
extern "C" {
    /** Set the matrix to scale by 1/divx and 1/divy. Returns false and doesn't
        touch the matrix if either divx or divy is zero.
    */
    #[link_name = "?setIDiv@SkMatrix@@QEAA_NHH@Z"]
    pub fn SkMatrix_setIDiv(this: *mut SkMatrix, divx: ::std::os::raw::c_int,
                            divy: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /** Set the matrix to rotate by the specified number of degrees, with a
        pivot point at (px, py). The pivot point is the coordinate that should
        remain unchanged by the specified transformation.
    */
    #[link_name = "?setRotate@SkMatrix@@QEAAXMMM@Z"]
    pub fn SkMatrix_setRotate(this: *mut SkMatrix, degrees: SkScalar,
                              px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Set the matrix to rotate about (0,0) by the specified number of degrees.
    */
    #[link_name = "?setRotate@SkMatrix@@QEAAXM@Z"]
    pub fn SkMatrix_setRotate1(this: *mut SkMatrix, degrees: SkScalar);
}
extern "C" {
    /** Set the matrix to rotate by the specified sine and cosine values, with
        a pivot point at (px, py). The pivot point is the coordinate that
        should remain unchanged by the specified transformation.
    */
    #[link_name = "?setSinCos@SkMatrix@@QEAAXMMMM@Z"]
    pub fn SkMatrix_setSinCos(this: *mut SkMatrix, sinValue: SkScalar,
                              cosValue: SkScalar, px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Set the matrix to rotate by the specified sine and cosine values.
    */
    #[link_name = "?setSinCos@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_setSinCos1(this: *mut SkMatrix, sinValue: SkScalar,
                               cosValue: SkScalar);
}
extern "C" {
    #[link_name = "?setRSXform@SkMatrix@@QEAAAEAV1@AEBUSkRSXform@@@Z"]
    pub fn SkMatrix_setRSXform(this: *mut SkMatrix, arg1: *const SkRSXform)
     -> *mut SkMatrix;
}
extern "C" {
    /** Set the matrix to skew by sx and sy, with a pivot point at (px, py).
        The pivot point is the coordinate that should remain unchanged by the
        specified transformation.
    */
    #[link_name = "?setSkew@SkMatrix@@QEAAXMMMM@Z"]
    pub fn SkMatrix_setSkew(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar,
                            px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Set the matrix to skew by sx and sy.
    */
    #[link_name = "?setSkew@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_setSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar);
}
extern "C" {
    /** Set the matrix to the concatenation of the two specified matrices.
        Either of the two matrices may also be the target matrix.
        *this = a * b;
    */
    #[link_name = "?setConcat@SkMatrix@@QEAAXAEBV1@0@Z"]
    pub fn SkMatrix_setConcat(this: *mut SkMatrix, a: *const SkMatrix,
                              b: *const SkMatrix);
}
extern "C" {
    /** Preconcats the matrix with the specified translation.
        M' = M * T(dx, dy)
    */
    #[link_name = "?preTranslate@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_preTranslate(this: *mut SkMatrix, dx: SkScalar,
                                 dy: SkScalar);
}
extern "C" {
    /** Preconcats the matrix with the specified scale.
        M' = M * S(sx, sy, px, py)
    */
    #[link_name = "?preScale@SkMatrix@@QEAAXMMMM@Z"]
    pub fn SkMatrix_preScale(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar,
                             px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Preconcats the matrix with the specified scale.
        M' = M * S(sx, sy)
    */
    #[link_name = "?preScale@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_preScale1(this: *mut SkMatrix, sx: SkScalar,
                              sy: SkScalar);
}
extern "C" {
    /** Preconcats the matrix with the specified rotation.
        M' = M * R(degrees, px, py)
    */
    #[link_name = "?preRotate@SkMatrix@@QEAAXMMM@Z"]
    pub fn SkMatrix_preRotate(this: *mut SkMatrix, degrees: SkScalar,
                              px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Preconcats the matrix with the specified rotation.
        M' = M * R(degrees)
    */
    #[link_name = "?preRotate@SkMatrix@@QEAAXM@Z"]
    pub fn SkMatrix_preRotate1(this: *mut SkMatrix, degrees: SkScalar);
}
extern "C" {
    /** Preconcats the matrix with the specified skew.
        M' = M * K(kx, ky, px, py)
    */
    #[link_name = "?preSkew@SkMatrix@@QEAAXMMMM@Z"]
    pub fn SkMatrix_preSkew(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar,
                            px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Preconcats the matrix with the specified skew.
        M' = M * K(kx, ky)
    */
    #[link_name = "?preSkew@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_preSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar);
}
extern "C" {
    /** Preconcats the matrix with the specified matrix.
        M' = M * other
    */
    #[link_name = "?preConcat@SkMatrix@@QEAAXAEBV1@@Z"]
    pub fn SkMatrix_preConcat(this: *mut SkMatrix, other: *const SkMatrix);
}
extern "C" {
    /** Postconcats the matrix with the specified translation.
        M' = T(dx, dy) * M
    */
    #[link_name = "?postTranslate@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_postTranslate(this: *mut SkMatrix, dx: SkScalar,
                                  dy: SkScalar);
}
extern "C" {
    /** Postconcats the matrix with the specified scale.
        M' = S(sx, sy, px, py) * M
    */
    #[link_name = "?postScale@SkMatrix@@QEAAXMMMM@Z"]
    pub fn SkMatrix_postScale(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar,
                              px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Postconcats the matrix with the specified scale.
        M' = S(sx, sy) * M
    */
    #[link_name = "?postScale@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_postScale1(this: *mut SkMatrix, sx: SkScalar,
                               sy: SkScalar);
}
extern "C" {
    /** Postconcats the matrix by dividing it by the specified integers.
        M' = S(1/divx, 1/divy, 0, 0) * M
    */
    #[link_name = "?postIDiv@SkMatrix@@QEAA_NHH@Z"]
    pub fn SkMatrix_postIDiv(this: *mut SkMatrix, divx: ::std::os::raw::c_int,
                             divy: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /** Postconcats the matrix with the specified rotation.
        M' = R(degrees, px, py) * M
    */
    #[link_name = "?postRotate@SkMatrix@@QEAAXMMM@Z"]
    pub fn SkMatrix_postRotate(this: *mut SkMatrix, degrees: SkScalar,
                               px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Postconcats the matrix with the specified rotation.
        M' = R(degrees) * M
    */
    #[link_name = "?postRotate@SkMatrix@@QEAAXM@Z"]
    pub fn SkMatrix_postRotate1(this: *mut SkMatrix, degrees: SkScalar);
}
extern "C" {
    /** Postconcats the matrix with the specified skew.
        M' = K(kx, ky, px, py) * M
    */
    #[link_name = "?postSkew@SkMatrix@@QEAAXMMMM@Z"]
    pub fn SkMatrix_postSkew(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar,
                             px: SkScalar, py: SkScalar);
}
extern "C" {
    /** Postconcats the matrix with the specified skew.
        M' = K(kx, ky) * M
    */
    #[link_name = "?postSkew@SkMatrix@@QEAAXMM@Z"]
    pub fn SkMatrix_postSkew1(this: *mut SkMatrix, kx: SkScalar,
                              ky: SkScalar);
}
extern "C" {
    /** Postconcats the matrix with the specified matrix.
        M' = other * M
    */
    #[link_name = "?postConcat@SkMatrix@@QEAAXAEBV1@@Z"]
    pub fn SkMatrix_postConcat(this: *mut SkMatrix, other: *const SkMatrix);
}
extern "C" {
    /** Set the matrix to the scale and translate values that map the source
        rectangle to the destination rectangle, returning true if the the result
        can be represented.
        @param src the source rectangle to map from.
        @param dst the destination rectangle to map to.
        @param stf the ScaleToFit option
        @return true if the matrix can be represented by the rectangle mapping.
    */
    #[link_name =
          "?setRectToRect@SkMatrix@@QEAA_NAEBUSkRect@@0W4ScaleToFit@1@@Z"]
    pub fn SkMatrix_setRectToRect(this: *mut SkMatrix, src: *const SkRect,
                                  dst: *const SkRect,
                                  stf: SkMatrix_ScaleToFit) -> bool;
}
extern "C" {
    /** Set the matrix such that the specified src points would map to the
        specified dst points. count must be within [0..4].
        @param src  The array of src points
        @param dst  The array of dst points
        @param count The number of points to use for the transformation
        @return true if the matrix was set to the specified transformation
    */
    #[link_name = "?setPolyToPoly@SkMatrix@@QEAA_NQEBUSkPoint@@0H@Z"]
    pub fn SkMatrix_setPolyToPoly(this: *mut SkMatrix, src: *const SkPoint,
                                  dst: *const SkPoint,
                                  count: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /** Fills the passed array with affine identity values
        in column major order.
        @param affine  The array to fill with affine identity values.
        Must not be NULL.
    */
    #[link_name = "?SetAffineIdentity@SkMatrix@@SAXQEAM@Z"]
    pub fn SkMatrix_SetAffineIdentity(affine: *mut SkScalar);
}
extern "C" {
    /** Fills the passed array with the affine values in column major order.
        If the matrix is a perspective transform, returns false
        and does not change the passed array.
        @param affine  The array to fill with affine values. Ignored if NULL.
    */
    #[link_name = "?asAffine@SkMatrix@@QEBA_NQEAM@Z"]
    pub fn SkMatrix_asAffine(this: *const SkMatrix, affine: *mut SkScalar)
     -> bool;
}
extern "C" {
    /** Set the matrix to the specified affine values.
     *  Note: these are passed in column major order.
     */
    #[link_name = "?setAffine@SkMatrix@@QEAAXQEBM@Z"]
    pub fn SkMatrix_setAffine(this: *mut SkMatrix, affine: *mut SkScalar);
}
extern "C" {
    /** Apply this matrix to the array of homogeneous points, specified by src,
        where a homogeneous point is defined by 3 contiguous scalar values,
        and write the transformed points into the array of scalars specified by dst.
        dst[] = M * src[]
        @param dst  Where the transformed coordinates are written. It must
                    contain at least 3 * count entries
        @param src  The original coordinates that are to be transformed. It
                    must contain at least 3 * count entries
        @param count The number of triples (homogeneous points) in src to read,
                     and then transform into dst.
    */
    #[link_name = "?mapHomogeneousPoints@SkMatrix@@QEBAXQEAMQEBMH@Z"]
    pub fn SkMatrix_mapHomogeneousPoints(this: *const SkMatrix,
                                         dst: *mut SkScalar,
                                         src: *const SkScalar,
                                         count: ::std::os::raw::c_int);
}
extern "C" {
    /** Apply this matrix to the array of vectors specified by src, and write
        the transformed vectors into the array of vectors specified by dst.
        This is similar to mapPoints, but ignores any translation in the matrix.
        @param dst  Where the transformed coordinates are written. It must
                    contain at least count entries
        @param src  The original coordinates that are to be transformed. It
                    must contain at least count entries
        @param count The number of vectors in src to read, and then transform
                     into dst.
    */
    #[link_name = "?mapVectors@SkMatrix@@QEBAXQEAUSkPoint@@QEBU2@H@Z"]
    pub fn SkMatrix_mapVectors(this: *const SkMatrix, dst: *mut SkVector,
                               src: *const SkVector,
                               count: ::std::os::raw::c_int);
}
extern "C" {
    /** Apply this matrix to the src rectangle, and write the transformed
        rectangle into dst. This is accomplished by transforming the 4 corners
        of src, and then setting dst to the bounds of those points.
        @param dst  Where the transformed rectangle is written.
        @param src  The original rectangle to be transformed.
        @return the result of calling rectStaysRect()
    */
    #[link_name = "?mapRect@SkMatrix@@QEBA_NPEAUSkRect@@AEBU2@@Z"]
    pub fn SkMatrix_mapRect(this: *const SkMatrix, dst: *mut SkRect,
                            src: *const SkRect) -> bool;
}
extern "C" {
    /**
     *  Maps a rect to another rect, asserting (in debug mode) that the matrix only contains
     *  scale and translate elements. If it contains other elements, the results are undefined.
     */
    #[link_name =
          "?mapRectScaleTranslate@SkMatrix@@QEBAXPEAUSkRect@@AEBU2@@Z"]
    pub fn SkMatrix_mapRectScaleTranslate(this: *const SkMatrix,
                                          dst: *mut SkRect,
                                          src: *const SkRect);
}
extern "C" {
    /** Return the mean radius of a circle after it has been mapped by
        this matrix. NOTE: in perspective this value assumes the circle
        has its center at the origin.
    */
    #[link_name = "?mapRadius@SkMatrix@@QEBAMM@Z"]
    pub fn SkMatrix_mapRadius(this: *const SkMatrix, radius: SkScalar)
     -> SkScalar;
}
extern "C" {
    /** Returns true if the matrix can be stepped in X (not complex
        perspective).
    */
    #[link_name = "?isFixedStepInX@SkMatrix@@QEBA_NXZ"]
    pub fn SkMatrix_isFixedStepInX(this: *const SkMatrix) -> bool;
}
extern "C" {
    /** If the matrix can be stepped in X (not complex perspective)
        then return the step value.
        If it cannot, behavior is undefined.
    */
    #[link_name = "?fixedStepInX@SkMatrix@@QEBA?AUSkPoint@@M@Z"]
    pub fn SkMatrix_fixedStepInX(this: *const SkMatrix, y: SkScalar)
     -> SkVector;
}
extern "C" {
    #[link_name = "?writeToMemory@SkMatrix@@QEBA_KPEAX@Z"]
    pub fn SkMatrix_writeToMemory(this: *const SkMatrix,
                                  buffer: *mut ::std::os::raw::c_void)
     -> usize;
}
extern "C" {
    /**
     * Reads data from the buffer parameter
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
    #[link_name = "?readFromMemory@SkMatrix@@QEAA_KPEBX_K@Z"]
    pub fn SkMatrix_readFromMemory(this: *mut SkMatrix,
                                   buffer: *const ::std::os::raw::c_void,
                                   length: usize) -> usize;
}
extern "C" {
    #[link_name = "?dump@SkMatrix@@QEBAXXZ"]
    pub fn SkMatrix_dump(this: *const SkMatrix);
}
extern "C" {
    #[link_name = "?toString@SkMatrix@@QEBAXPEAVSkString@@@Z"]
    pub fn SkMatrix_toString(this: *const SkMatrix, arg1: *mut SkString);
}
extern "C" {
    /**
     * Calculates the minimum scaling factor of the matrix as computed from the SVD of the upper
     * left 2x2. If the max scale factor cannot be computed (for example overflow or perspective)
     * -1 is returned.
     *
     * @return minimum scale factor
     */
    #[link_name = "?getMinScale@SkMatrix@@QEBAMXZ"]
    pub fn SkMatrix_getMinScale(this: *const SkMatrix) -> SkScalar;
}
extern "C" {
    /**
     * Calculates the maximum scaling factor of the matrix as computed from the SVD of the upper
     * left 2x2. If the max scale factor cannot be computed (for example overflow or perspective)
     * -1 is returned.
     *
     * @return maximum scale factor
     */
    #[link_name = "?getMaxScale@SkMatrix@@QEBAMXZ"]
    pub fn SkMatrix_getMaxScale(this: *const SkMatrix) -> SkScalar;
}
extern "C" {
    /**
     * Gets both the min and max scale factors. The min scale factor is scaleFactors[0] and the max
     * is scaleFactors[1]. If the min/max scale factors cannot be computed false is returned and the
     * values of scaleFactors[] are undefined.
     */
    #[link_name = "?getMinMaxScales@SkMatrix@@QEBA_NQEAM@Z"]
    pub fn SkMatrix_getMinMaxScales(this: *const SkMatrix,
                                    scaleFactors: *mut SkScalar) -> bool;
}
extern "C" {
    /**
     *  Attempt to decompose this matrix into a scale-only component and whatever remains, where
     *  the scale component is to be applied first.
     *
     *  M -> Remaining * Scale
     *
     *  On success, return true and assign the scale and remaining components (assuming their
     *  respective parameters are not null). On failure return false and ignore the parameters.
     *
     *  Possible reasons to fail: perspective, one or more scale factors are zero.
     */
    #[link_name = "?decomposeScale@SkMatrix@@QEBA_NPEAUSkSize@@PEAV1@@Z"]
    pub fn SkMatrix_decomposeScale(this: *const SkMatrix, scale: *mut SkSize,
                                   remaining: *mut SkMatrix) -> bool;
}
extern "C" {
    /**
     *  Return a reference to a const identity matrix
     */
    #[link_name = "?I@SkMatrix@@SAAEBV1@XZ"]
    pub fn SkMatrix_I() -> *const SkMatrix;
}
extern "C" {
    /**
     *  Return a reference to a const matrix that is "invalid", one that could
     *  never be used.
     */
    #[link_name = "?InvalidMatrix@SkMatrix@@SAAEBV1@XZ"]
    pub fn SkMatrix_InvalidMatrix() -> *const SkMatrix;
}
impl Clone for SkMatrix {
    fn clone(&self) -> Self { *self }
}
impl SkMatrix {
    #[inline]
    pub unsafe fn isSimilarity(&self, tol: SkScalar) -> bool {
        SkMatrix_isSimilarity(&*self, tol)
    }
    #[inline]
    pub unsafe fn preservesRightAngles(&self, tol: SkScalar) -> bool {
        SkMatrix_preservesRightAngles(&*self, tol)
    }
    #[inline]
    pub unsafe fn set9(&mut self, buffer: *mut SkScalar) {
        SkMatrix_set9(&mut *self, buffer)
    }
    #[inline]
    pub unsafe fn reset(&mut self) { SkMatrix_reset(&mut *self) }
    #[inline]
    pub unsafe fn setTranslate(&mut self, dx: SkScalar, dy: SkScalar) {
        SkMatrix_setTranslate(&mut *self, dx, dy)
    }
    #[inline]
    pub unsafe fn setScale(&mut self, sx: SkScalar, sy: SkScalar,
                           px: SkScalar, py: SkScalar) {
        SkMatrix_setScale(&mut *self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn setScale1(&mut self, sx: SkScalar, sy: SkScalar) {
        SkMatrix_setScale1(&mut *self, sx, sy)
    }
    #[inline]
    pub unsafe fn setIDiv(&mut self, divx: ::std::os::raw::c_int,
                          divy: ::std::os::raw::c_int) -> bool {
        SkMatrix_setIDiv(&mut *self, divx, divy)
    }
    #[inline]
    pub unsafe fn setRotate(&mut self, degrees: SkScalar, px: SkScalar,
                            py: SkScalar) {
        SkMatrix_setRotate(&mut *self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn setRotate1(&mut self, degrees: SkScalar) {
        SkMatrix_setRotate1(&mut *self, degrees)
    }
    #[inline]
    pub unsafe fn setSinCos(&mut self, sinValue: SkScalar, cosValue: SkScalar,
                            px: SkScalar, py: SkScalar) {
        SkMatrix_setSinCos(&mut *self, sinValue, cosValue, px, py)
    }
    #[inline]
    pub unsafe fn setSinCos1(&mut self, sinValue: SkScalar,
                             cosValue: SkScalar) {
        SkMatrix_setSinCos1(&mut *self, sinValue, cosValue)
    }
    #[inline]
    pub unsafe fn setRSXform(&mut self, arg1: *const SkRSXform)
     -> *mut SkMatrix {
        SkMatrix_setRSXform(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setSkew(&mut self, kx: SkScalar, ky: SkScalar, px: SkScalar,
                          py: SkScalar) {
        SkMatrix_setSkew(&mut *self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn setSkew1(&mut self, kx: SkScalar, ky: SkScalar) {
        SkMatrix_setSkew1(&mut *self, kx, ky)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkMatrix,
                            b: *const SkMatrix) {
        SkMatrix_setConcat(&mut *self, a, b)
    }
    #[inline]
    pub unsafe fn preTranslate(&mut self, dx: SkScalar, dy: SkScalar) {
        SkMatrix_preTranslate(&mut *self, dx, dy)
    }
    #[inline]
    pub unsafe fn preScale(&mut self, sx: SkScalar, sy: SkScalar,
                           px: SkScalar, py: SkScalar) {
        SkMatrix_preScale(&mut *self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn preScale1(&mut self, sx: SkScalar, sy: SkScalar) {
        SkMatrix_preScale1(&mut *self, sx, sy)
    }
    #[inline]
    pub unsafe fn preRotate(&mut self, degrees: SkScalar, px: SkScalar,
                            py: SkScalar) {
        SkMatrix_preRotate(&mut *self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn preRotate1(&mut self, degrees: SkScalar) {
        SkMatrix_preRotate1(&mut *self, degrees)
    }
    #[inline]
    pub unsafe fn preSkew(&mut self, kx: SkScalar, ky: SkScalar, px: SkScalar,
                          py: SkScalar) {
        SkMatrix_preSkew(&mut *self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn preSkew1(&mut self, kx: SkScalar, ky: SkScalar) {
        SkMatrix_preSkew1(&mut *self, kx, ky)
    }
    #[inline]
    pub unsafe fn preConcat(&mut self, other: *const SkMatrix) {
        SkMatrix_preConcat(&mut *self, other)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, dx: SkScalar, dy: SkScalar) {
        SkMatrix_postTranslate(&mut *self, dx, dy)
    }
    #[inline]
    pub unsafe fn postScale(&mut self, sx: SkScalar, sy: SkScalar,
                            px: SkScalar, py: SkScalar) {
        SkMatrix_postScale(&mut *self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn postScale1(&mut self, sx: SkScalar, sy: SkScalar) {
        SkMatrix_postScale1(&mut *self, sx, sy)
    }
    #[inline]
    pub unsafe fn postIDiv(&mut self, divx: ::std::os::raw::c_int,
                           divy: ::std::os::raw::c_int) -> bool {
        SkMatrix_postIDiv(&mut *self, divx, divy)
    }
    #[inline]
    pub unsafe fn postRotate(&mut self, degrees: SkScalar, px: SkScalar,
                             py: SkScalar) {
        SkMatrix_postRotate(&mut *self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn postRotate1(&mut self, degrees: SkScalar) {
        SkMatrix_postRotate1(&mut *self, degrees)
    }
    #[inline]
    pub unsafe fn postSkew(&mut self, kx: SkScalar, ky: SkScalar,
                           px: SkScalar, py: SkScalar) {
        SkMatrix_postSkew(&mut *self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn postSkew1(&mut self, kx: SkScalar, ky: SkScalar) {
        SkMatrix_postSkew1(&mut *self, kx, ky)
    }
    #[inline]
    pub unsafe fn postConcat(&mut self, other: *const SkMatrix) {
        SkMatrix_postConcat(&mut *self, other)
    }
    #[inline]
    pub unsafe fn setRectToRect(&mut self, src: *const SkRect,
                                dst: *const SkRect, stf: SkMatrix_ScaleToFit)
     -> bool {
        SkMatrix_setRectToRect(&mut *self, src, dst, stf)
    }
    #[inline]
    pub unsafe fn setPolyToPoly(&mut self, src: *const SkPoint,
                                dst: *const SkPoint,
                                count: ::std::os::raw::c_int) -> bool {
        SkMatrix_setPolyToPoly(&mut *self, src, dst, count)
    }
    #[inline]
    pub unsafe fn SetAffineIdentity(affine: *mut SkScalar) {
        SkMatrix_SetAffineIdentity(affine)
    }
    #[inline]
    pub unsafe fn asAffine(&self, affine: *mut SkScalar) -> bool {
        SkMatrix_asAffine(&*self, affine)
    }
    #[inline]
    pub unsafe fn setAffine(&mut self, affine: *mut SkScalar) {
        SkMatrix_setAffine(&mut *self, affine)
    }
    #[inline]
    pub unsafe fn mapHomogeneousPoints(&self, dst: *mut SkScalar,
                                       src: *const SkScalar,
                                       count: ::std::os::raw::c_int) {
        SkMatrix_mapHomogeneousPoints(&*self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapVectors(&self, dst: *mut SkVector, src: *const SkVector,
                             count: ::std::os::raw::c_int) {
        SkMatrix_mapVectors(&*self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapRect(&self, dst: *mut SkRect, src: *const SkRect)
     -> bool {
        SkMatrix_mapRect(&*self, dst, src)
    }
    #[inline]
    pub unsafe fn mapRectScaleTranslate(&self, dst: *mut SkRect,
                                        src: *const SkRect) {
        SkMatrix_mapRectScaleTranslate(&*self, dst, src)
    }
    #[inline]
    pub unsafe fn mapRadius(&self, radius: SkScalar) -> SkScalar {
        SkMatrix_mapRadius(&*self, radius)
    }
    #[inline]
    pub unsafe fn isFixedStepInX(&self) -> bool {
        SkMatrix_isFixedStepInX(&*self)
    }
    #[inline]
    pub unsafe fn fixedStepInX(&self, y: SkScalar) -> SkVector {
        SkMatrix_fixedStepInX(&*self, y)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::std::os::raw::c_void)
     -> usize {
        SkMatrix_writeToMemory(&*self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(&mut self,
                                 buffer: *const ::std::os::raw::c_void,
                                 length: usize) -> usize {
        SkMatrix_readFromMemory(&mut *self, buffer, length)
    }
    #[inline]
    pub unsafe fn dump(&self) { SkMatrix_dump(&*self) }
    #[inline]
    pub unsafe fn toString(&self, arg1: *mut SkString) {
        SkMatrix_toString(&*self, arg1)
    }
    #[inline]
    pub unsafe fn getMinScale(&self) -> SkScalar {
        SkMatrix_getMinScale(&*self)
    }
    #[inline]
    pub unsafe fn getMaxScale(&self) -> SkScalar {
        SkMatrix_getMaxScale(&*self)
    }
    #[inline]
    pub unsafe fn getMinMaxScales(&self, scaleFactors: *mut SkScalar)
     -> bool {
        SkMatrix_getMinMaxScales(&*self, scaleFactors)
    }
    #[inline]
    pub unsafe fn decomposeScale(&self, scale: *mut SkSize,
                                 remaining: *mut SkMatrix) -> bool {
        SkMatrix_decomposeScale(&*self, scale, remaining)
    }
    #[inline]
    pub unsafe fn I() -> *const SkMatrix { SkMatrix_I() }
    #[inline]
    pub unsafe fn InvalidMatrix() -> *const SkMatrix {
        SkMatrix_InvalidMatrix()
    }
}
pub type SkMScalar = f32;
extern "C" {
    #[link_name = "?SkFloatToMScalar@@YAMM@Z"]
    pub fn SkFloatToMScalar(x: f32) -> f32;
}
extern "C" {
    #[link_name = "?SkMScalarToFloat@@YAMM@Z"]
    pub fn SkMScalarToFloat(x: f32) -> f32;
}
extern "C" {
    #[link_name = "?SkDoubleToMScalar@@YAMN@Z"]
    pub fn SkDoubleToMScalar(x: f64) -> f32;
}
extern "C" {
    #[link_name = "?SkMScalarToDouble@@YANM@Z"]
    pub fn SkMScalarToDouble(x: f32) -> f64;
}
extern "C" {
    #[link_name = "?SkMScalarAbs@@YAMM@Z"]
    pub fn SkMScalarAbs(x: f32) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkMatrix44 {
    pub fMat: [[SkMScalar; 4usize]; 4usize],
    pub fTypeMask: ::std::os::raw::c_uint,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix44_Uninitialized_Constructor {
    kUninitialized_Constructor = 0,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix44_Identity_Constructor { kIdentity_Constructor = 0, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix44_TypeMask {
    kIdentity_Mask = 0,
    kTranslate_Mask = 1,
    kScale_Mask = 2,
    kAffine_Mask = 4,
    kPerspective_Mask = 8,
}
pub const SkMatrix44_kUnknown_Mask: SkMatrix44__bindgen_ty_1 =
    SkMatrix44__bindgen_ty_1::kUnknown_Mask;
pub const SkMatrix44_kAllPublic_Masks: SkMatrix44__bindgen_ty_1 =
    SkMatrix44__bindgen_ty_1::kAllPublic_Masks;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMatrix44__bindgen_ty_1 {
    kUnknown_Mask = 128,
    kAllPublic_Masks = 15,
}
#[test]
fn bindgen_test_layout_SkMatrix44() {
    assert_eq!(::std::mem::size_of::<SkMatrix44>() , 68usize);
    assert_eq!(::std::mem::align_of::<SkMatrix44>() , 4usize);
}
extern "C" {
    /**
     *  Return a reference to a const identity matrix
     */
    #[link_name = "?I@SkMatrix44@@SAAEBV1@XZ"]
    pub fn SkMatrix44_I() -> *const SkMatrix44;
}
extern "C" {
    #[link_name = "?setIdentity@SkMatrix44@@QEAAXXZ"]
    pub fn SkMatrix44_setIdentity(this: *mut SkMatrix44);
}
extern "C" {
    /** These methods allow one to efficiently read matrix entries into an
     *  array. The given array must have room for exactly 16 entries. Whenever
     *  possible, they will try to use memcpy rather than an entry-by-entry
     *  copy.
     *
     *  Col major indicates that consecutive elements of columns will be stored
     *  contiguously in memory.  Row major indicates that consecutive elements
     *  of rows will be stored contiguously in memory.
     */
    #[link_name = "?asColMajorf@SkMatrix44@@QEBAXQEAM@Z"]
    pub fn SkMatrix44_asColMajorf(this: *const SkMatrix44, arg1: *mut f32);
}
extern "C" {
    #[link_name = "?asColMajord@SkMatrix44@@QEBAXQEAN@Z"]
    pub fn SkMatrix44_asColMajord(this: *const SkMatrix44, arg1: *mut f64);
}
extern "C" {
    #[link_name = "?asRowMajorf@SkMatrix44@@QEBAXQEAM@Z"]
    pub fn SkMatrix44_asRowMajorf(this: *const SkMatrix44, arg1: *mut f32);
}
extern "C" {
    #[link_name = "?asRowMajord@SkMatrix44@@QEBAXQEAN@Z"]
    pub fn SkMatrix44_asRowMajord(this: *const SkMatrix44, arg1: *mut f64);
}
extern "C" {
    /** These methods allow one to efficiently set all matrix entries from an
     *  array. The given array must have room for exactly 16 entries. Whenever
     *  possible, they will try to use memcpy rather than an entry-by-entry
     *  copy.
     *
     *  Col major indicates that input memory will be treated as if consecutive
     *  elements of columns are stored contiguously in memory.  Row major
     *  indicates that input memory will be treated as if consecutive elements
     *  of rows are stored contiguously in memory.
     */
    #[link_name = "?setColMajorf@SkMatrix44@@QEAAXQEBM@Z"]
    pub fn SkMatrix44_setColMajorf(this: *mut SkMatrix44, arg1: *const f32);
}
extern "C" {
    #[link_name = "?setColMajord@SkMatrix44@@QEAAXQEBN@Z"]
    pub fn SkMatrix44_setColMajord(this: *mut SkMatrix44, arg1: *const f64);
}
extern "C" {
    #[link_name = "?setRowMajorf@SkMatrix44@@QEAAXQEBM@Z"]
    pub fn SkMatrix44_setRowMajorf(this: *mut SkMatrix44, arg1: *const f32);
}
extern "C" {
    #[link_name = "?setRowMajord@SkMatrix44@@QEAAXQEBN@Z"]
    pub fn SkMatrix44_setRowMajord(this: *mut SkMatrix44, arg1: *const f64);
}
extern "C" {
    #[link_name = "?set3x3@SkMatrix44@@QEAAXMMMMMMMMM@Z"]
    pub fn SkMatrix44_set3x3(this: *mut SkMatrix44, m00: SkMScalar,
                             m01: SkMScalar, m02: SkMScalar, m10: SkMScalar,
                             m11: SkMScalar, m12: SkMScalar, m20: SkMScalar,
                             m21: SkMScalar, m22: SkMScalar);
}
extern "C" {
    #[link_name = "?set3x3RowMajorf@SkMatrix44@@QEAAXQEBM@Z"]
    pub fn SkMatrix44_set3x3RowMajorf(this: *mut SkMatrix44,
                                      arg1: *const f32);
}
extern "C" {
    #[link_name = "?setTranslate@SkMatrix44@@QEAAXMMM@Z"]
    pub fn SkMatrix44_setTranslate(this: *mut SkMatrix44, dx: SkMScalar,
                                   dy: SkMScalar, dz: SkMScalar);
}
extern "C" {
    #[link_name = "?preTranslate@SkMatrix44@@QEAAXMMM@Z"]
    pub fn SkMatrix44_preTranslate(this: *mut SkMatrix44, dx: SkMScalar,
                                   dy: SkMScalar, dz: SkMScalar);
}
extern "C" {
    #[link_name = "?postTranslate@SkMatrix44@@QEAAXMMM@Z"]
    pub fn SkMatrix44_postTranslate(this: *mut SkMatrix44, dx: SkMScalar,
                                    dy: SkMScalar, dz: SkMScalar);
}
extern "C" {
    #[link_name = "?setScale@SkMatrix44@@QEAAXMMM@Z"]
    pub fn SkMatrix44_setScale(this: *mut SkMatrix44, sx: SkMScalar,
                               sy: SkMScalar, sz: SkMScalar);
}
extern "C" {
    #[link_name = "?preScale@SkMatrix44@@QEAAXMMM@Z"]
    pub fn SkMatrix44_preScale(this: *mut SkMatrix44, sx: SkMScalar,
                               sy: SkMScalar, sz: SkMScalar);
}
extern "C" {
    #[link_name = "?postScale@SkMatrix44@@QEAAXMMM@Z"]
    pub fn SkMatrix44_postScale(this: *mut SkMatrix44, sx: SkMScalar,
                                sy: SkMScalar, sz: SkMScalar);
}
extern "C" {
    /** Rotate about the vector [x,y,z]. If that vector is not unit-length,
        it will be automatically resized.
     */
    #[link_name = "?setRotateAbout@SkMatrix44@@QEAAXMMMM@Z"]
    pub fn SkMatrix44_setRotateAbout(this: *mut SkMatrix44, x: SkMScalar,
                                     y: SkMScalar, z: SkMScalar,
                                     radians: SkMScalar);
}
extern "C" {
    /** Rotate about the vector [x,y,z]. Does not check the length of the
        vector, assuming it is unit-length.
     */
    #[link_name = "?setRotateAboutUnit@SkMatrix44@@QEAAXMMMM@Z"]
    pub fn SkMatrix44_setRotateAboutUnit(this: *mut SkMatrix44, x: SkMScalar,
                                         y: SkMScalar, z: SkMScalar,
                                         radians: SkMScalar);
}
extern "C" {
    #[link_name = "?setConcat@SkMatrix44@@QEAAXAEBV1@0@Z"]
    pub fn SkMatrix44_setConcat(this: *mut SkMatrix44, a: *const SkMatrix44,
                                b: *const SkMatrix44);
}
extern "C" {
    /** If this is invertible, return that in inverse and return true. If it is
        not invertible, return false and leave the inverse parameter in an
        unspecified state.
     */
    #[link_name = "?invert@SkMatrix44@@QEBA_NPEAV1@@Z"]
    pub fn SkMatrix44_invert(this: *const SkMatrix44,
                             inverse: *mut SkMatrix44) -> bool;
}
extern "C" {
    /** Transpose this matrix in place. */
    #[link_name = "?transpose@SkMatrix44@@QEAAXXZ"]
    pub fn SkMatrix44_transpose(this: *mut SkMatrix44);
}
extern "C" {
    /** Apply the matrix to the src vector, returning the new vector in dst.
        It is legal for src and dst to point to the same memory.
     */
    #[link_name = "?mapScalars@SkMatrix44@@QEBAXQEBMQEAM@Z"]
    pub fn SkMatrix44_mapScalars(this: *const SkMatrix44, src: *mut SkScalar,
                                 dst: *mut SkScalar);
}
extern "C" {
    /**
     *  map an array of [x, y, 0, 1] through the matrix, returning an array
     *  of [x', y', z', w'].
     *
     *  @param src2     array of [x, y] pairs, with implied z=0 and w=1
     *  @param count    number of [x, y] pairs in src2
     *  @param dst4     array of [x', y', z', w'] quads as the output.
     */
    #[link_name = "?map2@SkMatrix44@@QEBAXQEBMHQEAM@Z"]
    pub fn SkMatrix44_map2(this: *const SkMatrix44, src2: *const f32,
                           count: ::std::os::raw::c_int, dst4: *mut f32);
}
extern "C" {
    #[link_name = "?map2@SkMatrix44@@QEBAXQEBNHQEAN@Z"]
    pub fn SkMatrix44_map21(this: *const SkMatrix44, src2: *const f64,
                            count: ::std::os::raw::c_int, dst4: *mut f64);
}
extern "C" {
    /** Returns true if transformating an axis-aligned square in 2d by this matrix
        will produce another 2d axis-aligned square; typically means the matrix
        is a scale with perhaps a 90-degree rotation. A 3d rotation through 90
        degrees into a perpendicular plane collapses a square to a line, but
        is still considered to be axis-aligned.

        By default, tolerates very slight error due to float imprecisions;
        a 90-degree rotation can still end up with 10^-17 of
        "non-axis-aligned" result.
     */
    #[link_name = "?preserves2dAxisAlignment@SkMatrix44@@QEBA_NM@Z"]
    pub fn SkMatrix44_preserves2dAxisAlignment(this: *const SkMatrix44,
                                               epsilon: SkMScalar) -> bool;
}
extern "C" {
    #[link_name = "?dump@SkMatrix44@@QEBAXXZ"]
    pub fn SkMatrix44_dump(this: *const SkMatrix44);
}
extern "C" {
    #[link_name = "?determinant@SkMatrix44@@QEBANXZ"]
    pub fn SkMatrix44_determinant(this: *const SkMatrix44) -> f64;
}
impl Clone for SkMatrix44 {
    fn clone(&self) -> Self { *self }
}
impl SkMatrix44 {
    #[inline]
    pub unsafe fn I() -> *const SkMatrix44 { SkMatrix44_I() }
    #[inline]
    pub unsafe fn setIdentity(&mut self) {
        SkMatrix44_setIdentity(&mut *self)
    }
    #[inline]
    pub unsafe fn asColMajorf(&self, arg1: *mut f32) {
        SkMatrix44_asColMajorf(&*self, arg1)
    }
    #[inline]
    pub unsafe fn asColMajord(&self, arg1: *mut f64) {
        SkMatrix44_asColMajord(&*self, arg1)
    }
    #[inline]
    pub unsafe fn asRowMajorf(&self, arg1: *mut f32) {
        SkMatrix44_asRowMajorf(&*self, arg1)
    }
    #[inline]
    pub unsafe fn asRowMajord(&self, arg1: *mut f64) {
        SkMatrix44_asRowMajord(&*self, arg1)
    }
    #[inline]
    pub unsafe fn setColMajorf(&mut self, arg1: *const f32) {
        SkMatrix44_setColMajorf(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setColMajord(&mut self, arg1: *const f64) {
        SkMatrix44_setColMajord(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setRowMajorf(&mut self, arg1: *const f32) {
        SkMatrix44_setRowMajorf(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setRowMajord(&mut self, arg1: *const f64) {
        SkMatrix44_setRowMajord(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn set3x3(&mut self, m00: SkMScalar, m01: SkMScalar,
                         m02: SkMScalar, m10: SkMScalar, m11: SkMScalar,
                         m12: SkMScalar, m20: SkMScalar, m21: SkMScalar,
                         m22: SkMScalar) {
        SkMatrix44_set3x3(&mut *self, m00, m01, m02, m10, m11, m12, m20, m21,
                          m22)
    }
    #[inline]
    pub unsafe fn set3x3RowMajorf(&mut self, arg1: *const f32) {
        SkMatrix44_set3x3RowMajorf(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setTranslate(&mut self, dx: SkMScalar, dy: SkMScalar,
                               dz: SkMScalar) {
        SkMatrix44_setTranslate(&mut *self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn preTranslate(&mut self, dx: SkMScalar, dy: SkMScalar,
                               dz: SkMScalar) {
        SkMatrix44_preTranslate(&mut *self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, dx: SkMScalar, dy: SkMScalar,
                                dz: SkMScalar) {
        SkMatrix44_postTranslate(&mut *self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn setScale(&mut self, sx: SkMScalar, sy: SkMScalar,
                           sz: SkMScalar) {
        SkMatrix44_setScale(&mut *self, sx, sy, sz)
    }
    #[inline]
    pub unsafe fn preScale(&mut self, sx: SkMScalar, sy: SkMScalar,
                           sz: SkMScalar) {
        SkMatrix44_preScale(&mut *self, sx, sy, sz)
    }
    #[inline]
    pub unsafe fn postScale(&mut self, sx: SkMScalar, sy: SkMScalar,
                            sz: SkMScalar) {
        SkMatrix44_postScale(&mut *self, sx, sy, sz)
    }
    #[inline]
    pub unsafe fn setRotateAbout(&mut self, x: SkMScalar, y: SkMScalar,
                                 z: SkMScalar, radians: SkMScalar) {
        SkMatrix44_setRotateAbout(&mut *self, x, y, z, radians)
    }
    #[inline]
    pub unsafe fn setRotateAboutUnit(&mut self, x: SkMScalar, y: SkMScalar,
                                     z: SkMScalar, radians: SkMScalar) {
        SkMatrix44_setRotateAboutUnit(&mut *self, x, y, z, radians)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkMatrix44,
                            b: *const SkMatrix44) {
        SkMatrix44_setConcat(&mut *self, a, b)
    }
    #[inline]
    pub unsafe fn invert(&self, inverse: *mut SkMatrix44) -> bool {
        SkMatrix44_invert(&*self, inverse)
    }
    #[inline]
    pub unsafe fn transpose(&mut self) { SkMatrix44_transpose(&mut *self) }
    #[inline]
    pub unsafe fn mapScalars(&self, src: *mut SkScalar, dst: *mut SkScalar) {
        SkMatrix44_mapScalars(&*self, src, dst)
    }
    #[inline]
    pub unsafe fn map2(&self, src2: *const f32, count: ::std::os::raw::c_int,
                       dst4: *mut f32) {
        SkMatrix44_map2(&*self, src2, count, dst4)
    }
    #[inline]
    pub unsafe fn map21(&self, src2: *const f64, count: ::std::os::raw::c_int,
                        dst4: *mut f64) {
        SkMatrix44_map21(&*self, src2, count, dst4)
    }
    #[inline]
    pub unsafe fn preserves2dAxisAlignment(&self, epsilon: SkMScalar)
     -> bool {
        SkMatrix44_preserves2dAxisAlignment(&*self, epsilon)
    }
    #[inline]
    pub unsafe fn dump(&self) { SkMatrix44_dump(&*self) }
    #[inline]
    pub unsafe fn determinant(&self) -> f64 { SkMatrix44_determinant(&*self) }
}
/**
 *  Describes a color gamut with primaries and a white point.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkColorSpacePrimaries {
    pub fRX: f32,
    pub fRY: f32,
    pub fGX: f32,
    pub fGY: f32,
    pub fBX: f32,
    pub fBY: f32,
    pub fWX: f32,
    pub fWY: f32,
}
#[test]
fn bindgen_test_layout_SkColorSpacePrimaries() {
    assert_eq!(::std::mem::size_of::<SkColorSpacePrimaries>() , 32usize);
    assert_eq!(::std::mem::align_of::<SkColorSpacePrimaries>() , 4usize);
}
extern "C" {
    /**
     *  Convert primaries and a white point to a toXYZD50 matrix, the preferred color gamut
     *  representation of SkColorSpace.
     */
    #[link_name = "?toXYZD50@SkColorSpacePrimaries@@QEBA_NPEAVSkMatrix44@@@Z"]
    pub fn SkColorSpacePrimaries_toXYZD50(this: *const SkColorSpacePrimaries,
                                          toXYZD50: *mut SkMatrix44) -> bool;
}
impl Clone for SkColorSpacePrimaries {
    fn clone(&self) -> Self { *self }
}
impl SkColorSpacePrimaries {
    #[inline]
    pub unsafe fn toXYZD50(&self, toXYZD50: *mut SkMatrix44) -> bool {
        SkColorSpacePrimaries_toXYZD50(&*self, toXYZD50)
    }
}
/**
 *  Contains the coefficients for a common transfer function equation, specified as
 *  a transformation from a curved space to linear.
 *
 *  LinearVal = E*InputVal + F        , for 0.0f <= InputVal <  D
 *  LinearVal = (A*InputVal + B)^G + C, for D    <= InputVal <= 1.0f
 *
 *  Function is undefined if InputVal is not in [ 0.0f, 1.0f ].
 *  Resulting LinearVals must be in [ 0.0f, 1.0f ].
 *  Function must be positive and increasing.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkColorSpaceTransferFn {
    pub fG: f32,
    pub fA: f32,
    pub fB: f32,
    pub fC: f32,
    pub fD: f32,
    pub fE: f32,
    pub fF: f32,
}
#[test]
fn bindgen_test_layout_SkColorSpaceTransferFn() {
    assert_eq!(::std::mem::size_of::<SkColorSpaceTransferFn>() , 28usize);
    assert_eq!(::std::mem::align_of::<SkColorSpaceTransferFn>() , 4usize);
}
impl Clone for SkColorSpaceTransferFn {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkColorSpace {
    pub _base: SkRefCnt,
}
#[repr(u8)]
/**
     *  Common, named profiles that we can recognize.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkColorSpace_Named {
    kSRGB_Named = 0,
    kAdobeRGB_Named = 1,
    kSRGBLinear_Named = 2,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkColorSpace_RenderTargetGamma {
    kLinear_RenderTargetGamma = 0,
    kSRGB_RenderTargetGamma = 1,
}
#[test]
fn bindgen_test_layout_SkColorSpace() {
    assert_eq!(::std::mem::size_of::<SkColorSpace>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkColorSpace>() , 1usize);
}
extern "C" {
    /**
     *  Create an SkColorSpace from a transfer function and a color gamut.
     *
     *  Transfer function can be specified as a render target, as the coefficients to an equation,
     *  or as three exponents (R, G, B).
     *  Gamut is specified using the matrix transformation to XYZ D50.
     */
    #[link_name =
          "?MakeRGB@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@W4RenderTargetGamma@1@AEBVSkMatrix44@@@Z"]
    pub fn SkColorSpace_MakeRGB(gamma: SkColorSpace_RenderTargetGamma,
                                toXYZD50: *const SkMatrix44)
     -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name =
          "?MakeRGB@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@AEBUSkColorSpaceTransferFn@@AEBVSkMatrix44@@@Z"]
    pub fn SkColorSpace_MakeRGB1(coeffs: *const SkColorSpaceTransferFn,
                                 toXYZD50: *const SkMatrix44)
     -> sk_sp<SkColorSpace>;
}
extern "C" {
    /**
     *  Create a common, named SkColorSpace.
     */
    #[link_name =
          "?MakeNamed@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@W4Named@1@@Z"]
    pub fn SkColorSpace_MakeNamed(arg1: SkColorSpace_Named)
     -> sk_sp<SkColorSpace>;
}
extern "C" {
    /**
     *  Create an SkColorSpace from an ICC profile.
     */
    #[link_name =
          "?MakeICC@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@PEBX_K@Z"]
    pub fn SkColorSpace_MakeICC(arg1: *const ::std::os::raw::c_void,
                                arg2: usize) -> sk_sp<SkColorSpace>;
}
extern "C" {
    /**
     *  Returns true if the color space gamma is near enough to be approximated as sRGB.
     */
    #[link_name = "?gammaCloseToSRGB@SkColorSpace@@QEBA_NXZ"]
    pub fn SkColorSpace_gammaCloseToSRGB(this: *const SkColorSpace) -> bool;
}
extern "C" {
    /**
     *  Returns true if the color space gamma is linear.
     */
    #[link_name = "?gammaIsLinear@SkColorSpace@@QEBA_NXZ"]
    pub fn SkColorSpace_gammaIsLinear(this: *const SkColorSpace) -> bool;
}
extern "C" {
    /**
     *  Returns nullptr on failure.  Fails when we fallback to serializing ICC data and
     *  the data is too large to serialize.
     */
    #[link_name = "?serialize@SkColorSpace@@QEBA?AV?$sk_sp@VSkData@@@@XZ"]
    pub fn SkColorSpace_serialize(this: *const SkColorSpace) -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  If |memory| is nullptr, returns the size required to serialize.
     *  Otherwise, serializes into |memory| and returns the size.
     */
    #[link_name = "?writeToMemory@SkColorSpace@@QEBA_KPEAX@Z"]
    pub fn SkColorSpace_writeToMemory(this: *const SkColorSpace,
                                      memory: *mut ::std::os::raw::c_void)
     -> usize;
}
extern "C" {
    #[link_name =
          "?Deserialize@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@PEBX_K@Z"]
    pub fn SkColorSpace_Deserialize(data: *const ::std::os::raw::c_void,
                                    length: usize) -> sk_sp<SkColorSpace>;
}
extern "C" {
    /**
     *  If both are null, we return true.  If one is null and the other is not, we return false.
     *  If both are non-null, we do a deeper compare.
     */
    #[link_name = "?Equals@SkColorSpace@@SA_NPEBV1@0@Z"]
    pub fn SkColorSpace_Equals(src: *const SkColorSpace,
                               dst: *const SkColorSpace) -> bool;
}
impl SkColorSpace {
    #[inline]
    pub unsafe fn MakeRGB(gamma: SkColorSpace_RenderTargetGamma,
                          toXYZD50: *const SkMatrix44)
     -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeRGB(gamma, toXYZD50)
    }
    #[inline]
    pub unsafe fn MakeRGB1(coeffs: *const SkColorSpaceTransferFn,
                           toXYZD50: *const SkMatrix44)
     -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeRGB1(coeffs, toXYZD50)
    }
    #[inline]
    pub unsafe fn MakeNamed(arg1: SkColorSpace_Named) -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeNamed(arg1)
    }
    #[inline]
    pub unsafe fn MakeICC(arg1: *const ::std::os::raw::c_void, arg2: usize)
     -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeICC(arg1, arg2)
    }
    #[inline]
    pub unsafe fn gammaCloseToSRGB(&self) -> bool {
        SkColorSpace_gammaCloseToSRGB(&*self)
    }
    #[inline]
    pub unsafe fn gammaIsLinear(&self) -> bool {
        SkColorSpace_gammaIsLinear(&*self)
    }
    #[inline]
    pub unsafe fn serialize(&self) -> sk_sp<SkData> {
        SkColorSpace_serialize(&*self)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, memory: *mut ::std::os::raw::c_void)
     -> usize {
        SkColorSpace_writeToMemory(&*self, memory)
    }
    #[inline]
    pub unsafe fn Deserialize(data: *const ::std::os::raw::c_void,
                              length: usize) -> sk_sp<SkColorSpace> {
        SkColorSpace_Deserialize(data, length)
    }
    #[inline]
    pub unsafe fn Equals(src: *const SkColorSpace, dst: *const SkColorSpace)
     -> bool {
        SkColorSpace_Equals(src, dst)
    }
}
extern "C" {
    #[link_name = "?SkAlphaTypeIsOpaque@@YA_NW4SkAlphaType@@@Z"]
    pub fn SkAlphaTypeIsOpaque(at: SkAlphaType) -> bool;
}
extern "C" {
    #[link_name = "?SkAlphaTypeIsValid@@YA_NI@Z"]
    pub fn SkAlphaTypeIsValid(value: ::std::os::raw::c_uint) -> bool;
}
pub const SkColorType_kLastEnum_SkColorType: SkColorType =
    SkColorType::kRGBA_F16_SkColorType;
pub const SkColorType_kN32_SkColorType: SkColorType =
    SkColorType::kBGRA_8888_SkColorType;
#[repr(i32)]
/**
 *  Describes how to interpret the components of a pixel.
 *
 *  kN32_SkColorType is an alias for whichever 32bit ARGB format is the "native"
 *  form for skia's blitters. Use this if you don't have a swizzle preference
 *  for 32bit pixels.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkColorType {
    kUnknown_SkColorType = 0,
    kAlpha_8_SkColorType = 1,
    kRGB_565_SkColorType = 2,
    kARGB_4444_SkColorType = 3,
    kRGBA_8888_SkColorType = 4,
    kBGRA_8888_SkColorType = 5,
    kIndex_8_SkColorType = 6,
    kGray_8_SkColorType = 7,
    kRGBA_F16_SkColorType = 8,
}
extern "C" {
    #[link_name = "?SkColorTypeBytesPerPixel@@YAHW4SkColorType@@@Z"]
    pub fn SkColorTypeBytesPerPixel(ct: SkColorType) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkColorTypeShiftPerPixel@@YAHW4SkColorType@@@Z"]
    pub fn SkColorTypeShiftPerPixel(ct: SkColorType) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkColorTypeMinRowBytes@@YA_KW4SkColorType@@H@Z"]
    pub fn SkColorTypeMinRowBytes(ct: SkColorType,
                                  width: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    #[link_name = "?SkColorTypeIsValid@@YA_NI@Z"]
    pub fn SkColorTypeIsValid(value: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    #[link_name = "?SkColorTypeComputeOffset@@YA_KW4SkColorType@@HH_K@Z"]
    pub fn SkColorTypeComputeOffset(ct: SkColorType, x: ::std::os::raw::c_int,
                                    y: ::std::os::raw::c_int, rowBytes: usize)
     -> usize;
}
extern "C" {
    /**
 *  Return true if alphaType is supported by colorType. If there is a canonical
 *  alphaType for this colorType, return it in canonical.
 */
    #[link_name =
          "?SkColorTypeValidateAlphaType@@YA_NW4SkColorType@@W4SkAlphaType@@PEAW42@@Z"]
    pub fn SkColorTypeValidateAlphaType(colorType: SkColorType,
                                        alphaType: SkAlphaType,
                                        canonical: *mut SkAlphaType) -> bool;
}
pub const SkYUVColorSpace_kLastEnum_SkYUVColorSpace: SkYUVColorSpace =
    SkYUVColorSpace::kRec709_SkYUVColorSpace;
#[repr(i32)]
/**
 *  Describes the color space a YUV pixel.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkYUVColorSpace {
    kJPEG_SkYUVColorSpace = 0,
    kRec601_SkYUVColorSpace = 1,
    kRec709_SkYUVColorSpace = 2,
}
#[repr(i32)]
///////////////////////////////////////////////////////////////////////////////
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkDestinationSurfaceColorMode {
    kLegacy = 0,
    kGammaAndColorSpaceAware = 1,
}
/** \class SkColorTable

    SkColorTable holds an array SkPMColors (premultiplied 32-bit colors) used by
    8-bit bitmaps, where the bitmap bytes are interpreted as indices into the colortable.

    SkColorTable is thread-safe.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkColorTable {
    pub _base: SkRefCnt,
    pub fColors: *mut SkPMColor,
    pub f16BitCache: *mut u16,
    pub f16BitCacheOnce: SkOnce,
    pub fCount: ::std::os::raw::c_int,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkColorTable_AllocatedWithMalloc { kAllocatedWithMalloc = 0, }
pub type SkColorTable_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkColorTable() {
    assert_eq!(::std::mem::size_of::<SkColorTable>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkColorTable>() , 1usize);
}
extern "C" {
    /** read16BitCache() returns the array of RGB16 colors that mirror the 32bit colors.
     */
    #[link_name = "?read16BitCache@SkColorTable@@QEBAPEBGXZ"]
    pub fn SkColorTable_read16BitCache(this: *const SkColorTable)
     -> *const u16;
}
extern "C" {
    #[link_name = "?writeToBuffer@SkColorTable@@QEBAXAEAVSkWriteBuffer@@@Z"]
    pub fn SkColorTable_writeToBuffer(this: *const SkColorTable,
                                      arg1: *mut SkWriteBuffer);
}
extern "C" {
    #[link_name = "?Create@SkColorTable@@SAPEAV1@AEAVSkReadBuffer@@@Z"]
    pub fn SkColorTable_Create(arg1: *mut SkReadBuffer) -> *mut SkColorTable;
}
impl SkColorTable {
    #[inline]
    pub unsafe fn read16BitCache(&self) -> *const u16 {
        SkColorTable_read16BitCache(&*self)
    }
    #[inline]
    pub unsafe fn writeToBuffer(&self, arg1: *mut SkWriteBuffer) {
        SkColorTable_writeToBuffer(&*self, arg1)
    }
    #[inline]
    pub unsafe fn Create(arg1: *mut SkReadBuffer) -> *mut SkColorTable {
        SkColorTable_Create(arg1)
    }
}
pub const SkFilterQuality_kLast_SkFilterQuality: SkFilterQuality =
    SkFilterQuality::kHigh_SkFilterQuality;
#[repr(i32)]
/**
 *  Controls how much filtering to be done when scaling/transforming complex colors
 *  e.g. images
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkFilterQuality {
    kNone_SkFilterQuality = 0,
    kLow_SkFilterQuality = 1,
    kMedium_SkFilterQuality = 2,
    kHigh_SkFilterQuality = 3,
}
/** \class SkMask
    SkMask is used to describe alpha bitmaps, either 1bit, 8bit, or
    the 3-channel 3D format. These are passed to SkMaskFilter objects.
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkMask {
    pub fImage: *mut u8,
    pub fBounds: SkIRect,
    pub fRowBytes: u32,
    pub fFormat: SkMask_Format,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMask_Format {
    kBW_Format = 0,
    kA8_Format = 1,
    k3D_Format = 2,
    kARGB32_Format = 3,
    kLCD16_Format = 4,
}
pub const SkMask_kCountMaskFormats: SkMask__bindgen_ty_1 =
    SkMask__bindgen_ty_1::kCountMaskFormats;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMask__bindgen_ty_1 { kCountMaskFormats = 5, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMask_CreateMode {
    kJustComputeBounds_CreateMode = 0,
    kJustRenderImage_CreateMode = 1,
    kComputeBoundsAndRenderImage_CreateMode = 2,
}
#[test]
fn bindgen_test_layout_SkMask() {
    assert_eq!(::std::mem::size_of::<SkMask>() , 32usize);
    assert_eq!(::std::mem::align_of::<SkMask>() , 8usize);
}
extern "C" {
    /** Return the byte size of the mask, assuming only 1 plane.
        Does not account for k3D_Format. For that, use computeTotalImageSize().
        If there is an overflow of 32bits, then returns 0.
    */
    #[link_name = "?computeImageSize@SkMask@@QEBA_KXZ"]
    pub fn SkMask_computeImageSize(this: *const SkMask) -> usize;
}
extern "C" {
    /** Return the byte size of the mask, taking into account
        any extra planes (e.g. k3D_Format).
        If there is an overflow of 32bits, then returns 0.
    */
    #[link_name = "?computeTotalImageSize@SkMask@@QEBA_KXZ"]
    pub fn SkMask_computeTotalImageSize(this: *const SkMask) -> usize;
}
extern "C" {
    /**
     *  Returns the address of the specified pixel, computing the pixel-size
     *  at runtime based on the mask format. This will be slightly slower than
     *  using one of the routines where the format is implied by the name
     *  e.g. getAddr8 or getAddr32.
     *
     *  x,y must be contained by the mask's bounds (this is asserted in the
     *  debug build, but not checked in the release build.)
     *
     *  This should not be called with kBW_Format, as it will give unspecified
     *  results (and assert in the debug build).
     */
    #[link_name = "?getAddr@SkMask@@QEBAPEAXHH@Z"]
    pub fn SkMask_getAddr(this: *const SkMask, x: ::std::os::raw::c_int,
                          y: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "?AllocImage@SkMask@@SAPEAE_K@Z"]
    pub fn SkMask_AllocImage(bytes: usize) -> *mut u8;
}
extern "C" {
    #[link_name = "?FreeImage@SkMask@@SAXPEAX@Z"]
    pub fn SkMask_FreeImage(image: *mut ::std::os::raw::c_void);
}
impl Clone for SkMask {
    fn clone(&self) -> Self { *self }
}
impl SkMask {
    #[inline]
    pub unsafe fn computeImageSize(&self) -> usize {
        SkMask_computeImageSize(&*self)
    }
    #[inline]
    pub unsafe fn computeTotalImageSize(&self) -> usize {
        SkMask_computeTotalImageSize(&*self)
    }
    #[inline]
    pub unsafe fn getAddr(&self, x: ::std::os::raw::c_int,
                          y: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void {
        SkMask_getAddr(&*self, x, y)
    }
    #[inline]
    pub unsafe fn AllocImage(bytes: usize) -> *mut u8 {
        SkMask_AllocImage(bytes)
    }
    #[inline]
    pub unsafe fn FreeImage(image: *mut ::std::os::raw::c_void) {
        SkMask_FreeImage(image)
    }
}
/**
 *  Pairs SkImageInfo with actual pixels and rowbytes. This class does not try to manage the
 *  lifetime of the pixel memory (nor the colortable if provided).
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkPixmap {
    pub fPixels: *const ::std::os::raw::c_void,
    pub fCTable: *mut SkColorTable,
    pub fRowBytes: usize,
    pub fInfo: SkImageInfo,
}
#[test]
fn bindgen_test_layout_SkPixmap() {
    assert_eq!(::std::mem::size_of::<SkPixmap>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPixmap>() , 1usize);
}
extern "C" {
    #[link_name = "?reset@SkPixmap@@QEAAXXZ"]
    pub fn SkPixmap_reset(this: *mut SkPixmap);
}
extern "C" {
    #[link_name =
          "?reset@SkPixmap@@QEAAXAEBUSkImageInfo@@PEBX_KPEAVSkColorTable@@@Z"]
    pub fn SkPixmap_reset1(this: *mut SkPixmap, info: *const SkImageInfo,
                           addr: *const ::std::os::raw::c_void,
                           rowBytes: usize, ctable: *mut SkColorTable);
}
extern "C" {
    #[link_name =
          "?setColorSpace@SkPixmap@@QEAAXV?$sk_sp@VSkColorSpace@@@@@Z"]
    pub fn SkPixmap_setColorSpace(this: *mut SkPixmap,
                                  arg1: sk_sp<SkColorSpace>);
}
extern "C" {
    /**
     *  If supported, set this pixmap to point to the pixels in the specified mask and return true.
     *  On failure, return false and set this pixmap to empty.
     */
    #[link_name = "?reset@SkPixmap@@QEAA_NAEBUSkMask@@@Z"]
    pub fn SkPixmap_reset2(this: *mut SkPixmap, arg1: *const SkMask) -> bool;
}
extern "C" {
    /**
     *  Computes the intersection of area and this pixmap. If that intersection is non-empty,
     *  set subset to that intersection and return true.
     *
     *  On failure, return false and ignore the subset parameter.
     */
    #[link_name = "?extractSubset@SkPixmap@@QEBA_NPEAV1@AEBUSkIRect@@@Z"]
    pub fn SkPixmap_extractSubset(this: *const SkPixmap,
                                  subset: *mut SkPixmap, area: *const SkIRect)
     -> bool;
}
extern "C" {
    /**
     *  This will brute-force return true if all of the pixels in the pixmap
     *  are opaque. If there are no pixels, or encounters an error, returns false.
     */
    #[link_name = "?computeIsOpaque@SkPixmap@@QEBA_NXZ"]
    pub fn SkPixmap_computeIsOpaque(this: *const SkPixmap) -> bool;
}
extern "C" {
    /**
     *  Converts the pixel at the specified coordinate to an unpremultiplied
     *  SkColor. Note: this ignores any SkColorSpace information, and may return
     *  lower precision data than is actually in the pixel. Alpha only
     *  colortypes (e.g. kAlpha_8_SkColorType) return black with the appropriate
     *  alpha set.  The value is undefined for kUnknown_SkColorType or if x or y
     *  are out of bounds, or if the pixtap does not have any pixels.
     */
    #[link_name = "?getColor@SkPixmap@@QEBAIHH@Z"]
    pub fn SkPixmap_getColor(this: *const SkPixmap, x: ::std::os::raw::c_int,
                             y: ::std::os::raw::c_int) -> SkColor;
}
extern "C" {
    #[link_name = "?readPixels@SkPixmap@@QEBA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
    pub fn SkPixmap_readPixels(this: *const SkPixmap,
                               dstInfo: *const SkImageInfo,
                               dstPixels: *mut ::std::os::raw::c_void,
                               dstRowBytes: usize,
                               srcX: ::std::os::raw::c_int,
                               srcY: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
     *  Copy the pixels from this pixmap into the dst pixmap, converting as needed into dst's
     *  colortype/alphatype. If the conversion cannot be performed, false is returned.
     *
     *  If dst's dimensions differ from the src dimension, the image will be scaled, applying the
     *  specified filter-quality.
     */
    #[link_name = "?scalePixels@SkPixmap@@QEBA_NAEBV1@W4SkFilterQuality@@@Z"]
    pub fn SkPixmap_scalePixels(this: *const SkPixmap, dst: *const SkPixmap,
                                arg1: SkFilterQuality) -> bool;
}
extern "C" {
    /**
     *  Returns true if pixels were written to (e.g. if colorType is kUnknown_SkColorType, this
     *  will return false). If subset does not intersect the bounds of this pixmap, returns false.
     */
    #[link_name = "?erase@SkPixmap@@QEBA_NIAEBUSkIRect@@@Z"]
    pub fn SkPixmap_erase(this: *const SkPixmap, arg1: SkColor,
                          subset: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "?erase@SkPixmap@@QEBA_NAEBUSkColor4f@@PEBUSkIRect@@@Z"]
    pub fn SkPixmap_erase1(this: *const SkPixmap, arg1: *const SkColor4f,
                           subset: *const SkIRect) -> bool;
}
impl SkPixmap {
    #[inline]
    pub unsafe fn reset(&mut self) { SkPixmap_reset(&mut *self) }
    #[inline]
    pub unsafe fn reset1(&mut self, info: *const SkImageInfo,
                         addr: *const ::std::os::raw::c_void, rowBytes: usize,
                         ctable: *mut SkColorTable) {
        SkPixmap_reset1(&mut *self, info, addr, rowBytes, ctable)
    }
    #[inline]
    pub unsafe fn setColorSpace(&mut self, arg1: sk_sp<SkColorSpace>) {
        SkPixmap_setColorSpace(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn reset2(&mut self, arg1: *const SkMask) -> bool {
        SkPixmap_reset2(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn extractSubset(&self, subset: *mut SkPixmap,
                                area: *const SkIRect) -> bool {
        SkPixmap_extractSubset(&*self, subset, area)
    }
    #[inline]
    pub unsafe fn computeIsOpaque(&self) -> bool {
        SkPixmap_computeIsOpaque(&*self)
    }
    #[inline]
    pub unsafe fn getColor(&self, x: ::std::os::raw::c_int,
                           y: ::std::os::raw::c_int) -> SkColor {
        SkPixmap_getColor(&*self, x, y)
    }
    #[inline]
    pub unsafe fn readPixels(&self, dstInfo: *const SkImageInfo,
                             dstPixels: *mut ::std::os::raw::c_void,
                             dstRowBytes: usize, srcX: ::std::os::raw::c_int,
                             srcY: ::std::os::raw::c_int) -> bool {
        SkPixmap_readPixels(&*self, dstInfo, dstPixels, dstRowBytes, srcX,
                            srcY)
    }
    #[inline]
    pub unsafe fn scalePixels(&self, dst: *const SkPixmap,
                              arg1: SkFilterQuality) -> bool {
        SkPixmap_scalePixels(&*self, dst, arg1)
    }
    #[inline]
    pub unsafe fn erase(&self, arg1: SkColor, subset: *const SkIRect)
     -> bool {
        SkPixmap_erase(&*self, arg1, subset)
    }
    #[inline]
    pub unsafe fn erase1(&self, arg1: *const SkColor4f,
                         subset: *const SkIRect) -> bool {
        SkPixmap_erase1(&*self, arg1, subset)
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
#[repr(C)]
#[derive(Debug)]
pub struct SkAutoPixmapUnlock {
    pub fUnlockProc: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut ::std::os::raw::c_void)>,
    pub fUnlockContext: *mut ::std::os::raw::c_void,
    pub fPixmap: SkPixmap,
    pub fIsLocked: bool,
}
#[test]
fn bindgen_test_layout_SkAutoPixmapUnlock() {
    assert_eq!(::std::mem::size_of::<SkAutoPixmapUnlock>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkAutoPixmapUnlock>() , 1usize);
}
extern "C" {
    /**
     *  If there is a currently locked pixmap, unlock it, then copy the specified pixmap
     *  and (optional) unlock proc/context.
     */
    #[link_name =
          "?reset@SkAutoPixmapUnlock@@QEAAXAEBVSkPixmap@@P6AXPEAX@Z1@Z"]
    pub fn SkAutoPixmapUnlock_reset(this: *mut SkAutoPixmapUnlock,
                                    pm: *const SkPixmap,
                                    unlock:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *mut ::std::os::raw::c_void)>,
                                    ctx: *mut ::std::os::raw::c_void);
}
impl SkAutoPixmapUnlock {
    #[inline]
    pub unsafe fn reset(&mut self, pm: *const SkPixmap,
                        unlock:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::std::os::raw::c_void)>,
                        ctx: *mut ::std::os::raw::c_void) {
        SkAutoPixmapUnlock_reset(&mut *self, pm, unlock, ctx)
    }
}
/** \class SkPaint

    The SkPaint class holds the style and color information about how to draw
    geometries, text and bitmaps.
*/
#[repr(C)]
pub struct SkPaint {
    pub fTypeface: sk_sp<SkTypeface>,
    pub fPathEffect: sk_sp<SkPathEffect>,
    pub fShader: sk_sp<SkShader>,
    pub fMaskFilter: sk_sp<SkMaskFilter>,
    pub fColorFilter: sk_sp<SkColorFilter>,
    pub fRasterizer: sk_sp<SkRasterizer>,
    pub fDrawLooper: sk_sp<SkDrawLooper>,
    pub fImageFilter: sk_sp<SkImageFilter>,
    pub fTextSize: SkScalar,
    pub fTextScaleX: SkScalar,
    pub fTextSkewX: SkScalar,
    pub fColor: SkColor,
    pub fWidth: SkScalar,
    pub fMiterLimit: SkScalar,
    pub fBlendMode: u32,
    pub __bindgen_anon_1: SkPaint__bindgen_ty_3,
}
#[repr(i32)]
/** Specifies the level of hinting to be performed. These names are taken
        from the Gnome/Cairo names for the same. They are translated into
        Freetype concepts the same as in cairo-ft-font.c:
           kNo_Hinting     -> FT_LOAD_NO_HINTING
           kSlight_Hinting -> FT_LOAD_TARGET_LIGHT
           kNormal_Hinting -> <default, no option>
           kFull_Hinting   -> <same as kNormalHinting, unless we are rendering
                              subpixel glyphs, in which case TARGET_LCD or
                              TARGET_LCD_V is used>
    */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPaint_Hinting {
    kNo_Hinting = 0,
    kSlight_Hinting = 1,
    kNormal_Hinting = 2,
    kFull_Hinting = 3,
}
pub const SkPaint_Flags_kAntiAlias_Flag: SkPaint_Flags = SkPaint_Flags(1);
pub const SkPaint_Flags_kDither_Flag: SkPaint_Flags = SkPaint_Flags(4);
pub const SkPaint_Flags_kUnderlineText_Flag: SkPaint_Flags = SkPaint_Flags(8);
pub const SkPaint_Flags_kStrikeThruText_Flag: SkPaint_Flags =
    SkPaint_Flags(16);
pub const SkPaint_Flags_kFakeBoldText_Flag: SkPaint_Flags = SkPaint_Flags(32);
pub const SkPaint_Flags_kLinearText_Flag: SkPaint_Flags = SkPaint_Flags(64);
pub const SkPaint_Flags_kSubpixelText_Flag: SkPaint_Flags =
    SkPaint_Flags(128);
pub const SkPaint_Flags_kDevKernText_Flag: SkPaint_Flags = SkPaint_Flags(256);
pub const SkPaint_Flags_kLCDRenderText_Flag: SkPaint_Flags =
    SkPaint_Flags(512);
pub const SkPaint_Flags_kEmbeddedBitmapText_Flag: SkPaint_Flags =
    SkPaint_Flags(1024);
pub const SkPaint_Flags_kAutoHinting_Flag: SkPaint_Flags =
    SkPaint_Flags(2048);
pub const SkPaint_Flags_kVerticalText_Flag: SkPaint_Flags =
    SkPaint_Flags(4096);
pub const SkPaint_Flags_kGenA8FromLCD_Flag: SkPaint_Flags =
    SkPaint_Flags(8192);
pub const SkPaint_Flags_kAllFlags: SkPaint_Flags = SkPaint_Flags(65535);
impl ::std::ops::BitOr<SkPaint_Flags> for SkPaint_Flags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { SkPaint_Flags(self.0 | other.0) }
}
#[repr(C)]
/** Specifies the bit values that are stored in the paint's flags.
    */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkPaint_Flags(pub i32);
#[repr(i32)]
/** Styles apply to rect, oval, path, and text.
        Bitmaps are always drawn in "fill", and lines are always drawn in
        "stroke".

        Note: strokeandfill implicitly draws the result with
        SkPath::kWinding_FillType, so if the original path is even-odd, the
        results may not appear the same as if it was drawn twice, filled and
        then stroked.
    */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPaint_Style {
    kFill_Style = 0,
    kStroke_Style = 1,
    kStrokeAndFill_Style = 2,
}
pub const SkPaint_kStyleCount: SkPaint__bindgen_ty_1 =
    SkPaint__bindgen_ty_1::kStyleCount;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPaint__bindgen_ty_1 { kStyleCount = 3, }
pub const SkPaint_Cap_kLast_Cap: SkPaint_Cap = SkPaint_Cap::kSquare_Cap;
pub const SkPaint_Cap_kDefault_Cap: SkPaint_Cap = SkPaint_Cap::kButt_Cap;
#[repr(i32)]
/** Cap enum specifies the settings for the paint's strokecap. This is the
        treatment that is applied to the beginning and end of each non-closed
        contour (e.g. lines).

        If the cap is round or square, the caps are drawn when the contour has
        a zero length. Zero length contours can be created by following moveTo
        with a lineTo at the same point, or a moveTo followed by a close.

        A dash with an on interval of zero also creates a zero length contour.

        The zero length contour draws the square cap without rotation, since
        the no direction can be inferred.
    */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPaint_Cap { kButt_Cap = 0, kRound_Cap = 1, kSquare_Cap = 2, }
pub const SkPaint_Join_kLast_Join: SkPaint_Join = SkPaint_Join::kBevel_Join;
pub const SkPaint_Join_kDefault_Join: SkPaint_Join =
    SkPaint_Join::kMiter_Join;
#[repr(i32)]
/** Join enum specifies the settings for the paint's strokejoin. This is
        the treatment that is applied to corners in paths and rectangles.
    */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPaint_Join { kMiter_Join = 0, kRound_Join = 1, kBevel_Join = 2, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPaint_Align {
    kLeft_Align = 0,
    kCenter_Align = 1,
    kRight_Align = 2,
}
pub const SkPaint_kAlignCount: SkPaint__bindgen_ty_2 =
    SkPaint__bindgen_ty_2::kAlignCount;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPaint__bindgen_ty_2 { kAlignCount = 3, }
#[repr(i32)]
/** Describes how to interpret the text parameters that are passed to paint
        methods like measureText() and getTextWidths().
    */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPaint_TextEncoding {
    kUTF8_TextEncoding = 0,
    kUTF16_TextEncoding = 1,
    kUTF32_TextEncoding = 2,
    kGlyphID_TextEncoding = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPaint_FontMetrics {
    //< Bit field to identify which values are unknown
    pub fFlags: u32,
    //< The greatest distance above the baseline for any glyph (will be <= 0)
    pub fTop: SkScalar,
    //< The recommended distance above the baseline (will be <= 0)
    pub fAscent: SkScalar,
    //< The recommended distance below the baseline (will be >= 0)
    pub fDescent: SkScalar,
    //< The greatest distance below the baseline for any glyph (will be >= 0)
    pub fBottom: SkScalar,
    //< The recommended distance to add between lines of text (will be >= 0)
    pub fLeading: SkScalar,
    //< the average character width (>= 0)
    pub fAvgCharWidth: SkScalar,
    //< the max character width (>= 0)
    pub fMaxCharWidth: SkScalar,
    //< The minimum bounding box x value for all glyphs
    pub fXMin: SkScalar,
    //< The maximum bounding box x value for all glyphs
    pub fXMax: SkScalar,
    //< The height of an 'x' in px, or 0 if no 'x' in face
    pub fXHeight: SkScalar,
    //< The cap height (> 0), or 0 if cannot be determined.
    pub fCapHeight: SkScalar,
    //< underline thickness, or 0 if cannot be determined
    pub fUnderlineThickness: SkScalar,
    //< underline position, or 0 if cannot be determined
    pub fUnderlinePosition: SkScalar,
}
pub const SkPaint_FontMetrics_FontMetricsFlags_kUnderlineThinknessIsValid_Flag:
          SkPaint_FontMetrics_FontMetricsFlags =
    SkPaint_FontMetrics_FontMetricsFlags(1);
pub const SkPaint_FontMetrics_FontMetricsFlags_kUnderlinePositionIsValid_Flag:
          SkPaint_FontMetrics_FontMetricsFlags =
    SkPaint_FontMetrics_FontMetricsFlags(2);
impl ::std::ops::BitOr<SkPaint_FontMetrics_FontMetricsFlags> for
 SkPaint_FontMetrics_FontMetricsFlags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkPaint_FontMetrics_FontMetricsFlags(self.0 | other.0)
    }
}
#[repr(C)]
/** Flags which indicate the confidence level of various metrics.
            A set flag indicates that the metric may be trusted.
        */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkPaint_FontMetrics_FontMetricsFlags(pub i32);
#[test]
fn bindgen_test_layout_SkPaint_FontMetrics() {
    assert_eq!(::std::mem::size_of::<SkPaint_FontMetrics>() , 56usize);
    assert_eq!(::std::mem::align_of::<SkPaint_FontMetrics>() , 4usize);
}
impl Clone for SkPaint_FontMetrics {
    fn clone(&self) -> Self { *self }
}
pub type SkPaint_GlyphCacheProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SkGlyphCache,
                                               arg2:
                                                   *mut *const ::std::os::raw::c_char)
                              -> *const SkGlyph>;
#[repr(C)]
#[derive(Copy)]
pub union SkPaint__bindgen_ty_3 {
    pub fBitfields: SkPaint__bindgen_ty_3__bindgen_ty_1,
    pub fBitfieldsUInt: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPaint__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_SkPaint__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<SkPaint__bindgen_ty_3__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<SkPaint__bindgen_ty_3__bindgen_ty_1>() ,
               4usize);
}
impl Clone for SkPaint__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl SkPaint__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn fFlags(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65535usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_fFlags(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(65535usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (65535usize as u32);
    }
    #[inline]
    pub fn fTextAlign(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (196608usize as u32))
                                       >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_fTextAlign(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(196608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (196608usize as u32);
    }
    #[inline]
    pub fn fCapType(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (786432usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_fCapType(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(786432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (786432usize as u32);
    }
    #[inline]
    pub fn fJoinType(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3145728usize as u32))
                                       >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_fJoinType(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3145728usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (3145728usize as u32);
    }
    #[inline]
    pub fn fStyle(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12582912usize as u32))
                                       >> 22u32) as u32)
        }
    }
    #[inline]
    pub fn set_fStyle(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12582912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (12582912usize as u32);
    }
    #[inline]
    pub fn fTextEncoding(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (50331648usize as u32))
                                       >> 24u32) as u32)
        }
    }
    #[inline]
    pub fn set_fTextEncoding(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(50331648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (50331648usize as u32);
    }
    #[inline]
    pub fn fHinting(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (201326592usize as u32)) >> 26u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_fHinting(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(201326592usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (201326592usize as u32);
    }
    #[inline]
    pub fn fFilterQuality(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (805306368usize as u32)) >> 28u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_fFilterQuality(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(805306368usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 28u32) & (805306368usize as u32);
    }
}
#[test]
fn bindgen_test_layout_SkPaint__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<SkPaint__bindgen_ty_3>() , 4usize);
    assert_eq!(::std::mem::align_of::<SkPaint__bindgen_ty_3>() , 4usize);
}
impl Clone for SkPaint__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
pub const SkPaint_ScalerContextFlags_kNone_ScalerContextFlags:
          SkPaint_ScalerContextFlags =
    SkPaint_ScalerContextFlags(0);
pub const SkPaint_ScalerContextFlags_kFakeGamma_ScalerContextFlag:
          SkPaint_ScalerContextFlags =
    SkPaint_ScalerContextFlags(1);
pub const SkPaint_ScalerContextFlags_kBoostContrast_ScalerContextFlag:
          SkPaint_ScalerContextFlags =
    SkPaint_ScalerContextFlags(2);
pub const SkPaint_ScalerContextFlags_kFakeGammaAndBoostContrast_ScalerContextFlags:
          SkPaint_ScalerContextFlags =
    SkPaint_ScalerContextFlags(3);
impl ::std::ops::BitOr<SkPaint_ScalerContextFlags> for
 SkPaint_ScalerContextFlags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkPaint_ScalerContextFlags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkPaint_ScalerContextFlags(pub u32);
pub const SkPaint_kCanonicalTextSizeForPaths: SkPaint__bindgen_ty_4 =
    SkPaint__bindgen_ty_4::kCanonicalTextSizeForPaths;
pub const SkPaint_kMaxSizeForGlyphCache: SkPaint__bindgen_ty_4 =
    SkPaint__bindgen_ty_4::kMaxSizeForGlyphCache;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPaint__bindgen_ty_4 {
    kCanonicalTextSizeForPaths = 64,
    kMaxSizeForGlyphCache = 256,
}
pub const SkPaint_kCapCount: ::std::os::raw::c_int = 3;
pub const SkPaint_kJoinCount: ::std::os::raw::c_int = 3;
#[test]
fn bindgen_test_layout_SkPaint() {
    assert_eq!(::std::mem::size_of::<SkPaint>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPaint>() , 1usize);
}
extern "C" {
    /** getHash() is a shallow hash, with the same limitations as operator==.
     *  If operator== returns true for two paints, getHash() returns the same value for each.
     */
    #[link_name = "?getHash@SkPaint@@QEBAIXZ"]
    pub fn SkPaint_getHash(this: *const SkPaint) -> u32;
}
extern "C" {
    #[link_name = "?flatten@SkPaint@@QEBAXAEAVSkWriteBuffer@@@Z"]
    pub fn SkPaint_flatten(this: *const SkPaint, arg1: *mut SkWriteBuffer);
}
extern "C" {
    #[link_name = "?unflatten@SkPaint@@QEAAXAEAVSkReadBuffer@@@Z"]
    pub fn SkPaint_unflatten(this: *mut SkPaint, arg1: *mut SkReadBuffer);
}
extern "C" {
    /** Restores the paint to its initial settings.
    */
    #[link_name = "?reset@SkPaint@@QEAAXXZ"]
    pub fn SkPaint_reset(this: *mut SkPaint);
}
extern "C" {
    #[link_name = "?setHinting@SkPaint@@QEAAXW4Hinting@1@@Z"]
    pub fn SkPaint_setHinting(this: *mut SkPaint,
                              hintingLevel: SkPaint_Hinting);
}
extern "C" {
    /** Set the paint's flags. Use the Flag enum to specific flag values.
        @param flags    The new flag bits for the paint (see Flags enum)
    */
    #[link_name = "?setFlags@SkPaint@@QEAAXI@Z"]
    pub fn SkPaint_setFlags(this: *mut SkPaint, flags: u32);
}
extern "C" {
    /** Helper for setFlags(), setting or clearing the kAntiAlias_Flag bit
        @param aa   true to enable antialiasing, false to disable it
        */
    #[link_name = "?setAntiAlias@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setAntiAlias(this: *mut SkPaint, aa: bool);
}
extern "C" {
    /** Helper for setFlags(), setting or clearing the kDither_Flag bit
        @param dither   true to enable dithering, false to disable it
        */
    #[link_name = "?setDither@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setDither(this: *mut SkPaint, dither: bool);
}
extern "C" {
    /** Helper for setFlags(), setting or clearing the kLinearText_Flag bit
        @param linearText true to set the linearText bit in the paint's flags,
                          false to clear it.
    */
    #[link_name = "?setLinearText@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setLinearText(this: *mut SkPaint, linearText: bool);
}
extern "C" {
    /**
     *  Helper for setFlags(), setting or clearing the kSubpixelText_Flag.
     *  @param subpixelText true to set the subpixelText bit in the paint's
     *                      flags, false to clear it.
     */
    #[link_name = "?setSubpixelText@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setSubpixelText(this: *mut SkPaint, subpixelText: bool);
}
extern "C" {
    /**
     *  Helper for setFlags(), setting or clearing the kLCDRenderText_Flag.
     *  Note: antialiasing must also be on for lcd rendering
     *  @param lcdText true to set the LCDRenderText bit in the paint's flags,
     *                 false to clear it.
     */
    #[link_name = "?setLCDRenderText@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setLCDRenderText(this: *mut SkPaint, lcdText: bool);
}
extern "C" {
    /** Helper for setFlags(), setting or clearing the kEmbeddedBitmapText_Flag bit
        @param useEmbeddedBitmapText true to set the kEmbeddedBitmapText bit in the paint's flags,
                                     false to clear it.
    */
    #[link_name = "?setEmbeddedBitmapText@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setEmbeddedBitmapText(this: *mut SkPaint,
                                         useEmbeddedBitmapText: bool);
}
extern "C" {
    /** Helper for setFlags(), setting or clearing the kAutoHinting_Flag bit
        @param useAutohinter true to set the kEmbeddedBitmapText bit in the
                                  paint's flags,
                             false to clear it.
    */
    #[link_name = "?setAutohinted@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setAutohinted(this: *mut SkPaint, useAutohinter: bool);
}
extern "C" {
    /**
     *  Helper for setting or clearing the kVerticalText_Flag bit in
     *  setFlags(...).
     *
     *  If this bit is set, then advances are treated as Y values rather than
     *  X values, and drawText will places its glyphs vertically rather than
     *  horizontally.
     */
    #[link_name = "?setVerticalText@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setVerticalText(this: *mut SkPaint, arg1: bool);
}
extern "C" {
    /** Helper for setFlags(), setting or clearing the kUnderlineText_Flag bit
        @param underlineText true to set the underlineText bit in the paint's
                             flags, false to clear it.
    */
    #[link_name = "?setUnderlineText@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setUnderlineText(this: *mut SkPaint, underlineText: bool);
}
extern "C" {
    /** Helper for setFlags(), setting or clearing the kStrikeThruText_Flag bit
        @param strikeThruText   true to set the strikeThruText bit in the
                                paint's flags, false to clear it.
    */
    #[link_name = "?setStrikeThruText@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setStrikeThruText(this: *mut SkPaint,
                                     strikeThruText: bool);
}
extern "C" {
    /** Helper for setFlags(), setting or clearing the kFakeBoldText_Flag bit
        @param fakeBoldText true to set the kFakeBoldText_Flag bit in the paint's
                            flags, false to clear it.
    */
    #[link_name = "?setFakeBoldText@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setFakeBoldText(this: *mut SkPaint, fakeBoldText: bool);
}
extern "C" {
    /** Helper for setFlags(), setting or clearing the kKernText_Flag bit
        @param kernText true to set the kKernText_Flag bit in the paint's
                            flags, false to clear it.
    */
    #[link_name = "?setDevKernText@SkPaint@@QEAAX_N@Z"]
    pub fn SkPaint_setDevKernText(this: *mut SkPaint, devKernText: bool);
}
extern "C" {
    /**
     *  Set the filter quality. This affects the quality (and performance) of
     *  drawing scaled images.
     */
    #[link_name = "?setFilterQuality@SkPaint@@QEAAXW4SkFilterQuality@@@Z"]
    pub fn SkPaint_setFilterQuality(this: *mut SkPaint,
                                    quality: SkFilterQuality);
}
extern "C" {
    /** Set the paint's style, used for controlling how primitives'
        geometries are interpreted (except for drawBitmap, which always assumes
        Fill).
        @param style    The new style to set in the paint
    */
    #[link_name = "?setStyle@SkPaint@@QEAAXW4Style@1@@Z"]
    pub fn SkPaint_setStyle(this: *mut SkPaint, style: SkPaint_Style);
}
extern "C" {
    /** Set the paint's color. Note that the color is a 32bit value containing
        alpha as well as r,g,b. This 32bit value is not premultiplied, meaning
        that its alpha can be any value, regardless of the values of r,g,b.
        @param color    The new color (including alpha) to set in the paint.
    */
    #[link_name = "?setColor@SkPaint@@QEAAXI@Z"]
    pub fn SkPaint_setColor(this: *mut SkPaint, color: SkColor);
}
extern "C" {
    /** Helper to setColor(), that only assigns the color's alpha value,
        leaving its r,g,b values unchanged.
        @param a    set the alpha component (0..255) of the paint's color.
    */
    #[link_name = "?setAlpha@SkPaint@@QEAAXI@Z"]
    pub fn SkPaint_setAlpha(this: *mut SkPaint, a: U8CPU);
}
extern "C" {
    /** Helper to setColor(), that takes a,r,g,b and constructs the color value
        using SkColorSetARGB()
        @param a    The new alpha component (0..255) of the paint's color.
        @param r    The new red component (0..255) of the paint's color.
        @param g    The new green component (0..255) of the paint's color.
        @param b    The new blue component (0..255) of the paint's color.
    */
    #[link_name = "?setARGB@SkPaint@@QEAAXIIII@Z"]
    pub fn SkPaint_setARGB(this: *mut SkPaint, a: U8CPU, r: U8CPU, g: U8CPU,
                           b: U8CPU);
}
extern "C" {
    /** Set the width for stroking.
        Pass 0 to stroke in hairline mode.
        Hairlines always draw 1-pixel wide, regardless of the matrix.
        @param width set the paint's stroke width, used whenever the paint's
                     style is Stroke or StrokeAndFill.
    */
    #[link_name = "?setStrokeWidth@SkPaint@@QEAAXM@Z"]
    pub fn SkPaint_setStrokeWidth(this: *mut SkPaint, width: SkScalar);
}
extern "C" {
    /** Set the paint's stroke miter value. This is used to control the
        behavior of miter joins when the joins angle is sharp. This value must
        be >= 0.
        @param miter    set the miter limit on the paint, used whenever the
                        paint's style is Stroke or StrokeAndFill.
    */
    #[link_name = "?setStrokeMiter@SkPaint@@QEAAXM@Z"]
    pub fn SkPaint_setStrokeMiter(this: *mut SkPaint, miter: SkScalar);
}
extern "C" {
    /** Set the paint's stroke cap type.
        @param cap  set the paint's line cap style, used whenever the paint's
                    style is Stroke or StrokeAndFill.
    */
    #[link_name = "?setStrokeCap@SkPaint@@QEAAXW4Cap@1@@Z"]
    pub fn SkPaint_setStrokeCap(this: *mut SkPaint, cap: SkPaint_Cap);
}
extern "C" {
    /** Set the paint's stroke join type.
        @param join set the paint's line join style, used whenever the paint's
                    style is Stroke or StrokeAndFill.
    */
    #[link_name = "?setStrokeJoin@SkPaint@@QEAAXW4Join@1@@Z"]
    pub fn SkPaint_setStrokeJoin(this: *mut SkPaint, join: SkPaint_Join);
}
extern "C" {
    /**
     *  Applies any/all effects (patheffect, stroking) to src, returning the
     *  result in dst. The result is that drawing src with this paint will be
     *  the same as drawing dst with a default paint (at least from the
     *  geometric perspective).
     *
     *  @param src  input path
     *  @param dst  output path (may be the same as src)
     *  @param cullRect If not null, the dst path may be culled to this rect.
     *  @param resScale If > 1, increase precision, else if (0 < res < 1) reduce precision
     *              in favor of speed/size.
     *  @return     true if the path should be filled, or false if it should be
     *              drawn with a hairline (width == 0)
     */
    #[link_name =
          "?getFillPath@SkPaint@@QEBA_NAEBVSkPath@@PEAV2@PEBUSkRect@@M@Z"]
    pub fn SkPaint_getFillPath(this: *const SkPaint, src: *const SkPath,
                               dst: *mut SkPath, cullRect: *const SkRect,
                               resScale: SkScalar) -> bool;
}
extern "C" {
    /** Set or clear the shader object.
     *  Shaders specify the source color(s) for what is being drawn. If a paint
     *  has no shader, then the paint's color is used. If the paint has a
     *  shader, then the shader's color(s) are use instead, but they are
     *  modulated by the paint's alpha. This makes it easy to create a shader
     *  once (e.g. bitmap tiling or gradient) and then change its transparency
     *  w/o having to modify the original shader... only the paint's alpha needs
     *  to be modified.
     *
     *  There is an exception to this only-respect-paint's-alpha rule: If the shader only generates
     *  alpha (e.g. SkShader::CreateBitmapShader(bitmap) where bitmap's colortype is kAlpha_8)
     *  then the shader will use the paint's entire color to "colorize" its output (modulating the
     *  bitmap's alpha with the paint's color+alpha).
     *
     *  Pass NULL to clear any previous shader.
     *  As a convenience, the parameter passed is also returned.
     *  If a previous shader exists, its reference count is decremented.
     *  If shader is not NULL, its reference count is incremented.
     *  @param shader   May be NULL. The shader to be installed in the paint
     */
    #[link_name = "?setShader@SkPaint@@QEAAXV?$sk_sp@VSkShader@@@@@Z"]
    pub fn SkPaint_setShader(this: *mut SkPaint, arg1: sk_sp<SkShader>);
}
extern "C" {
    /** Set or clear the paint's colorfilter.
        <p />
        If the paint already has a filter, its reference count is decremented.
        If filter is not NULL, its reference count is incremented.
        @param filter   May be NULL. The filter to be installed in the paint
    */
    #[link_name =
          "?setColorFilter@SkPaint@@QEAAXV?$sk_sp@VSkColorFilter@@@@@Z"]
    pub fn SkPaint_setColorFilter(this: *mut SkPaint,
                                  arg1: sk_sp<SkColorFilter>);
}
extern "C" {
    /** Set or clear the patheffect object.
        <p />
        Pass NULL to clear any previous patheffect.
        As a convenience, the parameter passed is also returned.
        If a previous patheffect exists, its reference count is decremented.
        If patheffect is not NULL, its reference count is incremented.
        @param effect   May be NULL. The new patheffect to be installed in the
                        paint
        @return         effect
    */
    #[link_name = "?setPathEffect@SkPaint@@QEAAXV?$sk_sp@VSkPathEffect@@@@@Z"]
    pub fn SkPaint_setPathEffect(this: *mut SkPaint,
                                 arg1: sk_sp<SkPathEffect>);
}
extern "C" {
    /** Set or clear the maskfilter object.
        <p />
        Pass NULL to clear any previous maskfilter.
        As a convenience, the parameter passed is also returned.
        If a previous maskfilter exists, its reference count is decremented.
        If maskfilter is not NULL, its reference count is incremented.
        @param maskfilter   May be NULL. The new maskfilter to be installed in
                            the paint
        @return             maskfilter
    */
    #[link_name = "?setMaskFilter@SkPaint@@QEAAXV?$sk_sp@VSkMaskFilter@@@@@Z"]
    pub fn SkPaint_setMaskFilter(this: *mut SkPaint,
                                 arg1: sk_sp<SkMaskFilter>);
}
extern "C" {
    /** Set or clear the typeface object.
        <p />
        Pass NULL to clear any previous typeface.
        As a convenience, the parameter passed is also returned.
        If a previous typeface exists, its reference count is decremented.
        If typeface is not NULL, its reference count is incremented.
        @param typeface May be NULL. The new typeface to be installed in the
                        paint
        @return         typeface
    */
    #[link_name = "?setTypeface@SkPaint@@QEAAXV?$sk_sp@VSkTypeface@@@@@Z"]
    pub fn SkPaint_setTypeface(this: *mut SkPaint, arg1: sk_sp<SkTypeface>);
}
extern "C" {
    /** Set or clear the rasterizer object.
        <p />
        Pass NULL to clear any previous rasterizer.
        As a convenience, the parameter passed is also returned.
        If a previous rasterizer exists in the paint, its reference count is
        decremented. If rasterizer is not NULL, its reference count is
        incremented.
        @param rasterizer May be NULL. The new rasterizer to be installed in
                          the paint.
        @return           rasterizer
    */
    #[link_name = "?setRasterizer@SkPaint@@QEAAXV?$sk_sp@VSkRasterizer@@@@@Z"]
    pub fn SkPaint_setRasterizer(this: *mut SkPaint,
                                 arg1: sk_sp<SkRasterizer>);
}
extern "C" {
    #[link_name =
          "?setImageFilter@SkPaint@@QEAAXV?$sk_sp@VSkImageFilter@@@@@Z"]
    pub fn SkPaint_setImageFilter(this: *mut SkPaint,
                                  arg1: sk_sp<SkImageFilter>);
}
extern "C" {
    /**
     *  Set or clear the looper object.
     *  <p />
     *  Pass NULL to clear any previous looper.
     *  If a previous looper exists in the paint, its reference count is
     *  decremented. If looper is not NULL, its reference count is
     *  incremented.
     *  @param looper May be NULL. The new looper to be installed in the paint.
     */
    #[link_name = "?setDrawLooper@SkPaint@@QEAAXV?$sk_sp@VSkDrawLooper@@@@@Z"]
    pub fn SkPaint_setDrawLooper(this: *mut SkPaint,
                                 arg1: sk_sp<SkDrawLooper>);
}
extern "C" {
    #[link_name = "?setLooper@SkPaint@@QEAAXV?$sk_sp@VSkDrawLooper@@@@@Z"]
    pub fn SkPaint_setLooper(this: *mut SkPaint, arg1: sk_sp<SkDrawLooper>);
}
extern "C" {
    /** Set the paint's text alignment.
        @param align set the paint's Align value for drawing text.
    */
    #[link_name = "?setTextAlign@SkPaint@@QEAAXW4Align@1@@Z"]
    pub fn SkPaint_setTextAlign(this: *mut SkPaint, align: SkPaint_Align);
}
extern "C" {
    /** Set the paint's text size. This value must be > 0
        @param textSize set the paint's text size.
    */
    #[link_name = "?setTextSize@SkPaint@@QEAAXM@Z"]
    pub fn SkPaint_setTextSize(this: *mut SkPaint, textSize: SkScalar);
}
extern "C" {
    /** Set the paint's horizontal scale factor for text. The default value
        is 1.0. Values > 1.0 will stretch the text wider. Values < 1.0 will
        stretch the text narrower.
        @param scaleX   set the paint's scale factor in X for drawing/measuring
                        text.
    */
    #[link_name = "?setTextScaleX@SkPaint@@QEAAXM@Z"]
    pub fn SkPaint_setTextScaleX(this: *mut SkPaint, scaleX: SkScalar);
}
extern "C" {
    /** Set the paint's horizontal skew factor for text. The default value
        is 0. For approximating oblique text, use values around -0.25.
        @param skewX set the paint's skew factor in X for drawing text.
    */
    #[link_name = "?setTextSkewX@SkPaint@@QEAAXM@Z"]
    pub fn SkPaint_setTextSkewX(this: *mut SkPaint, skewX: SkScalar);
}
extern "C" {
    #[link_name = "?setTextEncoding@SkPaint@@QEAAXW4TextEncoding@1@@Z"]
    pub fn SkPaint_setTextEncoding(this: *mut SkPaint,
                                   encoding: SkPaint_TextEncoding);
}
extern "C" {
    /** Return the recommend spacing between lines (which will be
        fDescent - fAscent + fLeading).
        If metrics is not null, return in it the font metrics for the
        typeface/pointsize/etc. currently set in the paint.
        @param metrics      If not null, returns the font metrics for the
                            current typeface/pointsize/etc setting in this
                            paint.
        @param scale        If not 0, return width as if the canvas were scaled
                            by this value
        @param return the recommended spacing between lines
    */
    #[link_name = "?getFontMetrics@SkPaint@@QEBAMPEAUFontMetrics@1@M@Z"]
    pub fn SkPaint_getFontMetrics(this: *const SkPaint,
                                  metrics: *mut SkPaint_FontMetrics,
                                  scale: SkScalar) -> SkScalar;
}
extern "C" {
    /** Convert the specified text into glyph IDs, returning the number of
        glyphs ID written. If glyphs is NULL, it is ignore and only the count
        is returned.
    */
    #[link_name = "?textToGlyphs@SkPaint@@QEBAHPEBX_KQEAG@Z"]
    pub fn SkPaint_textToGlyphs(this: *const SkPaint,
                                text: *const ::std::os::raw::c_void,
                                byteLength: usize, glyphs: *mut SkGlyphID)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Return true if all of the specified text has a corresponding non-zero
        glyph ID. If any of the code-points in the text are not supported in
        the typeface (i.e. the glyph ID would be zero), then return false.

        If the text encoding for the paint is kGlyph_TextEncoding, then this
        returns true if all of the specified glyph IDs are non-zero.
     */
    #[link_name = "?containsText@SkPaint@@QEBA_NPEBX_K@Z"]
    pub fn SkPaint_containsText(this: *const SkPaint,
                                text: *const ::std::os::raw::c_void,
                                byteLength: usize) -> bool;
}
extern "C" {
    /** Convert the glyph array into Unichars. Unconvertable glyphs are mapped
        to zero. Note: this does not look at the text-encoding setting in the
        paint, only at the typeface.
    */
    #[link_name = "?glyphsToUnichars@SkPaint@@QEBAXQEBGHQEAH@Z"]
    pub fn SkPaint_glyphsToUnichars(this: *const SkPaint,
                                    glyphs: *const SkGlyphID,
                                    count: ::std::os::raw::c_int,
                                    text: *mut SkUnichar);
}
extern "C" {
    /** Return the width of the text. This will return the vertical measure
     *  if isVerticalText() is true, in which case the returned value should
     *  be treated has a height instead of a width.
     *
     *  @param text         The text to be measured
     *  @param length       Number of bytes of text to measure
     *  @param bounds       If not NULL, returns the bounds of the text,
     *                      relative to (0, 0).
     *  @return             The advance width of the text
     */
    #[link_name = "?measureText@SkPaint@@QEBAMPEBX_KPEAUSkRect@@@Z"]
    pub fn SkPaint_measureText(this: *const SkPaint,
                               text: *const ::std::os::raw::c_void,
                               length: usize, bounds: *mut SkRect)
     -> SkScalar;
}
extern "C" {
    /** Return the number of bytes of text that were measured. If
     *  isVerticalText() is true, then the vertical advances are used for
     *  the measurement.
     *
     *  @param text     The text to be measured
     *  @param length   Number of bytes of text to measure
     *  @param maxWidth Maximum width. Only the subset of text whose accumulated
     *                  widths are <= maxWidth are measured.
     *  @param measuredWidth Optional. If non-null, this returns the actual
     *                  width of the measured text.
     *  @return         The number of bytes of text that were measured. Will be
     *                  <= length.
     */
    #[link_name = "?breakText@SkPaint@@QEBA_KPEBX_KMPEAM@Z"]
    pub fn SkPaint_breakText(this: *const SkPaint,
                             text: *const ::std::os::raw::c_void,
                             length: usize, maxWidth: SkScalar,
                             measuredWidth: *mut SkScalar) -> usize;
}
extern "C" {
    /** Return the advances for the text. These will be vertical advances if
     *  isVerticalText() returns true.
     *
     *  @param text         the text
     *  @param byteLength   number of bytes to of text
     *  @param widths       If not null, returns the array of advances for
     *                      the glyphs. If not NULL, must be at least a large
     *                      as the number of unichars in the specified text.
     *  @param bounds       If not null, returns the bounds for each of
     *                      character, relative to (0, 0)
     *  @return the number of unichars in the specified text.
     */
    #[link_name = "?getTextWidths@SkPaint@@QEBAHPEBX_KQEAMQEAUSkRect@@@Z"]
    pub fn SkPaint_getTextWidths(this: *const SkPaint,
                                 text: *const ::std::os::raw::c_void,
                                 byteLength: usize, widths: *mut SkScalar,
                                 bounds: *mut SkRect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Return the path (outline) for the specified text.
     *  Note: just like SkCanvas::drawText, this will respect the Align setting
     *        in the paint.
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param x            The x-coordinate of the origin of the text.
     *  @param y            The y-coordinate of the origin of the text.
     *  @param path         The outline of the text.
     */
    #[link_name = "?getTextPath@SkPaint@@QEBAXPEBX_KMMPEAVSkPath@@@Z"]
    pub fn SkPaint_getTextPath(this: *const SkPaint,
                               text: *const ::std::os::raw::c_void,
                               length: usize, x: SkScalar, y: SkScalar,
                               path: *mut SkPath);
}
extern "C" {
    /** Return the path (outline) for the specified text.
     *  Note: just like SkCanvas::drawText, this will respect the Align setting
     *        in the paint.
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param pos          array of positions, used to position each character
     *  @param path         The outline of the text.
     */
    #[link_name =
          "?getPosTextPath@SkPaint@@QEBAXPEBX_KQEBUSkPoint@@PEAVSkPath@@@Z"]
    pub fn SkPaint_getPosTextPath(this: *const SkPaint,
                                  text: *const ::std::os::raw::c_void,
                                  length: usize, pos: *const SkPoint,
                                  path: *mut SkPath);
}
extern "C" {
    /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  the string. The caller may pass nullptr for intervals to determine the size of the interval
     *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
     *  intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders. 
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param x            The x-coordinate of the origin of the text.
     *  @param y            The y-coordinate of the origin of the text.
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the found intersections.
     *
     *  @return             The number of intersections, which may be zero.
     */
    #[link_name = "?getTextIntercepts@SkPaint@@QEBAHPEBX_KMMQEBMPEAM@Z"]
    pub fn SkPaint_getTextIntercepts(this: *const SkPaint,
                                     text: *const ::std::os::raw::c_void,
                                     length: usize, x: SkScalar, y: SkScalar,
                                     bounds: *mut SkScalar,
                                     intervals: *mut SkScalar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  string. The caller may pass nullptr for intervals to determine the size of the interval
     *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
     *  intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders. 
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param pos          array of positions, used to position each character
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
     *
     *  @return             The number of intersections, which may be zero.
     */
    #[link_name =
          "?getPosTextIntercepts@SkPaint@@QEBAHPEBX_KQEBUSkPoint@@QEBMPEAM@Z"]
    pub fn SkPaint_getPosTextIntercepts(this: *const SkPaint,
                                        text: *const ::std::os::raw::c_void,
                                        length: usize, pos: *const SkPoint,
                                        bounds: *mut SkScalar,
                                        intervals: *mut SkScalar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  string. The caller may pass nullptr for intervals to determine the size of the interval
     *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
     *  intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders.
     *
     *  @param text         The text.
     *  @param length       Number of bytes of text.
     *  @param xpos         Array of x-positions, used to position each character.
     *  @param constY       The shared Y coordinate for all of the positions.
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
     *
     *  @return             The number of intersections, which may be zero.
     */
    #[link_name = "?getPosTextHIntercepts@SkPaint@@QEBAHPEBX_KQEBMM2PEAM@Z"]
    pub fn SkPaint_getPosTextHIntercepts(this: *const SkPaint,
                                         text: *const ::std::os::raw::c_void,
                                         length: usize, xpos: *const SkScalar,
                                         constY: SkScalar,
                                         bounds: *mut SkScalar,
                                         intervals: *mut SkScalar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  text blob. The caller may pass nullptr for intervals to determine the size of the interval
     *  array. The computed intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders.
     *
     *  @param blob         The text blob.
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
     *
     *  @return             The number of intersections, which may be zero.
     */
    #[link_name =
          "?getTextBlobIntercepts@SkPaint@@QEBAHPEBVSkTextBlob@@QEBMPEAM@Z"]
    pub fn SkPaint_getTextBlobIntercepts(this: *const SkPaint,
                                         blob: *const SkTextBlob,
                                         bounds: *mut SkScalar,
                                         intervals: *mut SkScalar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
     *  Return a rectangle that represents the union of the bounds of all
     *  of the glyphs, but each one positioned at (0,0). This may be conservatively large, and
     *  will not take into account any hinting, but will respect any text-scale-x or text-skew-x
     *  on this paint.
     */
    #[link_name = "?getFontBounds@SkPaint@@QEBA?AUSkRect@@XZ"]
    pub fn SkPaint_getFontBounds(this: *const SkPaint) -> SkRect;
}
extern "C" {
    #[link_name = "?nothingToDraw@SkPaint@@QEBA_NXZ"]
    pub fn SkPaint_nothingToDraw(this: *const SkPaint) -> bool;
}
extern "C" {
    /** Returns true if the current paint settings allow for fast computation of
     bounds (i.e. there is nothing complex like a patheffect that would make
     the bounds computation expensive.
     */
    #[link_name = "?canComputeFastBounds@SkPaint@@QEBA_NXZ"]
    pub fn SkPaint_canComputeFastBounds(this: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name =
          "?doComputeFastBounds@SkPaint@@QEBAAEBUSkRect@@AEBU2@PEAU2@W4Style@1@@Z"]
    pub fn SkPaint_doComputeFastBounds(this: *const SkPaint,
                                       orig: *const SkRect,
                                       storage: *mut SkRect,
                                       arg1: SkPaint_Style) -> *const SkRect;
}
extern "C" {
    #[link_name = "?toString@SkPaint@@QEBAXPEAVSkString@@@Z"]
    pub fn SkPaint_toString(this: *const SkPaint, str: *mut SkString);
}
impl SkPaint {
    #[inline]
    pub unsafe fn getHash(&self) -> u32 { SkPaint_getHash(&*self) }
    #[inline]
    pub unsafe fn flatten(&self, arg1: *mut SkWriteBuffer) {
        SkPaint_flatten(&*self, arg1)
    }
    #[inline]
    pub unsafe fn unflatten(&mut self, arg1: *mut SkReadBuffer) {
        SkPaint_unflatten(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn reset(&mut self) { SkPaint_reset(&mut *self) }
    #[inline]
    pub unsafe fn setHinting(&mut self, hintingLevel: SkPaint_Hinting) {
        SkPaint_setHinting(&mut *self, hintingLevel)
    }
    #[inline]
    pub unsafe fn setFlags(&mut self, flags: u32) {
        SkPaint_setFlags(&mut *self, flags)
    }
    #[inline]
    pub unsafe fn setAntiAlias(&mut self, aa: bool) {
        SkPaint_setAntiAlias(&mut *self, aa)
    }
    #[inline]
    pub unsafe fn setDither(&mut self, dither: bool) {
        SkPaint_setDither(&mut *self, dither)
    }
    #[inline]
    pub unsafe fn setLinearText(&mut self, linearText: bool) {
        SkPaint_setLinearText(&mut *self, linearText)
    }
    #[inline]
    pub unsafe fn setSubpixelText(&mut self, subpixelText: bool) {
        SkPaint_setSubpixelText(&mut *self, subpixelText)
    }
    #[inline]
    pub unsafe fn setLCDRenderText(&mut self, lcdText: bool) {
        SkPaint_setLCDRenderText(&mut *self, lcdText)
    }
    #[inline]
    pub unsafe fn setEmbeddedBitmapText(&mut self,
                                        useEmbeddedBitmapText: bool) {
        SkPaint_setEmbeddedBitmapText(&mut *self, useEmbeddedBitmapText)
    }
    #[inline]
    pub unsafe fn setAutohinted(&mut self, useAutohinter: bool) {
        SkPaint_setAutohinted(&mut *self, useAutohinter)
    }
    #[inline]
    pub unsafe fn setVerticalText(&mut self, arg1: bool) {
        SkPaint_setVerticalText(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setUnderlineText(&mut self, underlineText: bool) {
        SkPaint_setUnderlineText(&mut *self, underlineText)
    }
    #[inline]
    pub unsafe fn setStrikeThruText(&mut self, strikeThruText: bool) {
        SkPaint_setStrikeThruText(&mut *self, strikeThruText)
    }
    #[inline]
    pub unsafe fn setFakeBoldText(&mut self, fakeBoldText: bool) {
        SkPaint_setFakeBoldText(&mut *self, fakeBoldText)
    }
    #[inline]
    pub unsafe fn setDevKernText(&mut self, devKernText: bool) {
        SkPaint_setDevKernText(&mut *self, devKernText)
    }
    #[inline]
    pub unsafe fn setFilterQuality(&mut self, quality: SkFilterQuality) {
        SkPaint_setFilterQuality(&mut *self, quality)
    }
    #[inline]
    pub unsafe fn setStyle(&mut self, style: SkPaint_Style) {
        SkPaint_setStyle(&mut *self, style)
    }
    #[inline]
    pub unsafe fn setColor(&mut self, color: SkColor) {
        SkPaint_setColor(&mut *self, color)
    }
    #[inline]
    pub unsafe fn setAlpha(&mut self, a: U8CPU) {
        SkPaint_setAlpha(&mut *self, a)
    }
    #[inline]
    pub unsafe fn setARGB(&mut self, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) {
        SkPaint_setARGB(&mut *self, a, r, g, b)
    }
    #[inline]
    pub unsafe fn setStrokeWidth(&mut self, width: SkScalar) {
        SkPaint_setStrokeWidth(&mut *self, width)
    }
    #[inline]
    pub unsafe fn setStrokeMiter(&mut self, miter: SkScalar) {
        SkPaint_setStrokeMiter(&mut *self, miter)
    }
    #[inline]
    pub unsafe fn setStrokeCap(&mut self, cap: SkPaint_Cap) {
        SkPaint_setStrokeCap(&mut *self, cap)
    }
    #[inline]
    pub unsafe fn setStrokeJoin(&mut self, join: SkPaint_Join) {
        SkPaint_setStrokeJoin(&mut *self, join)
    }
    #[inline]
    pub unsafe fn getFillPath(&self, src: *const SkPath, dst: *mut SkPath,
                              cullRect: *const SkRect, resScale: SkScalar)
     -> bool {
        SkPaint_getFillPath(&*self, src, dst, cullRect, resScale)
    }
    #[inline]
    pub unsafe fn setShader(&mut self, arg1: sk_sp<SkShader>) {
        SkPaint_setShader(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setColorFilter(&mut self, arg1: sk_sp<SkColorFilter>) {
        SkPaint_setColorFilter(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setPathEffect(&mut self, arg1: sk_sp<SkPathEffect>) {
        SkPaint_setPathEffect(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setMaskFilter(&mut self, arg1: sk_sp<SkMaskFilter>) {
        SkPaint_setMaskFilter(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setTypeface(&mut self, arg1: sk_sp<SkTypeface>) {
        SkPaint_setTypeface(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setRasterizer(&mut self, arg1: sk_sp<SkRasterizer>) {
        SkPaint_setRasterizer(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setImageFilter(&mut self, arg1: sk_sp<SkImageFilter>) {
        SkPaint_setImageFilter(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setDrawLooper(&mut self, arg1: sk_sp<SkDrawLooper>) {
        SkPaint_setDrawLooper(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setLooper(&mut self, arg1: sk_sp<SkDrawLooper>) {
        SkPaint_setLooper(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setTextAlign(&mut self, align: SkPaint_Align) {
        SkPaint_setTextAlign(&mut *self, align)
    }
    #[inline]
    pub unsafe fn setTextSize(&mut self, textSize: SkScalar) {
        SkPaint_setTextSize(&mut *self, textSize)
    }
    #[inline]
    pub unsafe fn setTextScaleX(&mut self, scaleX: SkScalar) {
        SkPaint_setTextScaleX(&mut *self, scaleX)
    }
    #[inline]
    pub unsafe fn setTextSkewX(&mut self, skewX: SkScalar) {
        SkPaint_setTextSkewX(&mut *self, skewX)
    }
    #[inline]
    pub unsafe fn setTextEncoding(&mut self, encoding: SkPaint_TextEncoding) {
        SkPaint_setTextEncoding(&mut *self, encoding)
    }
    #[inline]
    pub unsafe fn getFontMetrics(&self, metrics: *mut SkPaint_FontMetrics,
                                 scale: SkScalar) -> SkScalar {
        SkPaint_getFontMetrics(&*self, metrics, scale)
    }
    #[inline]
    pub unsafe fn textToGlyphs(&self, text: *const ::std::os::raw::c_void,
                               byteLength: usize, glyphs: *mut SkGlyphID)
     -> ::std::os::raw::c_int {
        SkPaint_textToGlyphs(&*self, text, byteLength, glyphs)
    }
    #[inline]
    pub unsafe fn containsText(&self, text: *const ::std::os::raw::c_void,
                               byteLength: usize) -> bool {
        SkPaint_containsText(&*self, text, byteLength)
    }
    #[inline]
    pub unsafe fn glyphsToUnichars(&self, glyphs: *const SkGlyphID,
                                   count: ::std::os::raw::c_int,
                                   text: *mut SkUnichar) {
        SkPaint_glyphsToUnichars(&*self, glyphs, count, text)
    }
    #[inline]
    pub unsafe fn measureText(&self, text: *const ::std::os::raw::c_void,
                              length: usize, bounds: *mut SkRect)
     -> SkScalar {
        SkPaint_measureText(&*self, text, length, bounds)
    }
    #[inline]
    pub unsafe fn breakText(&self, text: *const ::std::os::raw::c_void,
                            length: usize, maxWidth: SkScalar,
                            measuredWidth: *mut SkScalar) -> usize {
        SkPaint_breakText(&*self, text, length, maxWidth, measuredWidth)
    }
    #[inline]
    pub unsafe fn getTextWidths(&self, text: *const ::std::os::raw::c_void,
                                byteLength: usize, widths: *mut SkScalar,
                                bounds: *mut SkRect)
     -> ::std::os::raw::c_int {
        SkPaint_getTextWidths(&*self, text, byteLength, widths, bounds)
    }
    #[inline]
    pub unsafe fn getTextPath(&self, text: *const ::std::os::raw::c_void,
                              length: usize, x: SkScalar, y: SkScalar,
                              path: *mut SkPath) {
        SkPaint_getTextPath(&*self, text, length, x, y, path)
    }
    #[inline]
    pub unsafe fn getPosTextPath(&self, text: *const ::std::os::raw::c_void,
                                 length: usize, pos: *const SkPoint,
                                 path: *mut SkPath) {
        SkPaint_getPosTextPath(&*self, text, length, pos, path)
    }
    #[inline]
    pub unsafe fn getTextIntercepts(&self,
                                    text: *const ::std::os::raw::c_void,
                                    length: usize, x: SkScalar, y: SkScalar,
                                    bounds: *mut SkScalar,
                                    intervals: *mut SkScalar)
     -> ::std::os::raw::c_int {
        SkPaint_getTextIntercepts(&*self, text, length, x, y, bounds,
                                  intervals)
    }
    #[inline]
    pub unsafe fn getPosTextIntercepts(&self,
                                       text: *const ::std::os::raw::c_void,
                                       length: usize, pos: *const SkPoint,
                                       bounds: *mut SkScalar,
                                       intervals: *mut SkScalar)
     -> ::std::os::raw::c_int {
        SkPaint_getPosTextIntercepts(&*self, text, length, pos, bounds,
                                     intervals)
    }
    #[inline]
    pub unsafe fn getPosTextHIntercepts(&self,
                                        text: *const ::std::os::raw::c_void,
                                        length: usize, xpos: *const SkScalar,
                                        constY: SkScalar,
                                        bounds: *mut SkScalar,
                                        intervals: *mut SkScalar)
     -> ::std::os::raw::c_int {
        SkPaint_getPosTextHIntercepts(&*self, text, length, xpos, constY,
                                      bounds, intervals)
    }
    #[inline]
    pub unsafe fn getTextBlobIntercepts(&self, blob: *const SkTextBlob,
                                        bounds: *mut SkScalar,
                                        intervals: *mut SkScalar)
     -> ::std::os::raw::c_int {
        SkPaint_getTextBlobIntercepts(&*self, blob, bounds, intervals)
    }
    #[inline]
    pub unsafe fn getFontBounds(&self) -> SkRect {
        SkPaint_getFontBounds(&*self)
    }
    #[inline]
    pub unsafe fn nothingToDraw(&self) -> bool {
        SkPaint_nothingToDraw(&*self)
    }
    #[inline]
    pub unsafe fn canComputeFastBounds(&self) -> bool {
        SkPaint_canComputeFastBounds(&*self)
    }
    #[inline]
    pub unsafe fn doComputeFastBounds(&self, orig: *const SkRect,
                                      storage: *mut SkRect,
                                      arg1: SkPaint_Style) -> *const SkRect {
        SkPaint_doComputeFastBounds(&*self, orig, storage, arg1)
    }
    #[inline]
    pub unsafe fn toString(&self, str: *mut SkString) {
        SkPaint_toString(&*self, str)
    }
}
/** \class SkPixelRef

    This class is the smart container for pixel memory, and is used with
    SkBitmap. A pixelref is installed into a bitmap, and then the bitmap can
    access the actual pixel memory by calling lockPixels/unlockPixels.

    This class can be shared/accessed between multiple threads.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkPixelRef {
    pub _base: SkRefCnt,
    pub fMutex: SkMutex,
    pub fInfo: SkImageInfo,
    pub fRec: SkPixelRef_LockRec,
    pub fLockCount: ::std::os::raw::c_int,
    pub fTaggedGenID: ::std::os::raw::c_int,
    pub fGenIDChangeListeners: SkTDArray<*mut SkPixelRef_GenIDChangeListener>,
    pub fURI: SkString,
    pub fAddedToCache: ::std::os::raw::c_int,
    pub _bitfield_1: u8,
    pub fPreLocked: bool,
}
/**
     *  To access the actual pixels of a pixelref, it must be "locked".
     *  Calling lockPixels returns a LockRec struct (on success).
     */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPixelRef_LockRec {
    pub fPixels: *mut ::std::os::raw::c_void,
    pub fColorTable: *mut SkColorTable,
    pub fRowBytes: usize,
}
#[test]
fn bindgen_test_layout_SkPixelRef_LockRec() {
    assert_eq!(::std::mem::size_of::<SkPixelRef_LockRec>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkPixelRef_LockRec>() , 8usize);
}
impl Clone for SkPixelRef_LockRec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPixelRef_LockRequest {
    pub fSize: SkISize,
    pub fQuality: SkFilterQuality,
}
#[test]
fn bindgen_test_layout_SkPixelRef_LockRequest() {
    assert_eq!(::std::mem::size_of::<SkPixelRef_LockRequest>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPixelRef_LockRequest>() , 1usize);
}
impl Clone for SkPixelRef_LockRequest {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPixelRef_LockResult {
    pub fUnlockProc: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                                    *mut ::std::os::raw::c_void)>,
    pub fUnlockContext: *mut ::std::os::raw::c_void,
    pub fPixels: *const ::std::os::raw::c_void,
    pub fCTable: *mut SkColorTable,
    pub fRowBytes: usize,
    pub fSize: SkISize,
}
#[test]
fn bindgen_test_layout_SkPixelRef_LockResult() {
    assert_eq!(::std::mem::size_of::<SkPixelRef_LockResult>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPixelRef_LockResult>() , 1usize);
}
impl Clone for SkPixelRef_LockResult {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct SkPixelRef_GenIDChangeListener__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPixelRef_GenIDChangeListener {
    pub vtable_: *const SkPixelRef_GenIDChangeListener__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkPixelRef_GenIDChangeListener() {
    assert_eq!(::std::mem::size_of::<SkPixelRef_GenIDChangeListener>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<SkPixelRef_GenIDChangeListener>() ,
               8usize);
}
pub const SkPixelRef_kMutable: SkPixelRef__bindgen_ty_1 =
    SkPixelRef__bindgen_ty_1::kMutable;
pub const SkPixelRef_kTemporarilyImmutable: SkPixelRef__bindgen_ty_1 =
    SkPixelRef__bindgen_ty_1::kTemporarilyImmutable;
pub const SkPixelRef_kImmutable: SkPixelRef__bindgen_ty_1 =
    SkPixelRef__bindgen_ty_1::kImmutable;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPixelRef__bindgen_ty_1 {
    kMutable = 0,
    kTemporarilyImmutable = 1,
    kImmutable = 2,
}
pub type SkPixelRef_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkPixelRef() {
    assert_eq!(::std::mem::size_of::<SkPixelRef>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPixelRef>() , 1usize);
}
extern "C" {
    /**
     *  Call to access the pixel memory. Return true on success. Balance this
     *  with a call to unlockPixels().
     */
    #[link_name = "?lockPixels@SkPixelRef@@QEAA_NXZ"]
    pub fn SkPixelRef_lockPixels(this: *mut SkPixelRef) -> bool;
}
extern "C" {
    /**
     *  Call to access the pixel memory. On success, return true and fill out
     *  the specified rec. On failure, return false and ignore the rec parameter.
     *  Balance this with a call to unlockPixels().
     */
    #[link_name = "?lockPixels@SkPixelRef@@QEAA_NPEAULockRec@1@@Z"]
    pub fn SkPixelRef_lockPixels1(this: *mut SkPixelRef,
                                  rec: *mut SkPixelRef_LockRec) -> bool;
}
extern "C" {
    /** Call to balanace a previous call to lockPixels(). Returns the pixels
        (or null) after the unlock. NOTE: lock calls can be nested, but the
        matching number of unlock calls must be made in order to free the
        memory (if the subclass implements caching/deferred-decoding.)
    */
    #[link_name = "?unlockPixels@SkPixelRef@@QEAAXXZ"]
    pub fn SkPixelRef_unlockPixels(this: *mut SkPixelRef);
}
extern "C" {
    /**
     *  Some bitmaps can return a copy of their pixels for lockPixels(), but
     *  that copy, if modified, will not be pushed back. These bitmaps should
     *  not be used as targets for a raster device/canvas (since all pixels
     *  modifications will be lost when unlockPixels() is called.)
     */
    #[link_name = "?lockPixelsAreWritable@SkPixelRef@@QEBA_NXZ"]
    pub fn SkPixelRef_lockPixelsAreWritable(this: *const SkPixelRef) -> bool;
}
extern "C" {
    /** Returns a non-zero, unique value corresponding to the pixels in this
        pixelref. Each time the pixels are changed (and notifyPixelsChanged is
        called), a different generation ID will be returned.
    */
    #[link_name = "?getGenerationID@SkPixelRef@@QEBAIXZ"]
    pub fn SkPixelRef_getGenerationID(this: *const SkPixelRef) -> u32;
}
extern "C" {
    /**
     *  Call this if you have changed the contents of the pixels. This will in-
     *  turn cause a different generation ID value to be returned from
     *  getGenerationID().
     */
    #[link_name = "?notifyPixelsChanged@SkPixelRef@@QEAAXXZ"]
    pub fn SkPixelRef_notifyPixelsChanged(this: *mut SkPixelRef);
}
extern "C" {
    /**
     *  Change the info's AlphaType. Note that this does not automatically
     *  invalidate the generation ID. If the pixel values themselves have
     *  changed, then you must explicitly call notifyPixelsChanged() as well.
     */
    #[link_name = "?changeAlphaType@SkPixelRef@@QEAAXW4SkAlphaType@@@Z"]
    pub fn SkPixelRef_changeAlphaType(this: *mut SkPixelRef, at: SkAlphaType);
}
extern "C" {
    /** Marks this pixelref is immutable, meaning that the contents of its
        pixels will not change for the lifetime of the pixelref. This state can
        be set on a pixelref, but it cannot be cleared once it is set.
    */
    #[link_name = "?setImmutable@SkPixelRef@@QEAAXXZ"]
    pub fn SkPixelRef_setImmutable(this: *mut SkPixelRef);
}
extern "C" {
    #[link_name =
          "?requestLock@SkPixelRef@@QEAA_NAEBULockRequest@1@PEAULockResult@1@@Z"]
    pub fn SkPixelRef_requestLock(this: *mut SkPixelRef,
                                  arg1: *const SkPixelRef_LockRequest,
                                  arg2: *mut SkPixelRef_LockResult) -> bool;
}
extern "C" {
    /** Populates dst with the pixels of this pixelRef, converting them to colorType. */
    #[link_name =
          "?readPixels@SkPixelRef@@QEAA_NPEAVSkBitmap@@W4SkColorType@@PEBUSkIRect@@@Z"]
    pub fn SkPixelRef_readPixels(this: *mut SkPixelRef, dst: *mut SkBitmap,
                                 colorType: SkColorType,
                                 subset: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name =
          "?addGenIDChangeListener@SkPixelRef@@QEAAXPEAUGenIDChangeListener@1@@Z"]
    pub fn SkPixelRef_addGenIDChangeListener(this: *mut SkPixelRef,
                                             listener:
                                                 *mut SkPixelRef_GenIDChangeListener);
}
extern "C" {
    #[link_name = "?setPreLocked@SkPixelRef@@IEAAXPEAX_KPEAVSkColorTable@@@Z"]
    pub fn SkPixelRef_setPreLocked(this: *mut SkPixelRef,
                                   arg1: *mut ::std::os::raw::c_void,
                                   rowBytes: usize, arg2: *mut SkColorTable);
}
impl SkPixelRef {
    #[inline]
    pub fn fMutability(&self) -> SkPixelRef__bindgen_ty_1 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (255usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_fMutability(&mut self, val: SkPixelRef__bindgen_ty_1) {
        self._bitfield_1 &= !(255usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (255usize as u8);
    }
    #[inline]
    pub unsafe fn lockPixels(&mut self) -> bool {
        SkPixelRef_lockPixels(&mut *self)
    }
    #[inline]
    pub unsafe fn lockPixels1(&mut self, rec: *mut SkPixelRef_LockRec)
     -> bool {
        SkPixelRef_lockPixels1(&mut *self, rec)
    }
    #[inline]
    pub unsafe fn unlockPixels(&mut self) {
        SkPixelRef_unlockPixels(&mut *self)
    }
    #[inline]
    pub unsafe fn lockPixelsAreWritable(&self) -> bool {
        SkPixelRef_lockPixelsAreWritable(&*self)
    }
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkPixelRef_getGenerationID(&*self)
    }
    #[inline]
    pub unsafe fn notifyPixelsChanged(&mut self) {
        SkPixelRef_notifyPixelsChanged(&mut *self)
    }
    #[inline]
    pub unsafe fn changeAlphaType(&mut self, at: SkAlphaType) {
        SkPixelRef_changeAlphaType(&mut *self, at)
    }
    #[inline]
    pub unsafe fn setImmutable(&mut self) {
        SkPixelRef_setImmutable(&mut *self)
    }
    #[inline]
    pub unsafe fn requestLock(&mut self, arg1: *const SkPixelRef_LockRequest,
                              arg2: *mut SkPixelRef_LockResult) -> bool {
        SkPixelRef_requestLock(&mut *self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn readPixels(&mut self, dst: *mut SkBitmap,
                             colorType: SkColorType, subset: *const SkIRect)
     -> bool {
        SkPixelRef_readPixels(&mut *self, dst, colorType, subset)
    }
    #[inline]
    pub unsafe fn addGenIDChangeListener(&mut self,
                                         listener:
                                             *mut SkPixelRef_GenIDChangeListener) {
        SkPixelRef_addGenIDChangeListener(&mut *self, listener)
    }
    #[inline]
    pub unsafe fn setPreLocked(&mut self, arg1: *mut ::std::os::raw::c_void,
                               rowBytes: usize, arg2: *mut SkColorTable) {
        SkPixelRef_setPreLocked(&mut *self, arg1, rowBytes, arg2)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPixelRefFactory {
    pub _base: SkRefCnt,
}
#[test]
fn bindgen_test_layout_SkPixelRefFactory() {
    assert_eq!(::std::mem::size_of::<SkPixelRefFactory>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPixelRefFactory>() , 1usize);
}
/** \class SkRegion

    The SkRegion class encapsulates the geometric region used to specify
    clipping areas for drawing.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkRegion {
    pub fBounds: SkIRect,
    pub fRunHead: *mut SkRegion_RunHead,
}
pub type SkRegion_RunType = i32;
pub const SkRegion_kRunTypeSentinel: SkRegion__bindgen_ty_1 =
    SkRegion__bindgen_ty_1::kRunTypeSentinel;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkRegion__bindgen_ty_1 { kRunTypeSentinel = 2147483647, }
pub const SkRegion_Op_kLastOp: SkRegion_Op = SkRegion_Op::kReplace_Op;
#[repr(i32)]
/**
     *  The logical operations that can be performed when combining two regions.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkRegion_Op {
    kDifference_Op = 0,
    kIntersect_Op = 1,
    kUnion_Op = 2,
    kXOR_Op = 3,
    kReverseDifference_Op = 4,
    kReplace_Op = 5,
}
/**
     *  Returns the sequence of rectangles, sorted in Y and X, that make up
     *  this region.
     */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRegion_Iterator {
    pub fRgn: *const SkRegion,
    pub fRuns: *const SkRegion_RunType,
    pub fRect: SkIRect,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Iterator() {
    assert_eq!(::std::mem::size_of::<SkRegion_Iterator>() , 40usize);
    assert_eq!(::std::mem::align_of::<SkRegion_Iterator>() , 8usize);
}
extern "C" {
    #[link_name = "?rewind@Iterator@SkRegion@@QEAA_NXZ"]
    pub fn SkRegion_Iterator_rewind(this: *mut SkRegion_Iterator) -> bool;
}
extern "C" {
    #[link_name = "?reset@Iterator@SkRegion@@QEAAXAEBV2@@Z"]
    pub fn SkRegion_Iterator_reset(this: *mut SkRegion_Iterator,
                                   arg1: *const SkRegion);
}
extern "C" {
    #[link_name = "?next@Iterator@SkRegion@@QEAAXXZ"]
    pub fn SkRegion_Iterator_next(this: *mut SkRegion_Iterator);
}
impl Clone for SkRegion_Iterator {
    fn clone(&self) -> Self { *self }
}
impl SkRegion_Iterator {
    #[inline]
    pub unsafe fn rewind(&mut self) -> bool {
        SkRegion_Iterator_rewind(&mut *self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, arg1: *const SkRegion) {
        SkRegion_Iterator_reset(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn next(&mut self) { SkRegion_Iterator_next(&mut *self) }
}
/**
     *  Returns the sequence of rectangles, sorted in Y and X, that make up
     *  this region intersected with the specified clip rectangle.
     */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRegion_Cliperator {
    pub fIter: SkRegion_Iterator,
    pub fClip: SkIRect,
    pub fRect: SkIRect,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Cliperator() {
    assert_eq!(::std::mem::size_of::<SkRegion_Cliperator>() , 80usize);
    assert_eq!(::std::mem::align_of::<SkRegion_Cliperator>() , 8usize);
}
extern "C" {
    #[link_name = "?next@Cliperator@SkRegion@@QEAAXXZ"]
    pub fn SkRegion_Cliperator_next(this: *mut SkRegion_Cliperator);
}
impl Clone for SkRegion_Cliperator {
    fn clone(&self) -> Self { *self }
}
impl SkRegion_Cliperator {
    #[inline]
    pub unsafe fn next(&mut self) { SkRegion_Cliperator_next(&mut *self) }
}
/**
     *  Returns the sequence of runs that make up this region for the specified
     *  Y scanline, clipped to the specified left and right X values.
     */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRegion_Spanerator {
    pub fRuns: *const SkRegion_RunType,
    pub fLeft: ::std::os::raw::c_int,
    pub fRight: ::std::os::raw::c_int,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Spanerator() {
    assert_eq!(::std::mem::size_of::<SkRegion_Spanerator>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkRegion_Spanerator>() , 8usize);
}
extern "C" {
    #[link_name = "?next@Spanerator@SkRegion@@QEAA_NPEAH0@Z"]
    pub fn SkRegion_Spanerator_next(this: *mut SkRegion_Spanerator,
                                    left: *mut ::std::os::raw::c_int,
                                    right: *mut ::std::os::raw::c_int)
     -> bool;
}
impl Clone for SkRegion_Spanerator {
    fn clone(&self) -> Self { *self }
}
impl SkRegion_Spanerator {
    #[inline]
    pub unsafe fn next(&mut self, left: *mut ::std::os::raw::c_int,
                       right: *mut ::std::os::raw::c_int) -> bool {
        SkRegion_Spanerator_next(&mut *self, left, right)
    }
}
pub const SkRegion_kOpCount: SkRegion__bindgen_ty_2 =
    SkRegion__bindgen_ty_2::kOpCount;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkRegion__bindgen_ty_2 { kOpCount = 6, }
pub const SkRegion_kRectRegionRuns: SkRegion__bindgen_ty_3 =
    SkRegion__bindgen_ty_3::kRectRegionRuns;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkRegion__bindgen_ty_3 { kRectRegionRuns = 7, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRegion_RunHead {
    pub _address: u8,
}
impl Clone for SkRegion_RunHead {
    fn clone(&self) -> Self { *self }
}
pub const SkRegion_kOpCnt: ::std::os::raw::c_int = 6;
#[test]
fn bindgen_test_layout_SkRegion() {
    assert_eq!(::std::mem::size_of::<SkRegion>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkRegion>() , 8usize);
}
extern "C" {
    /**
     *  Swap the contents of this and the specified region. This operation
     *  is gauarenteed to never fail.
     */
    #[link_name = "?swap@SkRegion@@QEAAXAEAV1@@Z"]
    pub fn SkRegion_swap(this: *mut SkRegion, arg1: *mut SkRegion);
}
extern "C" {
    /**
     *  Returns a value that grows approximately linearly with the number of
     *  intervals comprised in the region. Empty region will return 0, Rect
     *  will return 1, Complex will return a value > 1.
     *
     *  Use this to compare two regions, where the larger count likely
     *  indicates a more complex region.
     */
    #[link_name = "?computeRegionComplexity@SkRegion@@QEBAHXZ"]
    pub fn SkRegion_computeRegionComplexity(this: *const SkRegion)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
     *  Returns true if the region is non-empty, and if so, appends the
     *  boundary(s) of the region to the specified path.
     *  If the region is empty, returns false, and path is left unmodified.
     */
    #[link_name = "?getBoundaryPath@SkRegion@@QEBA_NPEAVSkPath@@@Z"]
    pub fn SkRegion_getBoundaryPath(this: *const SkRegion, path: *mut SkPath)
     -> bool;
}
extern "C" {
    /**
     *  Set the region to be empty, and return false, since the resulting
     *  region is empty
     */
    #[link_name = "?setEmpty@SkRegion@@QEAA_NXZ"]
    pub fn SkRegion_setEmpty(this: *mut SkRegion) -> bool;
}
extern "C" {
    /**
     *  If rect is non-empty, set this region to that rectangle and return true,
     *  otherwise set this region to empty and return false.
     */
    #[link_name = "?setRect@SkRegion@@QEAA_NAEBUSkIRect@@@Z"]
    pub fn SkRegion_setRect(this: *mut SkRegion, arg1: *const SkIRect)
     -> bool;
}
extern "C" {
    /**
     *  If left < right and top < bottom, set this region to that rectangle and
     *  return true, otherwise set this region to empty and return false.
     */
    #[link_name = "?setRect@SkRegion@@QEAA_NHHHH@Z"]
    pub fn SkRegion_setRect1(this: *mut SkRegion, left: i32, top: i32,
                             right: i32, bottom: i32) -> bool;
}
extern "C" {
    /**
     *  Set this region to the union of an array of rects. This is generally
     *  faster than calling region.op(rect, kUnion_Op) in a loop. If count is
     *  0, then this region is set to the empty region.
     *  @return true if the resulting region is non-empty
     */
    #[link_name = "?setRects@SkRegion@@QEAA_NQEBUSkIRect@@H@Z"]
    pub fn SkRegion_setRects(this: *mut SkRegion, rects: *const SkIRect,
                             count: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
     *  Set this region to the specified region, and return true if it is
     *  non-empty.
     */
    #[link_name = "?setRegion@SkRegion@@QEAA_NAEBV1@@Z"]
    pub fn SkRegion_setRegion(this: *mut SkRegion, arg1: *const SkRegion)
     -> bool;
}
extern "C" {
    /**
     *  Set this region to the area described by the path, clipped.
     *  Return true if the resulting region is non-empty.
     *  This produces a region that is identical to the pixels that would be
     *  drawn by the path (with no antialiasing) with the specified clip.
     */
    #[link_name = "?setPath@SkRegion@@QEAA_NAEBVSkPath@@AEBV1@@Z"]
    pub fn SkRegion_setPath(this: *mut SkRegion, arg1: *const SkPath,
                            clip: *const SkRegion) -> bool;
}
extern "C" {
    /**
     *  Returns true if the specified rectangle has a non-empty intersection
     *  with this region.
     */
    #[link_name = "?intersects@SkRegion@@QEBA_NAEBUSkIRect@@@Z"]
    pub fn SkRegion_intersects(this: *const SkRegion, arg1: *const SkIRect)
     -> bool;
}
extern "C" {
    /**
     *  Returns true if the specified region has a non-empty intersection
     *  with this region.
     */
    #[link_name = "?intersects@SkRegion@@QEBA_NAEBV1@@Z"]
    pub fn SkRegion_intersects1(this: *const SkRegion, arg1: *const SkRegion)
     -> bool;
}
extern "C" {
    /**
     *  Return true if the specified x,y coordinate is inside the region.
     */
    #[link_name = "?contains@SkRegion@@QEBA_NHH@Z"]
    pub fn SkRegion_contains(this: *const SkRegion, x: i32, y: i32) -> bool;
}
extern "C" {
    /**
     *  Return true if the specified rectangle is completely inside the region.
     *  This works for simple (rectangular) and complex regions, and always
     *  returns the correct result. Note: if either this region or the rectangle
     *  is empty, contains() returns false.
     */
    #[link_name = "?contains@SkRegion@@QEBA_NAEBUSkIRect@@@Z"]
    pub fn SkRegion_contains1(this: *const SkRegion, arg1: *const SkIRect)
     -> bool;
}
extern "C" {
    /**
     *  Return true if the specified region is completely inside the region.
     *  This works for simple (rectangular) and complex regions, and always
     *  returns the correct result. Note: if either region is empty, contains()
     *  returns false.
     */
    #[link_name = "?contains@SkRegion@@QEBA_NAEBV1@@Z"]
    pub fn SkRegion_contains2(this: *const SkRegion, arg1: *const SkRegion)
     -> bool;
}
extern "C" {
    /**
     *  Translate the region by the specified (dx, dy) amount, writing the
     *  resulting region into dst. Note: it is legal to pass this region as the
     *  dst parameter, effectively translating the region in place. If dst is
     *  null, nothing happens.
     */
    #[link_name = "?translate@SkRegion@@QEBAXHHPEAV1@@Z"]
    pub fn SkRegion_translate(this: *const SkRegion,
                              dx: ::std::os::raw::c_int,
                              dy: ::std::os::raw::c_int, dst: *mut SkRegion);
}
extern "C" {
    /**
     *  Set this region to the result of applying the Op to the specified
     *  rectangle and region: this = (rect op rgn).
     *  Return true if the resulting region is non-empty.
     */
    #[link_name = "?op@SkRegion@@QEAA_NAEBUSkIRect@@AEBV1@W4Op@1@@Z"]
    pub fn SkRegion_op(this: *mut SkRegion, rect: *const SkIRect,
                       rgn: *const SkRegion, arg1: SkRegion_Op) -> bool;
}
extern "C" {
    /**
     *  Set this region to the result of applying the Op to the specified
     *  region and rectangle: this = (rgn op rect).
     *  Return true if the resulting region is non-empty.
     */
    #[link_name = "?op@SkRegion@@QEAA_NAEBV1@AEBUSkIRect@@W4Op@1@@Z"]
    pub fn SkRegion_op1(this: *mut SkRegion, rgn: *const SkRegion,
                        rect: *const SkIRect, arg1: SkRegion_Op) -> bool;
}
extern "C" {
    /**
     *  Set this region to the result of applying the Op to the specified
     *  regions: this = (rgna op rgnb).
     *  Return true if the resulting region is non-empty.
     */
    #[link_name = "?op@SkRegion@@QEAA_NAEBV1@0W4Op@1@@Z"]
    pub fn SkRegion_op2(this: *mut SkRegion, rgna: *const SkRegion,
                        rgnb: *const SkRegion, op: SkRegion_Op) -> bool;
}
extern "C" {
    /**
     *  Write the region to the buffer, and return the number of bytes written.
     *  If buffer is NULL, it still returns the number of bytes.
     */
    #[link_name = "?writeToMemory@SkRegion@@QEBA_KPEAX@Z"]
    pub fn SkRegion_writeToMemory(this: *const SkRegion,
                                  buffer: *mut ::std::os::raw::c_void)
     -> usize;
}
extern "C" {
    /**
     * Initializes the region from the buffer
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
    #[link_name = "?readFromMemory@SkRegion@@QEAA_KPEBX_K@Z"]
    pub fn SkRegion_readFromMemory(this: *mut SkRegion,
                                   buffer: *const ::std::os::raw::c_void,
                                   length: usize) -> usize;
}
extern "C" {
    /**
     *  Returns a reference to a global empty region. Just a convenience for
     *  callers that need a const empty region.
     */
    #[link_name = "?GetEmptyRegion@SkRegion@@SAAEBV1@XZ"]
    pub fn SkRegion_GetEmptyRegion() -> *const SkRegion;
}
extern "C" {
    #[link_name = "?dump@SkRegion@@QEBAXXZ"]
    pub fn SkRegion_dump(this: *const SkRegion);
}
extern "C" {
    #[link_name = "?validate@SkRegion@@QEBAXXZ"]
    pub fn SkRegion_validate(this: *const SkRegion);
}
extern "C" {
    #[link_name = "?UnitTest@SkRegion@@SAXXZ"]
    pub fn SkRegion_UnitTest();
}
extern "C" {
    #[link_name = "?debugSetRuns@SkRegion@@QEAA_NQEBHH@Z"]
    pub fn SkRegion_debugSetRuns(this: *mut SkRegion,
                                 runs: *const SkRegion_RunType,
                                 count: ::std::os::raw::c_int) -> bool;
}
impl SkRegion {
    #[inline]
    pub unsafe fn swap(&mut self, arg1: *mut SkRegion) {
        SkRegion_swap(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn computeRegionComplexity(&self) -> ::std::os::raw::c_int {
        SkRegion_computeRegionComplexity(&*self)
    }
    #[inline]
    pub unsafe fn getBoundaryPath(&self, path: *mut SkPath) -> bool {
        SkRegion_getBoundaryPath(&*self, path)
    }
    #[inline]
    pub unsafe fn setEmpty(&mut self) -> bool {
        SkRegion_setEmpty(&mut *self)
    }
    #[inline]
    pub unsafe fn setRect(&mut self, arg1: *const SkIRect) -> bool {
        SkRegion_setRect(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setRect1(&mut self, left: i32, top: i32, right: i32,
                           bottom: i32) -> bool {
        SkRegion_setRect1(&mut *self, left, top, right, bottom)
    }
    #[inline]
    pub unsafe fn setRects(&mut self, rects: *const SkIRect,
                           count: ::std::os::raw::c_int) -> bool {
        SkRegion_setRects(&mut *self, rects, count)
    }
    #[inline]
    pub unsafe fn setRegion(&mut self, arg1: *const SkRegion) -> bool {
        SkRegion_setRegion(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setPath(&mut self, arg1: *const SkPath,
                          clip: *const SkRegion) -> bool {
        SkRegion_setPath(&mut *self, arg1, clip)
    }
    #[inline]
    pub unsafe fn intersects(&self, arg1: *const SkIRect) -> bool {
        SkRegion_intersects(&*self, arg1)
    }
    #[inline]
    pub unsafe fn intersects1(&self, arg1: *const SkRegion) -> bool {
        SkRegion_intersects1(&*self, arg1)
    }
    #[inline]
    pub unsafe fn contains(&self, x: i32, y: i32) -> bool {
        SkRegion_contains(&*self, x, y)
    }
    #[inline]
    pub unsafe fn contains1(&self, arg1: *const SkIRect) -> bool {
        SkRegion_contains1(&*self, arg1)
    }
    #[inline]
    pub unsafe fn contains2(&self, arg1: *const SkRegion) -> bool {
        SkRegion_contains2(&*self, arg1)
    }
    #[inline]
    pub unsafe fn translate(&self, dx: ::std::os::raw::c_int,
                            dy: ::std::os::raw::c_int, dst: *mut SkRegion) {
        SkRegion_translate(&*self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn op(&mut self, rect: *const SkIRect, rgn: *const SkRegion,
                     arg1: SkRegion_Op) -> bool {
        SkRegion_op(&mut *self, rect, rgn, arg1)
    }
    #[inline]
    pub unsafe fn op1(&mut self, rgn: *const SkRegion, rect: *const SkIRect,
                      arg1: SkRegion_Op) -> bool {
        SkRegion_op1(&mut *self, rgn, rect, arg1)
    }
    #[inline]
    pub unsafe fn op2(&mut self, rgna: *const SkRegion, rgnb: *const SkRegion,
                      op: SkRegion_Op) -> bool {
        SkRegion_op2(&mut *self, rgna, rgnb, op)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::std::os::raw::c_void)
     -> usize {
        SkRegion_writeToMemory(&*self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(&mut self,
                                 buffer: *const ::std::os::raw::c_void,
                                 length: usize) -> usize {
        SkRegion_readFromMemory(&mut *self, buffer, length)
    }
    #[inline]
    pub unsafe fn GetEmptyRegion() -> *const SkRegion {
        SkRegion_GetEmptyRegion()
    }
    #[inline]
    pub unsafe fn dump(&self) { SkRegion_dump(&*self) }
    #[inline]
    pub unsafe fn validate(&self) { SkRegion_validate(&*self) }
    #[inline]
    pub unsafe fn UnitTest() { SkRegion_UnitTest() }
    #[inline]
    pub unsafe fn debugSetRuns(&mut self, runs: *const SkRegion_RunType,
                               count: ::std::os::raw::c_int) -> bool {
        SkRegion_debugSetRuns(&mut *self, runs, count)
    }
}
/** \class SkBitmap

    The SkBitmap class specifies a raster bitmap. A bitmap has an integer width
    and height, and a format (colortype), and a pointer to the actual pixels.
    Bitmaps can be drawn into a SkCanvas, but they are also used to specify the
    target of a SkCanvas' drawing operations.
    A const SkBitmap exposes getAddr(), which lets a caller write its pixels;
    the constness is considered to apply to the bitmap's configuration, not
    its contents.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkBitmap {
    pub fPixelRef: *mut SkPixelRef,
    pub fPixelLockCount: ::std::os::raw::c_int,
    pub fPixels: *mut ::std::os::raw::c_void,
    pub fColorTable: *mut SkColorTable,
    pub fPixelRefOrigin: SkIPoint,
    pub fInfo: SkImageInfo,
    pub fRowBytes: u32,
    pub fFlags: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBitmap_Allocator {
    pub _base: SkRefCnt,
}
pub type SkBitmap_Allocator_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkBitmap_Allocator() {
    assert_eq!(::std::mem::size_of::<SkBitmap_Allocator>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkBitmap_Allocator>() , 1usize);
}
/** Subclass of Allocator that returns a pixelref that allocates its pixel
        memory from the heap. This is the default Allocator invoked by
        allocPixels().
    */
#[repr(C)]
#[derive(Debug)]
pub struct SkBitmap_HeapAllocator {
    pub _base: SkBitmap_Allocator,
}
#[test]
fn bindgen_test_layout_SkBitmap_HeapAllocator() {
    assert_eq!(::std::mem::size_of::<SkBitmap_HeapAllocator>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkBitmap_HeapAllocator>() , 1usize);
}
#[repr(C)]
pub struct SkBitmap_RLEPixels__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBitmap_RLEPixels {
    pub vtable_: *const SkBitmap_RLEPixels__bindgen_vtable,
    pub fYPtrs: *mut *mut u8,
    pub fHeight: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkBitmap_RLEPixels() {
    assert_eq!(::std::mem::size_of::<SkBitmap_RLEPixels>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkBitmap_RLEPixels>() , 8usize);
}
pub const SkBitmap_Flags_kImageIsVolatile_Flag: SkBitmap_Flags =
    SkBitmap_Flags(2);
impl ::std::ops::BitOr<SkBitmap_Flags> for SkBitmap_Flags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { SkBitmap_Flags(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkBitmap_Flags(pub i32);
#[test]
fn bindgen_test_layout_SkBitmap() {
    assert_eq!(::std::mem::size_of::<SkBitmap>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkBitmap>() , 1usize);
}
extern "C" {
    /** Swap the fields of the two bitmaps. This routine is guaranteed to never fail or throw.
    */
    #[link_name = "?swap@SkBitmap@@QEAAXAEAV1@@Z"]
    pub fn SkBitmap_swap(this: *mut SkBitmap, other: *mut SkBitmap);
}
extern "C" {
    /**
     *  Set the bitmap's alphaType, returning true on success. If false is
     *  returned, then the specified new alphaType is incompatible with the
     *  colortype, and the current alphaType is unchanged.
     *
     *  Note: this changes the alphatype for the underlying pixels, which means
     *  that all bitmaps that might be sharing (subsets of) the pixels will
     *  be affected.
     */
    #[link_name = "?setAlphaType@SkBitmap@@QEAA_NW4SkAlphaType@@@Z"]
    pub fn SkBitmap_setAlphaType(this: *mut SkBitmap, arg1: SkAlphaType)
     -> bool;
}
extern "C" {
    /** Returns true if this bitmap is marked as immutable, meaning that the
        contents of its pixels will not change for the lifetime of the bitmap.
    */
    #[link_name = "?isImmutable@SkBitmap@@QEBA_NXZ"]
    pub fn SkBitmap_isImmutable(this: *const SkBitmap) -> bool;
}
extern "C" {
    /** Marks this bitmap as immutable, meaning that the contents of its
        pixels will not change for the lifetime of the bitmap and of the
        underlying pixelref. This state can be set, but it cannot be
        cleared once it is set. This state propagates to all other bitmaps
        that share the same pixelref.
    */
    #[link_name = "?setImmutable@SkBitmap@@QEAAXXZ"]
    pub fn SkBitmap_setImmutable(this: *mut SkBitmap);
}
extern "C" {
    /** Returns true if the bitmap is volatile (i.e. should not be cached by devices.)
    */
    #[link_name = "?isVolatile@SkBitmap@@QEBA_NXZ"]
    pub fn SkBitmap_isVolatile(this: *const SkBitmap) -> bool;
}
extern "C" {
    /** Specify whether this bitmap is volatile. Bitmaps are not volatile by
        default. Temporary bitmaps that are discarded after use should be
        marked as volatile. This provides a hint to the device that the bitmap
        should not be cached. Providing this hint when appropriate can
        improve performance by avoiding unnecessary overhead and resource
        consumption on the device.
    */
    #[link_name = "?setIsVolatile@SkBitmap@@QEAAX_N@Z"]
    pub fn SkBitmap_setIsVolatile(this: *mut SkBitmap, arg1: bool);
}
extern "C" {
    /** Reset the bitmap to its initial state (see default constructor). If we are a (shared)
        owner of the pixels, that ownership is decremented.
    */
    #[link_name = "?reset@SkBitmap@@QEAAXXZ"]
    pub fn SkBitmap_reset(this: *mut SkBitmap);
}
extern "C" {
    /**
     *  Return the bitmap's bounds [0, 0, width, height] as an SkRect
     */
    #[link_name = "?getBounds@SkBitmap@@QEBAXPEAUSkRect@@@Z"]
    pub fn SkBitmap_getBounds(this: *const SkBitmap, bounds: *mut SkRect);
}
extern "C" {
    #[link_name = "?getBounds@SkBitmap@@QEBAXPEAUSkIRect@@@Z"]
    pub fn SkBitmap_getBounds1(this: *const SkBitmap, bounds: *mut SkIRect);
}
extern "C" {
    #[link_name = "?setInfo@SkBitmap@@QEAA_NAEBUSkImageInfo@@_K@Z"]
    pub fn SkBitmap_setInfo(this: *mut SkBitmap, arg1: *const SkImageInfo,
                            rowBytes: usize) -> bool;
}
extern "C" {
    /**
     *  Allocate the bitmap's pixels to match the requested image info. If the Factory
     *  is non-null, call it to allcoate the pixelref. If the ImageInfo requires
     *  a colortable, then ColorTable must be non-null, and will be ref'd.
     *  On failure, the bitmap will be set to empty and return false.
     */
    #[link_name =
          "?tryAllocPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@PEAVSkPixelRefFactory@@PEAVSkColorTable@@@Z"]
    pub fn SkBitmap_tryAllocPixels(this: *mut SkBitmap,
                                   arg1: *const SkImageInfo,
                                   arg2: *mut SkPixelRefFactory,
                                   arg3: *mut SkColorTable) -> bool;
}
extern "C" {
    /**
     *  Allocate the bitmap's pixels to match the requested image info and
     *  rowBytes. If the request cannot be met (e.g. the info is invalid or
     *  the requested rowBytes are not compatible with the info
     *  (e.g. rowBytes < info.minRowBytes() or rowBytes is not aligned with
     *  the pixel size specified by info.colorType()) then false is returned
     *  and the bitmap is set to empty.
     */
    #[link_name = "?tryAllocPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@_K@Z"]
    pub fn SkBitmap_tryAllocPixels1(this: *mut SkBitmap,
                                    info: *const SkImageInfo, rowBytes: usize)
     -> bool;
}
extern "C" {
    /**
     *  Install a pixelref that wraps the specified pixels and rowBytes, and
     *  optional ReleaseProc and context. When the pixels are no longer
     *  referenced, if releaseProc is not null, it will be called with the
     *  pixels and context as parameters.
     *  On failure, the bitmap will be set to empty and return false.
     *
     *  If specified, the releaseProc will always be called, even on failure. It is also possible
     *  for success but the releaseProc is immediately called (e.g. valid Info but NULL pixels).
     */
    #[link_name =
          "?installPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@PEAX_KPEAVSkColorTable@@P6AX11@Z1@Z"]
    pub fn SkBitmap_installPixels(this: *mut SkBitmap,
                                  arg1: *const SkImageInfo,
                                  pixels: *mut ::std::os::raw::c_void,
                                  rowBytes: usize, arg2: *mut SkColorTable,
                                  releaseProc:
                                      ::std::option::Option<unsafe extern "C" fn(addr:
                                                                                     *mut ::std::os::raw::c_void,
                                                                                 context:
                                                                                     *mut ::std::os::raw::c_void)>,
                                  context: *mut ::std::os::raw::c_void)
     -> bool;
}
extern "C" {
    /**
     *  Call installPixels with no ReleaseProc specified. This means
     *  that the caller must ensure that the specified pixels and
     *  colortable are valid for the lifetime of the created bitmap
     *  (and its pixelRef).
     */
    #[link_name = "?installPixels@SkBitmap@@QEAA_NAEBVSkPixmap@@@Z"]
    pub fn SkBitmap_installPixels1(this: *mut SkBitmap, arg1: *const SkPixmap)
     -> bool;
}
extern "C" {
    /**
     *  Calls installPixels() with the value in the SkMask. The caller must
     *  ensure that the specified mask pixels are valid for the lifetime
     *  of the created bitmap (and its pixelRef).
     */
    #[link_name = "?installMaskPixels@SkBitmap@@QEAA_NAEBUSkMask@@@Z"]
    pub fn SkBitmap_installMaskPixels(this: *mut SkBitmap,
                                      arg1: *const SkMask) -> bool;
}
extern "C" {
    /** Use this to assign a new pixel address for an existing bitmap. This
        will automatically release any pixelref previously installed. Only call
        this if you are handling ownership/lifetime of the pixel memory.

        If the bitmap retains a reference to the colortable (assuming it is
        not null) it will take care of incrementing the reference count.

        @param pixels   Address for the pixels, managed by the caller.
        @param ctable   ColorTable (or null) that matches the specified pixels
    */
    #[link_name = "?setPixels@SkBitmap@@QEAAXPEAXPEAVSkColorTable@@@Z"]
    pub fn SkBitmap_setPixels(this: *mut SkBitmap,
                              p: *mut ::std::os::raw::c_void,
                              ctable: *mut SkColorTable);
}
extern "C" {
    /** Copies the bitmap's pixels to the location pointed at by dst and returns
        true if possible, returns false otherwise.

        In the case when the dstRowBytes matches the bitmap's rowBytes, the copy
        may be made faster by copying over the dst's per-row padding (for all
        rows but the last). By setting preserveDstPad to true the caller can
        disable this optimization and ensure that pixels in the padding are not
        overwritten.

        Always returns false for RLE formats.

        @param dst      Location of destination buffer.
        @param dstSize  Size of destination buffer. Must be large enough to hold
                        pixels using indicated stride.
        @param dstRowBytes  Width of each line in the buffer. If 0, uses
                            bitmap's internal stride.
        @param preserveDstPad Must we preserve padding in the dst
    */
    #[link_name = "?copyPixelsTo@SkBitmap@@QEBA_NQEAX_K1_N@Z"]
    pub fn SkBitmap_copyPixelsTo(this: *const SkBitmap,
                                 dst: *const ::std::os::raw::c_void,
                                 dstSize: usize, dstRowBytes: usize,
                                 preserveDstPad: bool) -> bool;
}
extern "C" {
    /** Use the specified Allocator to create the pixelref that manages the
        pixel memory. It will be sized based on the current ImageInfo.
        If this is called multiple times, a new pixelref object will be created
        each time.

        If the bitmap retains a reference to the colortable (assuming it is
        not null) it will take care of incrementing the reference count.

        @param allocator The Allocator to use to create a pixelref that can
                         manage the pixel memory for the current ImageInfo.
                         If allocator is NULL, the standard HeapAllocator will be used.
        @param ctable   ColorTable (or null) to use with the pixels that will
                        be allocated. Only used if colortype == kIndex_8_SkColorType.
                        If it is non-null and the colortype is not indexed, it will
                        be ignored.
        @return true if the allocation succeeds. If not the pixelref field of
                     the bitmap will be unchanged.
    */
    #[link_name =
          "?tryAllocPixels@SkBitmap@@QEAA_NPEAVAllocator@1@PEAVSkColorTable@@@Z"]
    pub fn SkBitmap_tryAllocPixels2(this: *mut SkBitmap,
                                    allocator: *mut SkBitmap_Allocator,
                                    ctable: *mut SkColorTable) -> bool;
}
extern "C" {
    /**
     *  Assign a pixelref and origin to the bitmap. Pixelrefs are reference,
     *  so the existing one (if any) will be unref'd and the new one will be
     *  ref'd. (x,y) specify the offset within the pixelref's pixels for the
     *  top/left corner of the bitmap. For a bitmap that encompases the entire
     *  pixels of the pixelref, these will be (0,0).
     */
    #[link_name = "?setPixelRef@SkBitmap@@QEAAPEAVSkPixelRef@@PEAV2@HH@Z"]
    pub fn SkBitmap_setPixelRef(this: *mut SkBitmap, pr: *mut SkPixelRef,
                                dx: ::std::os::raw::c_int,
                                dy: ::std::os::raw::c_int) -> *mut SkPixelRef;
}
extern "C" {
    /** Call this to ensure that the bitmap points to the current pixel address
        in the pixelref. Balance it with a call to unlockPixels(). These calls
        are harmless if there is no pixelref.
    */
    #[link_name = "?lockPixels@SkBitmap@@QEBAXXZ"]
    pub fn SkBitmap_lockPixels(this: *const SkBitmap);
}
extern "C" {
    /** When you are finished access the pixel memory, call this to balance a
        previous call to lockPixels(). This allows pixelrefs that implement
        cached/deferred image decoding to know when there are active clients of
        a given image.
    */
    #[link_name = "?unlockPixels@SkBitmap@@QEBAXXZ"]
    pub fn SkBitmap_unlockPixels(this: *const SkBitmap);
}
extern "C" {
    /**
     *  Some bitmaps can return a copy of their pixels for lockPixels(), but
     *  that copy, if modified, will not be pushed back. These bitmaps should
     *  not be used as targets for a raster device/canvas (since all pixels
     *  modifications will be lost when unlockPixels() is called.)
     */
    #[link_name = "?lockPixelsAreWritable@SkBitmap@@QEBA_NXZ"]
    pub fn SkBitmap_lockPixelsAreWritable(this: *const SkBitmap) -> bool;
}
extern "C" {
    #[link_name = "?requestLock@SkBitmap@@QEBA_NPEAVSkAutoPixmapUnlock@@@Z"]
    pub fn SkBitmap_requestLock(this: *const SkBitmap,
                                result: *mut SkAutoPixmapUnlock) -> bool;
}
extern "C" {
    /** Returns a non-zero, unique value corresponding to the pixels in our
        pixelref. Each time the pixels are changed (and notifyPixelsChanged
        is called), a different generation ID will be returned. Finally, if
        there is no pixelRef then zero is returned.
    */
    #[link_name = "?getGenerationID@SkBitmap@@QEBAIXZ"]
    pub fn SkBitmap_getGenerationID(this: *const SkBitmap) -> u32;
}
extern "C" {
    /** Call this if you have changed the contents of the pixels. This will in-
        turn cause a different generation ID value to be returned from
        getGenerationID().
    */
    #[link_name = "?notifyPixelsChanged@SkBitmap@@QEBAXXZ"]
    pub fn SkBitmap_notifyPixelsChanged(this: *const SkBitmap);
}
extern "C" {
    /**
     *  Fill the entire bitmap with the specified color.
     *  If the bitmap's colortype does not support alpha (e.g. 565) then the alpha
     *  of the color is ignored (treated as opaque). If the colortype only supports
     *  alpha (e.g. A1 or A8) then the color's r,g,b components are ignored.
     */
    #[link_name = "?eraseColor@SkBitmap@@QEBAXI@Z"]
    pub fn SkBitmap_eraseColor(this: *const SkBitmap, c: SkColor);
}
extern "C" {
    /**
     *  Fill the specified area of this bitmap with the specified color.
     *  If the bitmap's colortype does not support alpha (e.g. 565) then the alpha
     *  of the color is ignored (treated as opaque). If the colortype only supports
     *  alpha (e.g. A1 or A8) then the color's r,g,b components are ignored.
     */
    #[link_name = "?erase@SkBitmap@@QEBAXIAEBUSkIRect@@@Z"]
    pub fn SkBitmap_erase(this: *const SkBitmap, c: SkColor,
                          area: *const SkIRect);
}
extern "C" {
    /** Returns the address of the specified pixel. This performs a runtime
        check to know the size of the pixels, and will return the same answer
        as the corresponding size-specific method (e.g. getAddr16). Since the
        check happens at runtime, it is much slower than using a size-specific
        version. Unlike the size-specific methods, this routine also checks if
        getPixels() returns null, and returns that. The size-specific routines
        perform a debugging assert that getPixels() is not null, but they do
        not do any runtime checks.
    */
    #[link_name = "?getAddr@SkBitmap@@QEBAPEAXHH@Z"]
    pub fn SkBitmap_getAddr(this: *const SkBitmap, x: ::std::os::raw::c_int,
                            y: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /** Set dst to be a setset of this bitmap. If possible, it will share the
        pixel memory, and just point into a subset of it. However, if the colortype
        does not support this, a local copy will be made and associated with
        the dst bitmap. If the subset rectangle, intersected with the bitmap's
        dimensions is empty, or if there is an unsupported colortype, false will be
        returned and dst will be untouched.
        @param dst  The bitmap that will be set to a subset of this bitmap
        @param subset The rectangle of pixels in this bitmap that dst will
                      reference.
        @return true if the subset copy was successfully made.
    */
    #[link_name = "?extractSubset@SkBitmap@@QEBA_NPEAV1@AEBUSkIRect@@@Z"]
    pub fn SkBitmap_extractSubset(this: *const SkBitmap, dst: *mut SkBitmap,
                                  subset: *const SkIRect) -> bool;
}
extern "C" {
    /** Makes a deep copy of this bitmap, respecting the requested colorType,
     *  and allocating the dst pixels on the cpu.
     *  Returns false if either there is an error (i.e. the src does not have
     *  pixels) or the request cannot be satisfied (e.g. the src has per-pixel
     *  alpha, and the requested colortype does not support alpha).
     *  @param dst The bitmap to be sized and allocated
     *  @param ct The desired colorType for dst
     *  @param allocator Allocator used to allocate the pixelref for the dst
     *                   bitmap. If this is null, the standard HeapAllocator
     *                   will be used.
     *  @return true if the copy was made.
     */
    #[link_name =
          "?copyTo@SkBitmap@@QEBA_NPEAV1@W4SkColorType@@PEAVAllocator@1@@Z"]
    pub fn SkBitmap_copyTo(this: *const SkBitmap, dst: *mut SkBitmap,
                           ct: SkColorType, arg1: *mut SkBitmap_Allocator)
     -> bool;
}
extern "C" {
    /**
     *  Copy the bitmap's pixels into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (SkImageInfo). The src pixels are read
     *  starting at the specified (srcX,srcY) offset, relative to the top-left corner.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the bitmap. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the bitmap bounds.
     *  - If the requested colortype/alphatype cannot be converted from the src's types.
     *  - If the src pixels are not available.
     */
    #[link_name = "?readPixels@SkBitmap@@QEBA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
    pub fn SkBitmap_readPixels(this: *const SkBitmap,
                               dstInfo: *const SkImageInfo,
                               dstPixels: *mut ::std::os::raw::c_void,
                               dstRowBytes: usize,
                               srcX: ::std::os::raw::c_int,
                               srcY: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
     *  Returns true if this bitmap's pixels can be converted into the requested
     *  colorType, such that copyTo() could succeed.
     */
    #[link_name = "?canCopyTo@SkBitmap@@QEBA_NW4SkColorType@@@Z"]
    pub fn SkBitmap_canCopyTo(this: *const SkBitmap, colorType: SkColorType)
     -> bool;
}
extern "C" {
    /** Makes a deep copy of this bitmap, keeping the copied pixels
     *  in the same domain as the source: If the src pixels are allocated for
     *  the cpu, then so will the dst. If the src pixels are allocated on the
     *  gpu (typically as a texture), the it will do the same for the dst.
     *  If the request cannot be fulfilled, returns false and dst is unmodified.
     */
    #[link_name = "?deepCopyTo@SkBitmap@@QEBA_NPEAV1@@Z"]
    pub fn SkBitmap_deepCopyTo(this: *const SkBitmap, dst: *mut SkBitmap)
     -> bool;
}
extern "C" {
    /** Set dst to contain alpha layer of this bitmap. If destination bitmap
        fails to be initialized, e.g. because allocator can't allocate pixels
        for it, dst will not be modified and false will be returned.

        @param dst The bitmap to be filled with alpha layer
        @param paint The paint to draw with
        @param allocator Allocator used to allocate the pixelref for the dst
                         bitmap. If this is null, the standard HeapAllocator
                         will be used.
        @param offset If not null, it is set to top-left coordinate to position
                      the returned bitmap so that it visually lines up with the
                      original
    */
    #[link_name =
          "?extractAlpha@SkBitmap@@QEBA_NPEAV1@PEBVSkPaint@@PEAVAllocator@1@PEAUSkIPoint@@@Z"]
    pub fn SkBitmap_extractAlpha(this: *const SkBitmap, dst: *mut SkBitmap,
                                 paint: *const SkPaint,
                                 allocator: *mut SkBitmap_Allocator,
                                 offset: *mut SkIPoint) -> bool;
}
extern "C" {
    /**
     *  If the pixels are available from this bitmap (w/o locking) return true, and fill out the
     *  specified pixmap (if not null). If the pixels are not available (either because there are
     *  none, or becuase accessing them would require locking or other machinary) return false and
     *  ignore the pixmap parameter.
     *
     *  Note: if this returns true, the results (in the pixmap) are only valid until the bitmap
     *  is changed in anyway, in which case the results are invalid.
     */
    #[link_name = "?peekPixels@SkBitmap@@QEBA_NPEAVSkPixmap@@@Z"]
    pub fn SkBitmap_peekPixels(this: *const SkBitmap, arg1: *mut SkPixmap)
     -> bool;
}
extern "C" {
    #[link_name = "?validate@SkBitmap@@QEBAXXZ"]
    pub fn SkBitmap_validate(this: *const SkBitmap);
}
extern "C" {
    #[link_name = "?toString@SkBitmap@@QEBAXPEAVSkString@@@Z"]
    pub fn SkBitmap_toString(this: *const SkBitmap, str: *mut SkString);
}
impl SkBitmap {
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkBitmap) {
        SkBitmap_swap(&mut *self, other)
    }
    #[inline]
    pub unsafe fn setAlphaType(&mut self, arg1: SkAlphaType) -> bool {
        SkBitmap_setAlphaType(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn isImmutable(&self) -> bool { SkBitmap_isImmutable(&*self) }
    #[inline]
    pub unsafe fn setImmutable(&mut self) {
        SkBitmap_setImmutable(&mut *self)
    }
    #[inline]
    pub unsafe fn isVolatile(&self) -> bool { SkBitmap_isVolatile(&*self) }
    #[inline]
    pub unsafe fn setIsVolatile(&mut self, arg1: bool) {
        SkBitmap_setIsVolatile(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn reset(&mut self) { SkBitmap_reset(&mut *self) }
    #[inline]
    pub unsafe fn getBounds(&self, bounds: *mut SkRect) {
        SkBitmap_getBounds(&*self, bounds)
    }
    #[inline]
    pub unsafe fn getBounds1(&self, bounds: *mut SkIRect) {
        SkBitmap_getBounds1(&*self, bounds)
    }
    #[inline]
    pub unsafe fn setInfo(&mut self, arg1: *const SkImageInfo,
                          rowBytes: usize) -> bool {
        SkBitmap_setInfo(&mut *self, arg1, rowBytes)
    }
    #[inline]
    pub unsafe fn tryAllocPixels(&mut self, arg1: *const SkImageInfo,
                                 arg2: *mut SkPixelRefFactory,
                                 arg3: *mut SkColorTable) -> bool {
        SkBitmap_tryAllocPixels(&mut *self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn tryAllocPixels1(&mut self, info: *const SkImageInfo,
                                  rowBytes: usize) -> bool {
        SkBitmap_tryAllocPixels1(&mut *self, info, rowBytes)
    }
    #[inline]
    pub unsafe fn installPixels(&mut self, arg1: *const SkImageInfo,
                                pixels: *mut ::std::os::raw::c_void,
                                rowBytes: usize, arg2: *mut SkColorTable,
                                releaseProc:
                                    ::std::option::Option<unsafe extern "C" fn(addr:
                                                                                   *mut ::std::os::raw::c_void,
                                                                               context:
                                                                                   *mut ::std::os::raw::c_void)>,
                                context: *mut ::std::os::raw::c_void)
     -> bool {
        SkBitmap_installPixels(&mut *self, arg1, pixels, rowBytes, arg2,
                               releaseProc, context)
    }
    #[inline]
    pub unsafe fn installPixels1(&mut self, arg1: *const SkPixmap) -> bool {
        SkBitmap_installPixels1(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn installMaskPixels(&mut self, arg1: *const SkMask) -> bool {
        SkBitmap_installMaskPixels(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setPixels(&mut self, p: *mut ::std::os::raw::c_void,
                            ctable: *mut SkColorTable) {
        SkBitmap_setPixels(&mut *self, p, ctable)
    }
    #[inline]
    pub unsafe fn copyPixelsTo(&self, dst: *const ::std::os::raw::c_void,
                               dstSize: usize, dstRowBytes: usize,
                               preserveDstPad: bool) -> bool {
        SkBitmap_copyPixelsTo(&*self, dst, dstSize, dstRowBytes,
                              preserveDstPad)
    }
    #[inline]
    pub unsafe fn tryAllocPixels2(&mut self,
                                  allocator: *mut SkBitmap_Allocator,
                                  ctable: *mut SkColorTable) -> bool {
        SkBitmap_tryAllocPixels2(&mut *self, allocator, ctable)
    }
    #[inline]
    pub unsafe fn setPixelRef(&mut self, pr: *mut SkPixelRef,
                              dx: ::std::os::raw::c_int,
                              dy: ::std::os::raw::c_int) -> *mut SkPixelRef {
        SkBitmap_setPixelRef(&mut *self, pr, dx, dy)
    }
    #[inline]
    pub unsafe fn lockPixels(&self) { SkBitmap_lockPixels(&*self) }
    #[inline]
    pub unsafe fn unlockPixels(&self) { SkBitmap_unlockPixels(&*self) }
    #[inline]
    pub unsafe fn lockPixelsAreWritable(&self) -> bool {
        SkBitmap_lockPixelsAreWritable(&*self)
    }
    #[inline]
    pub unsafe fn requestLock(&self, result: *mut SkAutoPixmapUnlock)
     -> bool {
        SkBitmap_requestLock(&*self, result)
    }
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkBitmap_getGenerationID(&*self)
    }
    #[inline]
    pub unsafe fn notifyPixelsChanged(&self) {
        SkBitmap_notifyPixelsChanged(&*self)
    }
    #[inline]
    pub unsafe fn eraseColor(&self, c: SkColor) {
        SkBitmap_eraseColor(&*self, c)
    }
    #[inline]
    pub unsafe fn erase(&self, c: SkColor, area: *const SkIRect) {
        SkBitmap_erase(&*self, c, area)
    }
    #[inline]
    pub unsafe fn getAddr(&self, x: ::std::os::raw::c_int,
                          y: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void {
        SkBitmap_getAddr(&*self, x, y)
    }
    #[inline]
    pub unsafe fn extractSubset(&self, dst: *mut SkBitmap,
                                subset: *const SkIRect) -> bool {
        SkBitmap_extractSubset(&*self, dst, subset)
    }
    #[inline]
    pub unsafe fn copyTo(&self, dst: *mut SkBitmap, ct: SkColorType,
                         arg1: *mut SkBitmap_Allocator) -> bool {
        SkBitmap_copyTo(&*self, dst, ct, arg1)
    }
    #[inline]
    pub unsafe fn readPixels(&self, dstInfo: *const SkImageInfo,
                             dstPixels: *mut ::std::os::raw::c_void,
                             dstRowBytes: usize, srcX: ::std::os::raw::c_int,
                             srcY: ::std::os::raw::c_int) -> bool {
        SkBitmap_readPixels(&*self, dstInfo, dstPixels, dstRowBytes, srcX,
                            srcY)
    }
    #[inline]
    pub unsafe fn canCopyTo(&self, colorType: SkColorType) -> bool {
        SkBitmap_canCopyTo(&*self, colorType)
    }
    #[inline]
    pub unsafe fn deepCopyTo(&self, dst: *mut SkBitmap) -> bool {
        SkBitmap_deepCopyTo(&*self, dst)
    }
    #[inline]
    pub unsafe fn extractAlpha(&self, dst: *mut SkBitmap,
                               paint: *const SkPaint,
                               allocator: *mut SkBitmap_Allocator,
                               offset: *mut SkIPoint) -> bool {
        SkBitmap_extractAlpha(&*self, dst, paint, allocator, offset)
    }
    #[inline]
    pub unsafe fn peekPixels(&self, arg1: *mut SkPixmap) -> bool {
        SkBitmap_peekPixels(&*self, arg1)
    }
    #[inline]
    pub unsafe fn validate(&self) { SkBitmap_validate(&*self) }
    #[inline]
    pub unsafe fn toString(&self, str: *mut SkString) {
        SkBitmap_toString(&*self, str)
    }
}
extern "C" {
    /**
 *  Return the (c-string) name of the blendmode.
 */
    #[link_name = "?SkBlendMode_Name@@YAPEBDW4SkBlendMode@@@Z"]
    pub fn SkBlendMode_Name(arg1: SkBlendMode)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkDeque {
    pub fFront: *mut ::std::os::raw::c_void,
    pub fBack: *mut ::std::os::raw::c_void,
    pub fFrontBlock: *mut SkDeque_Block,
    pub fBackBlock: *mut SkDeque_Block,
    pub fElemSize: usize,
    pub fInitialStorage: *mut ::std::os::raw::c_void,
    pub fCount: ::std::os::raw::c_int,
    pub fAllocCount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDeque_Block {
    pub _address: u8,
}
impl Clone for SkDeque_Block {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDeque_Iter {
    pub fCurBlock: *mut SkDeque_Block,
    pub fPos: *mut ::std::os::raw::c_char,
    pub fElemSize: usize,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkDeque_Iter_IterStart { kFront_IterStart = 0, kBack_IterStart = 1, }
#[test]
fn bindgen_test_layout_SkDeque_Iter() {
    assert_eq!(::std::mem::size_of::<SkDeque_Iter>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkDeque_Iter>() , 8usize);
}
extern "C" {
    #[link_name = "?next@Iter@SkDeque@@QEAAPEAXXZ"]
    pub fn SkDeque_Iter_next(this: *mut SkDeque_Iter)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "?prev@Iter@SkDeque@@QEAAPEAXXZ"]
    pub fn SkDeque_Iter_prev(this: *mut SkDeque_Iter)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "?reset@Iter@SkDeque@@QEAAXAEBV2@W4IterStart@12@@Z"]
    pub fn SkDeque_Iter_reset(this: *mut SkDeque_Iter, d: *const SkDeque,
                              startLoc: SkDeque_Iter_IterStart);
}
impl Clone for SkDeque_Iter {
    fn clone(&self) -> Self { *self }
}
impl SkDeque_Iter {
    #[inline]
    pub unsafe fn next(&mut self) -> *mut ::std::os::raw::c_void {
        SkDeque_Iter_next(&mut *self)
    }
    #[inline]
    pub unsafe fn prev(&mut self) -> *mut ::std::os::raw::c_void {
        SkDeque_Iter_prev(&mut *self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, d: *const SkDeque,
                        startLoc: SkDeque_Iter_IterStart) {
        SkDeque_Iter_reset(&mut *self, d, startLoc)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDeque_F2BIter {
    pub _base: SkDeque_Iter,
}
pub type SkDeque_F2BIter_INHERITED = SkDeque_Iter;
#[test]
fn bindgen_test_layout_SkDeque_F2BIter() {
    assert_eq!(::std::mem::size_of::<SkDeque_F2BIter>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkDeque_F2BIter>() , 8usize);
}
impl Clone for SkDeque_F2BIter {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SkDeque() {
    assert_eq!(::std::mem::size_of::<SkDeque>() , 56usize);
    assert_eq!(::std::mem::align_of::<SkDeque>() , 8usize);
}
extern "C" {
    /**
     * push_front and push_back return a pointer to the memory space
     * for the new element
     */
    #[link_name = "?push_front@SkDeque@@QEAAPEAXXZ"]
    pub fn SkDeque_push_front(this: *mut SkDeque)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "?push_back@SkDeque@@QEAAPEAXXZ"]
    pub fn SkDeque_push_back(this: *mut SkDeque)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "?pop_front@SkDeque@@QEAAXXZ"]
    pub fn SkDeque_pop_front(this: *mut SkDeque);
}
extern "C" {
    #[link_name = "?pop_back@SkDeque@@QEAAXXZ"]
    pub fn SkDeque_pop_back(this: *mut SkDeque);
}
impl SkDeque {
    #[inline]
    pub unsafe fn push_front(&mut self) -> *mut ::std::os::raw::c_void {
        SkDeque_push_front(&mut *self)
    }
    #[inline]
    pub unsafe fn push_back(&mut self) -> *mut ::std::os::raw::c_void {
        SkDeque_push_back(&mut *self)
    }
    #[inline]
    pub unsafe fn pop_front(&mut self) { SkDeque_pop_front(&mut *self) }
    #[inline]
    pub unsafe fn pop_back(&mut self) { SkDeque_pop_back(&mut *self) }
}
#[repr(i32)]
/**
 *  Enum describing format of encoded data.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkEncodedImageFormat {
    kBMP = 0,
    kGIF = 1,
    kICO = 2,
    kJPEG = 3,
    kPNG = 4,
    kWBMP = 5,
    kWEBP = 6,
    kPKM = 7,
    kKTX = 8,
    kASTC = 9,
    kDNG = 10,
}
#[repr(C)]
pub struct SkStream__bindgen_vtable {
}
/**
 *  SkStream -- abstraction for a source of bytes. Subclasses can be backed by
 *  memory, or a file, or something else.
 *
 *  NOTE:
 *
 *  Classic "streams" APIs are sort of async, in that on a request for N
 *  bytes, they may return fewer than N bytes on a given call, in which case
 *  the caller can "try again" to get more bytes, eventually (modulo an error)
 *  receiving their total N bytes.
 *
 *  Skia streams behave differently. They are effectively synchronous, and will
 *  always return all N bytes of the request if possible. If they return fewer
 *  (the read() call returns the number of bytes read) then that means there is
 *  no more data (at EOF or hit an error). The caller should *not* call again
 *  in hopes of fulfilling more of the request.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkStream {
    pub vtable_: *const SkStream__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkStream() {
    assert_eq!(::std::mem::size_of::<SkStream>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkStream>() , 8usize);
}
extern "C" {
    /**
     *  Attempts to open the specified file as a stream, returns nullptr on failure.
     */
    #[link_name = "?MakeFromFile@SkStream@@SAHQEBD@Z"]
    pub fn SkStream_MakeFromFile(path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?readS8@SkStream@@QEAACXZ"]
    pub fn SkStream_readS8(this: *mut SkStream) -> i8;
}
extern "C" {
    #[link_name = "?readS16@SkStream@@QEAAFXZ"]
    pub fn SkStream_readS16(this: *mut SkStream) -> i16;
}
extern "C" {
    #[link_name = "?readS32@SkStream@@QEAAHXZ"]
    pub fn SkStream_readS32(this: *mut SkStream) -> i32;
}
extern "C" {
    #[link_name = "?readScalar@SkStream@@QEAAMXZ"]
    pub fn SkStream_readScalar(this: *mut SkStream) -> SkScalar;
}
extern "C" {
    #[link_name = "?readPackedUInt@SkStream@@QEAA_KXZ"]
    pub fn SkStream_readPackedUInt(this: *mut SkStream) -> usize;
}
impl SkStream {
    #[inline]
    pub unsafe fn MakeFromFile(path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int {
        SkStream_MakeFromFile(path)
    }
    #[inline]
    pub unsafe fn readS8(&mut self) -> i8 { SkStream_readS8(&mut *self) }
    #[inline]
    pub unsafe fn readS16(&mut self) -> i16 { SkStream_readS16(&mut *self) }
    #[inline]
    pub unsafe fn readS32(&mut self) -> i32 { SkStream_readS32(&mut *self) }
    #[inline]
    pub unsafe fn readScalar(&mut self) -> SkScalar {
        SkStream_readScalar(&mut *self)
    }
    #[inline]
    pub unsafe fn readPackedUInt(&mut self) -> usize {
        SkStream_readPackedUInt(&mut *self)
    }
}
/** SkStreamRewindable is a SkStream for which rewind and duplicate are required. */
#[repr(C)]
#[derive(Debug)]
pub struct SkStreamRewindable {
    pub _base: SkStream,
}
#[test]
fn bindgen_test_layout_SkStreamRewindable() {
    assert_eq!(::std::mem::size_of::<SkStreamRewindable>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkStreamRewindable>() , 8usize);
}
/** SkStreamSeekable is a SkStreamRewindable for which position, seek, move, and fork are required. */
#[repr(C)]
#[derive(Debug)]
pub struct SkStreamSeekable {
    pub _base: SkStreamRewindable,
}
#[test]
fn bindgen_test_layout_SkStreamSeekable() {
    assert_eq!(::std::mem::size_of::<SkStreamSeekable>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkStreamSeekable>() , 8usize);
}
/** SkStreamAsset is a SkStreamSeekable for which getLength is required. */
#[repr(C)]
#[derive(Debug)]
pub struct SkStreamAsset {
    pub _base: SkStreamSeekable,
}
#[test]
fn bindgen_test_layout_SkStreamAsset() {
    assert_eq!(::std::mem::size_of::<SkStreamAsset>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkStreamAsset>() , 8usize);
}
/** SkStreamMemory is a SkStreamAsset for which getMemoryBase is required. */
#[repr(C)]
#[derive(Debug)]
pub struct SkStreamMemory {
    pub _base: SkStreamAsset,
}
#[test]
fn bindgen_test_layout_SkStreamMemory() {
    assert_eq!(::std::mem::size_of::<SkStreamMemory>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkStreamMemory>() , 8usize);
}
#[repr(C)]
pub struct SkWStream__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkWStream {
    pub vtable_: *const SkWStream__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkWStream() {
    assert_eq!(::std::mem::size_of::<SkWStream>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkWStream>() , 8usize);
}
extern "C" {
    #[link_name = "?write8@SkWStream@@QEAA_NI@Z"]
    pub fn SkWStream_write8(this: *mut SkWStream, arg1: U8CPU) -> bool;
}
extern "C" {
    #[link_name = "?write16@SkWStream@@QEAA_NI@Z"]
    pub fn SkWStream_write16(this: *mut SkWStream, arg1: U16CPU) -> bool;
}
extern "C" {
    #[link_name = "?write32@SkWStream@@QEAA_NI@Z"]
    pub fn SkWStream_write32(this: *mut SkWStream, arg1: u32) -> bool;
}
extern "C" {
    #[link_name = "?writeDecAsText@SkWStream@@QEAA_NH@Z"]
    pub fn SkWStream_writeDecAsText(this: *mut SkWStream, arg1: i32) -> bool;
}
extern "C" {
    #[link_name = "?writeBigDecAsText@SkWStream@@QEAA_N_JH@Z"]
    pub fn SkWStream_writeBigDecAsText(this: *mut SkWStream, arg1: i64,
                                       minDigits: ::std::os::raw::c_int)
     -> bool;
}
extern "C" {
    #[link_name = "?writeHexAsText@SkWStream@@QEAA_NIH@Z"]
    pub fn SkWStream_writeHexAsText(this: *mut SkWStream, arg1: u32,
                                    minDigits: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "?writeScalarAsText@SkWStream@@QEAA_NM@Z"]
    pub fn SkWStream_writeScalarAsText(this: *mut SkWStream, arg1: SkScalar)
     -> bool;
}
extern "C" {
    #[link_name = "?writeScalar@SkWStream@@QEAA_NM@Z"]
    pub fn SkWStream_writeScalar(this: *mut SkWStream, arg1: SkScalar)
     -> bool;
}
extern "C" {
    #[link_name = "?writePackedUInt@SkWStream@@QEAA_N_K@Z"]
    pub fn SkWStream_writePackedUInt(this: *mut SkWStream, arg1: usize)
     -> bool;
}
extern "C" {
    #[link_name = "?writeStream@SkWStream@@QEAA_NPEAVSkStream@@_K@Z"]
    pub fn SkWStream_writeStream(this: *mut SkWStream, input: *mut SkStream,
                                 length: usize) -> bool;
}
extern "C" {
    /**
     * This returns the number of bytes in the stream required to store
     * 'value'.
     */
    #[link_name = "?SizeOfPackedUInt@SkWStream@@SAH_K@Z"]
    pub fn SkWStream_SizeOfPackedUInt(value: usize) -> ::std::os::raw::c_int;
}
impl SkWStream {
    #[inline]
    pub unsafe fn write8(&mut self, arg1: U8CPU) -> bool {
        SkWStream_write8(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn write16(&mut self, arg1: U16CPU) -> bool {
        SkWStream_write16(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn write32(&mut self, arg1: u32) -> bool {
        SkWStream_write32(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn writeDecAsText(&mut self, arg1: i32) -> bool {
        SkWStream_writeDecAsText(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn writeBigDecAsText(&mut self, arg1: i64,
                                    minDigits: ::std::os::raw::c_int)
     -> bool {
        SkWStream_writeBigDecAsText(&mut *self, arg1, minDigits)
    }
    #[inline]
    pub unsafe fn writeHexAsText(&mut self, arg1: u32,
                                 minDigits: ::std::os::raw::c_int) -> bool {
        SkWStream_writeHexAsText(&mut *self, arg1, minDigits)
    }
    #[inline]
    pub unsafe fn writeScalarAsText(&mut self, arg1: SkScalar) -> bool {
        SkWStream_writeScalarAsText(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn writeScalar(&mut self, arg1: SkScalar) -> bool {
        SkWStream_writeScalar(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn writePackedUInt(&mut self, arg1: usize) -> bool {
        SkWStream_writePackedUInt(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn writeStream(&mut self, input: *mut SkStream, length: usize)
     -> bool {
        SkWStream_writeStream(&mut *self, input, length)
    }
    #[inline]
    pub unsafe fn SizeOfPackedUInt(value: usize) -> ::std::os::raw::c_int {
        SkWStream_SizeOfPackedUInt(value)
    }
}
/** Manages an array of T elements, freeing the array in the destructor.
 *  Does NOT call any constructors/destructors on T (T must be POD).
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkAutoTMalloc<T> {
    pub fPtr: *mut T,
}
extern "C" {
    #[link_name = "?SkStrStartsWith@@YA_NQEBD0@Z"]
    pub fn SkStrStartsWith(string: *const ::std::os::raw::c_char,
                           prefixStr: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?SkStrStartsWith@@YA_NQEBDD@Z"]
    pub fn SkStrStartsWith1(string: *const ::std::os::raw::c_char,
                            prefixChar: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?SkStrEndsWith@@YA_NQEBD0@Z"]
    pub fn SkStrEndsWith(string: *const ::std::os::raw::c_char,
                         suffixStr: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?SkStrEndsWith@@YA_NQEBDD@Z"]
    pub fn SkStrEndsWith1(string: *const ::std::os::raw::c_char,
                          suffixChar: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?SkStrStartsWithOneOf@@YAHQEBD0@Z"]
    pub fn SkStrStartsWithOneOf(string: *const ::std::os::raw::c_char,
                                prefixes: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkStrFind@@YAHQEBD0@Z"]
    pub fn SkStrFind(string: *const ::std::os::raw::c_char,
                     substring: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkStrFindLastOf@@YAHQEBDD@Z"]
    pub fn SkStrFindLastOf(string: *const ::std::os::raw::c_char,
                           subchar: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkStrContains@@YA_NQEBD0@Z"]
    pub fn SkStrContains(string: *const ::std::os::raw::c_char,
                         substring: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?SkStrContains@@YA_NQEBDD@Z"]
    pub fn SkStrContains1(string: *const ::std::os::raw::c_char,
                          subchar: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?SkStrDup@@YAPEADQEBD@Z"]
    pub fn SkStrDup(string: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?SkStrAppendU32@@YAPEADQEADI@Z"]
    pub fn SkStrAppendU32(buffer: *mut ::std::os::raw::c_char, arg1: u32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?SkStrAppendU64@@YAPEADQEAD_KH@Z"]
    pub fn SkStrAppendU64(buffer: *mut ::std::os::raw::c_char, arg1: u64,
                          minDigits: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?SkStrAppendS32@@YAPEADQEADH@Z"]
    pub fn SkStrAppendS32(buffer: *mut ::std::os::raw::c_char, arg1: i32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?SkStrAppendS64@@YAPEADQEAD_JH@Z"]
    pub fn SkStrAppendS64(buffer: *mut ::std::os::raw::c_char, arg1: i64,
                          minDigits: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "?SkStrAppendFloat@@YAPEADQEADM@Z"]
    pub fn SkStrAppendFloat(buffer: *mut ::std::os::raw::c_char, arg1: f32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Creates a new string and writes into it using a printf()-style format.
    #[link_name = "?SkStringPrintf@@YA?AVSkString@@PEBDZZ"]
    pub fn SkStringPrintf(format: *const ::std::os::raw::c_char)
     -> SkString;
}
extern "C" {
    #[link_name = "?SkTSwap@@YAXAEAVSkString@@0@Z"]
    pub fn SkTSwap(a: *mut SkString, b: *mut SkString);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkStrSplitMode {
    kStrict_SkStrSplitMode = 0,
    kCoalesce_SkStrSplitMode = 1,
}
extern "C" {
    #[link_name = "?SkStrSplit@@YAXPEBD0W4SkStrSplitMode@@PEAH@Z"]
    pub fn SkStrSplit(str: *const ::std::os::raw::c_char,
                      delimiters: *const ::std::os::raw::c_char,
                      splitMode: SkStrSplitMode,
                      out: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?SkStrSplit@@YAXPEBD0PEAH@Z"]
    pub fn SkStrSplit1(str: *const ::std::os::raw::c_char,
                       delimiters: *const ::std::os::raw::c_char,
                       out: *mut ::std::os::raw::c_int);
}
/** A stream that wraps a C FILE* file stream. */
#[repr(C)]
#[derive(Debug)]
pub struct SkFILEStream {
    pub _base: SkStreamAsset,
    pub fFILE: *mut FILE,
    pub fName: SkString,
    pub fOwnership: SkFILEStream_Ownership,
    pub fData: sk_sp<SkData>,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkFILEStream_Ownership {
    kCallerPasses_Ownership = 0,
    kCallerRetains_Ownership = 1,
}
pub type SkFILEStream_INHERITED = SkStreamAsset;
#[test]
fn bindgen_test_layout_SkFILEStream() {
    assert_eq!(::std::mem::size_of::<SkFILEStream>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkFILEStream>() , 1usize);
}
extern "C" {
    /** Close the current file, and open a new file with the specified path.
     *  If path is NULL, just close the current file.
     */
    #[link_name = "?setPath@SkFILEStream@@QEAAXQEBD@Z"]
    pub fn SkFILEStream_setPath(this: *mut SkFILEStream,
                                path: *const ::std::os::raw::c_char);
}
impl SkFILEStream {
    #[inline]
    pub unsafe fn setPath(&mut self, path: *const ::std::os::raw::c_char) {
        SkFILEStream_setPath(&mut *self, path)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkMemoryStream {
    pub _base: SkStreamMemory,
    pub fData: sk_sp<SkData>,
    pub fOffset: usize,
}
pub type SkMemoryStream_INHERITED = SkStreamMemory;
#[test]
fn bindgen_test_layout_SkMemoryStream() {
    assert_eq!(::std::mem::size_of::<SkMemoryStream>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkMemoryStream>() , 1usize);
}
extern "C" {
    /** Replace any memory buffer with the specified buffer. The caller
        must have allocated data with sk_malloc or sk_realloc, since it
        will be freed with sk_free.
    */
    #[link_name = "?setMemoryOwned@SkMemoryStream@@QEAAXPEBX_K@Z"]
    pub fn SkMemoryStream_setMemoryOwned(this: *mut SkMemoryStream,
                                         data: *const ::std::os::raw::c_void,
                                         length: usize);
}
extern "C" {
    #[link_name = "?setData@SkMemoryStream@@QEAAXV?$sk_sp@VSkData@@@@@Z"]
    pub fn SkMemoryStream_setData(this: *mut SkMemoryStream,
                                  arg1: sk_sp<SkData>);
}
extern "C" {
    #[link_name = "?skipToAlign4@SkMemoryStream@@QEAAXXZ"]
    pub fn SkMemoryStream_skipToAlign4(this: *mut SkMemoryStream);
}
extern "C" {
    #[link_name = "?getAtPos@SkMemoryStream@@QEAAPEBXXZ"]
    pub fn SkMemoryStream_getAtPos(this: *mut SkMemoryStream)
     -> *const ::std::os::raw::c_void;
}
impl SkMemoryStream {
    #[inline]
    pub unsafe fn setMemoryOwned(&mut self,
                                 data: *const ::std::os::raw::c_void,
                                 length: usize) {
        SkMemoryStream_setMemoryOwned(&mut *self, data, length)
    }
    #[inline]
    pub unsafe fn setData(&mut self, arg1: sk_sp<SkData>) {
        SkMemoryStream_setData(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn skipToAlign4(&mut self) {
        SkMemoryStream_skipToAlign4(&mut *self)
    }
    #[inline]
    pub unsafe fn getAtPos(&mut self) -> *const ::std::os::raw::c_void {
        SkMemoryStream_getAtPos(&mut *self)
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
#[repr(C)]
#[derive(Debug)]
pub struct SkFILEWStream {
    pub _base: SkWStream,
    pub fFILE: *mut FILE,
}
pub type SkFILEWStream_INHERITED = SkWStream;
#[test]
fn bindgen_test_layout_SkFILEWStream() {
    assert_eq!(::std::mem::size_of::<SkFILEWStream>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkFILEWStream>() , 8usize);
}
extern "C" {
    #[link_name = "?fsync@SkFILEWStream@@QEAAXXZ"]
    pub fn SkFILEWStream_fsync(this: *mut SkFILEWStream);
}
impl SkFILEWStream {
    #[inline]
    pub unsafe fn fsync(&mut self) { SkFILEWStream_fsync(&mut *self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkDynamicMemoryWStream {
    pub _base: SkWStream,
    pub fHead: *mut SkDynamicMemoryWStream_Block,
    pub fTail: *mut SkDynamicMemoryWStream_Block,
    pub fBytesWritten: usize,
    pub fCopy: sk_sp<SkData>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDynamicMemoryWStream_Block {
    pub _address: u8,
}
impl Clone for SkDynamicMemoryWStream_Block {
    fn clone(&self) -> Self { *self }
}
pub type SkDynamicMemoryWStream_INHERITED = SkWStream;
#[test]
fn bindgen_test_layout_SkDynamicMemoryWStream() {
    assert_eq!(::std::mem::size_of::<SkDynamicMemoryWStream>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkDynamicMemoryWStream>() , 1usize);
}
extern "C" {
    #[link_name = "?write@SkDynamicMemoryWStream@@QEAA_NPEBX_K1@Z"]
    pub fn SkDynamicMemoryWStream_write1(this: *mut SkDynamicMemoryWStream,
                                         buffer:
                                             *const ::std::os::raw::c_void,
                                         offset: usize, size: usize) -> bool;
}
extern "C" {
    #[link_name = "?read@SkDynamicMemoryWStream@@QEAA_NPEAX_K1@Z"]
    pub fn SkDynamicMemoryWStream_read(this: *mut SkDynamicMemoryWStream,
                                       buffer: *mut ::std::os::raw::c_void,
                                       offset: usize, size: usize) -> bool;
}
extern "C" {
    #[link_name = "?copyTo@SkDynamicMemoryWStream@@QEBAXPEAX@Z"]
    pub fn SkDynamicMemoryWStream_copyTo(this: *const SkDynamicMemoryWStream,
                                         dst: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name =
          "?writeToStream@SkDynamicMemoryWStream@@QEBAXPEAVSkWStream@@@Z"]
    pub fn SkDynamicMemoryWStream_writeToStream(this:
                                                    *const SkDynamicMemoryWStream,
                                                dst: *mut SkWStream);
}
extern "C" {
    #[link_name =
          "?snapshotAsData@SkDynamicMemoryWStream@@QEBA?AV?$sk_sp@VSkData@@@@XZ"]
    pub fn SkDynamicMemoryWStream_snapshotAsData(this:
                                                     *const SkDynamicMemoryWStream)
     -> sk_sp<SkData>;
}
extern "C" {
    #[link_name =
          "?detachAsData@SkDynamicMemoryWStream@@QEAA?AV?$sk_sp@VSkData@@@@XZ"]
    pub fn SkDynamicMemoryWStream_detachAsData(this:
                                                   *mut SkDynamicMemoryWStream)
     -> sk_sp<SkData>;
}
extern "C" {
    /** Reset, returning a reader stream with the current content. */
    #[link_name =
          "?detachAsStream@SkDynamicMemoryWStream@@QEAAPEAVSkStreamAsset@@XZ"]
    pub fn SkDynamicMemoryWStream_detachAsStream(this:
                                                     *mut SkDynamicMemoryWStream)
     -> *mut SkStreamAsset;
}
extern "C" {
    /** Reset the stream to its original, empty, state. */
    #[link_name = "?reset@SkDynamicMemoryWStream@@QEAAXXZ"]
    pub fn SkDynamicMemoryWStream_reset(this: *mut SkDynamicMemoryWStream);
}
extern "C" {
    #[link_name = "?padToAlign4@SkDynamicMemoryWStream@@QEAAXXZ"]
    pub fn SkDynamicMemoryWStream_padToAlign4(this:
                                                  *mut SkDynamicMemoryWStream);
}
impl SkDynamicMemoryWStream {
    #[inline]
    pub unsafe fn write(&mut self, buffer: *const ::std::os::raw::c_void,
                        offset: usize, size: usize) -> bool {
        SkDynamicMemoryWStream_write1(&mut *self, buffer, offset, size)
    }
    #[inline]
    pub unsafe fn read(&mut self, buffer: *mut ::std::os::raw::c_void,
                       offset: usize, size: usize) -> bool {
        SkDynamicMemoryWStream_read(&mut *self, buffer, offset, size)
    }
    #[inline]
    pub unsafe fn copyTo(&self, dst: *mut ::std::os::raw::c_void) {
        SkDynamicMemoryWStream_copyTo(&*self, dst)
    }
    #[inline]
    pub unsafe fn writeToStream(&self, dst: *mut SkWStream) {
        SkDynamicMemoryWStream_writeToStream(&*self, dst)
    }
    #[inline]
    pub unsafe fn snapshotAsData(&self) -> sk_sp<SkData> {
        SkDynamicMemoryWStream_snapshotAsData(&*self)
    }
    #[inline]
    pub unsafe fn detachAsData(&mut self) -> sk_sp<SkData> {
        SkDynamicMemoryWStream_detachAsData(&mut *self)
    }
    #[inline]
    pub unsafe fn detachAsStream(&mut self) -> *mut SkStreamAsset {
        SkDynamicMemoryWStream_detachAsStream(&mut *self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkDynamicMemoryWStream_reset(&mut *self)
    }
    #[inline]
    pub unsafe fn padToAlign4(&mut self) {
        SkDynamicMemoryWStream_padToAlign4(&mut *self)
    }
}
extern "C" {
    /**
 * Encode SkPixmap in the given binary image format.
 *
 * @param  dst     results are written to this stream.
 * @param  src     source pixels.
 * @param  format  image format, not all formats are supported.
 * @param  quality range from 0-100, not all formats respect quality.
 *
 * @return false iff input is bad or format is unsupported.
 *
 * Will always return false if Skia is compiled without image
 * encoders.
 *
 * For examples of encoding an image to a file or to a block of memory,
 * see tools/sk_tool_utils.h.
 */
    #[link_name =
          "?SkEncodeImage@@YA_NPEAVSkWStream@@AEBVSkPixmap@@W4SkEncodedImageFormat@@H@Z"]
    pub fn SkEncodeImage(dst: *mut SkWStream, src: *const SkPixmap,
                         format: SkEncodedImageFormat,
                         quality: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
 * The following helper function wraps SkEncodeImage().
 */
    #[link_name =
          "?SkEncodeImage@@YA_NPEAVSkWStream@@AEBVSkBitmap@@W4SkEncodedImageFormat@@H@Z"]
    pub fn SkEncodeImage1(dst: *mut SkWStream, src: *const SkBitmap,
                          f: SkEncodedImageFormat, q: ::std::os::raw::c_int)
     -> bool;
}
/**
 *  ColorFilters are optional objects in the drawing pipeline. When present in
 *  a paint, they are called with the "src" colors, and return new colors, which
 *  are then passed onto the next stage (either ImageFilter or Xfermode).
 *
 *  All subclasses are required to be reentrant-safe : it must be legal to share
 *  the same instance between several threads.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkColorFilter {
    pub _base: SkFlattenable,
}
pub const SkColorFilter_Flags_kAlphaUnchanged_Flag: SkColorFilter_Flags =
    SkColorFilter_Flags(1);
impl ::std::ops::BitOr<SkColorFilter_Flags> for SkColorFilter_Flags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkColorFilter_Flags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkColorFilter_Flags(pub i32);
pub type SkColorFilter_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkColorFilter() {
    assert_eq!(::std::mem::size_of::<SkColorFilter>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkColorFilter>() , 1usize);
}
extern "C" {
    #[link_name =
          "?appendStages@SkColorFilter@@QEBA_NPEAVSkRasterPipeline@@PEAVSkColorSpace@@PEAVSkFallbackAlloc@@_N@Z"]
    pub fn SkColorFilter_appendStages(this: *const SkColorFilter,
                                      arg1: *mut SkRasterPipeline,
                                      arg2: *mut SkColorSpace,
                                      arg3: *mut SkFallbackAlloc,
                                      shaderIsOpaque: bool) -> bool;
}
extern "C" {
    /**
     *  Apply this colorfilter to the specified SkColor. This routine handles
     *  converting to SkPMColor, calling the filter, and then converting back
     *  to SkColor. This method is not virtual, but will call filterSpan()
     *   which is virtual.
     */
    #[link_name = "?filterColor@SkColorFilter@@QEBAII@Z"]
    pub fn SkColorFilter_filterColor(this: *const SkColorFilter,
                                     arg1: SkColor) -> SkColor;
}
extern "C" {
    /**
     *  Filters a single color.
     */
    #[link_name = "?filterColor4f@SkColorFilter@@QEBA?AUSkColor4f@@AEBU2@@Z"]
    pub fn SkColorFilter_filterColor4f(this: *const SkColorFilter,
                                       arg1: *const SkColor4f) -> SkColor4f;
}
extern "C" {
    /** Create a colorfilter that uses the specified color and mode.
        If the Mode is DST, this function will return NULL (since that
        mode will have no effect on the result).
        @param c    The source color used with the specified mode
        @param mode The blend that is applied to each color in
                        the colorfilter's filterSpan[16,32] methods
        @return colorfilter object that applies the src color and mode,
                    or NULL if the mode will have no effect.
    */
    #[link_name =
          "?MakeModeFilter@SkColorFilter@@SA?AV?$sk_sp@VSkColorFilter@@@@IW4SkBlendMode@@@Z"]
    pub fn SkColorFilter_MakeModeFilter(c: SkColor, mode: SkBlendMode)
     -> sk_sp<SkColorFilter>;
}
extern "C" {
    /** Construct a colorfilter whose effect is to first apply the inner filter and then apply
     *  the outer filter to the result of the inner's.
     *  The reference counts for outer and inner are incremented.
     *
     *  Due to internal limits, it is possible that this will return NULL, so the caller must
     *  always check.
     */
    #[link_name =
          "?MakeComposeFilter@SkColorFilter@@SA?AV?$sk_sp@VSkColorFilter@@@@V2@0@Z"]
    pub fn SkColorFilter_MakeComposeFilter(outer: sk_sp<SkColorFilter>,
                                           inner: sk_sp<SkColorFilter>)
     -> sk_sp<SkColorFilter>;
}
extern "C" {
    /** Construct a color filter that transforms a color by a 4x5 matrix. The matrix is in row-
     *  major order and the translation column is specified in unnormalized, 0...255, space.
     */
    #[link_name =
          "?MakeMatrixFilterRowMajor255@SkColorFilter@@SA?AV?$sk_sp@VSkColorFilter@@@@QEBM@Z"]
    pub fn SkColorFilter_MakeMatrixFilterRowMajor255(array: *mut SkScalar)
     -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "?InitializeFlattenables@SkColorFilter@@SAXXZ"]
    pub fn SkColorFilter_InitializeFlattenables();
}
impl SkColorFilter {
    #[inline]
    pub unsafe fn appendStages(&self, arg1: *mut SkRasterPipeline,
                               arg2: *mut SkColorSpace,
                               arg3: *mut SkFallbackAlloc,
                               shaderIsOpaque: bool) -> bool {
        SkColorFilter_appendStages(&*self, arg1, arg2, arg3, shaderIsOpaque)
    }
    #[inline]
    pub unsafe fn filterColor(&self, arg1: SkColor) -> SkColor {
        SkColorFilter_filterColor(&*self, arg1)
    }
    #[inline]
    pub unsafe fn filterColor4f(&self, arg1: *const SkColor4f) -> SkColor4f {
        SkColorFilter_filterColor4f(&*self, arg1)
    }
    #[inline]
    pub unsafe fn MakeModeFilter(c: SkColor, mode: SkBlendMode)
     -> sk_sp<SkColorFilter> {
        SkColorFilter_MakeModeFilter(c, mode)
    }
    #[inline]
    pub unsafe fn MakeComposeFilter(outer: sk_sp<SkColorFilter>,
                                    inner: sk_sp<SkColorFilter>)
     -> sk_sp<SkColorFilter> {
        SkColorFilter_MakeComposeFilter(outer, inner)
    }
    #[inline]
    pub unsafe fn MakeMatrixFilterRowMajor255(array: *mut SkScalar)
     -> sk_sp<SkColorFilter> {
        SkColorFilter_MakeMatrixFilterRowMajor255(array)
    }
    #[inline]
    pub unsafe fn InitializeFlattenables() {
        SkColorFilter_InitializeFlattenables()
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDescriptor {
    pub _address: u8,
}
impl Clone for SkDescriptor {
    fn clone(&self) -> Self { *self }
}
/** \class SkDrawLooper
    Subclasses of SkDrawLooper can be attached to a SkPaint. Where they are,
    and something is drawn to a canvas with that paint, the looper subclass will
    be called, allowing it to modify the canvas and/or paint for that draw call.
    More than that, via the next() method, the looper can modify the draw to be
    invoked multiple times (hence the name loop-er), allow it to perform effects
    like shadows or frame/fills, that require more than one pass.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkDrawLooper {
    pub _base: SkFlattenable,
}
#[repr(C)]
pub struct SkDrawLooper_Context__bindgen_vtable {
}
/**
     *  Holds state during a draw. Users call next() until it returns false.
     *
     *  Subclasses of SkDrawLooper should create a subclass of this object to
     *  hold state specific to their subclass.
     */
#[repr(C)]
#[derive(Debug)]
pub struct SkDrawLooper_Context {
    pub vtable_: *const SkDrawLooper_Context__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkDrawLooper_Context() {
    assert_eq!(::std::mem::size_of::<SkDrawLooper_Context>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkDrawLooper_Context>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDrawLooper_BlurShadowRec {
    pub fSigma: SkScalar,
    pub fOffset: SkVector,
    pub fColor: SkColor,
    pub fStyle: SkBlurStyle,
    pub fQuality: SkBlurQuality,
}
#[test]
fn bindgen_test_layout_SkDrawLooper_BlurShadowRec() {
    assert_eq!(::std::mem::size_of::<SkDrawLooper_BlurShadowRec>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkDrawLooper_BlurShadowRec>() , 4usize);
}
impl Clone for SkDrawLooper_BlurShadowRec {
    fn clone(&self) -> Self { *self }
}
pub type SkDrawLooper_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkDrawLooper() {
    assert_eq!(::std::mem::size_of::<SkDrawLooper>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkDrawLooper>() , 1usize);
}
extern "C" {
    /**
     * The fast bounds functions are used to enable the paint to be culled early
     * in the drawing pipeline. If a subclass can support this feature it must
     * return true for the canComputeFastBounds() function.  If that function
     * returns false then computeFastBounds behavior is undefined otherwise it
     * is expected to have the following behavior. Given the parent paint and
     * the parent's bounding rect the subclass must fill in and return the
     * storage rect, where the storage rect is with the union of the src rect
     * and the looper's bounding rect.
     */
    #[link_name = "?canComputeFastBounds@SkDrawLooper@@QEBA_NAEBVSkPaint@@@Z"]
    pub fn SkDrawLooper_canComputeFastBounds(this: *const SkDrawLooper,
                                             paint: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name =
          "?computeFastBounds@SkDrawLooper@@QEBAXAEBVSkPaint@@AEBUSkRect@@PEAU3@@Z"]
    pub fn SkDrawLooper_computeFastBounds(this: *const SkDrawLooper,
                                          paint: *const SkPaint,
                                          src: *const SkRect,
                                          dst: *mut SkRect);
}
impl SkDrawLooper {
    #[inline]
    pub unsafe fn canComputeFastBounds(&self, paint: *const SkPaint) -> bool {
        SkDrawLooper_canComputeFastBounds(&*self, paint)
    }
    #[inline]
    pub unsafe fn computeFastBounds(&self, paint: *const SkPaint,
                                    src: *const SkRect, dst: *mut SkRect) {
        SkDrawLooper_computeFastBounds(&*self, paint, src, dst)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkGlyph {
    pub _address: u8,
}
impl Clone for SkGlyph {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkGlyphCache {
    pub _address: u8,
}
impl Clone for SkGlyphCache {
    fn clone(&self) -> Self { *self }
}
/**
 *  Base class for image filters. If one is installed in the paint, then
 *  all drawing occurs as usual, but it is as if the drawing happened into an
 *  offscreen (before the xfermode is applied). This offscreen bitmap will
 *  then be handed to the imagefilter, who in turn creates a new bitmap which
 *  is what will finally be drawn to the device (using the original xfermode).
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkImageFilter {
    pub _base: SkFlattenable,
    pub fInputs: (),
    pub fUsesSrcInput: bool,
    pub fCropRect: SkImageFilter_CropRect,
    pub fUniqueID: u32,
    pub fCacheKeys: ::std::os::raw::c_int,
    pub fMutex: SkMutex,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkImageFilter_OutputProperties {
    pub fColorSpace: *mut SkColorSpace,
}
#[test]
fn bindgen_test_layout_SkImageFilter_OutputProperties() {
    assert_eq!(::std::mem::size_of::<SkImageFilter_OutputProperties>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<SkImageFilter_OutputProperties>() ,
               8usize);
}
impl Clone for SkImageFilter_OutputProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkImageFilter_Context {
    pub fCTM: SkMatrix,
    pub fClipBounds: SkIRect,
    pub fCache: *mut SkImageFilterCache,
    pub fOutputProperties: SkImageFilter_OutputProperties,
}
#[test]
fn bindgen_test_layout_SkImageFilter_Context() {
    assert_eq!(::std::mem::size_of::<SkImageFilter_Context>() , 72usize);
    assert_eq!(::std::mem::align_of::<SkImageFilter_Context>() , 8usize);
}
impl Clone for SkImageFilter_Context {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkImageFilter_CropRect {
    pub fRect: SkRect,
    pub fFlags: u32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkImageFilter_CropRect_CropEdge {
    kHasLeft_CropEdge = 1,
    kHasTop_CropEdge = 2,
    kHasWidth_CropEdge = 4,
    kHasHeight_CropEdge = 8,
    kHasAll_CropEdge = 15,
}
#[test]
fn bindgen_test_layout_SkImageFilter_CropRect() {
    assert_eq!(::std::mem::size_of::<SkImageFilter_CropRect>() , 20usize);
    assert_eq!(::std::mem::align_of::<SkImageFilter_CropRect>() , 4usize);
}
extern "C" {
    #[link_name = "?toString@CropRect@SkImageFilter@@QEBAXPEAVSkString@@@Z"]
    pub fn SkImageFilter_CropRect_toString(this:
                                               *const SkImageFilter_CropRect,
                                           str: *mut SkString);
}
extern "C" {
    /**
         *  Apply this cropRect to the imageBounds. If a given edge of the cropRect is not
         *  set, then the corresponding edge from imageBounds will be used. If "embiggen"
         *  is true, the crop rect is allowed to enlarge the size of the rect, otherwise
         *  it may only reduce the rect. Filters that can affect transparent black should 
         *  pass "true", while all other filters should pass "false".
         *
         *  Note: imageBounds is in "device" space, as the output cropped rectangle will be,
         *  so the matrix is ignored for those. It is only applied the croprect's bounds.
         */
    #[link_name =
          "?applyTo@CropRect@SkImageFilter@@QEBAXAEBUSkIRect@@AEBVSkMatrix@@_NPEAU3@@Z"]
    pub fn SkImageFilter_CropRect_applyTo(this: *const SkImageFilter_CropRect,
                                          imageBounds: *const SkIRect,
                                          arg1: *const SkMatrix,
                                          embiggen: bool,
                                          cropped: *mut SkIRect);
}
impl Clone for SkImageFilter_CropRect {
    fn clone(&self) -> Self { *self }
}
impl SkImageFilter_CropRect {
    #[inline]
    pub unsafe fn toString(&self, str: *mut SkString) {
        SkImageFilter_CropRect_toString(&*self, str)
    }
    #[inline]
    pub unsafe fn applyTo(&self, imageBounds: *const SkIRect,
                          arg1: *const SkMatrix, embiggen: bool,
                          cropped: *mut SkIRect) {
        SkImageFilter_CropRect_applyTo(&*self, imageBounds, arg1, embiggen,
                                       cropped)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkImageFilter_TileUsage {
    kPossible_TileUsage = 0,
    kNever_TileUsage = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkImageFilter_MapDirection {
    kForward_MapDirection = 0,
    kReverse_MapDirection = 1,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkImageFilter_Common {
    pub fCropRect: SkImageFilter_CropRect,
    pub fInputs: (),
}
#[test]
fn bindgen_test_layout_SkImageFilter_Common() {
    assert_eq!(::std::mem::size_of::<SkImageFilter_Common>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkImageFilter_Common>() , 1usize);
}
extern "C" {
    /**
         *  Attempt to unflatten the cropRect and the expected number of input filters.
         *  If any number of input filters is valid, pass -1.
         *  If this fails (i.e. corrupt buffer or contents) then return false and common will
         *  be left uninitialized.
         *  If this returns true, then inputCount() is the number of found input filters, each
         *  of which may be NULL or a valid imagefilter.
         */
    #[link_name =
          "?unflatten@Common@SkImageFilter@@QEAA_NAEAVSkReadBuffer@@H@Z"]
    pub fn SkImageFilter_Common_unflatten(this: *mut SkImageFilter_Common,
                                          arg1: *mut SkReadBuffer,
                                          expectedInputs:
                                              ::std::os::raw::c_int) -> bool;
}
impl SkImageFilter_Common {
    #[inline]
    pub unsafe fn unflatten(&mut self, arg1: *mut SkReadBuffer,
                            expectedInputs: ::std::os::raw::c_int) -> bool {
        SkImageFilter_Common_unflatten(&mut *self, arg1, expectedInputs)
    }
}
pub type SkImageFilter_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkImageFilter() {
    assert_eq!(::std::mem::size_of::<SkImageFilter>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkImageFilter>() , 1usize);
}
extern "C" {
    /**
     *  Request a new filtered image to be created from the src image.
     *
     *  The context contains the environment in which the filter is occurring.
     *  It includes the clip bounds, CTM and cache.
     *
     *  Offset is the amount to translate the resulting image relative to the
     *  src when it is drawn. This is an out-param.
     *
     *  If the result image cannot be created, or the result would be
     *  transparent black, return null, in which case the offset parameter
     *  should be ignored by the caller.
     *
     *  TODO: Right now the imagefilters sometimes return empty result bitmaps/
     *        specialimages. That doesn't seem quite right.
     */
    #[link_name =
          "?filterImage@SkImageFilter@@QEBA?AV?$sk_sp@VSkSpecialImage@@@@PEAVSkSpecialImage@@AEBVContext@1@PEAUSkIPoint@@@Z"]
    pub fn SkImageFilter_filterImage(this: *const SkImageFilter,
                                     src: *mut SkSpecialImage,
                                     arg1: *const SkImageFilter_Context,
                                     offset: *mut SkIPoint)
     -> sk_sp<SkSpecialImage>;
}
extern "C" {
    /**
     * Map a device-space rect recursively forward or backward through the
     * filter DAG. kForward_MapDirection is used to determine which pixels of
     * the destination canvas a source image rect would touch after filtering.
     * kReverse_MapDirection is used to determine which rect of the source
     * image would be required to fill the given rect (typically, clip bounds).
     * Used for clipping and temp-buffer allocations, so the result need not
     * be exact, but should never be smaller than the real answer. The default
     * implementation recursively unions all input bounds, or returns the
     * source rect if no inputs.
     */
    #[link_name =
          "?filterBounds@SkImageFilter@@QEBA?AUSkIRect@@AEBU2@AEBVSkMatrix@@W4MapDirection@1@@Z"]
    pub fn SkImageFilter_filterBounds(this: *const SkImageFilter,
                                      src: *const SkIRect,
                                      ctm: *const SkMatrix,
                                      arg1: SkImageFilter_MapDirection)
     -> SkIRect;
}
extern "C" {
    #[link_name =
          "?DrawWithFP@SkImageFilter@@SA?AV?$sk_sp@VSkSpecialImage@@@@PEAVGrContext@@V?$sk_sp@VGrFragmentProcessor@@@@AEBUSkIRect@@AEBVOutputProperties@1@@Z"]
    pub fn SkImageFilter_DrawWithFP(context: *mut GrContext,
                                    fp: sk_sp<GrFragmentProcessor>,
                                    bounds: *const SkIRect,
                                    outputProperties:
                                        *const SkImageFilter_OutputProperties)
     -> sk_sp<SkSpecialImage>;
}
extern "C" {
    #[link_name =
          "?MakeBlur@SkImageFilter@@SA?AV?$sk_sp@VSkImageFilter@@@@MMV2@PEBVCropRect@1@@Z"]
    pub fn SkImageFilter_MakeBlur(sigmaX: SkScalar, sigmaY: SkScalar,
                                  input: sk_sp<SkImageFilter>,
                                  cropRect: *const SkImageFilter_CropRect)
     -> sk_sp<SkImageFilter>;
}
extern "C" {
    /**
     *  Returns true (and optionally returns a ref'd filter) if this imagefilter can be completely
     *  replaced by the returned colorfilter. i.e. the two effects will affect drawing in the
     *  same way.
     */
    #[link_name =
          "?asAColorFilter@SkImageFilter@@QEBA_NPEAPEAVSkColorFilter@@@Z"]
    pub fn SkImageFilter_asAColorFilter(this: *const SkImageFilter,
                                        filterPtr: *mut *mut SkColorFilter)
     -> bool;
}
extern "C" {
    #[link_name = "?canComputeFastBounds@SkImageFilter@@QEBA_NXZ"]
    pub fn SkImageFilter_canComputeFastBounds(this: *const SkImageFilter)
     -> bool;
}
extern "C" {
    /**
     *  If this filter can be represented by another filter + a localMatrix, return that filter,
     *  else return null.
     */
    #[link_name =
          "?makeWithLocalMatrix@SkImageFilter@@QEBA?AV?$sk_sp@VSkImageFilter@@@@AEBVSkMatrix@@@Z"]
    pub fn SkImageFilter_makeWithLocalMatrix(this: *const SkImageFilter,
                                             arg1: *const SkMatrix)
     -> sk_sp<SkImageFilter>;
}
extern "C" {
    /**
     *  ImageFilters can natively handle scaling and translate components in the CTM. Only some of
     *  them can handle affine (or more complex) matrices. This call returns true iff the filter
     *  and all of its (non-null) inputs can handle these more complex matrices.
     */
    #[link_name = "?canHandleComplexCTM@SkImageFilter@@QEBA_NXZ"]
    pub fn SkImageFilter_canHandleComplexCTM(this: *const SkImageFilter)
     -> bool;
}
extern "C" {
    /**
     * Return an imagefilter which transforms its input by the given matrix.
     */
    #[link_name =
          "?MakeMatrixFilter@SkImageFilter@@SA?AV?$sk_sp@VSkImageFilter@@@@AEBVSkMatrix@@W4SkFilterQuality@@V2@@Z"]
    pub fn SkImageFilter_MakeMatrixFilter(matrix: *const SkMatrix,
                                          quality: SkFilterQuality,
                                          input: sk_sp<SkImageFilter>)
     -> sk_sp<SkImageFilter>;
}
extern "C" {
    #[link_name = "?InitializeFlattenables@SkImageFilter@@SAXXZ"]
    pub fn SkImageFilter_InitializeFlattenables();
}
extern "C" {
    #[link_name =
          "?filterInput@SkImageFilter@@IEBA?AV?$sk_sp@VSkSpecialImage@@@@HPEAVSkSpecialImage@@AEBVContext@1@PEAUSkIPoint@@@Z"]
    pub fn SkImageFilter_filterInput(this: *const SkImageFilter,
                                     index: ::std::os::raw::c_int,
                                     src: *mut SkSpecialImage,
                                     arg1: *const SkImageFilter_Context,
                                     offset: *mut SkIPoint)
     -> sk_sp<SkSpecialImage>;
}
extern "C" {
    /** Given a "srcBounds" rect, computes destination bounds for this filter.
     *  "dstBounds" are computed by transforming the crop rect by the context's
     *  CTM, applying it to the initial bounds, and intersecting the result with
     *  the context's clip bounds.  "srcBounds" (if non-null) are computed by
     *  intersecting the initial bounds with "dstBounds", to ensure that we never
     *  sample outside of the crop rect (this restriction may be relaxed in the
     *  future).
     */
    #[link_name =
          "?applyCropRect@SkImageFilter@@IEBA_NAEBVContext@1@AEBUSkIRect@@PEAU3@@Z"]
    pub fn SkImageFilter_applyCropRect(this: *const SkImageFilter,
                                       arg1: *const SkImageFilter_Context,
                                       srcBounds: *const SkIRect,
                                       dstBounds: *mut SkIRect) -> bool;
}
extern "C" {
    /** A variant of the above call which takes the original source bitmap and
     *  source offset. If the resulting crop rect is not entirely contained by
     *  the source bitmap's bounds, it creates a new bitmap in "result" and
     *  pads the edges with transparent black. In that case, the srcOffset is
     *  modified to be the same as the bounds, since no further adjustment is
     *  needed by the caller. This version should only be used by filters
     *  which are not capable of processing a smaller source bitmap into a
     *  larger destination.
     */
    #[link_name =
          "?applyCropRect@SkImageFilter@@IEBA?AV?$sk_sp@VSkSpecialImage@@@@AEBVContext@1@PEAVSkSpecialImage@@PEAUSkIPoint@@PEAUSkIRect@@@Z"]
    pub fn SkImageFilter_applyCropRect1(this: *const SkImageFilter,
                                        arg1: *const SkImageFilter_Context,
                                        src: *mut SkSpecialImage,
                                        srcOffset: *mut SkIPoint,
                                        bounds: *mut SkIRect)
     -> sk_sp<SkSpecialImage>;
}
extern "C" {
    /**
     *  Creates a modified Context for use when recursing up the image filter DAG.
     *  The clip bounds are adjusted to accommodate any margins that this
     *  filter requires by calling this node's
     *  onFilterNodeBounds(..., kReverse_MapDirection).
     */
    #[link_name = "?mapContext@SkImageFilter@@IEBA?AVContext@1@AEBV21@@Z"]
    pub fn SkImageFilter_mapContext(this: *const SkImageFilter,
                                    ctx: *const SkImageFilter_Context)
     -> SkImageFilter_Context;
}
impl SkImageFilter {
    #[inline]
    pub unsafe fn filterImage(&self, src: *mut SkSpecialImage,
                              arg1: *const SkImageFilter_Context,
                              offset: *mut SkIPoint)
     -> sk_sp<SkSpecialImage> {
        SkImageFilter_filterImage(&*self, src, arg1, offset)
    }
    #[inline]
    pub unsafe fn filterBounds(&self, src: *const SkIRect,
                               ctm: *const SkMatrix,
                               arg1: SkImageFilter_MapDirection) -> SkIRect {
        SkImageFilter_filterBounds(&*self, src, ctm, arg1)
    }
    #[inline]
    pub unsafe fn DrawWithFP(context: *mut GrContext,
                             fp: sk_sp<GrFragmentProcessor>,
                             bounds: *const SkIRect,
                             outputProperties:
                                 *const SkImageFilter_OutputProperties)
     -> sk_sp<SkSpecialImage> {
        SkImageFilter_DrawWithFP(context, fp, bounds, outputProperties)
    }
    #[inline]
    pub unsafe fn MakeBlur(sigmaX: SkScalar, sigmaY: SkScalar,
                           input: sk_sp<SkImageFilter>,
                           cropRect: *const SkImageFilter_CropRect)
     -> sk_sp<SkImageFilter> {
        SkImageFilter_MakeBlur(sigmaX, sigmaY, input, cropRect)
    }
    #[inline]
    pub unsafe fn asAColorFilter(&self, filterPtr: *mut *mut SkColorFilter)
     -> bool {
        SkImageFilter_asAColorFilter(&*self, filterPtr)
    }
    #[inline]
    pub unsafe fn canComputeFastBounds(&self) -> bool {
        SkImageFilter_canComputeFastBounds(&*self)
    }
    #[inline]
    pub unsafe fn makeWithLocalMatrix(&self, arg1: *const SkMatrix)
     -> sk_sp<SkImageFilter> {
        SkImageFilter_makeWithLocalMatrix(&*self, arg1)
    }
    #[inline]
    pub unsafe fn canHandleComplexCTM(&self) -> bool {
        SkImageFilter_canHandleComplexCTM(&*self)
    }
    #[inline]
    pub unsafe fn MakeMatrixFilter(matrix: *const SkMatrix,
                                   quality: SkFilterQuality,
                                   input: sk_sp<SkImageFilter>)
     -> sk_sp<SkImageFilter> {
        SkImageFilter_MakeMatrixFilter(matrix, quality, input)
    }
    #[inline]
    pub unsafe fn InitializeFlattenables() {
        SkImageFilter_InitializeFlattenables()
    }
    #[inline]
    pub unsafe fn filterInput(&self, index: ::std::os::raw::c_int,
                              src: *mut SkSpecialImage,
                              arg1: *const SkImageFilter_Context,
                              offset: *mut SkIPoint)
     -> sk_sp<SkSpecialImage> {
        SkImageFilter_filterInput(&*self, index, src, arg1, offset)
    }
    #[inline]
    pub unsafe fn applyCropRect(&self, arg1: *const SkImageFilter_Context,
                                srcBounds: *const SkIRect,
                                dstBounds: *mut SkIRect) -> bool {
        SkImageFilter_applyCropRect(&*self, arg1, srcBounds, dstBounds)
    }
    #[inline]
    pub unsafe fn applyCropRect1(&self, arg1: *const SkImageFilter_Context,
                                 src: *mut SkSpecialImage,
                                 srcOffset: *mut SkIPoint,
                                 bounds: *mut SkIRect)
     -> sk_sp<SkSpecialImage> {
        SkImageFilter_applyCropRect1(&*self, arg1, src, srcOffset, bounds)
    }
    #[inline]
    pub unsafe fn mapContext(&self, ctx: *const SkImageFilter_Context)
     -> SkImageFilter_Context {
        SkImageFilter_mapContext(&*self, ctx)
    }
}
/** \class SkMaskFilter

    SkMaskFilter is the base class for object that perform transformations on
    an alpha-channel mask before drawing it. A subclass of SkMaskFilter may be
    installed into a SkPaint. Once there, each time a primitive is drawn, it
    is first scan converted into a SkMask::kA8_Format mask, and handed to the
    filter, calling its filterMask() method. If this returns true, then the
    new mask is used to render into the device.

    Blur and emboss are implemented as subclasses of SkMaskFilter.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkMaskFilter {
    pub _base: SkFlattenable,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkMaskFilter_BlurRec {
    pub fSigma: SkScalar,
    pub fStyle: SkBlurStyle,
    pub fQuality: SkBlurQuality,
}
#[test]
fn bindgen_test_layout_SkMaskFilter_BlurRec() {
    assert_eq!(::std::mem::size_of::<SkMaskFilter_BlurRec>() , 12usize);
    assert_eq!(::std::mem::align_of::<SkMaskFilter_BlurRec>() , 4usize);
}
impl Clone for SkMaskFilter_BlurRec {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMaskFilter_FilterReturn {
    kFalse_FilterReturn = 0,
    kTrue_FilterReturn = 1,
    kUnimplemented_FilterReturn = 2,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkMaskFilter_NinePatch {
    pub fMask: SkMask,
    pub fOuterRect: SkIRect,
    pub fCenter: SkIPoint,
    pub fCache: *mut SkCachedData,
}
#[test]
fn bindgen_test_layout_SkMaskFilter_NinePatch() {
    assert_eq!(::std::mem::size_of::<SkMaskFilter_NinePatch>() , 64usize);
    assert_eq!(::std::mem::align_of::<SkMaskFilter_NinePatch>() , 8usize);
}
pub type SkMaskFilter_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkMaskFilter() {
    assert_eq!(::std::mem::size_of::<SkMaskFilter>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkMaskFilter>() , 1usize);
}
/** \class SkPath

    The SkPath class encapsulates compound (multiple contour) geometric paths
    consisting of straight line segments, quadratic curves, and cubic curves.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkPath {
    pub fPathRef: sk_sp<SkPathRef>,
    pub fLastMoveToIndex: ::std::os::raw::c_int,
    pub fFillType: u8,
    pub fConvexity: u8,
    pub fFirstDirection: (),
    pub fIsVolatile: SkBool8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPath_Direction { kCW_Direction = 0, kCCW_Direction = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPath_FillType {
    kWinding_FillType = 0,
    kEvenOdd_FillType = 1,
    kInverseWinding_FillType = 2,
    kInverseEvenOdd_FillType = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPath_Convexity {
    kUnknown_Convexity = 0,
    kConvex_Convexity = 1,
    kConcave_Convexity = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPath_ArcSize { kSmall_ArcSize = 0, kLarge_ArcSize = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPath_AddPathMode {
    kAppend_AddPathMode = 0,
    kExtend_AddPathMode = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPath_SegmentMask {
    kLine_SegmentMask = 1,
    kQuad_SegmentMask = 2,
    kConic_SegmentMask = 4,
    kCubic_SegmentMask = 8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPath_Verb {
    kMove_Verb = 0,
    kLine_Verb = 1,
    kQuad_Verb = 2,
    kConic_Verb = 3,
    kCubic_Verb = 4,
    kClose_Verb = 5,
    kDone_Verb = 6,
}
/** Iterate through all of the segments (lines, quadratics, cubics) of
        each contours in a path.

        The iterator cleans up the segments along the way, removing degenerate
        segments and adding close verbs where necessary. When the forceClose
        argument is provided, each contour (as defined by a new starting
        move command) will be completed with a close verb regardless of the
        contour's contents.
    */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPath_Iter {
    pub fPts: *const SkPoint,
    pub fVerbs: *const u8,
    pub fVerbStop: *const u8,
    pub fConicWeights: *const SkScalar,
    pub fMoveTo: SkPoint,
    pub fLastPt: SkPoint,
    pub fForceClose: SkBool8,
    pub fNeedClose: SkBool8,
    pub fCloseLine: SkBool8,
    pub fSegmentState: SkBool8,
}
#[test]
fn bindgen_test_layout_SkPath_Iter() {
    assert_eq!(::std::mem::size_of::<SkPath_Iter>() , 56usize);
    assert_eq!(::std::mem::align_of::<SkPath_Iter>() , 8usize);
}
extern "C" {
    #[link_name = "?setPath@Iter@SkPath@@QEAAXAEBV2@_N@Z"]
    pub fn SkPath_Iter_setPath(this: *mut SkPath_Iter, arg1: *const SkPath,
                               forceClose: bool);
}
extern "C" {
    /** Returns true if the current contour is closed (has a kClose_Verb)
            @return true if the current contour is closed (has a kClose_Verb)
        */
    #[link_name = "?isClosedContour@Iter@SkPath@@QEBA_NXZ"]
    pub fn SkPath_Iter_isClosedContour(this: *const SkPath_Iter) -> bool;
}
impl Clone for SkPath_Iter {
    fn clone(&self) -> Self { *self }
}
impl SkPath_Iter {
    #[inline]
    pub unsafe fn setPath(&mut self, arg1: *const SkPath, forceClose: bool) {
        SkPath_Iter_setPath(&mut *self, arg1, forceClose)
    }
    #[inline]
    pub unsafe fn isClosedContour(&self) -> bool {
        SkPath_Iter_isClosedContour(&*self)
    }
}
/** Iterate through the verbs in the path, providing the associated points.
    */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPath_RawIter {
    pub fRawIter: SkPathRef_Iter,
}
#[test]
fn bindgen_test_layout_SkPath_RawIter() {
    assert_eq!(::std::mem::size_of::<SkPath_RawIter>() , 32usize);
    assert_eq!(::std::mem::align_of::<SkPath_RawIter>() , 8usize);
}
impl Clone for SkPath_RawIter {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPath_SerializationOffsets {
    kUnused1_SerializationShift = 28,
    kDirection_SerializationShift = 26,
    kIsVolatile_SerializationShift = 25,
    kConvexity_SerializationShift = 16,
    kFillType_SerializationShift = 8,
}
pub const SkPath_SerializationVersions_kCurrent_Version:
          SkPath_SerializationVersions =
    SkPath_SerializationVersions::kPathPrivLastMoveToIndex_Version;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPath_SerializationVersions {
    kPathPrivFirstDirection_Version = 1,
    kPathPrivLastMoveToIndex_Version = 2,
}
pub const SkPath_kPathRefGenIDBitCnt: ::std::os::raw::c_int = 32;
#[test]
fn bindgen_test_layout_SkPath() {
    assert_eq!(::std::mem::size_of::<SkPath>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPath>() , 1usize);
}
extern "C" {
    /** Return true if the paths contain an equal array of verbs and weights. Paths
     *  with equal verb counts can be readily interpolated. If the paths contain one
     *  or more conics, the conics' weights must also match.
     *
     *  @param compare  The path to compare.
     *
     *  @return true if the paths have the same verbs and weights.
     */
    #[link_name = "?isInterpolatable@SkPath@@QEBA_NAEBV1@@Z"]
    pub fn SkPath_isInterpolatable(this: *const SkPath,
                                   compare: *const SkPath) -> bool;
}
extern "C" {
    /** Interpolate between two paths with same-sized point arrays.
     *  The out path contains the verbs and weights of this path.
     *  The out points are a weighted average of this path and the ending path. 
     *
     *  @param ending  The path to interpolate between.
     *  @param weight  The weight, from 0 to 1. The output points are set to
     *                 (this->points * weight) + ending->points * (1 - weight).
     *  @return true if the paths could be interpolated.
     */
    #[link_name = "?interpolate@SkPath@@QEBA_NAEBV1@MPEAV1@@Z"]
    pub fn SkPath_interpolate(this: *const SkPath, ending: *const SkPath,
                              weight: SkScalar, out: *mut SkPath) -> bool;
}
extern "C" {
    /**
     *  Store a convexity setting in the path. There is no automatic check to
     *  see if this value actually agrees with the return value that would be
     *  computed by getConvexity().
     *
     *  Note: even if this is set to a "known" value, if the path is later
     *  changed (e.g. lineTo(), addRect(), etc.) then the cached value will be
     *  reset to kUnknown_Convexity.
     */
    #[link_name = "?setConvexity@SkPath@@QEAAXW4Convexity@1@@Z"]
    pub fn SkPath_setConvexity(this: *mut SkPath, arg1: SkPath_Convexity);
}
extern "C" {
    /** Clear any lines and curves from the path, making it empty. This frees up
        internal storage associated with those segments.
        On Android, does not change fSourcePath.
    */
    #[link_name = "?reset@SkPath@@QEAAXXZ"]
    pub fn SkPath_reset(this: *mut SkPath);
}
extern "C" {
    /** Similar to reset(), in that all lines and curves are removed from the
        path. However, any internal storage for those lines/curves is retained,
        making reuse of the path potentially faster.
        On Android, does not change fSourcePath.
    */
    #[link_name = "?rewind@SkPath@@QEAAXXZ"]
    pub fn SkPath_rewind(this: *mut SkPath);
}
extern "C" {
    /** Return true if the last contour of this path ends with a close verb.
     */
    #[link_name = "?isLastContourClosed@SkPath@@QEBA_NXZ"]
    pub fn SkPath_isLastContourClosed(this: *const SkPath) -> bool;
}
extern "C" {
    /**
     *  Returns true if the path specifies a single line (i.e. it contains just
     *  a moveTo and a lineTo). If so, and line[] is not null, it sets the 2
     *  points in line[] to the end-points of the line. If the path is not a
     *  line, returns false and ignores line[].
     */
    #[link_name = "?isLine@SkPath@@QEBA_NQEAUSkPoint@@@Z"]
    pub fn SkPath_isLine(this: *const SkPath, line: *mut SkPoint) -> bool;
}
extern "C" {
    /** Return the number of points in the path
     */
    #[link_name = "?countPoints@SkPath@@QEBAHXZ"]
    pub fn SkPath_countPoints(this: *const SkPath) -> ::std::os::raw::c_int;
}
extern "C" {
    /** Return the point at the specified index. If the index is out of range
         (i.e. is not 0 <= index < countPoints()) then the returned coordinates
         will be (0,0)
     */
    #[link_name = "?getPoint@SkPath@@QEBA?AUSkPoint@@H@Z"]
    pub fn SkPath_getPoint(this: *const SkPath, index: ::std::os::raw::c_int)
     -> SkPoint;
}
extern "C" {
    /** Returns the number of points in the path. Up to max points are copied.

        @param points If not null, receives up to max points
        @param max The maximum number of points to copy into points
        @return the actual number of points in the path
    */
    #[link_name = "?getPoints@SkPath@@QEBAHQEAUSkPoint@@H@Z"]
    pub fn SkPath_getPoints(this: *const SkPath, points: *mut SkPoint,
                            max: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Return the number of verbs in the path
     */
    #[link_name = "?countVerbs@SkPath@@QEBAHXZ"]
    pub fn SkPath_countVerbs(this: *const SkPath) -> ::std::os::raw::c_int;
}
extern "C" {
    /** Returns the number of verbs in the path. Up to max verbs are copied. The
        verbs are copied as one byte per verb.

        @param verbs If not null, receives up to max verbs
        @param max The maximum number of verbs to copy into verbs
        @return the actual number of verbs in the path
    */
    #[link_name = "?getVerbs@SkPath@@QEBAHQEAEH@Z"]
    pub fn SkPath_getVerbs(this: *const SkPath, verbs: *mut u8,
                           max: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    // Swap contents of this and other. Guaranteed not to throw
    #[link_name = "?swap@SkPath@@QEAAXAEAV1@@Z"]
    pub fn SkPath_swap(this: *mut SkPath, other: *mut SkPath);
}
extern "C" {
    /**
     * Does a conservative test to see whether a rectangle is inside a path. Currently it only
     * will ever return true for single convex contour paths. The empty-status of the rect is not
     * considered (e.g. a rect that is a point can be inside a path). Points or line segments where
     * the rect edge touches the path border are not considered containment violations.
     */
    #[link_name = "?conservativelyContainsRect@SkPath@@QEBA_NAEBUSkRect@@@Z"]
    pub fn SkPath_conservativelyContainsRect(this: *const SkPath,
                                             rect: *const SkRect) -> bool;
}
extern "C" {
    /** Hint to the path to prepare for adding more points. This can allow the
        path to more efficiently grow its storage.

        @param extraPtCount The number of extra points the path should
                            preallocate for.
    */
    #[link_name = "?incReserve@SkPath@@QEAAXI@Z"]
    pub fn SkPath_incReserve(this: *mut SkPath,
                             extraPtCount: ::std::os::raw::c_uint);
}
extern "C" {
    /** Set the beginning of the next contour to the point (x,y).

        @param x    The x-coordinate of the start of a new contour
        @param y    The y-coordinate of the start of a new contour
    */
    #[link_name = "?moveTo@SkPath@@QEAAXMM@Z"]
    pub fn SkPath_moveTo(this: *mut SkPath, x: SkScalar, y: SkScalar);
}
extern "C" {
    /** Set the beginning of the next contour relative to the last point on the
        previous contour. If there is no previous contour, this is treated the
        same as moveTo().

        @param dx   The amount to add to the x-coordinate of the end of the
                    previous contour, to specify the start of a new contour
        @param dy   The amount to add to the y-coordinate of the end of the
                    previous contour, to specify the start of a new contour
    */
    #[link_name = "?rMoveTo@SkPath@@QEAAXMM@Z"]
    pub fn SkPath_rMoveTo(this: *mut SkPath, dx: SkScalar, dy: SkScalar);
}
extern "C" {
    /** Add a line from the last point to the specified point (x,y). If no
        moveTo() call has been made for this contour, the first point is
        automatically set to (0,0).

        @param x    The x-coordinate of the end of a line
        @param y    The y-coordinate of the end of a line
    */
    #[link_name = "?lineTo@SkPath@@QEAAXMM@Z"]
    pub fn SkPath_lineTo(this: *mut SkPath, x: SkScalar, y: SkScalar);
}
extern "C" {
    /** Same as lineTo, but the coordinates are considered relative to the last
        point on this contour. If there is no previous point, then a moveTo(0,0)
        is inserted automatically.

        @param dx   The amount to add to the x-coordinate of the previous point
                    on this contour, to specify a line
        @param dy   The amount to add to the y-coordinate of the previous point
                    on this contour, to specify a line
    */
    #[link_name = "?rLineTo@SkPath@@QEAAXMM@Z"]
    pub fn SkPath_rLineTo(this: *mut SkPath, dx: SkScalar, dy: SkScalar);
}
extern "C" {
    /** Add a quadratic bezier from the last point, approaching control point
        (x1,y1), and ending at (x2,y2). If no moveTo() call has been made for
        this contour, the first point is automatically set to (0,0).

        @param x1   The x-coordinate of the control point on a quadratic curve
        @param y1   The y-coordinate of the control point on a quadratic curve
        @param x2   The x-coordinate of the end point on a quadratic curve
        @param y2   The y-coordinate of the end point on a quadratic curve
    */
    #[link_name = "?quadTo@SkPath@@QEAAXMMMM@Z"]
    pub fn SkPath_quadTo(this: *mut SkPath, x1: SkScalar, y1: SkScalar,
                         x2: SkScalar, y2: SkScalar);
}
extern "C" {
    /** Same as quadTo, but the coordinates are considered relative to the last
        point on this contour. If there is no previous point, then a moveTo(0,0)
        is inserted automatically.

        @param dx1   The amount to add to the x-coordinate of the last point on
                this contour, to specify the control point of a quadratic curve
        @param dy1   The amount to add to the y-coordinate of the last point on
                this contour, to specify the control point of a quadratic curve
        @param dx2   The amount to add to the x-coordinate of the last point on
                     this contour, to specify the end point of a quadratic curve
        @param dy2   The amount to add to the y-coordinate of the last point on
                     this contour, to specify the end point of a quadratic curve
    */
    #[link_name = "?rQuadTo@SkPath@@QEAAXMMMM@Z"]
    pub fn SkPath_rQuadTo(this: *mut SkPath, dx1: SkScalar, dy1: SkScalar,
                          dx2: SkScalar, dy2: SkScalar);
}
extern "C" {
    #[link_name = "?conicTo@SkPath@@QEAAXMMMMM@Z"]
    pub fn SkPath_conicTo(this: *mut SkPath, x1: SkScalar, y1: SkScalar,
                          x2: SkScalar, y2: SkScalar, w: SkScalar);
}
extern "C" {
    #[link_name = "?rConicTo@SkPath@@QEAAXMMMMM@Z"]
    pub fn SkPath_rConicTo(this: *mut SkPath, dx1: SkScalar, dy1: SkScalar,
                           dx2: SkScalar, dy2: SkScalar, w: SkScalar);
}
extern "C" {
    /** Add a cubic bezier from the last point, approaching control points
        (x1,y1) and (x2,y2), and ending at (x3,y3). If no moveTo() call has been
        made for this contour, the first point is automatically set to (0,0).

        @param x1   The x-coordinate of the 1st control point on a cubic curve
        @param y1   The y-coordinate of the 1st control point on a cubic curve
        @param x2   The x-coordinate of the 2nd control point on a cubic curve
        @param y2   The y-coordinate of the 2nd control point on a cubic curve
        @param x3   The x-coordinate of the end point on a cubic curve
        @param y3   The y-coordinate of the end point on a cubic curve
    */
    #[link_name = "?cubicTo@SkPath@@QEAAXMMMMMM@Z"]
    pub fn SkPath_cubicTo(this: *mut SkPath, x1: SkScalar, y1: SkScalar,
                          x2: SkScalar, y2: SkScalar, x3: SkScalar,
                          y3: SkScalar);
}
extern "C" {
    /** Same as cubicTo, but the coordinates are considered relative to the
        current point on this contour. If there is no previous point, then a
        moveTo(0,0) is inserted automatically.

        @param dx1   The amount to add to the x-coordinate of the last point on
                this contour, to specify the 1st control point of a cubic curve
        @param dy1   The amount to add to the y-coordinate of the last point on
                this contour, to specify the 1st control point of a cubic curve
        @param dx2   The amount to add to the x-coordinate of the last point on
                this contour, to specify the 2nd control point of a cubic curve
        @param dy2   The amount to add to the y-coordinate of the last point on
                this contour, to specify the 2nd control point of a cubic curve
        @param dx3   The amount to add to the x-coordinate of the last point on
                     this contour, to specify the end point of a cubic curve
        @param dy3   The amount to add to the y-coordinate of the last point on
                     this contour, to specify the end point of a cubic curve
    */
    #[link_name = "?rCubicTo@SkPath@@QEAAXMMMMMM@Z"]
    pub fn SkPath_rCubicTo(this: *mut SkPath, x1: SkScalar, y1: SkScalar,
                           x2: SkScalar, y2: SkScalar, x3: SkScalar,
                           y3: SkScalar);
}
extern "C" {
    /**
     *  Append the specified arc to the path. If the start of the arc is different from the path's
     *  current last point, then an automatic lineTo() is added to connect the current contour
     *  to the start of the arc. However, if the path is empty, then we call moveTo() with
     *  the first point of the arc. The sweep angle is treated mod 360.
     *
     *  @param oval The bounding oval defining the shape and size of the arc
     *  @param startAngle Starting angle (in degrees) where the arc begins
     *  @param sweepAngle Sweep angle (in degrees) measured clockwise. This is treated mod 360.
     *  @param forceMoveTo If true, always begin a new contour with the arc
     */
    #[link_name = "?arcTo@SkPath@@QEAAXAEBUSkRect@@MM_N@Z"]
    pub fn SkPath_arcTo(this: *mut SkPath, oval: *const SkRect,
                        startAngle: SkScalar, sweepAngle: SkScalar,
                        forceMoveTo: bool);
}
extern "C" {
    /**
     *  Append a line and arc to the current path. This is the same as the PostScript call "arct".
     */
    #[link_name = "?arcTo@SkPath@@QEAAXMMMMM@Z"]
    pub fn SkPath_arcTo1(this: *mut SkPath, x1: SkScalar, y1: SkScalar,
                         x2: SkScalar, y2: SkScalar, radius: SkScalar);
}
extern "C" {
    /**
     *  Append an elliptical arc from the current point in the format used by SVG.
     *  The center of the ellipse is computed to satisfy the constraints below.
     *
     *  @param rx,ry The radii in the x and y directions respectively.
     *  @param xAxisRotate The angle in degrees relative to the x-axis.
     *  @param largeArc Determines whether the smallest or largest arc possible
     *         is drawn.
     *  @param sweep Determines if the arc should be swept in an anti-clockwise or
     *         clockwise direction. Note that this enum value is opposite the SVG
     *         arc sweep value.
     *  @param x,y The destination coordinates.
     */
    #[link_name = "?arcTo@SkPath@@QEAAXMMMW4ArcSize@1@W4Direction@1@MM@Z"]
    pub fn SkPath_arcTo2(this: *mut SkPath, rx: SkScalar, ry: SkScalar,
                         xAxisRotate: SkScalar, largeArc: SkPath_ArcSize,
                         sweep: SkPath_Direction, x: SkScalar, y: SkScalar);
}
extern "C" {
    /** Same as arcTo format used by SVG, but the destination coordinate is relative to the
     *  last point on this contour. If there is no previous point, then a
     *  moveTo(0,0) is inserted automatically.
     *
     *  @param rx,ry The radii in the x and y directions respectively.
     *  @param xAxisRotate The angle in degrees relative to the x-axis.
     *  @param largeArc Determines whether the smallest or largest arc possible
     *         is drawn.
     *  @param sweep Determines if the arc should be swept in an anti-clockwise or
     *         clockwise direction. Note that this enum value is opposite the SVG
     *         arc sweep value.
     *  @param dx,dy The destination coordinates relative to the last point.
     */
    #[link_name = "?rArcTo@SkPath@@QEAAXMMMW4ArcSize@1@W4Direction@1@MM@Z"]
    pub fn SkPath_rArcTo(this: *mut SkPath, rx: SkScalar, ry: SkScalar,
                         xAxisRotate: SkScalar, largeArc: SkPath_ArcSize,
                         sweep: SkPath_Direction, dx: SkScalar, dy: SkScalar);
}
extern "C" {
    /** Close the current contour. If the current point is not equal to the
        first point of the contour, a line segment is automatically added.
    */
    #[link_name = "?close@SkPath@@QEAAXXZ"]
    pub fn SkPath_close(this: *mut SkPath);
}
extern "C" {
    /**
     *  Chop a conic into N quads, stored continguously in pts[], where
     *  N = 1 << pow2. The amount of storage needed is (1 + 2 * N)
     */
    #[link_name = "?ConvertConicToQuads@SkPath@@SAHAEBUSkPoint@@00MQEAU2@H@Z"]
    pub fn SkPath_ConvertConicToQuads(p0: *const SkPoint, p1: *const SkPoint,
                                      p2: *const SkPoint, w: SkScalar,
                                      pts: *mut SkPoint,
                                      pow2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
     *  Returns true if the path specifies a rectangle.
     *
     *  If this returns false, then all output parameters are ignored, and left
     *  unchanged. If this returns true, then each of the output parameters
     *  are checked for NULL. If they are not, they return their value.
     *
     *  @param rect If not null, set to the bounds of the rectangle.
     *              Note : this bounds may be smaller than the path's bounds, since it is just
     *              the bounds of the "drawable" parts of the path. e.g. a trailing MoveTo would
     *              be ignored in this rect, but not by the path's bounds
     *  @param isClosed If not null, set to true if the path is closed
     *  @param direction If not null, set to the rectangle's direction
     *  @return true if the path specifies a rectangle
     */
    #[link_name =
          "?isRect@SkPath@@QEBA_NPEAUSkRect@@PEA_NPEAW4Direction@1@@Z"]
    pub fn SkPath_isRect(this: *const SkPath, rect: *mut SkRect,
                         isClosed: *mut bool,
                         direction: *mut SkPath_Direction) -> bool;
}
extern "C" {
    /** Returns true if the path specifies a pair of nested rectangles, or would draw a
        pair of nested rectangles when filled. If so, and if
        rect is not null, set rect[0] to the outer rectangle and rect[1] to the inner
        rectangle. If so, and dirs is not null, set dirs[0] to the direction of
        the outer rectangle and dirs[1] to the direction of the inner rectangle. If
        the path does not specify a pair of nested rectangles, return
        false and ignore rect and dirs.

        @param rect If not null, returns the path as a pair of nested rectangles
        @param dirs If not null, returns the direction of the rects
        @return true if the path describes a pair of nested rectangles
    */
    #[link_name =
          "?isNestedFillRects@SkPath@@QEBA_NQEAUSkRect@@QEAW4Direction@1@@Z"]
    pub fn SkPath_isNestedFillRects(this: *const SkPath, rect: *mut SkRect,
                                    dirs: *mut SkPath_Direction) -> bool;
}
extern "C" {
    /**
     *  Add a closed rectangle contour to the path
     *  @param rect The rectangle to add as a closed contour to the path
     *  @param dir  The direction to wind the rectangle's contour.
     *
     *  Note: the contour initial point index is 0 (as defined below).
     */
    #[link_name = "?addRect@SkPath@@QEAAXAEBUSkRect@@W4Direction@1@@Z"]
    pub fn SkPath_addRect(this: *mut SkPath, rect: *const SkRect,
                          dir: SkPath_Direction);
}
extern "C" {
    /**
     *  Add a closed rectangle contour to the path
     *  @param rect  The rectangle to add as a closed contour to the path
     *  @param dir   The direction to wind the rectangle's contour.
     *  @param start Initial point of the contour (initial moveTo), expressed as
     *               a corner index, starting in the upper-left position, clock-wise:
     *
     *  0         1
     *   *-------*
     *   |       |
     *   *-------*
     *  3         2
     */
    #[link_name = "?addRect@SkPath@@QEAAXAEBUSkRect@@W4Direction@1@I@Z"]
    pub fn SkPath_addRect1(this: *mut SkPath, rect: *const SkRect,
                           dir: SkPath_Direction,
                           start: ::std::os::raw::c_uint);
}
extern "C" {
    /**
     *  Add a closed rectangle contour to the path
     *
     *  @param left     The left side of a rectangle to add as a closed contour
     *                  to the path
     *  @param top      The top of a rectangle to add as a closed contour to the
     *                  path
     *  @param right    The right side of a rectangle to add as a closed contour
     *                  to the path
     *  @param bottom   The bottom of a rectangle to add as a closed contour to
     *                  the path
     *  @param dir  The direction to wind the rectangle's contour.
     *
     *  Note: the contour initial point index is 0 (as defined above).
     */
    #[link_name = "?addRect@SkPath@@QEAAXMMMMW4Direction@1@@Z"]
    pub fn SkPath_addRect2(this: *mut SkPath, left: SkScalar, top: SkScalar,
                           right: SkScalar, bottom: SkScalar,
                           dir: SkPath_Direction);
}
extern "C" {
    /**
     *  Add a closed oval contour to the path
     *
     *  @param oval The bounding oval to add as a closed contour to the path
     *  @param dir  The direction to wind the oval's contour.
     *
     *  Note: the contour initial point index is 1 (as defined below).
     */
    #[link_name = "?addOval@SkPath@@QEAAXAEBUSkRect@@W4Direction@1@@Z"]
    pub fn SkPath_addOval(this: *mut SkPath, oval: *const SkRect,
                          dir: SkPath_Direction);
}
extern "C" {
    /**
     *  Add a closed oval contour to the path
     *
     *  @param oval  The bounding oval to add as a closed contour to the path
     *  @param dir   The direction to wind the oval's contour.
     *  @param start Initial point of the contour (initial moveTo), expressed
     *               as an ellipse vertex index, starting at the top, clock-wise
     *               (90/0/270/180deg order):
     *
     *        0
     *       -*-
     *     |     |
     *   3 *     * 1
     *     |     |
     *       -*-
     *        2
     */
    #[link_name = "?addOval@SkPath@@QEAAXAEBUSkRect@@W4Direction@1@I@Z"]
    pub fn SkPath_addOval1(this: *mut SkPath, oval: *const SkRect,
                           dir: SkPath_Direction,
                           start: ::std::os::raw::c_uint);
}
extern "C" {
    /**
     *  Add a closed circle contour to the path. The circle contour begins at
     *  the right-most point (as though 1 were passed to addOval's 'start' param).
     *
     *  @param x        The x-coordinate of the center of a circle to add as a
     *                  closed contour to the path
     *  @param y        The y-coordinate of the center of a circle to add as a
     *                  closed contour to the path
     *  @param radius   The radius of a circle to add as a closed contour to the
     *                  path
     *  @param dir  The direction to wind the circle's contour.
     */
    #[link_name = "?addCircle@SkPath@@QEAAXMMMW4Direction@1@@Z"]
    pub fn SkPath_addCircle(this: *mut SkPath, x: SkScalar, y: SkScalar,
                            radius: SkScalar, dir: SkPath_Direction);
}
extern "C" {
    /** Add the specified arc to the path as a new contour.

        @param oval The bounds of oval used to define the size of the arc
        @param startAngle Starting angle (in degrees) where the arc begins
        @param sweepAngle Sweep angle (in degrees) measured clockwise
    */
    #[link_name = "?addArc@SkPath@@QEAAXAEBUSkRect@@MM@Z"]
    pub fn SkPath_addArc(this: *mut SkPath, oval: *const SkRect,
                         startAngle: SkScalar, sweepAngle: SkScalar);
}
extern "C" {
    /**
     *  Add a closed round-rectangle contour to the path
     *  @param rect The bounds of a round-rectangle to add as a closed contour
     *  @param rx   The x-radius of the rounded corners on the round-rectangle
     *  @param ry   The y-radius of the rounded corners on the round-rectangle
     *  @param dir  The direction to wind the rectangle's contour.
     */
    #[link_name = "?addRoundRect@SkPath@@QEAAXAEBUSkRect@@MMW4Direction@1@@Z"]
    pub fn SkPath_addRoundRect(this: *mut SkPath, rect: *const SkRect,
                               rx: SkScalar, ry: SkScalar,
                               dir: SkPath_Direction);
}
extern "C" {
    /**
     *  Add a closed round-rectangle contour to the path. Each corner receives
     *  two radius values [X, Y]. The corners are ordered top-left, top-right,
     *  bottom-right, bottom-left.
     *  @param rect The bounds of a round-rectangle to add as a closed contour
     *  @param radii Array of 8 scalars, 4 [X,Y] pairs for each corner
     *  @param dir  The direction to wind the rectangle's contour.
     * Note: The radii here now go through the same constraint handling as the
     *       SkRRect radii (i.e., either radii at a corner being 0 implies a
     *       sqaure corner and oversized radii are proportionally scaled down).
     */
    #[link_name =
          "?addRoundRect@SkPath@@QEAAXAEBUSkRect@@QEBMW4Direction@1@@Z"]
    pub fn SkPath_addRoundRect1(this: *mut SkPath, rect: *const SkRect,
                                radii: *const SkScalar,
                                dir: SkPath_Direction);
}
extern "C" {
    /**
     *  Add an SkRRect contour to the path
     *  @param rrect The rounded rect to add as a closed contour
     *  @param dir   The winding direction for the new contour.
     *
     *  Note: the contour initial point index is either 6 (for dir == kCW_Direction)
     *        or 7 (for dir == kCCW_Direction), as defined below.
     *
     */
    #[link_name = "?addRRect@SkPath@@QEAAXAEBVSkRRect@@W4Direction@1@@Z"]
    pub fn SkPath_addRRect(this: *mut SkPath, rrect: *const SkRRect,
                           dir: SkPath_Direction);
}
extern "C" {
    /**
     *  Add an SkRRect contour to the path
     *  @param rrect The rounded rect to add as a closed contour
     *  @param dir   The winding direction for the new contour.
     *  @param start Initial point of the contour (initial moveTo), expressed as
     *               an index of the radii minor/major points, ordered clock-wise:
     *
     *      0    1
     *      *----*
     *   7 *      * 2
     *     |      |
     *   6 *      * 3
     *      *----*
     *      5    4
     */
    #[link_name = "?addRRect@SkPath@@QEAAXAEBVSkRRect@@W4Direction@1@I@Z"]
    pub fn SkPath_addRRect1(this: *mut SkPath, rrect: *const SkRRect,
                            dir: SkPath_Direction,
                            start: ::std::os::raw::c_uint);
}
extern "C" {
    /**
     *  Add a new contour made of just lines. This is just a fast version of
     *  the following:
     *      this->moveTo(pts[0]);
     *      for (int i = 1; i < count; ++i) {
     *          this->lineTo(pts[i]);
     *      }
     *      if (close) {
     *          this->close();
     *      }
     */
    #[link_name = "?addPoly@SkPath@@QEAAXQEBUSkPoint@@H_N@Z"]
    pub fn SkPath_addPoly(this: *mut SkPath, pts: *const SkPoint,
                          count: ::std::os::raw::c_int, close: bool);
}
extern "C" {
    /** Add a copy of src to the path, offset by (dx,dy)
        @param src  The path to add as a new contour
        @param dx   The amount to translate the path in X as it is added
        @param dx   The amount to translate the path in Y as it is added
    */
    #[link_name = "?addPath@SkPath@@QEAAXAEBV1@MMW4AddPathMode@1@@Z"]
    pub fn SkPath_addPath(this: *mut SkPath, src: *const SkPath, dx: SkScalar,
                          dy: SkScalar, mode: SkPath_AddPathMode);
}
extern "C" {
    /** Add a copy of src to the path, transformed by matrix
        @param src  The path to add as a new contour
        @param matrix  Transform applied to src
        @param mode  Determines how path is added
    */
    #[link_name =
          "?addPath@SkPath@@QEAAXAEBV1@AEBVSkMatrix@@W4AddPathMode@1@@Z"]
    pub fn SkPath_addPath1(this: *mut SkPath, src: *const SkPath,
                           matrix: *const SkMatrix, mode: SkPath_AddPathMode);
}
extern "C" {
    /**
     *  Same as addPath(), but reverses the src input
     */
    #[link_name = "?reverseAddPath@SkPath@@QEAAXAEBV1@@Z"]
    pub fn SkPath_reverseAddPath(this: *mut SkPath, src: *const SkPath);
}
extern "C" {
    /** Offset the path by (dx,dy), returning true on success

        @param dx   The amount in the X direction to offset the entire path
        @param dy   The amount in the Y direction to offset the entire path
        @param dst  The translated path is written here
    */
    #[link_name = "?offset@SkPath@@QEBAXMMPEAV1@@Z"]
    pub fn SkPath_offset(this: *const SkPath, dx: SkScalar, dy: SkScalar,
                         dst: *mut SkPath);
}
extern "C" {
    /** Transform the points in this path by matrix, and write the answer into
        dst.

        @param matrix   The matrix to apply to the path
        @param dst      The transformed path is written here
    */
    #[link_name = "?transform@SkPath@@QEBAXAEBVSkMatrix@@PEAV1@@Z"]
    pub fn SkPath_transform(this: *const SkPath, matrix: *const SkMatrix,
                            dst: *mut SkPath);
}
extern "C" {
    /** Return the last point on the path. If no points have been added, (0,0)
        is returned. If there are no points, this returns false, otherwise it
        returns true.

        @param lastPt   The last point on the path is returned here
    */
    #[link_name = "?getLastPt@SkPath@@QEBA_NPEAUSkPoint@@@Z"]
    pub fn SkPath_getLastPt(this: *const SkPath, lastPt: *mut SkPoint)
     -> bool;
}
extern "C" {
    /** Set the last point on the path. If no points have been added,
        moveTo(x,y) is automatically called.

        @param x    The new x-coordinate for the last point
        @param y    The new y-coordinate for the last point
    */
    #[link_name = "?setLastPt@SkPath@@QEAAXMM@Z"]
    pub fn SkPath_setLastPt(this: *mut SkPath, x: SkScalar, y: SkScalar);
}
extern "C" {
    /**
     *  Returns true if the point { x, y } is contained by the path, taking into
     *  account the FillType.
     */
    #[link_name = "?contains@SkPath@@QEBA_NMM@Z"]
    pub fn SkPath_contains(this: *const SkPath, x: SkScalar, y: SkScalar)
     -> bool;
}
extern "C" {
    #[link_name = "?dump@SkPath@@QEBAXPEAVSkWStream@@_N1@Z"]
    pub fn SkPath_dump(this: *const SkPath, arg1: *mut SkWStream,
                       forceClose: bool, dumpAsHex: bool);
}
extern "C" {
    #[link_name = "?dump@SkPath@@QEBAXXZ"]
    pub fn SkPath_dump1(this: *const SkPath);
}
extern "C" {
    #[link_name = "?dumpHex@SkPath@@QEBAXXZ"]
    pub fn SkPath_dumpHex(this: *const SkPath);
}
extern "C" {
    /**
     *  Write the path to the buffer, and return the number of bytes written.
     *  If buffer is NULL, it still returns the number of bytes.
     */
    #[link_name = "?writeToMemory@SkPath@@QEBA_KPEAX@Z"]
    pub fn SkPath_writeToMemory(this: *const SkPath,
                                buffer: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    /**
     * Initializes the path from the buffer
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
    #[link_name = "?readFromMemory@SkPath@@QEAA_KPEBX_K@Z"]
    pub fn SkPath_readFromMemory(this: *mut SkPath,
                                 buffer: *const ::std::os::raw::c_void,
                                 length: usize) -> usize;
}
extern "C" {
    /** Returns a non-zero, globally unique value corresponding to the set of verbs
        and points in the path (but not the fill type [except on Android skbug.com/1762]).
        Each time the path is modified, a different generation ID will be returned.
    */
    #[link_name = "?getGenerationID@SkPath@@QEBAIXZ"]
    pub fn SkPath_getGenerationID(this: *const SkPath) -> u32;
}
extern "C" {
    #[link_name = "?validate@SkPath@@QEBAXXZ"]
    pub fn SkPath_validate(this: *const SkPath);
}
impl SkPath {
    #[inline]
    pub unsafe fn isInterpolatable(&self, compare: *const SkPath) -> bool {
        SkPath_isInterpolatable(&*self, compare)
    }
    #[inline]
    pub unsafe fn interpolate(&self, ending: *const SkPath, weight: SkScalar,
                              out: *mut SkPath) -> bool {
        SkPath_interpolate(&*self, ending, weight, out)
    }
    #[inline]
    pub unsafe fn setConvexity(&mut self, arg1: SkPath_Convexity) {
        SkPath_setConvexity(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn reset(&mut self) { SkPath_reset(&mut *self) }
    #[inline]
    pub unsafe fn rewind(&mut self) { SkPath_rewind(&mut *self) }
    #[inline]
    pub unsafe fn isLastContourClosed(&self) -> bool {
        SkPath_isLastContourClosed(&*self)
    }
    #[inline]
    pub unsafe fn isLine(&self, line: *mut SkPoint) -> bool {
        SkPath_isLine(&*self, line)
    }
    #[inline]
    pub unsafe fn countPoints(&self) -> ::std::os::raw::c_int {
        SkPath_countPoints(&*self)
    }
    #[inline]
    pub unsafe fn getPoint(&self, index: ::std::os::raw::c_int) -> SkPoint {
        SkPath_getPoint(&*self, index)
    }
    #[inline]
    pub unsafe fn getPoints(&self, points: *mut SkPoint,
                            max: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int {
        SkPath_getPoints(&*self, points, max)
    }
    #[inline]
    pub unsafe fn countVerbs(&self) -> ::std::os::raw::c_int {
        SkPath_countVerbs(&*self)
    }
    #[inline]
    pub unsafe fn getVerbs(&self, verbs: *mut u8, max: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int {
        SkPath_getVerbs(&*self, verbs, max)
    }
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkPath) {
        SkPath_swap(&mut *self, other)
    }
    #[inline]
    pub unsafe fn conservativelyContainsRect(&self, rect: *const SkRect)
     -> bool {
        SkPath_conservativelyContainsRect(&*self, rect)
    }
    #[inline]
    pub unsafe fn incReserve(&mut self,
                             extraPtCount: ::std::os::raw::c_uint) {
        SkPath_incReserve(&mut *self, extraPtCount)
    }
    #[inline]
    pub unsafe fn moveTo(&mut self, x: SkScalar, y: SkScalar) {
        SkPath_moveTo(&mut *self, x, y)
    }
    #[inline]
    pub unsafe fn rMoveTo(&mut self, dx: SkScalar, dy: SkScalar) {
        SkPath_rMoveTo(&mut *self, dx, dy)
    }
    #[inline]
    pub unsafe fn lineTo(&mut self, x: SkScalar, y: SkScalar) {
        SkPath_lineTo(&mut *self, x, y)
    }
    #[inline]
    pub unsafe fn rLineTo(&mut self, dx: SkScalar, dy: SkScalar) {
        SkPath_rLineTo(&mut *self, dx, dy)
    }
    #[inline]
    pub unsafe fn quadTo(&mut self, x1: SkScalar, y1: SkScalar, x2: SkScalar,
                         y2: SkScalar) {
        SkPath_quadTo(&mut *self, x1, y1, x2, y2)
    }
    #[inline]
    pub unsafe fn rQuadTo(&mut self, dx1: SkScalar, dy1: SkScalar,
                          dx2: SkScalar, dy2: SkScalar) {
        SkPath_rQuadTo(&mut *self, dx1, dy1, dx2, dy2)
    }
    #[inline]
    pub unsafe fn conicTo(&mut self, x1: SkScalar, y1: SkScalar, x2: SkScalar,
                          y2: SkScalar, w: SkScalar) {
        SkPath_conicTo(&mut *self, x1, y1, x2, y2, w)
    }
    #[inline]
    pub unsafe fn rConicTo(&mut self, dx1: SkScalar, dy1: SkScalar,
                           dx2: SkScalar, dy2: SkScalar, w: SkScalar) {
        SkPath_rConicTo(&mut *self, dx1, dy1, dx2, dy2, w)
    }
    #[inline]
    pub unsafe fn cubicTo(&mut self, x1: SkScalar, y1: SkScalar, x2: SkScalar,
                          y2: SkScalar, x3: SkScalar, y3: SkScalar) {
        SkPath_cubicTo(&mut *self, x1, y1, x2, y2, x3, y3)
    }
    #[inline]
    pub unsafe fn rCubicTo(&mut self, x1: SkScalar, y1: SkScalar,
                           x2: SkScalar, y2: SkScalar, x3: SkScalar,
                           y3: SkScalar) {
        SkPath_rCubicTo(&mut *self, x1, y1, x2, y2, x3, y3)
    }
    #[inline]
    pub unsafe fn arcTo(&mut self, oval: *const SkRect, startAngle: SkScalar,
                        sweepAngle: SkScalar, forceMoveTo: bool) {
        SkPath_arcTo(&mut *self, oval, startAngle, sweepAngle, forceMoveTo)
    }
    #[inline]
    pub unsafe fn arcTo1(&mut self, x1: SkScalar, y1: SkScalar, x2: SkScalar,
                         y2: SkScalar, radius: SkScalar) {
        SkPath_arcTo1(&mut *self, x1, y1, x2, y2, radius)
    }
    #[inline]
    pub unsafe fn arcTo2(&mut self, rx: SkScalar, ry: SkScalar,
                         xAxisRotate: SkScalar, largeArc: SkPath_ArcSize,
                         sweep: SkPath_Direction, x: SkScalar, y: SkScalar) {
        SkPath_arcTo2(&mut *self, rx, ry, xAxisRotate, largeArc, sweep, x, y)
    }
    #[inline]
    pub unsafe fn rArcTo(&mut self, rx: SkScalar, ry: SkScalar,
                         xAxisRotate: SkScalar, largeArc: SkPath_ArcSize,
                         sweep: SkPath_Direction, dx: SkScalar,
                         dy: SkScalar) {
        SkPath_rArcTo(&mut *self, rx, ry, xAxisRotate, largeArc, sweep, dx,
                      dy)
    }
    #[inline]
    pub unsafe fn close(&mut self) { SkPath_close(&mut *self) }
    #[inline]
    pub unsafe fn ConvertConicToQuads(p0: *const SkPoint, p1: *const SkPoint,
                                      p2: *const SkPoint, w: SkScalar,
                                      pts: *mut SkPoint,
                                      pow2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int {
        SkPath_ConvertConicToQuads(p0, p1, p2, w, pts, pow2)
    }
    #[inline]
    pub unsafe fn isRect(&self, rect: *mut SkRect, isClosed: *mut bool,
                         direction: *mut SkPath_Direction) -> bool {
        SkPath_isRect(&*self, rect, isClosed, direction)
    }
    #[inline]
    pub unsafe fn isNestedFillRects(&self, rect: *mut SkRect,
                                    dirs: *mut SkPath_Direction) -> bool {
        SkPath_isNestedFillRects(&*self, rect, dirs)
    }
    #[inline]
    pub unsafe fn addRect(&mut self, rect: *const SkRect,
                          dir: SkPath_Direction) {
        SkPath_addRect(&mut *self, rect, dir)
    }
    #[inline]
    pub unsafe fn addRect1(&mut self, rect: *const SkRect,
                           dir: SkPath_Direction,
                           start: ::std::os::raw::c_uint) {
        SkPath_addRect1(&mut *self, rect, dir, start)
    }
    #[inline]
    pub unsafe fn addRect2(&mut self, left: SkScalar, top: SkScalar,
                           right: SkScalar, bottom: SkScalar,
                           dir: SkPath_Direction) {
        SkPath_addRect2(&mut *self, left, top, right, bottom, dir)
    }
    #[inline]
    pub unsafe fn addOval(&mut self, oval: *const SkRect,
                          dir: SkPath_Direction) {
        SkPath_addOval(&mut *self, oval, dir)
    }
    #[inline]
    pub unsafe fn addOval1(&mut self, oval: *const SkRect,
                           dir: SkPath_Direction,
                           start: ::std::os::raw::c_uint) {
        SkPath_addOval1(&mut *self, oval, dir, start)
    }
    #[inline]
    pub unsafe fn addCircle(&mut self, x: SkScalar, y: SkScalar,
                            radius: SkScalar, dir: SkPath_Direction) {
        SkPath_addCircle(&mut *self, x, y, radius, dir)
    }
    #[inline]
    pub unsafe fn addArc(&mut self, oval: *const SkRect, startAngle: SkScalar,
                         sweepAngle: SkScalar) {
        SkPath_addArc(&mut *self, oval, startAngle, sweepAngle)
    }
    #[inline]
    pub unsafe fn addRoundRect(&mut self, rect: *const SkRect, rx: SkScalar,
                               ry: SkScalar, dir: SkPath_Direction) {
        SkPath_addRoundRect(&mut *self, rect, rx, ry, dir)
    }
    #[inline]
    pub unsafe fn addRoundRect1(&mut self, rect: *const SkRect,
                                radii: *const SkScalar,
                                dir: SkPath_Direction) {
        SkPath_addRoundRect1(&mut *self, rect, radii, dir)
    }
    #[inline]
    pub unsafe fn addRRect(&mut self, rrect: *const SkRRect,
                           dir: SkPath_Direction) {
        SkPath_addRRect(&mut *self, rrect, dir)
    }
    #[inline]
    pub unsafe fn addRRect1(&mut self, rrect: *const SkRRect,
                            dir: SkPath_Direction,
                            start: ::std::os::raw::c_uint) {
        SkPath_addRRect1(&mut *self, rrect, dir, start)
    }
    #[inline]
    pub unsafe fn addPoly(&mut self, pts: *const SkPoint,
                          count: ::std::os::raw::c_int, close: bool) {
        SkPath_addPoly(&mut *self, pts, count, close)
    }
    #[inline]
    pub unsafe fn addPath(&mut self, src: *const SkPath, dx: SkScalar,
                          dy: SkScalar, mode: SkPath_AddPathMode) {
        SkPath_addPath(&mut *self, src, dx, dy, mode)
    }
    #[inline]
    pub unsafe fn addPath1(&mut self, src: *const SkPath,
                           matrix: *const SkMatrix,
                           mode: SkPath_AddPathMode) {
        SkPath_addPath1(&mut *self, src, matrix, mode)
    }
    #[inline]
    pub unsafe fn reverseAddPath(&mut self, src: *const SkPath) {
        SkPath_reverseAddPath(&mut *self, src)
    }
    #[inline]
    pub unsafe fn offset(&self, dx: SkScalar, dy: SkScalar,
                         dst: *mut SkPath) {
        SkPath_offset(&*self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn transform(&self, matrix: *const SkMatrix,
                            dst: *mut SkPath) {
        SkPath_transform(&*self, matrix, dst)
    }
    #[inline]
    pub unsafe fn getLastPt(&self, lastPt: *mut SkPoint) -> bool {
        SkPath_getLastPt(&*self, lastPt)
    }
    #[inline]
    pub unsafe fn setLastPt(&mut self, x: SkScalar, y: SkScalar) {
        SkPath_setLastPt(&mut *self, x, y)
    }
    #[inline]
    pub unsafe fn contains(&self, x: SkScalar, y: SkScalar) -> bool {
        SkPath_contains(&*self, x, y)
    }
    #[inline]
    pub unsafe fn dump(&self, arg1: *mut SkWStream, forceClose: bool,
                       dumpAsHex: bool) {
        SkPath_dump(&*self, arg1, forceClose, dumpAsHex)
    }
    #[inline]
    pub unsafe fn dump1(&self) { SkPath_dump1(&*self) }
    #[inline]
    pub unsafe fn dumpHex(&self) { SkPath_dumpHex(&*self) }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::std::os::raw::c_void)
     -> usize {
        SkPath_writeToMemory(&*self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(&mut self,
                                 buffer: *const ::std::os::raw::c_void,
                                 length: usize) -> usize {
        SkPath_readFromMemory(&mut *self, buffer, length)
    }
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkPath_getGenerationID(&*self)
    }
    #[inline]
    pub unsafe fn validate(&self) { SkPath_validate(&*self) }
}
/** \class SkPathEffect

    SkPathEffect is the base class for objects in the SkPaint that affect
    the geometry of a drawing primitive before it is transformed by the
    canvas' matrix and drawn.

    Dashing is implemented as a subclass of SkPathEffect.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkPathEffect {
    pub _base: SkFlattenable,
}
/** \class PointData

        PointData aggregates all the information needed to draw the point
        primitives returned by an 'asPoints' call.
    */
#[repr(C)]
#[derive(Debug)]
pub struct SkPathEffect_PointData {
    pub fFlags: u32,
    pub fPoints: *mut SkPoint,
    pub fNumPoints: ::std::os::raw::c_int,
    pub fSize: SkVector,
    pub fClipRect: SkRect,
    pub fPath: SkPath,
    pub fFirst: SkPath,
    pub fLast: SkPath,
}
pub const SkPathEffect_PointData_PointFlags_kCircles_PointFlag:
          SkPathEffect_PointData_PointFlags =
    SkPathEffect_PointData_PointFlags(1);
pub const SkPathEffect_PointData_PointFlags_kUsePath_PointFlag:
          SkPathEffect_PointData_PointFlags =
    SkPathEffect_PointData_PointFlags(2);
pub const SkPathEffect_PointData_PointFlags_kUseClip_PointFlag:
          SkPathEffect_PointData_PointFlags =
    SkPathEffect_PointData_PointFlags(4);
impl ::std::ops::BitOr<SkPathEffect_PointData_PointFlags> for
 SkPathEffect_PointData_PointFlags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkPathEffect_PointData_PointFlags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkPathEffect_PointData_PointFlags(pub i32);
#[test]
fn bindgen_test_layout_SkPathEffect_PointData() {
    assert_eq!(::std::mem::size_of::<SkPathEffect_PointData>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPathEffect_PointData>() , 1usize);
}
#[repr(i32)]
/**
     *  If the PathEffect can be represented as a dash pattern, asADash will return kDash_DashType
     *  and None otherwise. If a non NULL info is passed in, the various DashInfo will be filled
     *  in if the PathEffect can be a dash pattern. If passed in info has an fCount equal or
     *  greater to that of the effect, it will memcpy the values of the dash intervals into the
     *  info. Thus the general approach will be call asADash once with default info to get DashType
     *  and fCount. If effect can be represented as a dash pattern, allocate space for the intervals
     *  in info, then call asADash again with the same info and the intervals will get copied in.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPathEffect_DashType { kNone_DashType = 0, kDash_DashType = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPathEffect_DashInfo {
    //< Length of on/off intervals for dashed lines
    pub fIntervals: *mut SkScalar,
    //< Number of intervals in the dash. Should be even number
    pub fCount: i32,
    //< Offset into the dashed interval pattern
    pub fPhase: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPathEffect_DashInfo() {
    assert_eq!(::std::mem::size_of::<SkPathEffect_DashInfo>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkPathEffect_DashInfo>() , 8usize);
}
impl Clone for SkPathEffect_DashInfo {
    fn clone(&self) -> Self { *self }
}
pub type SkPathEffect_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkPathEffect() {
    assert_eq!(::std::mem::size_of::<SkPathEffect>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPathEffect>() , 1usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRasterizer {
    pub _base: SkFlattenable,
}
pub type SkRasterizer_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkRasterizer() {
    assert_eq!(::std::mem::size_of::<SkRasterizer>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkRasterizer>() , 1usize);
}
extern "C" {
    /** Turn the path into a mask, respecting the specified local->device matrix.
    */
    #[link_name =
          "?rasterize@SkRasterizer@@QEBA_NAEBVSkPath@@AEBVSkMatrix@@PEBUSkIRect@@PEAVSkMaskFilter@@PEAUSkMask@@W4CreateMode@6@@Z"]
    pub fn SkRasterizer_rasterize(this: *const SkRasterizer,
                                  path: *const SkPath,
                                  matrix: *const SkMatrix,
                                  clipBounds: *const SkIRect,
                                  filter: *mut SkMaskFilter,
                                  mask: *mut SkMask, mode: SkMask_CreateMode)
     -> bool;
}
impl SkRasterizer {
    #[inline]
    pub unsafe fn rasterize(&self, path: *const SkPath,
                            matrix: *const SkMatrix,
                            clipBounds: *const SkIRect,
                            filter: *mut SkMaskFilter, mask: *mut SkMask,
                            mode: SkMask_CreateMode) -> bool {
        SkRasterizer_rasterize(&*self, path, matrix, clipBounds, filter, mask,
                               mode)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkScalerContextEffects {
    pub _address: u8,
}
impl Clone for SkScalerContextEffects {
    fn clone(&self) -> Self { *self }
}
/** \class SkShader
 *
 *  Shaders specify the source color(s) for what is being drawn. If a paint
 *  has no shader, then the paint's color is used. If the paint has a
 *  shader, then the shader's color(s) are use instead, but they are
 *  modulated by the paint's alpha. This makes it easy to create a shader
 *  once (e.g. bitmap tiling or gradient) and then change its transparency
 *  w/o having to modify the original shader... only the paint's alpha needs
 *  to be modified.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkShader {
    pub _base: SkFlattenable,
    pub fLocalMatrix: SkMatrix,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkShader_TileMode {
    kClamp_TileMode = 0,
    kRepeat_TileMode = 1,
    kMirror_TileMode = 2,
}
pub const SkShader_kTileModeCount: SkShader__bindgen_ty_1 =
    SkShader__bindgen_ty_1::kTileModeCount;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkShader__bindgen_ty_1 { kTileModeCount = 3, }
pub const SkShader_Flags_kOpaqueAlpha_Flag: SkShader_Flags =
    SkShader_Flags(1);
pub const SkShader_Flags_kConstInY32_Flag: SkShader_Flags = SkShader_Flags(2);
pub const SkShader_Flags_kPrefers4f_Flag: SkShader_Flags = SkShader_Flags(4);
impl ::std::ops::BitOr<SkShader_Flags> for SkShader_Flags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { SkShader_Flags(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkShader_Flags(pub i32);
/**
     *  ContextRec acts as a parameter bundle for creating Contexts.
     */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkShader_ContextRec {
    pub fPaint: *const SkPaint,
    pub fMatrix: *const SkMatrix,
    pub fLocalMatrix: *const SkMatrix,
    pub fPreferredDstType: SkShader_ContextRec_DstType,
    pub fDstColorSpace: *mut SkColorSpace,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkShader_ContextRec_DstType {
    kPMColor_DstType = 0,
    kPM4f_DstType = 1,
}
#[test]
fn bindgen_test_layout_SkShader_ContextRec() {
    assert_eq!(::std::mem::size_of::<SkShader_ContextRec>() , 40usize);
    assert_eq!(::std::mem::align_of::<SkShader_ContextRec>() , 8usize);
}
impl Clone for SkShader_ContextRec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct SkShader_Context__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkShader_Context {
    pub vtable_: *const SkShader_Context__bindgen_vtable,
    pub fShader: *const SkShader,
    pub fCTM: SkMatrix,
    pub fTotalInverse: SkMatrix,
    pub fPaintAlpha: u8,
    pub fTotalInverseClass: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkShader_Context_BlitState {
    pub fCtx: *mut SkShader_Context,
    pub fMode: SkBlendMode,
    pub fStorage: [*mut ::std::os::raw::c_void; 2usize],
    pub fBlitBW: SkShader_Context_BlitBW,
    pub fBlitAA: SkShader_Context_BlitAA,
}
pub const SkShader_Context_BlitState_N:
          SkShader_Context_BlitState__bindgen_ty_1 =
    SkShader_Context_BlitState__bindgen_ty_1::N;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkShader_Context_BlitState__bindgen_ty_1 { N = 2, }
#[test]
fn bindgen_test_layout_SkShader_Context_BlitState() {
    assert_eq!(::std::mem::size_of::<SkShader_Context_BlitState>() , 48usize);
    assert_eq!(::std::mem::align_of::<SkShader_Context_BlitState>() , 8usize);
}
impl Clone for SkShader_Context_BlitState {
    fn clone(&self) -> Self { *self }
}
pub type SkShader_Context_BlitBW =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut SkShader_Context_BlitState,
                                               x: ::std::os::raw::c_int,
                                               y: ::std::os::raw::c_int,
                                               arg2: *const SkPixmap,
                                               count: ::std::os::raw::c_int)>;
pub type SkShader_Context_BlitAA =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut SkShader_Context_BlitState,
                                               x: ::std::os::raw::c_int,
                                               y: ::std::os::raw::c_int,
                                               arg2: *const SkPixmap,
                                               count: ::std::os::raw::c_int,
                                               arg3: *const SkAlpha)>;
/**
         * The const void* ctx is only const because all the implementations are const.
         * This can be changed to non-const if a new shade proc needs to change the ctx.
         */
pub type SkShader_Context_ShadeProc =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *const ::std::os::raw::c_void,
                                               x: ::std::os::raw::c_int,
                                               y: ::std::os::raw::c_int,
                                               arg1: *mut SkPMColor,
                                               count: ::std::os::raw::c_int)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkShader_Context_MatrixClass {
    kLinear_MatrixClass = 0,
    kFixedStepInX_MatrixClass = 1,
    kPerspective_MatrixClass = 2,
}
pub type SkShader_Context_INHERITED = SkNoncopyable;
#[test]
fn bindgen_test_layout_SkShader_Context() {
    assert_eq!(::std::mem::size_of::<SkShader_Context>() , 104usize);
    assert_eq!(::std::mem::align_of::<SkShader_Context>() , 8usize);
}
extern "C" {
    #[link_name =
          "?ComputeMatrixClass@Context@SkShader@@KA?AW4MatrixClass@12@AEBVSkMatrix@@@Z"]
    pub fn SkShader_Context_ComputeMatrixClass(arg1: *const SkMatrix)
     -> SkShader_Context_MatrixClass;
}
impl SkShader_Context {
    #[inline]
    pub unsafe fn ComputeMatrixClass(arg1: *const SkMatrix)
     -> SkShader_Context_MatrixClass {
        SkShader_Context_ComputeMatrixClass(arg1)
    }
}
pub const SkShader_GradientType_kLast_GradientType: SkShader_GradientType =
    SkShader_GradientType::kConical_GradientType;
#[repr(i32)]
/**
     *  If the shader subclass can be represented as a gradient, asAGradient
     *  returns the matching GradientType enum (or kNone_GradientType if it
     *  cannot). Also, if info is not null, asAGradient populates info with
     *  the relevant (see below) parameters for the gradient.  fColorCount
     *  is both an input and output parameter.  On input, it indicates how
     *  many entries in fColors and fColorOffsets can be used, if they are
     *  non-NULL.  After asAGradient has run, fColorCount indicates how
     *  many color-offset pairs there are in the gradient.  If there is
     *  insufficient space to store all of the color-offset pairs, fColors
     *  and fColorOffsets will not be altered.  fColorOffsets specifies
     *  where on the range of 0 to 1 to transition to the given color.
     *  The meaning of fPoint and fRadius is dependant on the type of gradient.
     *
     *  None:
     *      info is ignored.
     *  Color:
     *      fColorOffsets[0] is meaningless.
     *  Linear:
     *      fPoint[0] and fPoint[1] are the end-points of the gradient
     *  Radial:
     *      fPoint[0] and fRadius[0] are the center and radius
     *  Conical:
     *      fPoint[0] and fRadius[0] are the center and radius of the 1st circle
     *      fPoint[1] and fRadius[1] are the center and radius of the 2nd circle
     *  Sweep:
     *      fPoint[0] is the center of the sweep.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkShader_GradientType {
    kNone_GradientType = 0,
    kColor_GradientType = 1,
    kLinear_GradientType = 2,
    kRadial_GradientType = 3,
    kSweep_GradientType = 4,
    kConical_GradientType = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkShader_GradientInfo {
    //< In-out parameter, specifies passed size
    pub fColorCount: ::std::os::raw::c_int,
    //< The colors in the gradient.
    pub fColors: *mut SkColor,
    //< The unit offset for color transitions.
    pub fColorOffsets: *mut SkScalar,
    //< Type specific, see above.
    pub fPoint: [SkPoint; 2usize],
    //< Type specific, see above.
    pub fRadius: [SkScalar; 2usize],
    //< The tile mode used.
    pub fTileMode: SkShader_TileMode,
    //< see SkGradientShader::Flags
    pub fGradientFlags: u32,
}
#[test]
fn bindgen_test_layout_SkShader_GradientInfo() {
    assert_eq!(::std::mem::size_of::<SkShader_GradientInfo>() , 56usize);
    assert_eq!(::std::mem::align_of::<SkShader_GradientInfo>() , 8usize);
}
impl Clone for SkShader_GradientInfo {
    fn clone(&self) -> Self { *self }
}
/**
     *  If the shader subclass is composed of two shaders, return true, and if rec is not NULL,
     *  fill it out with info about the shader.
     *
     *  These are bare pointers; the ownership and reference count are unchanged.
     */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkShader_ComposeRec {
    pub fShaderA: *const SkShader,
    pub fShaderB: *const SkShader,
    pub fBlendMode: SkBlendMode,
}
#[test]
fn bindgen_test_layout_SkShader_ComposeRec() {
    assert_eq!(::std::mem::size_of::<SkShader_ComposeRec>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkShader_ComposeRec>() , 8usize);
}
impl Clone for SkShader_ComposeRec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkShader_AsFPArgs {
    pub fContext: *mut GrContext,
    pub fViewMatrix: *const SkMatrix,
    pub fLocalMatrix: *const SkMatrix,
    pub fFilterQuality: SkFilterQuality,
    pub fDstColorSpace: *mut SkColorSpace,
    pub fColorMode: SkDestinationSurfaceColorMode,
}
#[test]
fn bindgen_test_layout_SkShader_AsFPArgs() {
    assert_eq!(::std::mem::size_of::<SkShader_AsFPArgs>() , 48usize);
    assert_eq!(::std::mem::align_of::<SkShader_AsFPArgs>() , 8usize);
}
impl Clone for SkShader_AsFPArgs {
    fn clone(&self) -> Self { *self }
}
pub type SkShader_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkShader() {
    assert_eq!(::std::mem::size_of::<SkShader>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkShader>() , 1usize);
}
extern "C" {
    /**
     *  Create the actual object that does the shading.
     *  Size of storage must be >= contextSize.
     */
    #[link_name =
          "?createContext@SkShader@@QEBAPEAVContext@1@AEBUContextRec@1@PEAX@Z"]
    pub fn SkShader_createContext(this: *const SkShader,
                                  arg1: *const SkShader_ContextRec,
                                  storage: *mut ::std::os::raw::c_void)
     -> *mut SkShader_Context;
}
extern "C" {
    /**
     *  Return the size of a Context returned by createContext.
     */
    #[link_name = "?contextSize@SkShader@@QEBA_KAEBUContextRec@1@@Z"]
    pub fn SkShader_contextSize(this: *const SkShader,
                                arg1: *const SkShader_ContextRec) -> usize;
}
extern "C" {
    /**
     *  If the shader can represent its "average" luminance in a single color, return true and
     *  if color is not NULL, return that color. If it cannot, return false and ignore the color
     *  parameter.
     *
     *  Note: if this returns true, the returned color will always be opaque, as only the RGB
     *  components are used to compute luminance.
     */
    #[link_name = "?asLuminanceColor@SkShader@@QEBA_NPEAI@Z"]
    pub fn SkShader_asLuminanceColor(this: *const SkShader,
                                     arg1: *mut SkColor) -> bool;
}
extern "C" {
    /**
     *  Return a shader that will apply the specified localMatrix to this shader.
     *  The specified matrix will be applied before any matrix associated with this shader.
     */
    #[link_name =
          "?makeWithLocalMatrix@SkShader@@QEBA?AV?$sk_sp@VSkShader@@@@AEBVSkMatrix@@@Z"]
    pub fn SkShader_makeWithLocalMatrix(this: *const SkShader,
                                        arg1: *const SkMatrix)
     -> sk_sp<SkShader>;
}
extern "C" {
    /**
     *  Create a new shader that produces the same colors as invoking this shader and then applying
     *  the colorfilter.
     */
    #[link_name =
          "?makeWithColorFilter@SkShader@@QEBA?AV?$sk_sp@VSkShader@@@@V?$sk_sp@VSkColorFilter@@@@@Z"]
    pub fn SkShader_makeWithColorFilter(this: *const SkShader,
                                        arg1: sk_sp<SkColorFilter>)
     -> sk_sp<SkShader>;
}
extern "C" {
    /**
     *  Call this to create a new "empty" shader, that will not draw anything.
     */
    #[link_name = "?MakeEmptyShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@XZ"]
    pub fn SkShader_MakeEmptyShader() -> sk_sp<SkShader>;
}
extern "C" {
    /**
     *  Call this to create a new shader that just draws the specified color. This should always
     *  draw the same as a paint with this color (and no shader).
     */
    #[link_name = "?MakeColorShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@I@Z"]
    pub fn SkShader_MakeColorShader(arg1: SkColor) -> sk_sp<SkShader>;
}
extern "C" {
    /**
     *  Create a shader that draws the specified color (in the specified colorspace).
     *
     *  This works around the limitation that SkPaint::setColor() only takes byte values, and does
     *  not support specific colorspaces.
     */
    #[link_name =
          "?MakeColorShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@AEBUSkColor4f@@V?$sk_sp@VSkColorSpace@@@@@Z"]
    pub fn SkShader_MakeColorShader1(arg1: *const SkColor4f,
                                     arg2: sk_sp<SkColorSpace>)
     -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name =
          "?MakeComposeShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@V2@0W4SkBlendMode@@@Z"]
    pub fn SkShader_MakeComposeShader(dst: sk_sp<SkShader>,
                                      src: sk_sp<SkShader>, arg1: SkBlendMode)
     -> sk_sp<SkShader>;
}
extern "C" {
    /** Call this to create a new shader that will draw with the specified bitmap.
     *
     *  If the bitmap cannot be used (e.g. has no pixels, or its dimensions
     *  exceed implementation limits (currently at 64K - 1)) then SkEmptyShader
     *  may be returned.
     *
     *  If the src is kA8_Config then that mask will be colorized using the color on
     *  the paint.
     *
     *  @param src  The bitmap to use inside the shader
     *  @param tmx  The tiling mode to use when sampling the bitmap in the x-direction.
     *  @param tmy  The tiling mode to use when sampling the bitmap in the y-direction.
     *  @return     Returns a new shader object. Note: this function never returns null.
    */
    #[link_name =
          "?MakeBitmapShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@AEBVSkBitmap@@W4TileMode@1@1PEBVSkMatrix@@@Z"]
    pub fn SkShader_MakeBitmapShader(src: *const SkBitmap,
                                     tmx: SkShader_TileMode,
                                     tmy: SkShader_TileMode,
                                     localMatrix: *const SkMatrix)
     -> sk_sp<SkShader>;
}
extern "C" {
    /** Call this to create a new shader that will draw with the specified picture.
     *
     *  @param src  The picture to use inside the shader (if not NULL, its ref count
     *              is incremented). The SkPicture must not be changed after
     *              successfully creating a picture shader.
     *  @param tmx  The tiling mode to use when sampling the bitmap in the x-direction.
     *  @param tmy  The tiling mode to use when sampling the bitmap in the y-direction.
     *  @param tile The tile rectangle in picture coordinates: this represents the subset
     *              (or superset) of the picture used when building a tile. It is not
     *              affected by localMatrix and does not imply scaling (only translation
     *              and cropping). If null, the tile rect is considered equal to the picture
     *              bounds.
     *  @return     Returns a new shader object. Note: this function never returns null.
    */
    #[link_name =
          "?MakePictureShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@V?$sk_sp@VSkPicture@@@@W4TileMode@1@1PEBVSkMatrix@@PEBUSkRect@@@Z"]
    pub fn SkShader_MakePictureShader(src: sk_sp<SkPicture>,
                                      tmx: SkShader_TileMode,
                                      tmy: SkShader_TileMode,
                                      localMatrix: *const SkMatrix,
                                      tile: *const SkRect) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "?InitializeFlattenables@SkShader@@SAXXZ"]
    pub fn SkShader_InitializeFlattenables();
}
extern "C" {
    #[link_name =
          "?appendStages@SkShader@@QEBA_NPEAVSkRasterPipeline@@PEAVSkColorSpace@@PEAVSkFallbackAlloc@@AEBVSkMatrix@@AEBVSkPaint@@@Z"]
    pub fn SkShader_appendStages(this: *const SkShader,
                                 arg1: *mut SkRasterPipeline,
                                 arg2: *mut SkColorSpace,
                                 arg3: *mut SkFallbackAlloc,
                                 ctm: *const SkMatrix, arg4: *const SkPaint)
     -> bool;
}
extern "C" {
    #[link_name =
          "?computeTotalInverse@SkShader@@IEBA_NAEBUContextRec@1@PEAVSkMatrix@@@Z"]
    pub fn SkShader_computeTotalInverse(this: *const SkShader,
                                        arg1: *const SkShader_ContextRec,
                                        totalInverse: *mut SkMatrix) -> bool;
}
impl SkShader {
    #[inline]
    pub unsafe fn createContext(&self, arg1: *const SkShader_ContextRec,
                                storage: *mut ::std::os::raw::c_void)
     -> *mut SkShader_Context {
        SkShader_createContext(&*self, arg1, storage)
    }
    #[inline]
    pub unsafe fn contextSize(&self, arg1: *const SkShader_ContextRec)
     -> usize {
        SkShader_contextSize(&*self, arg1)
    }
    #[inline]
    pub unsafe fn asLuminanceColor(&self, arg1: *mut SkColor) -> bool {
        SkShader_asLuminanceColor(&*self, arg1)
    }
    #[inline]
    pub unsafe fn makeWithLocalMatrix(&self, arg1: *const SkMatrix)
     -> sk_sp<SkShader> {
        SkShader_makeWithLocalMatrix(&*self, arg1)
    }
    #[inline]
    pub unsafe fn makeWithColorFilter(&self, arg1: sk_sp<SkColorFilter>)
     -> sk_sp<SkShader> {
        SkShader_makeWithColorFilter(&*self, arg1)
    }
    #[inline]
    pub unsafe fn MakeEmptyShader() -> sk_sp<SkShader> {
        SkShader_MakeEmptyShader()
    }
    #[inline]
    pub unsafe fn MakeColorShader(arg1: SkColor) -> sk_sp<SkShader> {
        SkShader_MakeColorShader(arg1)
    }
    #[inline]
    pub unsafe fn MakeColorShader1(arg1: *const SkColor4f,
                                   arg2: sk_sp<SkColorSpace>)
     -> sk_sp<SkShader> {
        SkShader_MakeColorShader1(arg1, arg2)
    }
    #[inline]
    pub unsafe fn MakeComposeShader(dst: sk_sp<SkShader>,
                                    src: sk_sp<SkShader>, arg1: SkBlendMode)
     -> sk_sp<SkShader> {
        SkShader_MakeComposeShader(dst, src, arg1)
    }
    #[inline]
    pub unsafe fn MakeBitmapShader(src: *const SkBitmap,
                                   tmx: SkShader_TileMode,
                                   tmy: SkShader_TileMode,
                                   localMatrix: *const SkMatrix)
     -> sk_sp<SkShader> {
        SkShader_MakeBitmapShader(src, tmx, tmy, localMatrix)
    }
    #[inline]
    pub unsafe fn MakePictureShader(src: sk_sp<SkPicture>,
                                    tmx: SkShader_TileMode,
                                    tmy: SkShader_TileMode,
                                    localMatrix: *const SkMatrix,
                                    tile: *const SkRect) -> sk_sp<SkShader> {
        SkShader_MakePictureShader(src, tmx, tmy, localMatrix, tile)
    }
    #[inline]
    pub unsafe fn InitializeFlattenables() {
        SkShader_InitializeFlattenables()
    }
    #[inline]
    pub unsafe fn appendStages(&self, arg1: *mut SkRasterPipeline,
                               arg2: *mut SkColorSpace,
                               arg3: *mut SkFallbackAlloc,
                               ctm: *const SkMatrix, arg4: *const SkPaint)
     -> bool {
        SkShader_appendStages(&*self, arg1, arg2, arg3, ctm, arg4)
    }
    #[inline]
    pub unsafe fn computeTotalInverse(&self, arg1: *const SkShader_ContextRec,
                                      totalInverse: *mut SkMatrix) -> bool {
        SkShader_computeTotalInverse(&*self, arg1, totalInverse)
    }
}
/**
 *  Describes properties and constraints of a given SkSurface. The rendering engine can parse these
 *  during drawing, and can sometimes optimize its performance (e.g. disabling an expensive
 *  feature).
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkSurfaceProps {
    pub fFlags: u32,
    pub fPixelGeometry: SkPixelGeometry,
}
pub const SkSurfaceProps_Flags_kUseDeviceIndependentFonts_Flag:
          SkSurfaceProps_Flags =
    SkSurfaceProps_Flags(1);
impl ::std::ops::BitOr<SkSurfaceProps_Flags> for SkSurfaceProps_Flags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkSurfaceProps_Flags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkSurfaceProps_Flags(pub i32);
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkSurfaceProps_InitType { kLegacyFontHost_InitType = 0, }
extern "C" {
    #[link_name = "?kUseDistanceFieldFonts_Flag@SkSurfaceProps@@2W4Flags@1@B"]
    pub static SkSurfaceProps_kUseDistanceFieldFonts_Flag:
               SkSurfaceProps_Flags;
}
#[test]
fn bindgen_test_layout_SkSurfaceProps() {
    assert_eq!(::std::mem::size_of::<SkSurfaceProps>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkSurfaceProps>() , 4usize);
}
impl Clone for SkSurfaceProps {
    fn clone(&self) -> Self { *self }
}
/** \class SkTextBlob

    SkTextBlob combines multiple text runs into an immutable, ref-counted structure.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlob {
    pub fRunCount: ::std::os::raw::c_int,
    pub fBounds: SkRect,
    pub fUniqueID: u32,
    pub fStorageSize: usize,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkTextBlob_GlyphPositioning {
    kDefault_Positioning = 0,
    kHorizontal_Positioning = 1,
    kFull_Positioning = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkTextBlob_RunRecord {
    pub _address: u8,
}
impl Clone for SkTextBlob_RunRecord {
    fn clone(&self) -> Self { *self }
}
pub type SkTextBlob_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkTextBlob() {
    assert_eq!(::std::mem::size_of::<SkTextBlob>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkTextBlob>() , 1usize);
}
extern "C" {
    /**
     *  Serialize to a buffer.
     */
    #[link_name = "?flatten@SkTextBlob@@QEBAXAEAVSkWriteBuffer@@@Z"]
    pub fn SkTextBlob_flatten(this: *const SkTextBlob,
                              arg1: *mut SkWriteBuffer);
}
extern "C" {
    /**
     *  Recreate an SkTextBlob that was serialized into a buffer.
     *
     *  @param  SkReadBuffer Serialized blob data.
     *  @return A new SkTextBlob representing the serialized data, or NULL if the buffer is
     *          invalid.
     */
    #[link_name =
          "?MakeFromBuffer@SkTextBlob@@SA?AV?$sk_sp@VSkTextBlob@@@@AEAVSkReadBuffer@@@Z"]
    pub fn SkTextBlob_MakeFromBuffer(arg1: *mut SkReadBuffer)
     -> sk_sp<SkTextBlob>;
}
impl SkTextBlob {
    #[inline]
    pub unsafe fn flatten(&self, arg1: *mut SkWriteBuffer) {
        SkTextBlob_flatten(&*self, arg1)
    }
    #[inline]
    pub unsafe fn MakeFromBuffer(arg1: *mut SkReadBuffer)
     -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromBuffer(arg1)
    }
}
/** \class SkWeakRefCnt

    SkWeakRefCnt is the base class for objects that may be shared by multiple
    objects. When an existing strong owner wants to share a reference, it calls
    ref(). When a strong owner wants to release its reference, it calls
    unref(). When the shared object's strong reference count goes to zero as
    the result of an unref() call, its (virtual) weak_dispose method is called.
    It is an error for the destructor to be called explicitly (or via the
    object going out of scope on the stack or calling delete) if
    getRefCnt() > 1.

    In addition to strong ownership, an owner may instead obtain a weak
    reference by calling weak_ref(). A call to weak_ref() must be balanced by a
    call to weak_unref(). To obtain a strong reference from a weak reference,
    call try_ref(). If try_ref() returns true, the owner's pointer is now also
    a strong reference on which unref() must be called. Note that this does not
    affect the original weak reference, weak_unref() must still be called. When
    the weak reference count goes to zero, the object is deleted. While the
    weak reference count is positive and the strong reference count is zero the
    object still exists, but will be in the disposed state. It is up to the
    object to define what this means.

    Note that a strong reference implicitly implies a weak reference. As a
    result, it is allowable for the owner of a strong ref to call try_ref().
    This will have the same effect as calling ref(), but may be more expensive.

    Example:

    SkWeakRefCnt myRef = strongRef.weak_ref();
    ... // strongRef.unref() may or may not be called
    if (myRef.try_ref()) {
        ... // use myRef
        myRef.unref();
    } else {
        // myRef is in the disposed state
    }
    myRef.weak_unref();
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkWeakRefCnt {
    pub _base: SkRefCnt,
    pub fWeakCnt: std_atomic<::std::os::raw::c_int>,
}
pub type SkWeakRefCnt_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkWeakRefCnt() {
    assert_eq!(::std::mem::size_of::<SkWeakRefCnt>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkWeakRefCnt>() , 1usize);
}
pub type SkFontID = u32;
#[repr(C)]
#[derive(Copy)]
pub struct SkFontStyle {
    pub fUnion: SkFontStyle__bindgen_ty_1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkFontStyle_Weight {
    kInvisible_Weight = 0,
    kThin_Weight = 100,
    kExtraLight_Weight = 200,
    kLight_Weight = 300,
    kNormal_Weight = 400,
    kMedium_Weight = 500,
    kSemiBold_Weight = 600,
    kBold_Weight = 700,
    kExtraBold_Weight = 800,
    kBlack_Weight = 900,
    kExtraBlack_Weight = 1000,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkFontStyle_Width {
    kUltraCondensed_Width = 1,
    kExtraCondensed_Width = 2,
    kCondensed_Width = 3,
    kSemiCondensed_Width = 4,
    kNormal_Width = 5,
    kSemiExpanded_Width = 6,
    kExpanded_Width = 7,
    kExtraExpanded_Width = 8,
    kUltraExpanded_Width = 9,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkFontStyle_Slant {
    kUpright_Slant = 0,
    kItalic_Slant = 1,
    kOblique_Slant = 2,
}
#[repr(C)]
#[derive(Copy)]
pub union SkFontStyle__bindgen_ty_1 {
    pub fR: SkFontStyle__bindgen_ty_1__bindgen_ty_1,
    pub fU32: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkFontStyle__bindgen_ty_1__bindgen_ty_1 {
    pub fWeight: u16,
    pub fWidth: u8,
    pub fSlant: u8,
}
#[test]
fn bindgen_test_layout_SkFontStyle__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<SkFontStyle__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<SkFontStyle__bindgen_ty_1__bindgen_ty_1>()
               , 2usize);
}
impl Clone for SkFontStyle__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SkFontStyle__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<SkFontStyle__bindgen_ty_1>() , 4usize);
    assert_eq!(::std::mem::align_of::<SkFontStyle__bindgen_ty_1>() , 4usize);
}
impl Clone for SkFontStyle__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SkFontStyle() {
    assert_eq!(::std::mem::size_of::<SkFontStyle>() , 4usize);
    assert_eq!(::std::mem::align_of::<SkFontStyle>() , 4usize);
}
extern "C" {
    #[link_name = "?FromOldStyle@SkFontStyle@@SA?AV1@I@Z"]
    pub fn SkFontStyle_FromOldStyle(oldStyle: ::std::os::raw::c_uint)
     -> SkFontStyle;
}
impl Clone for SkFontStyle {
    fn clone(&self) -> Self { *self }
}
impl SkFontStyle {
    #[inline]
    pub unsafe fn FromOldStyle(oldStyle: ::std::os::raw::c_uint)
     -> SkFontStyle {
        SkFontStyle_FromOldStyle(oldStyle)
    }
}
/** Machine endian. */
pub type SkFontTableTag = u32;
/** \class SkTypeface

    The SkTypeface class specifies the typeface and intrinsic style of a font.
    This is used in the paint, along with optionally algorithmic settings like
    textSize, textSkewX, textScaleX, kFakeBoldText_Mask, to specify
    how text appears when drawn (and measured).

    Typeface objects are immutable, and so they can be shared between threads.
*/
#[repr(C)]
pub struct SkTypeface {
    pub _base: SkWeakRefCnt,
    pub fUniqueID: SkFontID,
    pub fStyle: SkFontStyle,
    pub fBounds: SkRect,
    pub fBoundsOnce: SkOnce,
    pub fIsFixedPitch: bool,
}
#[repr(i32)]
/** Style specifies the intrinsic style attributes of a given typeface
    */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkTypeface_Style {
    kNormal = 0,
    kBold = 1,
    kItalic = 2,
    kBoldItalic = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkTypeface_Encoding {
    kUTF8_Encoding = 0,
    kUTF16_Encoding = 1,
    kUTF32_Encoding = 2,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTypeface_LocalizedString {
    pub fString: SkString,
    pub fLanguage: SkString,
}
#[test]
fn bindgen_test_layout_SkTypeface_LocalizedString() {
    assert_eq!(::std::mem::size_of::<SkTypeface_LocalizedString>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkTypeface_LocalizedString>() , 8usize);
}
#[repr(C)]
pub struct SkTypeface_LocalizedStrings__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTypeface_LocalizedStrings {
    pub vtable_: *const SkTypeface_LocalizedStrings__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkTypeface_LocalizedStrings() {
    assert_eq!(::std::mem::size_of::<SkTypeface_LocalizedStrings>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkTypeface_LocalizedStrings>() ,
               8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkTypeface_PerGlyphInfo {
    kNo_PerGlyphInfo = 0,
    kGlyphNames_PerGlyphInfo = 1,
    kToUnicode_PerGlyphInfo = 2,
}
pub type SkTypeface_INHERITED = SkWeakRefCnt;
#[test]
fn bindgen_test_layout_SkTypeface() {
    assert_eq!(::std::mem::size_of::<SkTypeface>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkTypeface>() , 1usize);
}
extern "C" {
    /** Return the uniqueID for the specified typeface. If the face is null,
        resolve it to the default font and return its uniqueID. Will never
        return 0.
    */
    #[link_name = "?UniqueID@SkTypeface@@SAIPEBV1@@Z"]
    pub fn SkTypeface_UniqueID(face: *const SkTypeface) -> SkFontID;
}
extern "C" {
    /** Returns true if the two typefaces reference the same underlying font,
        handling either being null (treating null as the default font)
     */
    #[link_name = "?Equal@SkTypeface@@SA_NPEBV1@0@Z"]
    pub fn SkTypeface_Equal(facea: *const SkTypeface,
                            faceb: *const SkTypeface) -> bool;
}
extern "C" {
    /** Returns the default typeface, which is never nullptr. */
    #[link_name =
          "?MakeDefault@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@W4Style@1@@Z"]
    pub fn SkTypeface_MakeDefault(style: SkTypeface_Style)
     -> sk_sp<SkTypeface>;
}
extern "C" {
    /** Creates a new reference to the typeface that most closely matches the
      requested familyName and fontStyle. This method allows extended font
      face specifiers as in the SkFontStyle type. Will never return null.

      @param familyName  May be NULL. The name of the font family.
      @param fontStyle   The style of the typeface.
      @return reference to the closest-matching typeface. Call must call
              unref() when they are done.
    */
    #[link_name =
          "?MakeFromName@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@QEBDVSkFontStyle@@@Z"]
    pub fn SkTypeface_MakeFromName(familyName: *const ::std::os::raw::c_char,
                                   fontStyle: SkFontStyle)
     -> sk_sp<SkTypeface>;
}
extern "C" {
    /** Return the typeface that most closely matches the requested typeface and style.
        Use this to pick a new style from the same family of the existing typeface.
        If family is nullptr, this selects from the default font's family.

        @param family  May be NULL. The name of the existing type face.
        @param s       The style (normal, bold, italic) of the type face.
        @return the closest-matching typeface.
    */
    #[link_name =
          "?MakeFromTypeface@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@PEAV1@W4Style@1@@Z"]
    pub fn SkTypeface_MakeFromTypeface(family: *mut SkTypeface,
                                       arg1: SkTypeface_Style)
     -> sk_sp<SkTypeface>;
}
extern "C" {
    /** Return a new typeface given a file. If the file does not exist, or is
        not a valid font file, returns nullptr.
    */
    #[link_name =
          "?MakeFromFile@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@QEBDH@Z"]
    pub fn SkTypeface_MakeFromFile(path: *const ::std::os::raw::c_char,
                                   index: ::std::os::raw::c_int)
     -> sk_sp<SkTypeface>;
}
extern "C" {
    /** Return a new typeface given a stream. If the stream is
        not a valid font file, returns nullptr. Ownership of the stream is
        transferred, so the caller must not reference it again.
    */
    #[link_name =
          "?MakeFromStream@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@PEAVSkStreamAsset@@H@Z"]
    pub fn SkTypeface_MakeFromStream(stream: *mut SkStreamAsset,
                                     index: ::std::os::raw::c_int)
     -> sk_sp<SkTypeface>;
}
extern "C" {
    /** Return a new typeface given font data and configuration. If the data
        is not valid font data, returns nullptr.
    */
    #[link_name =
          "?MakeFromFontData@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@H@Z"]
    pub fn SkTypeface_MakeFromFontData(arg1: ::std::os::raw::c_int)
     -> sk_sp<SkTypeface>;
}
extern "C" {
    /** Write a unique signature to a stream, sufficient to reconstruct a
        typeface referencing the same font when Deserialize is called.
     */
    #[link_name = "?serialize@SkTypeface@@QEBAXPEAVSkWStream@@@Z"]
    pub fn SkTypeface_serialize(this: *const SkTypeface,
                                arg1: *mut SkWStream);
}
extern "C" {
    /** Given the data previously written by serialize(), return a new instance
        of a typeface referring to the same font. If that font is not available,
        return nullptr.
        Does not affect ownership of SkStream.
     */
    #[link_name =
          "?MakeDeserialize@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@PEAVSkStream@@@Z"]
    pub fn SkTypeface_MakeDeserialize(arg1: *mut SkStream)
     -> sk_sp<SkTypeface>;
}
extern "C" {
    /**
     *  Given an array of character codes, of the specified encoding,
     *  optionally return their corresponding glyph IDs (if glyphs is not NULL).
     *
     *  @param chars pointer to the array of character codes
     *  @param encoding how the characters are encoded
     *  @param glyphs (optional) returns the corresponding glyph IDs for each
     *          character code, up to glyphCount values. If a character code is
     *          not found in the typeface, the corresponding glyph ID will be 0.
     *  @param glyphCount number of code points in 'chars' to process. If glyphs
     *          is not NULL, then it must point sufficient memory to write
     *          glyphCount values into it.
     *  @return the number of number of continuous non-zero glyph IDs computed
     *          from the beginning of chars. This value is valid, even if the
     *          glyphs parameter is NULL.
     */
    #[link_name = "?charsToGlyphs@SkTypeface@@QEBAHPEBXW4Encoding@1@QEAGH@Z"]
    pub fn SkTypeface_charsToGlyphs(this: *const SkTypeface,
                                    chars: *const ::std::os::raw::c_void,
                                    encoding: SkTypeface_Encoding,
                                    glyphs: *mut SkGlyphID,
                                    glyphCount: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
     *  Return the number of glyphs in the typeface.
     */
    #[link_name = "?countGlyphs@SkTypeface@@QEBAHXZ"]
    pub fn SkTypeface_countGlyphs(this: *const SkTypeface)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Return the number of tables in the font. */
    #[link_name = "?countTables@SkTypeface@@QEBAHXZ"]
    pub fn SkTypeface_countTables(this: *const SkTypeface)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Copy into tags[] (allocated by the caller) the list of table tags in
     *  the font, and return the number. This will be the same as CountTables()
     *  or 0 if an error occured. If tags == NULL, this only returns the count
     *  (the same as calling countTables()).
     */
    #[link_name = "?getTableTags@SkTypeface@@QEBAHQEAI@Z"]
    pub fn SkTypeface_getTableTags(this: *const SkTypeface,
                                   tags: *mut SkFontTableTag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** Given a table tag, return the size of its contents, or 0 if not present
     */
    #[link_name = "?getTableSize@SkTypeface@@QEBA_KI@Z"]
    pub fn SkTypeface_getTableSize(this: *const SkTypeface,
                                   arg1: SkFontTableTag) -> usize;
}
extern "C" {
    /** Copy the contents of a table into data (allocated by the caller). Note
     *  that the contents of the table will be in their native endian order
     *  (which for most truetype tables is big endian). If the table tag is
     *  not found, or there is an error copying the data, then 0 is returned.
     *  If this happens, it is possible that some or all of the memory pointed
     *  to by data may have been written to, even though an error has occured.
     *
     *  @param fontID the font to copy the table from
     *  @param tag  The table tag whose contents are to be copied
     *  @param offset The offset in bytes into the table's contents where the
     *  copy should start from.
     *  @param length The number of bytes, starting at offset, of table data
     *  to copy.
     *  @param data storage address where the table contents are copied to
     *  @return the number of bytes actually copied into data. If offset+length
     *  exceeds the table's size, then only the bytes up to the table's
     *  size are actually copied, and this is the value returned. If
     *  offset > the table's size, or tag is not a valid table,
     *  then 0 is returned.
     */
    #[link_name = "?getTableData@SkTypeface@@QEBA_KI_K0PEAX@Z"]
    pub fn SkTypeface_getTableData(this: *const SkTypeface,
                                   tag: SkFontTableTag, offset: usize,
                                   length: usize,
                                   data: *mut ::std::os::raw::c_void)
     -> usize;
}
extern "C" {
    /**
     *  Return the units-per-em value for this typeface, or zero if there is an
     *  error.
     */
    #[link_name = "?getUnitsPerEm@SkTypeface@@QEBAHXZ"]
    pub fn SkTypeface_getUnitsPerEm(this: *const SkTypeface)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
     *  Given a run of glyphs, return the associated horizontal adjustments.
     *  Adjustments are in "design units", which are integers relative to the
     *  typeface's units per em (see getUnitsPerEm).
     *
     *  Some typefaces are known to never support kerning. Calling this method
     *  with all zeros (e.g. getKerningPairAdustments(NULL, 0, NULL)) returns
     *  a boolean indicating if the typeface might support kerning. If it
     *  returns false, then it will always return false (no kerning) for all
     *  possible glyph runs. If it returns true, then it *may* return true for
     *  somne glyph runs.
     *
     *  If count is non-zero, then the glyphs parameter must point to at least
     *  [count] valid glyph IDs, and the adjustments parameter must be
     *  sized to at least [count - 1] entries. If the method returns true, then
     *  [count-1] entries in the adjustments array will be set. If the method
     *  returns false, then no kerning should be applied, and the adjustments
     *  array will be in an undefined state (possibly some values may have been
     *  written, but none of them should be interpreted as valid values).
     */
    #[link_name = "?getKerningPairAdjustments@SkTypeface@@QEBA_NQEBGHQEAH@Z"]
    pub fn SkTypeface_getKerningPairAdjustments(this: *const SkTypeface,
                                                glyphs: *const SkGlyphID,
                                                count: ::std::os::raw::c_int,
                                                adjustments: *mut i32)
     -> bool;
}
extern "C" {
    /**
     *  Returns an iterator which will attempt to enumerate all of the
     *  family names specified by the font.
     *  It is the caller's responsibility to unref() the returned pointer.
     */
    #[link_name =
          "?createFamilyNameIterator@SkTypeface@@QEBAPEAVLocalizedStrings@1@XZ"]
    pub fn SkTypeface_createFamilyNameIterator(this: *const SkTypeface)
     -> *mut SkTypeface_LocalizedStrings;
}
extern "C" {
    /**
     *  Return the family name for this typeface. It will always be returned
     *  encoded as UTF8, but the language of the name is whatever the host
     *  platform chooses.
     */
    #[link_name = "?getFamilyName@SkTypeface@@QEBAXPEAVSkString@@@Z"]
    pub fn SkTypeface_getFamilyName(this: *const SkTypeface,
                                    name: *mut SkString);
}
extern "C" {
    /**
     *  Return a stream for the contents of the font data, or NULL on failure.
     *  If ttcIndex is not null, it is set to the TrueTypeCollection index
     *  of this typeface within the stream, or 0 if the stream is not a
     *  collection.
     *  The caller is responsible for deleting the stream.
     */
    #[link_name = "?openStream@SkTypeface@@QEBAPEAVSkStreamAsset@@PEAH@Z"]
    pub fn SkTypeface_openStream(this: *const SkTypeface,
                                 ttcIndex: *mut ::std::os::raw::c_int)
     -> *mut SkStreamAsset;
}
extern "C" {
    /**
     *  Return the font data, or nullptr on failure.
     */
    #[link_name = "?makeFontData@SkTypeface@@QEBAHXZ"]
    pub fn SkTypeface_makeFontData(this: *const SkTypeface)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
     *  Return a scalercontext for the given descriptor. If this fails, then
     *  if allowFailure is true, this returns NULL, else it returns a
     *  dummy scalercontext that will not crash, but will draw nothing.
     */
    #[link_name =
          "?createScalerContext@SkTypeface@@QEBAHAEBUSkScalerContextEffects@@PEBVSkDescriptor@@_N@Z"]
    pub fn SkTypeface_createScalerContext(this: *const SkTypeface,
                                          arg1: *const SkScalerContextEffects,
                                          arg2: *const SkDescriptor,
                                          allowFailure: bool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
     *  Return a rectangle (scaled to 1-pt) that represents the union of the bounds of all
     *  of the glyphs, but each one positioned at (0,). This may be conservatively large, and
     *  will not take into account any hinting or other size-specific adjustments.
     */
    #[link_name = "?getBounds@SkTypeface@@QEBA?AUSkRect@@XZ"]
    pub fn SkTypeface_getBounds(this: *const SkTypeface) -> SkRect;
}
extern "C" {
    #[link_name = "?GetDefaultTypeface@SkTypeface@@KAPEAV1@W4Style@1@@Z"]
    pub fn SkTypeface_GetDefaultTypeface(style: SkTypeface_Style)
     -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "?onMakeFontData@SkTypeface@@IEBAHXZ"]
    pub fn SkTypeface_onMakeFontData(this: *const SkTypeface)
     -> ::std::os::raw::c_int;
}
impl SkTypeface {
    #[inline]
    pub unsafe fn UniqueID(face: *const SkTypeface) -> SkFontID {
        SkTypeface_UniqueID(face)
    }
    #[inline]
    pub unsafe fn Equal(facea: *const SkTypeface, faceb: *const SkTypeface)
     -> bool {
        SkTypeface_Equal(facea, faceb)
    }
    #[inline]
    pub unsafe fn MakeDefault(style: SkTypeface_Style) -> sk_sp<SkTypeface> {
        SkTypeface_MakeDefault(style)
    }
    #[inline]
    pub unsafe fn MakeFromName(familyName: *const ::std::os::raw::c_char,
                               fontStyle: SkFontStyle) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromName(familyName, fontStyle)
    }
    #[inline]
    pub unsafe fn MakeFromTypeface(family: *mut SkTypeface,
                                   arg1: SkTypeface_Style)
     -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromTypeface(family, arg1)
    }
    #[inline]
    pub unsafe fn MakeFromFile(path: *const ::std::os::raw::c_char,
                               index: ::std::os::raw::c_int)
     -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromFile(path, index)
    }
    #[inline]
    pub unsafe fn MakeFromStream(stream: *mut SkStreamAsset,
                                 index: ::std::os::raw::c_int)
     -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromStream(stream, index)
    }
    #[inline]
    pub unsafe fn MakeFromFontData(arg1: ::std::os::raw::c_int)
     -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromFontData(arg1)
    }
    #[inline]
    pub unsafe fn serialize(&self, arg1: *mut SkWStream) {
        SkTypeface_serialize(&*self, arg1)
    }
    #[inline]
    pub unsafe fn MakeDeserialize(arg1: *mut SkStream) -> sk_sp<SkTypeface> {
        SkTypeface_MakeDeserialize(arg1)
    }
    #[inline]
    pub unsafe fn charsToGlyphs(&self, chars: *const ::std::os::raw::c_void,
                                encoding: SkTypeface_Encoding,
                                glyphs: *mut SkGlyphID,
                                glyphCount: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int {
        SkTypeface_charsToGlyphs(&*self, chars, encoding, glyphs, glyphCount)
    }
    #[inline]
    pub unsafe fn countGlyphs(&self) -> ::std::os::raw::c_int {
        SkTypeface_countGlyphs(&*self)
    }
    #[inline]
    pub unsafe fn countTables(&self) -> ::std::os::raw::c_int {
        SkTypeface_countTables(&*self)
    }
    #[inline]
    pub unsafe fn getTableTags(&self, tags: *mut SkFontTableTag)
     -> ::std::os::raw::c_int {
        SkTypeface_getTableTags(&*self, tags)
    }
    #[inline]
    pub unsafe fn getTableSize(&self, arg1: SkFontTableTag) -> usize {
        SkTypeface_getTableSize(&*self, arg1)
    }
    #[inline]
    pub unsafe fn getTableData(&self, tag: SkFontTableTag, offset: usize,
                               length: usize,
                               data: *mut ::std::os::raw::c_void) -> usize {
        SkTypeface_getTableData(&*self, tag, offset, length, data)
    }
    #[inline]
    pub unsafe fn getUnitsPerEm(&self) -> ::std::os::raw::c_int {
        SkTypeface_getUnitsPerEm(&*self)
    }
    #[inline]
    pub unsafe fn getKerningPairAdjustments(&self, glyphs: *const SkGlyphID,
                                            count: ::std::os::raw::c_int,
                                            adjustments: *mut i32) -> bool {
        SkTypeface_getKerningPairAdjustments(&*self, glyphs, count,
                                             adjustments)
    }
    #[inline]
    pub unsafe fn createFamilyNameIterator(&self)
     -> *mut SkTypeface_LocalizedStrings {
        SkTypeface_createFamilyNameIterator(&*self)
    }
    #[inline]
    pub unsafe fn getFamilyName(&self, name: *mut SkString) {
        SkTypeface_getFamilyName(&*self, name)
    }
    #[inline]
    pub unsafe fn openStream(&self, ttcIndex: *mut ::std::os::raw::c_int)
     -> *mut SkStreamAsset {
        SkTypeface_openStream(&*self, ttcIndex)
    }
    #[inline]
    pub unsafe fn makeFontData(&self) -> ::std::os::raw::c_int {
        SkTypeface_makeFontData(&*self)
    }
    #[inline]
    pub unsafe fn createScalerContext(&self,
                                      arg1: *const SkScalerContextEffects,
                                      arg2: *const SkDescriptor,
                                      allowFailure: bool)
     -> ::std::os::raw::c_int {
        SkTypeface_createScalerContext(&*self, arg1, arg2, allowFailure)
    }
    #[inline]
    pub unsafe fn getBounds(&self) -> SkRect { SkTypeface_getBounds(&*self) }
    #[inline]
    pub unsafe fn GetDefaultTypeface(style: SkTypeface_Style)
     -> *mut SkTypeface {
        SkTypeface_GetDefaultTypeface(style)
    }
    #[inline]
    pub unsafe fn onMakeFontData(&self) -> ::std::os::raw::c_int {
        SkTypeface_onMakeFontData(&*self)
    }
}
pub const GrPixelConfig_kLast_GrPixelConfig: GrPixelConfig =
    GrPixelConfig::kRGBA_half_GrPixelConfig;
#[repr(i32)]
/**
 * Pixel configurations.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GrPixelConfig {
    kUnknown_GrPixelConfig = 0,
    kAlpha_8_GrPixelConfig = 1,
    kIndex_8_GrPixelConfig = 2,
    kRGB_565_GrPixelConfig = 3,
    kRGBA_4444_GrPixelConfig = 4,
    kRGBA_8888_GrPixelConfig = 5,
    kBGRA_8888_GrPixelConfig = 6,
    kSRGBA_8888_GrPixelConfig = 7,
    kSBGRA_8888_GrPixelConfig = 8,
    kRGBA_8888_sint_GrPixelConfig = 9,
    kETC1_GrPixelConfig = 10,
    kLATC_GrPixelConfig = 11,
    kR11_EAC_GrPixelConfig = 12,
    kASTC_12x12_GrPixelConfig = 13,
    kRGBA_float_GrPixelConfig = 14,
    kAlpha_half_GrPixelConfig = 15,
    kRGBA_half_GrPixelConfig = 16,
}
pub type GrBackendObject = isize;
#[repr(i32)]
/**
 * Some textures will be stored such that the upper and left edges of the content meet at the
 * the origin (in texture coord space) and for other textures the lower and left edges meet at
 * the origin. kDefault_GrSurfaceOrigin sets textures to TopLeft, and render targets
 * to BottomLeft.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GrSurfaceOrigin {
    kDefault_GrSurfaceOrigin = 0,
    kTopLeft_GrSurfaceOrigin = 1,
    kBottomLeft_GrSurfaceOrigin = 2,
}
pub const GrBackendTextureFlags_kNone_GrBackendTextureFlag:
          GrBackendTextureFlags =
    GrBackendTextureFlags(0);
pub const GrBackendTextureFlags_kRenderTarget_GrBackendTextureFlag:
          GrBackendTextureFlags =
    GrBackendTextureFlags(1);
impl ::std::ops::BitOr<GrBackendTextureFlags> for GrBackendTextureFlags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        GrBackendTextureFlags(self.0 | other.0)
    }
}
#[repr(C)]
/**
 * Gr can wrap an existing texture created by the client with a GrTexture
 * object. The client is responsible for ensuring that the texture lives at
 * least as long as the GrTexture object wrapping it. We require the client to
 * explicitly provide information about the texture, such as width, height,
 * and pixel config, rather than querying the 3D APIfor these values. We expect
 * these to be immutable even if the 3D API doesn't require this (OpenGL).
 *
 * Textures that are also render targets are supported as well. Gr will manage
 * any ancillary 3D API (stencil buffer, FBO id, etc) objects necessary for
 * Gr to draw into the render target. To access the render target object
 * call GrTexture::asRenderTarget().
 *
 * If in addition to the render target flag, the caller also specifies a sample
 * count Gr will create an MSAA buffer that resolves into the texture. Gr auto-
 * resolves when it reads from the texture. The client can explictly resolve
 * using the GrRenderTarget interface.
 *
 * Note: These flags currently form a subset of GrTexture's flags.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct GrBackendTextureFlags(pub i32);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrBackendTextureDesc {
    pub fFlags: GrBackendTextureFlags,
    pub fOrigin: GrSurfaceOrigin,
    pub fWidth: ::std::os::raw::c_int,
    pub fHeight: ::std::os::raw::c_int,
    pub fConfig: GrPixelConfig,
    /**
     * If the render target flag is set and sample count is greater than 0
     * then Gr will create an MSAA buffer that resolves to the texture.
     */
    pub fSampleCnt: ::std::os::raw::c_int,
    /**
     * Handle to the 3D API object.
     * OpenGL: Texture ID.
     * Vulkan: GrVkImageInfo*
     */
    pub fTextureHandle: GrBackendObject,
}
#[test]
fn bindgen_test_layout_GrBackendTextureDesc() {
    assert_eq!(::std::mem::size_of::<GrBackendTextureDesc>() , 32usize);
    assert_eq!(::std::mem::align_of::<GrBackendTextureDesc>() , 8usize);
}
impl Clone for GrBackendTextureDesc {
    fn clone(&self) -> Self { *self }
}
/**
 * Gr can wrap an existing render target created by the client in the 3D API
 * with a GrRenderTarget object. The client is responsible for ensuring that the
 * underlying 3D API object lives at least as long as the GrRenderTarget object
 * wrapping it. We require the client to explicitly provide information about
 * the target, such as width, height, and pixel config rather than querying the
 * 3D API for these values. We expect these properties to be immutable even if
 * the 3D API doesn't require this (OpenGL).
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrBackendRenderTargetDesc {
    pub fWidth: ::std::os::raw::c_int,
    pub fHeight: ::std::os::raw::c_int,
    pub fConfig: GrPixelConfig,
    pub fOrigin: GrSurfaceOrigin,
    /**
     * The number of samples per pixel. Gr uses this to influence decisions
     * about applying other forms of anti-aliasing.
     */
    pub fSampleCnt: ::std::os::raw::c_int,
    /**
     * Number of bits of stencil per-pixel.
     */
    pub fStencilBits: ::std::os::raw::c_int,
    /**
     * Handle to the 3D API object.
     * OpenGL: FBO ID
     * Vulkan: GrVkImageInfo*
     */
    pub fRenderTargetHandle: GrBackendObject,
}
#[test]
fn bindgen_test_layout_GrBackendRenderTargetDesc() {
    assert_eq!(::std::mem::size_of::<GrBackendRenderTargetDesc>() , 32usize);
    assert_eq!(::std::mem::align_of::<GrBackendRenderTargetDesc>() , 8usize);
}
impl Clone for GrBackendRenderTargetDesc {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    //////////////////////////////////////////////////////////////////////////////
    #[link_name = "?SkSwizzle_RB@@YAII@Z"]
    pub fn SkSwizzle_RB(c: u32) -> u32;
}
extern "C" {
    #[link_name = "?SkPackARGB_as_RGBA@@YAIIIII@Z"]
    pub fn SkPackARGB_as_RGBA(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) -> u32;
}
extern "C" {
    #[link_name = "?SkPackARGB_as_BGRA@@YAIIIII@Z"]
    pub fn SkPackARGB_as_BGRA(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) -> u32;
}
extern "C" {
    #[link_name = "?SkSwizzle_RGBA_to_PMColor@@YAII@Z"]
    pub fn SkSwizzle_RGBA_to_PMColor(c: u32) -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkSwizzle_BGRA_to_PMColor@@YAII@Z"]
    pub fn SkSwizzle_BGRA_to_PMColor(c: u32) -> SkPMColor;
}
extern "C" {
    /** Computes the luminance from the given r, g, and b in accordance with
    SK_LUM_COEFF_X. For correct results, r, g, and b should be in linear space.
*/
    #[link_name = "?SkComputeLuminance@@YAIIII@Z"]
    pub fn SkComputeLuminance(r: U8CPU, g: U8CPU, b: U8CPU) -> U8CPU;
}
extern "C" {
    /** Turn 0..255 into 0..256 by adding 1 at the half-way point. Used to turn a
    byte into a scale value, so that we can say scale * value >> 8 instead of
    alpha * value / 255.

    In debugging, asserts that alpha is 0..255
*/
    #[link_name = "?SkAlpha255To256@@YAII@Z"]
    pub fn SkAlpha255To256(alpha: U8CPU) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 *  Turn a 0..255 value into a 0..256 value, rounding up if the value is >= 0x80.
 *  This is slightly more accurate than SkAlpha255To256.
 */
    #[link_name = "?Sk255To256@@YAII@Z"]
    pub fn Sk255To256(value: U8CPU) -> ::std::os::raw::c_uint;
}
extern "C" {
    /** Calculates 256 - (value * alpha256) / 255 in range [0,256],
 *  for [0,255] value and [0,256] alpha256.
 */
    #[link_name = "?SkAlphaMulInv256@@YAIII@Z"]
    pub fn SkAlphaMulInv256(value: U16CPU, alpha256: U16CPU) -> U16CPU;
}
extern "C" {
    #[link_name = "?SkAlphaBlend@@YAHHHH@Z"]
    pub fn SkAlphaBlend(src: ::std::os::raw::c_int,
                        dst: ::std::os::raw::c_int,
                        scale256: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *  Returns (src * alpha + dst * (255 - alpha)) / 255
 *
 *  This is more accurate than SkAlphaBlend, but slightly slower
 */
    #[link_name = "?SkAlphaBlend255@@YAHHHI@Z"]
    pub fn SkAlphaBlend255(src: S16CPU, dst: S16CPU, alpha: U8CPU)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkUnitScalarClampToByte@@YAIM@Z"]
    pub fn SkUnitScalarClampToByte(x: SkScalar) -> U8CPU;
}
extern "C" {
    #[link_name = "?SkPackRGB16@@YAGIII@Z"]
    pub fn SkPackRGB16(r: ::std::os::raw::c_uint, g: ::std::os::raw::c_uint,
                       b: ::std::os::raw::c_uint) -> u16;
}
extern "C" {
    /** Expand the 16bit color into a 32bit value that can be scaled all at once
    by a value up to 32. Used in conjunction with SkCompact_rgb_16.
*/
    #[link_name = "?SkExpand_rgb_16@@YAII@Z"]
    pub fn SkExpand_rgb_16(c: U16CPU) -> u32;
}
extern "C" {
    /** Compress an expanded value (from SkExpand_rgb_16) back down to a 16bit
    color value. The computation yields only 16bits of valid data, but we claim
    to return 32bits, so that the compiler won't generate extra instructions to
    "clean" the top 16bits. However, the top 16 can contain garbage, so it is
    up to the caller to safely ignore them.
*/
    #[link_name = "?SkCompact_rgb_16@@YAII@Z"]
    pub fn SkCompact_rgb_16(c: u32) -> U16CPU;
}
extern "C" {
    /** Scale the 16bit color value by the 0..256 scale parameter.
    The computation yields only 16bits of valid data, but we claim
    to return 32bits, so that the compiler won't generate extra instructions to
    "clean" the top 16bits.
*/
    #[link_name = "?SkAlphaMulRGB16@@YAIII@Z"]
    pub fn SkAlphaMulRGB16(c: U16CPU, scale: ::std::os::raw::c_uint)
     -> U16CPU;
}
extern "C" {
    /** Blend pre-expanded RGB32 with 16bit color value by the 0..32 scale parameter.
    The computation yields only 16bits of valid data, but we claim to return
    32bits, so that the compiler won't generate extra instructions to "clean"
    the top 16bits.
*/
    #[link_name = "?SkBlend32_RGB16@@YAIIGI@Z"]
    pub fn SkBlend32_RGB16(src_expand: u32, dst: u16,
                           scale: ::std::os::raw::c_uint) -> U16CPU;
}
extern "C" {
    /** Blend src and dst 16bit colors by the 0..256 scale parameter.
    The computation yields only 16bits of valid data, but we claim
    to return 32bits, so that the compiler won't generate extra instructions to
    "clean" the top 16bits.
*/
    #[link_name = "?SkBlendRGB16@@YAIIIH@Z"]
    pub fn SkBlendRGB16(src: U16CPU, dst: U16CPU,
                        srcScale: ::std::os::raw::c_int) -> U16CPU;
}
extern "C" {
    #[link_name = "?SkBlendRGB16@@YAXQEBGQEAGHH@Z"]
    pub fn SkBlendRGB161(src: *const u16, dst: *mut u16,
                         srcScale: ::std::os::raw::c_int,
                         count: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?SkRGB16Add@@YAIII@Z"]
    pub fn SkRGB16Add(a: U16CPU, b: U16CPU) -> U16CPU;
}
extern "C" {
    #[link_name = "?SkPMColorValid@@YA_NI@Z"]
    pub fn SkPMColorValid(c: SkPMColor) -> bool;
}
extern "C" {
    /**
 *  Pack the components into a SkPMColor, checking (in the debug version) that
 *  the components are 0..255, and are already premultiplied (i.e. alpha >= color)
 */
    #[link_name = "?SkPackARGB32@@YAIIIII@Z"]
    pub fn SkPackARGB32(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkPackPMColor_as_RGBA@@YAII@Z"]
    pub fn SkPackPMColor_as_RGBA(c: SkPMColor) -> u32;
}
extern "C" {
    #[link_name = "?SkPackPMColor_as_BGRA@@YAII@Z"]
    pub fn SkPackPMColor_as_BGRA(c: SkPMColor) -> u32;
}
extern "C" {
    /**
 * Abstract 4-byte interpolation, implemented on top of SkPMColor
 * utility functions. Third parameter controls blending of the first two:
 *   (src, dst, 0) returns dst
 *   (src, dst, 0xFF) returns src
 *   srcWeight is [0..256], unlike SkFourByteInterp which takes [0..255]
 */
    #[link_name = "?SkFourByteInterp256@@YAIIII@Z"]
    pub fn SkFourByteInterp256(src: SkPMColor, dst: SkPMColor,
                               scale: ::std::os::raw::c_uint) -> SkPMColor;
}
extern "C" {
    /**
 * Abstract 4-byte interpolation, implemented on top of SkPMColor
 * utility functions. Third parameter controls blending of the first two:
 *   (src, dst, 0) returns dst
 *   (src, dst, 0xFF) returns src
 */
    #[link_name = "?SkFourByteInterp@@YAIIII@Z"]
    pub fn SkFourByteInterp(src: SkPMColor, dst: SkPMColor, srcWeight: U8CPU)
     -> SkPMColor;
}
extern "C" {
    /**
 * 0xAARRGGBB -> 0x00AA00GG, 0x00RR00BB
 */
    #[link_name = "?SkSplay@@YAXIPEAI0@Z"]
    pub fn SkSplay(color: u32, ag: *mut u32, rb: *mut u32);
}
extern "C" {
    /**
 * 0xAARRGGBB -> 0x00AA00GG00RR00BB
 * (note, ARGB -> AGRB)
 */
    #[link_name = "?SkSplay@@YA_KI@Z"]
    pub fn SkSplay1(color: u32) -> u64;
}
extern "C" {
    /**
 * 0xAAxxGGxx, 0xRRxxBBxx-> 0xAARRGGBB
 */
    #[link_name = "?SkUnsplay@@YAIII@Z"]
    pub fn SkUnsplay(ag: u32, rb: u32) -> u32;
}
extern "C" {
    /**
 * 0xAAxxGGxxRRxxBBxx -> 0xAARRGGBB
 * (note, AGRB -> ARGB)
 */
    #[link_name = "?SkUnsplay@@YAI_K@Z"]
    pub fn SkUnsplay1(agrb: u64) -> u32;
}
extern "C" {
    #[link_name = "?SkFastFourByteInterp256_32@@YAIIII@Z"]
    pub fn SkFastFourByteInterp256_32(src: SkPMColor, dst: SkPMColor,
                                      scale: ::std::os::raw::c_uint)
     -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkFastFourByteInterp256_64@@YAIIII@Z"]
    pub fn SkFastFourByteInterp256_64(src: SkPMColor, dst: SkPMColor,
                                      scale: ::std::os::raw::c_uint)
     -> SkPMColor;
}
extern "C" {
    /**
 * Same as SkFourByteInterp256, but faster.
 */
    #[link_name = "?SkFastFourByteInterp256@@YAIIII@Z"]
    pub fn SkFastFourByteInterp256(src: SkPMColor, dst: SkPMColor,
                                   scale: ::std::os::raw::c_uint)
     -> SkPMColor;
}
extern "C" {
    /**
 * Nearly the same as SkFourByteInterp, but faster and a touch more accurate, due to better
 * srcWeight scaling to [0, 256].
 */
    #[link_name = "?SkFastFourByteInterp@@YAIIII@Z"]
    pub fn SkFastFourByteInterp(src: SkPMColor, dst: SkPMColor,
                                srcWeight: U8CPU) -> SkPMColor;
}
extern "C" {
    /**
 *  Same as SkPackARGB32, but this version guarantees to not check that the
 *  values are premultiplied in the debug version.
 */
    #[link_name = "?SkPackARGB32NoCheck@@YAIIIII@Z"]
    pub fn SkPackARGB32NoCheck(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU)
     -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkPremultiplyARGBInline@@YAIIIII@Z"]
    pub fn SkPremultiplyARGBInline(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU)
     -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkAlphaMulQ@@YAIII@Z"]
    pub fn SkAlphaMulQ(c: u32, scale: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    #[link_name = "?SkPMSrcOver@@YAIII@Z"]
    pub fn SkPMSrcOver(src: SkPMColor, dst: SkPMColor) -> SkPMColor;
}
extern "C" {
    /**
 * Interpolates between colors src and dst using [0,256] scale.
 */
    #[link_name = "?SkPMLerp@@YAIIII@Z"]
    pub fn SkPMLerp(src: SkPMColor, dst: SkPMColor,
                    scale: ::std::os::raw::c_uint) -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkBlendARGB32@@YAIIII@Z"]
    pub fn SkBlendARGB32(src: SkPMColor, dst: SkPMColor, aa: U8CPU)
     -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkR32ToR16@@YAII@Z"]
    pub fn SkR32ToR16(r: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkG32ToG16@@YAII@Z"]
    pub fn SkG32ToG16(g: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkB32ToB16@@YAII@Z"]
    pub fn SkB32ToB16(b: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkPixel32ToPixel16@@YAII@Z"]
    pub fn SkPixel32ToPixel16(c: SkPMColor) -> U16CPU;
}
extern "C" {
    #[link_name = "?SkPack888ToRGB16@@YAIIII@Z"]
    pub fn SkPack888ToRGB16(r: U8CPU, g: U8CPU, b: U8CPU) -> U16CPU;
}
extern "C" {
    #[link_name = "?SkDitherPack888ToRGB16@@YAGIII@Z"]
    pub fn SkDitherPack888ToRGB16(r: U8CPU, g: U8CPU, b: U8CPU) -> u16;
}
extern "C" {
    #[link_name = "?SkDitherPixel32ToPixel16@@YAGI@Z"]
    pub fn SkDitherPixel32ToPixel16(c: SkPMColor) -> u16;
}
extern "C" {
    #[link_name = "?SkPMColorToExpanded16x5@@YAII@Z"]
    pub fn SkPMColorToExpanded16x5(c: SkPMColor) -> u32;
}
extern "C" {
    #[link_name = "?SkSrcOver32To16@@YAIIG@Z"]
    pub fn SkSrcOver32To16(src: SkPMColor, dst: u16) -> U16CPU;
}
extern "C" {
    ////////////////////////////////////////////////////////////////////////////////////////////
    #[link_name = "?SkR16ToR32@@YAII@Z"]
    pub fn SkR16ToR32(r: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkG16ToG32@@YAII@Z"]
    pub fn SkG16ToG32(g: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkB16ToB32@@YAII@Z"]
    pub fn SkB16ToB32(b: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkPixel16ToPixel32@@YAII@Z"]
    pub fn SkPixel16ToPixel32(src: U16CPU) -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkPixel16ToColor@@YAII@Z"]
    pub fn SkPixel16ToColor(src: U16CPU) -> SkColor;
}
///////////////////////////////////////////////////////////////////////////////
pub type SkPMColor16 = u16;
extern "C" {
    #[link_name = "?SkReplicateNibble@@YAII@Z"]
    pub fn SkReplicateNibble(nib: ::std::os::raw::c_uint) -> U8CPU;
}
extern "C" {
    #[link_name = "?SkPMColor16Assert@@YAXI@Z"]
    pub fn SkPMColor16Assert(c: U16CPU);
}
extern "C" {
    #[link_name = "?SkAlpha15To16@@YAII@Z"]
    pub fn SkAlpha15To16(a: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkAlphaMul4@@YAHHH@Z"]
    pub fn SkAlphaMul4(value: ::std::os::raw::c_int,
                       scale: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkR4444ToR565@@YAII@Z"]
    pub fn SkR4444ToR565(r: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkG4444ToG565@@YAII@Z"]
    pub fn SkG4444ToG565(g: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkB4444ToB565@@YAII@Z"]
    pub fn SkB4444ToB565(b: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "?SkPackARGB4444@@YAGIIII@Z"]
    pub fn SkPackARGB4444(a: ::std::os::raw::c_uint,
                          r: ::std::os::raw::c_uint,
                          g: ::std::os::raw::c_uint,
                          b: ::std::os::raw::c_uint) -> SkPMColor16;
}
extern "C" {
    #[link_name = "?SkAlphaMulQ4@@YAGGH@Z"]
    pub fn SkAlphaMulQ4(c: SkPMColor16, scale: ::std::os::raw::c_int)
     -> SkPMColor16;
}
extern "C" {
    /** Expand the SkPMColor16 color into a 32bit value that can be scaled all at
    once by a value up to 16.
*/
    #[link_name = "?SkExpand_4444@@YAII@Z"]
    pub fn SkExpand_4444(c: U16CPU) -> u32;
}
extern "C" {
    #[link_name = "?SkSrcOver4444To16@@YAGGG@Z"]
    pub fn SkSrcOver4444To16(s: SkPMColor16, d: u16) -> u16;
}
extern "C" {
    #[link_name = "?SkBlend4444To16@@YAGGGH@Z"]
    pub fn SkBlend4444To16(src: SkPMColor16, dst: u16,
                           scale16: ::std::os::raw::c_int) -> u16;
}
extern "C" {
    #[link_name = "?SkPixel4444ToPixel32@@YAII@Z"]
    pub fn SkPixel4444ToPixel32(c: U16CPU) -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkPixel32ToPixel4444@@YAGI@Z"]
    pub fn SkPixel32ToPixel4444(c: SkPMColor) -> SkPMColor16;
}
extern "C" {
    #[link_name = "?SkDitherARGB32To4444@@YAGIIII@Z"]
    pub fn SkDitherARGB32To4444(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU)
     -> SkPMColor16;
}
extern "C" {
    #[link_name = "?SkDitherPixel32To4444@@YAGI@Z"]
    pub fn SkDitherPixel32To4444(c: SkPMColor) -> SkPMColor16;
}
extern "C" {
    #[link_name = "?SkExpand_8888@@YAII@Z"]
    pub fn SkExpand_8888(c: SkPMColor) -> u32;
}
extern "C" {
    #[link_name = "?SkCompact_8888@@YAII@Z"]
    pub fn SkCompact_8888(c: u32) -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkExpand32_4444@@YAII@Z"]
    pub fn SkExpand32_4444(c: SkPMColor) -> u32;
}
extern "C" {
    ///////////////////////////////////////////////////////////////////////////////
    #[link_name = "?SkUpscale31To32@@YAHH@Z"]
    pub fn SkUpscale31To32(value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkBlend32@@YAHHHH@Z"]
    pub fn SkBlend32(src: ::std::os::raw::c_int, dst: ::std::os::raw::c_int,
                     scale: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?SkBlendLCD16@@YAIHHHHIG@Z"]
    pub fn SkBlendLCD16(srcA: ::std::os::raw::c_int,
                        srcR: ::std::os::raw::c_int,
                        srcG: ::std::os::raw::c_int,
                        srcB: ::std::os::raw::c_int, dst: SkPMColor,
                        mask: u16) -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkBlendLCD16Opaque@@YAIHHHIGI@Z"]
    pub fn SkBlendLCD16Opaque(srcR: ::std::os::raw::c_int,
                              srcG: ::std::os::raw::c_int,
                              srcB: ::std::os::raw::c_int, dst: SkPMColor,
                              mask: u16, opaqueDst: SkPMColor) -> SkPMColor;
}
extern "C" {
    #[link_name = "?SkBlitLCD16Row@@YAXQEAIQEBGIHI@Z"]
    pub fn SkBlitLCD16Row(dst: *mut SkPMColor, mask: *const u16, src: SkColor,
                          width: ::std::os::raw::c_int, arg1: SkPMColor);
}
extern "C" {
    #[link_name = "?SkBlitLCD16OpaqueRow@@YAXQEAIQEBGIHI@Z"]
    pub fn SkBlitLCD16OpaqueRow(dst: *mut SkPMColor, mask: *const u16,
                                src: SkColor, width: ::std::os::raw::c_int,
                                opaqueDst: SkPMColor);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkFallbackAlloc {
    pub _address: u8,
}
impl Clone for SkFallbackAlloc {
    fn clone(&self) -> Self { *self }
}
/**
 *  SkImage is an abstraction for drawing a rectagle of pixels, though the
 *  particular type of image could be actually storing its data on the GPU, or
 *  as drawing commands (picture or PDF or otherwise), ready to be played back
 *  into another canvas.
 *
 *  The content of SkImage is always immutable, though the actual storage may
 *  change, if for example that image can be re-created via encoded data or
 *  other means.
 *
 *  SkImage always has a non-zero dimensions. If there is a request to create a new image, either
 *  directly or via SkSurface, and either of the requested dimensions are zero, then NULL will be
 *  returned.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkImage {
    pub _base: SkRefCnt,
    pub fWidth: ::std::os::raw::c_int,
    pub fHeight: ::std::os::raw::c_int,
    pub fUniqueID: u32,
}
pub type SkImage_Info = SkImageInfo;
pub type SkImage_ReleaseContext = *mut ::std::os::raw::c_void;
pub type SkImage_RasterReleaseProc =
    ::std::option::Option<unsafe extern "C" fn(pixels:
                                                   *const ::std::os::raw::c_void,
                                               arg1: SkImage_ReleaseContext)>;
pub type SkImage_TextureReleaseProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: SkImage_ReleaseContext)>;
#[repr(i32)]
/**
     *  Hints to image calls where the system might cache computed intermediates (e.g. the results
     *  of decoding or a read-back from the GPU. Passing kAllow signals that the system's default
     *  behavior is fine. Passing kDisallow signals that caching should be avoided.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkImage_CachingHint {
    kAllow_CachingHint = 0,
    kDisallow_CachingHint = 1,
}
/** Drawing params for which a deferred texture image data should be optimized. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkImage_DeferredTextureImageUsageParams {
    pub fMatrix: SkMatrix,
    pub fQuality: SkFilterQuality,
    pub fPreScaleMipLevel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkImage_DeferredTextureImageUsageParams() {
    assert_eq!(::std::mem::size_of::<SkImage_DeferredTextureImageUsageParams>()
               , 48usize);
    assert_eq!(::std::mem::align_of::<SkImage_DeferredTextureImageUsageParams>()
               , 4usize);
}
impl Clone for SkImage_DeferredTextureImageUsageParams {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkImage_LegacyBitmapMode {
    kRO_LegacyBitmapMode = 0,
    kRW_LegacyBitmapMode = 1,
}
pub type SkImage_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkImage() {
    assert_eq!(::std::mem::size_of::<SkImage>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkImage>() , 1usize);
}
extern "C" {
    #[link_name =
          "?MakeRasterCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkPixmap@@@Z"]
    pub fn SkImage_MakeRasterCopy(arg1: *const SkPixmap) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name =
          "?MakeRasterData@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBUSkImageInfo@@V?$sk_sp@VSkData@@@@_K@Z"]
    pub fn SkImage_MakeRasterData(arg1: *const SkImage_Info,
                                  pixels: sk_sp<SkData>, rowBytes: usize)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Return a new Image referencing the specified pixels. These must remain valid and unchanged
     *  until the specified release-proc is called, indicating that Skia no longer has a reference
     *  to the pixels.
     *
     *  Returns NULL if the requested pixmap info is unsupported.
     */
    #[link_name =
          "?MakeFromRaster@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkPixmap@@P6AXPEBXPEAX@Z2@Z"]
    pub fn SkImage_MakeFromRaster(arg1: *const SkPixmap,
                                  arg2: SkImage_RasterReleaseProc,
                                  arg3: SkImage_ReleaseContext)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Construct a new image from the specified bitmap. If the bitmap is marked immutable, and
     *  its pixel memory is shareable, it may be shared instead of copied.
     */
    #[link_name =
          "?MakeFromBitmap@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkBitmap@@@Z"]
    pub fn SkImage_MakeFromBitmap(arg1: *const SkBitmap) -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Construct a new SkImage based on the given ImageGenerator. Returns NULL on error.
     *  This function will always take ownership of the passed generator.
     *
     *  If a subset is specified, it must be contained within the generator's bounds.
     */
    #[link_name =
          "?MakeFromGenerator@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVSkImageGenerator@@PEBUSkIRect@@@Z"]
    pub fn SkImage_MakeFromGenerator(arg1: *mut SkImageGenerator,
                                     subset: *const SkIRect)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Construct a new SkImage based on the specified encoded data. Returns NULL on failure,
     *  which can mean that the format of the encoded data was not recognized/supported.
     *
     *  If a subset is specified, it must be contained within the encoded data's bounds.
     */
    #[link_name =
          "?MakeFromEncoded@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkData@@@@PEBUSkIRect@@@Z"]
    pub fn SkImage_MakeFromEncoded(encoded: sk_sp<SkData>,
                                   subset: *const SkIRect) -> sk_sp<SkImage>;
}
extern "C" {
    /**
    *  Create a new image from the specified descriptor. The underlying platform texture must stay
    *  valid and unaltered until the specified release-proc is invoked, indicating that Skia
    *  no longer is holding a reference to it.
    *
    *  Will return NULL if the specified descriptor is unsupported.
    */
    #[link_name =
          "?MakeFromTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@P6AXPEAX@Z4@Z"]
    pub fn SkImage_MakeFromTexture(arg1: *mut GrContext,
                                   arg2: *const GrBackendTextureDesc,
                                   arg3: SkAlphaType,
                                   arg4: sk_sp<SkColorSpace>,
                                   arg5: SkImage_TextureReleaseProc,
                                   arg6: SkImage_ReleaseContext)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Create a new image from the specified descriptor. Note - Skia will delete or recycle the
     *  texture when the image is released.
     *
     *  Will return NULL if the specified descriptor is unsupported.
     */
    #[link_name =
          "?MakeFromAdoptedTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@@Z"]
    pub fn SkImage_MakeFromAdoptedTexture(arg1: *mut GrContext,
                                          arg2: *const GrBackendTextureDesc,
                                          arg3: SkAlphaType,
                                          arg4: sk_sp<SkColorSpace>)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Create a new image by copying the pixels from the specified y, u, v textures. The data
     *  from the textures is immediately ingested into the image and the textures can be modified or
     *  deleted after the function returns. The image will have the dimensions of the y texture.
     */
    #[link_name =
          "?MakeFromYUVTexturesCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@W4SkYUVColorSpace@@QEB_JQEBU?$SkTSize@H@@W4GrSurfaceOrigin@@V?$sk_sp@VSkColorSpace@@@@@Z"]
    pub fn SkImage_MakeFromYUVTexturesCopy(arg1: *mut GrContext,
                                           arg2: SkYUVColorSpace,
                                           yuvTextureHandles:
                                               *mut GrBackendObject,
                                           yuvSizes: *mut SkISize,
                                           arg3: GrSurfaceOrigin,
                                           arg4: sk_sp<SkColorSpace>)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Create a new image by copying the pixels from the specified y and uv textures. The data
     *  from the textures is immediately ingested into the image and the textures can be modified or
     *  deleted after the function returns. The image will have the dimensions of the y texture.
     */
    #[link_name =
          "?MakeFromNV12TexturesCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@W4SkYUVColorSpace@@QEB_JQEBU?$SkTSize@H@@W4GrSurfaceOrigin@@V?$sk_sp@VSkColorSpace@@@@@Z"]
    pub fn SkImage_MakeFromNV12TexturesCopy(arg1: *mut GrContext,
                                            arg2: SkYUVColorSpace,
                                            nv12TextureHandles:
                                                *mut GrBackendObject,
                                            nv12Sizes: *mut SkISize,
                                            arg3: GrSurfaceOrigin,
                                            arg4: sk_sp<SkColorSpace>)
     -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name =
          "?MakeFromPicture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkPicture@@@@AEBU?$SkTSize@H@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
    pub fn SkImage_MakeFromPicture(arg1: sk_sp<SkPicture>,
                                   dimensions: *const SkISize,
                                   arg2: *const SkMatrix,
                                   arg3: *const SkPaint) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name =
          "?MakeTextureFromPixmap@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@AEBVSkPixmap@@W4SkBudgeted@@@Z"]
    pub fn SkImage_MakeTextureFromPixmap(arg1: *mut GrContext,
                                         arg2: *const SkPixmap,
                                         budgeted: SkBudgeted)
     -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "?alphaType@SkImage@@QEBA?AW4SkAlphaType@@XZ"]
    pub fn SkImage_alphaType(this: *const SkImage) -> SkAlphaType;
}
extern "C" {
    /**
     *  Returns true fi the image will be drawn as a mask, with no intrinsic color of its own.
     */
    #[link_name = "?isAlphaOnly@SkImage@@QEBA_NXZ"]
    pub fn SkImage_isAlphaOnly(this: *const SkImage) -> bool;
}
extern "C" {
    /**
     * Extracts YUV planes from the SkImage and stores them in client-provided memory. The sizes
     * planes and rowBytes arrays are ordered [y, u, v].
     */
    #[link_name =
          "?readYUV8Planes@SkImage@@QEBA_NQEBU?$SkTSize@H@@QEBQEAXQEB_KW4SkYUVColorSpace@@@Z"]
    pub fn SkImage_readYUV8Planes(this: *const SkImage, arg1: *mut SkISize,
                                  planes: *mut *const ::std::os::raw::c_void,
                                  rowBytes: *mut usize, arg2: SkYUVColorSpace)
     -> bool;
}
extern "C" {
    #[link_name =
          "?makeShader@SkImage@@QEBA?AV?$sk_sp@VSkShader@@@@W4TileMode@SkShader@@0PEBVSkMatrix@@@Z"]
    pub fn SkImage_makeShader(this: *const SkImage, arg1: SkShader_TileMode,
                              arg2: SkShader_TileMode,
                              localMatrix: *const SkMatrix)
     -> sk_sp<SkShader>;
}
extern "C" {
    /**
     *  If the image has direct access to its pixels (i.e. they are in local RAM)
     *  return true, and if not null, return in the pixmap parameter the info about the
     *  images pixels.
     *
     *  On failure, return false and ignore the pixmap parameter.
     */
    #[link_name = "?peekPixels@SkImage@@QEBA_NPEAVSkPixmap@@@Z"]
    pub fn SkImage_peekPixels(this: *const SkImage, pixmap: *mut SkPixmap)
     -> bool;
}
extern "C" {
    /**
     *  Some images have to perform preliminary work in preparation for drawing. This can be
     *  decoding, uploading to a GPU, or other tasks. These happen automatically when an image
     *  is drawn, and often they are cached so that the cost is only paid the first time.
     *
     *  Preroll() can be called before drawing to try to perform this prepatory work ahead of time.
     *  For images that have no such work, this returns instantly. Others may do some thing to
     *  prepare their cache and then return.
     *
     *  If the image will drawn to a GPU-backed canvas or surface, pass the associated GrContext.
     *  If the image will be drawn to any other type of canvas or surface, pass null.
     */
    #[link_name = "?preroll@SkImage@@QEBAXPEAVGrContext@@@Z"]
    pub fn SkImage_preroll(this: *const SkImage, arg1: *mut GrContext);
}
extern "C" {
    #[link_name = "?getTexture@SkImage@@QEBAPEAVGrTexture@@XZ"]
    pub fn SkImage_getTexture(this: *const SkImage) -> *mut GrTexture;
}
extern "C" {
    /**
     *  Returns true if the image is texture backed.
     */
    #[link_name = "?isTextureBacked@SkImage@@QEBA_NXZ"]
    pub fn SkImage_isTextureBacked(this: *const SkImage) -> bool;
}
extern "C" {
    /**
     *  Retrieves the backend API handle of the texture. If flushPendingGrContextIO then the
     *  GrContext will issue to the backend API any deferred IO operations on the texture before
     *  returning.
     */
    #[link_name = "?getTextureHandle@SkImage@@QEBA_J_N@Z"]
    pub fn SkImage_getTextureHandle(this: *const SkImage,
                                    flushPendingGrContextIO: bool)
     -> GrBackendObject;
}
extern "C" {
    /**
     *  Copy the pixels from the image into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (dstInfo). The image pixels are read
     *  starting at the specified (srcX,srcY) location.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the image. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the image bounds.
     *  - If the requested colortype/alphatype cannot be converted from the image's types.
     */
    #[link_name =
          "?readPixels@SkImage@@QEBA_NAEBUSkImageInfo@@PEAX_KHHW4CachingHint@1@@Z"]
    pub fn SkImage_readPixels(this: *const SkImage,
                              dstInfo: *const SkImageInfo,
                              dstPixels: *mut ::std::os::raw::c_void,
                              dstRowBytes: usize, srcX: ::std::os::raw::c_int,
                              srcY: ::std::os::raw::c_int,
                              arg1: SkImage_CachingHint) -> bool;
}
extern "C" {
    #[link_name =
          "?readPixels@SkImage@@QEBA_NAEBVSkPixmap@@HHW4CachingHint@1@@Z"]
    pub fn SkImage_readPixels1(this: *const SkImage, dst: *const SkPixmap,
                               srcX: ::std::os::raw::c_int,
                               srcY: ::std::os::raw::c_int,
                               arg1: SkImage_CachingHint) -> bool;
}
extern "C" {
    /**
     *  Copy the pixels from this image into the dst pixmap, converting as needed into dst's
     *  colortype/alphatype. If the conversion cannot be performed, false is returned.
     *
     *  If dst's dimensions differ from the src dimension, the image will be scaled, applying the
     *  specified filter-quality.
     */
    #[link_name =
          "?scalePixels@SkImage@@QEBA_NAEBVSkPixmap@@W4SkFilterQuality@@W4CachingHint@1@@Z"]
    pub fn SkImage_scalePixels(this: *const SkImage, dst: *const SkPixmap,
                               arg1: SkFilterQuality,
                               arg2: SkImage_CachingHint) -> bool;
}
extern "C" {
    /**
     *  Encode the image's pixels and return the result as a new SkData, which
     *  the caller must manage (i.e. call unref() when they are done).
     *
     *  If the image type cannot be encoded, or the requested encoder type is
     *  not supported, this will return NULL.
     *
     *  Note: this will attempt to encode the image's pixels in the specified format,
     *  even if the image returns a data from refEncoded(). That data will be ignored.
     */
    #[link_name =
          "?encode@SkImage@@QEBAPEAVSkData@@W4SkEncodedImageFormat@@H@Z"]
    pub fn SkImage_encode(this: *const SkImage, arg1: SkEncodedImageFormat,
                          quality: ::std::os::raw::c_int) -> *mut SkData;
}
extern "C" {
    /**
     *  Encode the image and return the result as a caller-managed SkData.  This will
     *  attempt to reuse existing encoded data (as returned by refEncoded).
     *
     *  We defer to the SkPixelSerializer both for vetting existing encoded data
     *  (useEncodedData) and for encoding the image (encode) when no such data is
     *  present or is rejected by the serializer.
     *
     *  If not specified, we use a default serializer which 1) always accepts existing data
     *  (in any format) and 2) encodes to PNG.
     *
     *  If no compatible encoded data exists and encoding fails, this method will also
     *  fail (return NULL).
     */
    #[link_name =
          "?encode@SkImage@@QEBAPEAVSkData@@PEAVSkPixelSerializer@@@Z"]
    pub fn SkImage_encode1(this: *const SkImage, arg1: *mut SkPixelSerializer)
     -> *mut SkData;
}
extern "C" {
    /**
     *  If the image already has its contents in encoded form (e.g. PNG or JPEG), return a ref
     *  to that data (which the caller must call unref() on). The caller is responsible for calling
     *  unref on the data when they are done.
     *
     *  If the image does not already has its contents in encoded form, return NULL.
     *
     *  Note: to force the image to return its contents as encoded data, try calling encode(...).
     */
    #[link_name = "?refEncoded@SkImage@@QEBAPEAVSkData@@XZ"]
    pub fn SkImage_refEncoded(this: *const SkImage) -> *mut SkData;
}
extern "C" {
    #[link_name = "?toString@SkImage@@QEBAPEBDPEAVSkString@@@Z"]
    pub fn SkImage_toString(this: *const SkImage, arg1: *mut SkString)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
     *  Return a new image that is a subset of this image. The underlying implementation may
     *  share the pixels, or it may make a copy.
     *
     *  If subset does not intersect the bounds of this image, or the copy/share cannot be made,
     *  NULL will be returned.
     */
    #[link_name =
          "?makeSubset@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@AEBUSkIRect@@@Z"]
    pub fn SkImage_makeSubset(this: *const SkImage, subset: *const SkIRect)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Ensures that an image is backed by a texture (when GrContext is non-null). If no
     *  transformation is required, the returned image may be the same as this image. If the this
     *  image is from a different GrContext, this will fail.
     */
    #[link_name =
          "?makeTextureImage@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@@Z"]
    pub fn SkImage_makeTextureImage(this: *const SkImage,
                                    arg1: *mut GrContext) -> sk_sp<SkImage>;
}
extern "C" {
    /**
     * If the image is texture-backed this will make a raster copy of it (or nullptr if reading back
     * the pixels fails). Otherwise, it returns the original image.
     */
    #[link_name =
          "?makeNonTextureImage@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@XZ"]
    pub fn SkImage_makeNonTextureImage(this: *const SkImage)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Apply a given image filter to this image, and return the filtered result.
     *
     *  The subset represents the active portion of this image. The return value is similarly an
     *  SkImage, with an active subset (outSubset). This is usually used with texture-backed
     *  images, where the texture may be approx-match and thus larger than the required size.
     *
     *  clipBounds constrains the device-space extent of the image which may be produced to the
     *  given rect.
     *
     *  offset is the amount to translate the resulting image relative to the src when it is drawn.
     *  This is an out-param.
     *
     *  If the result image cannot be created, or the result would be transparent black, null
     *  is returned, in which case the offset and outSubset parameters should be ignored by the
     *  caller.
     */
    #[link_name =
          "?makeWithFilter@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@PEBVSkImageFilter@@AEBUSkIRect@@1PEAU4@PEAUSkIPoint@@@Z"]
    pub fn SkImage_makeWithFilter(this: *const SkImage,
                                  filter: *const SkImageFilter,
                                  subset: *const SkIRect,
                                  clipBounds: *const SkIRect,
                                  outSubset: *mut SkIRect,
                                  offset: *mut SkIPoint) -> sk_sp<SkImage>;
}
extern "C" {
    /**
     * This method allows clients to capture the data necessary to turn a SkImage into a texture-
     * backed image. If the original image is codec-backed this will decode into a format optimized
     * for the context represented by the proxy. This method is thread safe with respect to the
     * GrContext whence the proxy came. Clients allocate and manage the storage of the deferred
     * texture data and control its lifetime. No cleanup is required, thus it is safe to simply free
     * the memory out from under the data.
     *
     * The same method is used both for getting the size necessary for pre-uploaded texture data
     * and for retrieving the data. The params array represents the set of draws over which to
     * optimize the pre-upload data.
     *
     * When called with a null buffer this returns the size that the client must allocate in order
     * to create deferred texture data for this image (or zero if this is an inappropriate
     * candidate). The buffer allocated by the client should be 8 byte aligned.
     *
     * When buffer is not null this fills in the deferred texture data for this image in the
     * provided buffer (assuming this is an appropriate candidate image and the buffer is
     * appropriately aligned). Upon success the size written is returned, otherwise 0.
     *
     * dstColorSpace is the color space of the surface where this texture will ultimately be used.
     * If the method determines that mip-maps are needed, this helps determine the correct strategy
     * for building them (gamma-correct or not).
     */
    #[link_name =
          "?getDeferredTextureImageData@SkImage@@QEBA_KAEBVGrContextThreadSafeProxy@@QEBUDeferredTextureImageUsageParams@1@HPEAXPEAVSkColorSpace@@@Z"]
    pub fn SkImage_getDeferredTextureImageData(this: *const SkImage,
                                               arg1:
                                                   *const GrContextThreadSafeProxy,
                                               arg2:
                                                   *const SkImage_DeferredTextureImageUsageParams,
                                               paramCnt:
                                                   ::std::os::raw::c_int,
                                               buffer:
                                                   *mut ::std::os::raw::c_void,
                                               dstColorSpace:
                                                   *mut SkColorSpace)
     -> usize;
}
extern "C" {
    /**
     * Returns a texture-backed image from data produced in SkImage::getDeferredTextureImageData.
     * The context must be the context that provided the proxy passed to
     * getDeferredTextureImageData.
     */
    #[link_name =
          "?MakeFromDeferredTextureImageData@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@PEBXW4SkBudgeted@@@Z"]
    pub fn SkImage_MakeFromDeferredTextureImageData(arg1: *mut GrContext,
                                                    arg2:
                                                        *const ::std::os::raw::c_void,
                                                    arg3: SkBudgeted)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Attempt to create a bitmap with the same pixels as the image. The result will always be
     *  a raster-backed bitmap (texture-backed bitmaps are DEPRECATED, and not supported here).
     *
     *  If the mode is kRO (read-only), the resulting bitmap will be marked as immutable.
     *
     *  On succcess, returns true. On failure, returns false and the bitmap parameter will be reset
     *  to empty.
     */
    #[link_name =
          "?asLegacyBitmap@SkImage@@QEBA_NPEAVSkBitmap@@W4LegacyBitmapMode@1@@Z"]
    pub fn SkImage_asLegacyBitmap(this: *const SkImage, arg1: *mut SkBitmap,
                                  arg2: SkImage_LegacyBitmapMode) -> bool;
}
extern "C" {
    /**
     *  Returns true if the image is backed by an image-generator or other src that creates
     *  (and caches) its pixels / texture on-demand.
     */
    #[link_name = "?isLazyGenerated@SkImage@@QEBA_NXZ"]
    pub fn SkImage_isLazyGenerated(this: *const SkImage) -> bool;
}
impl SkImage {
    #[inline]
    pub unsafe fn MakeRasterCopy(arg1: *const SkPixmap) -> sk_sp<SkImage> {
        SkImage_MakeRasterCopy(arg1)
    }
    #[inline]
    pub unsafe fn MakeRasterData(arg1: *const SkImage_Info,
                                 pixels: sk_sp<SkData>, rowBytes: usize)
     -> sk_sp<SkImage> {
        SkImage_MakeRasterData(arg1, pixels, rowBytes)
    }
    #[inline]
    pub unsafe fn MakeFromRaster(arg1: *const SkPixmap,
                                 arg2: SkImage_RasterReleaseProc,
                                 arg3: SkImage_ReleaseContext)
     -> sk_sp<SkImage> {
        SkImage_MakeFromRaster(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn MakeFromBitmap(arg1: *const SkBitmap) -> sk_sp<SkImage> {
        SkImage_MakeFromBitmap(arg1)
    }
    #[inline]
    pub unsafe fn MakeFromGenerator(arg1: *mut SkImageGenerator,
                                    subset: *const SkIRect)
     -> sk_sp<SkImage> {
        SkImage_MakeFromGenerator(arg1, subset)
    }
    #[inline]
    pub unsafe fn MakeFromEncoded(encoded: sk_sp<SkData>,
                                  subset: *const SkIRect) -> sk_sp<SkImage> {
        SkImage_MakeFromEncoded(encoded, subset)
    }
    #[inline]
    pub unsafe fn MakeFromTexture(arg1: *mut GrContext,
                                  arg2: *const GrBackendTextureDesc,
                                  arg3: SkAlphaType,
                                  arg4: sk_sp<SkColorSpace>,
                                  arg5: SkImage_TextureReleaseProc,
                                  arg6: SkImage_ReleaseContext)
     -> sk_sp<SkImage> {
        SkImage_MakeFromTexture(arg1, arg2, arg3, arg4, arg5, arg6)
    }
    #[inline]
    pub unsafe fn MakeFromAdoptedTexture(arg1: *mut GrContext,
                                         arg2: *const GrBackendTextureDesc,
                                         arg3: SkAlphaType,
                                         arg4: sk_sp<SkColorSpace>)
     -> sk_sp<SkImage> {
        SkImage_MakeFromAdoptedTexture(arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn MakeFromYUVTexturesCopy(arg1: *mut GrContext,
                                          arg2: SkYUVColorSpace,
                                          yuvTextureHandles:
                                              *mut GrBackendObject,
                                          yuvSizes: *mut SkISize,
                                          arg3: GrSurfaceOrigin,
                                          arg4: sk_sp<SkColorSpace>)
     -> sk_sp<SkImage> {
        SkImage_MakeFromYUVTexturesCopy(arg1, arg2, yuvTextureHandles,
                                        yuvSizes, arg3, arg4)
    }
    #[inline]
    pub unsafe fn MakeFromNV12TexturesCopy(arg1: *mut GrContext,
                                           arg2: SkYUVColorSpace,
                                           nv12TextureHandles:
                                               *mut GrBackendObject,
                                           nv12Sizes: *mut SkISize,
                                           arg3: GrSurfaceOrigin,
                                           arg4: sk_sp<SkColorSpace>)
     -> sk_sp<SkImage> {
        SkImage_MakeFromNV12TexturesCopy(arg1, arg2, nv12TextureHandles,
                                         nv12Sizes, arg3, arg4)
    }
    #[inline]
    pub unsafe fn MakeFromPicture(arg1: sk_sp<SkPicture>,
                                  dimensions: *const SkISize,
                                  arg2: *const SkMatrix, arg3: *const SkPaint)
     -> sk_sp<SkImage> {
        SkImage_MakeFromPicture(arg1, dimensions, arg2, arg3)
    }
    #[inline]
    pub unsafe fn MakeTextureFromPixmap(arg1: *mut GrContext,
                                        arg2: *const SkPixmap,
                                        budgeted: SkBudgeted)
     -> sk_sp<SkImage> {
        SkImage_MakeTextureFromPixmap(arg1, arg2, budgeted)
    }
    #[inline]
    pub unsafe fn alphaType(&self) -> SkAlphaType {
        SkImage_alphaType(&*self)
    }
    #[inline]
    pub unsafe fn isAlphaOnly(&self) -> bool { SkImage_isAlphaOnly(&*self) }
    #[inline]
    pub unsafe fn readYUV8Planes(&self, arg1: *mut SkISize,
                                 planes: *mut *const ::std::os::raw::c_void,
                                 rowBytes: *mut usize, arg2: SkYUVColorSpace)
     -> bool {
        SkImage_readYUV8Planes(&*self, arg1, planes, rowBytes, arg2)
    }
    #[inline]
    pub unsafe fn makeShader(&self, arg1: SkShader_TileMode,
                             arg2: SkShader_TileMode,
                             localMatrix: *const SkMatrix)
     -> sk_sp<SkShader> {
        SkImage_makeShader(&*self, arg1, arg2, localMatrix)
    }
    #[inline]
    pub unsafe fn peekPixels(&self, pixmap: *mut SkPixmap) -> bool {
        SkImage_peekPixels(&*self, pixmap)
    }
    #[inline]
    pub unsafe fn preroll(&self, arg1: *mut GrContext) {
        SkImage_preroll(&*self, arg1)
    }
    #[inline]
    pub unsafe fn getTexture(&self) -> *mut GrTexture {
        SkImage_getTexture(&*self)
    }
    #[inline]
    pub unsafe fn isTextureBacked(&self) -> bool {
        SkImage_isTextureBacked(&*self)
    }
    #[inline]
    pub unsafe fn getTextureHandle(&self, flushPendingGrContextIO: bool)
     -> GrBackendObject {
        SkImage_getTextureHandle(&*self, flushPendingGrContextIO)
    }
    #[inline]
    pub unsafe fn readPixels(&self, dstInfo: *const SkImageInfo,
                             dstPixels: *mut ::std::os::raw::c_void,
                             dstRowBytes: usize, srcX: ::std::os::raw::c_int,
                             srcY: ::std::os::raw::c_int,
                             arg1: SkImage_CachingHint) -> bool {
        SkImage_readPixels(&*self, dstInfo, dstPixels, dstRowBytes, srcX,
                           srcY, arg1)
    }
    #[inline]
    pub unsafe fn readPixels1(&self, dst: *const SkPixmap,
                              srcX: ::std::os::raw::c_int,
                              srcY: ::std::os::raw::c_int,
                              arg1: SkImage_CachingHint) -> bool {
        SkImage_readPixels1(&*self, dst, srcX, srcY, arg1)
    }
    #[inline]
    pub unsafe fn scalePixels(&self, dst: *const SkPixmap,
                              arg1: SkFilterQuality,
                              arg2: SkImage_CachingHint) -> bool {
        SkImage_scalePixels(&*self, dst, arg1, arg2)
    }
    #[inline]
    pub unsafe fn encode(&self, arg1: SkEncodedImageFormat,
                         quality: ::std::os::raw::c_int) -> *mut SkData {
        SkImage_encode(&*self, arg1, quality)
    }
    #[inline]
    pub unsafe fn encode1(&self, arg1: *mut SkPixelSerializer)
     -> *mut SkData {
        SkImage_encode1(&*self, arg1)
    }
    #[inline]
    pub unsafe fn refEncoded(&self) -> *mut SkData {
        SkImage_refEncoded(&*self)
    }
    #[inline]
    pub unsafe fn toString(&self, arg1: *mut SkString)
     -> *const ::std::os::raw::c_char {
        SkImage_toString(&*self, arg1)
    }
    #[inline]
    pub unsafe fn makeSubset(&self, subset: *const SkIRect)
     -> sk_sp<SkImage> {
        SkImage_makeSubset(&*self, subset)
    }
    #[inline]
    pub unsafe fn makeTextureImage(&self, arg1: *mut GrContext)
     -> sk_sp<SkImage> {
        SkImage_makeTextureImage(&*self, arg1)
    }
    #[inline]
    pub unsafe fn makeNonTextureImage(&self) -> sk_sp<SkImage> {
        SkImage_makeNonTextureImage(&*self)
    }
    #[inline]
    pub unsafe fn makeWithFilter(&self, filter: *const SkImageFilter,
                                 subset: *const SkIRect,
                                 clipBounds: *const SkIRect,
                                 outSubset: *mut SkIRect,
                                 offset: *mut SkIPoint) -> sk_sp<SkImage> {
        SkImage_makeWithFilter(&*self, filter, subset, clipBounds, outSubset,
                               offset)
    }
    #[inline]
    pub unsafe fn getDeferredTextureImageData(&self,
                                              arg1:
                                                  *const GrContextThreadSafeProxy,
                                              arg2:
                                                  *const SkImage_DeferredTextureImageUsageParams,
                                              paramCnt: ::std::os::raw::c_int,
                                              buffer:
                                                  *mut ::std::os::raw::c_void,
                                              dstColorSpace:
                                                  *mut SkColorSpace)
     -> usize {
        SkImage_getDeferredTextureImageData(&*self, arg1, arg2, paramCnt,
                                            buffer, dstColorSpace)
    }
    #[inline]
    pub unsafe fn MakeFromDeferredTextureImageData(arg1: *mut GrContext,
                                                   arg2:
                                                       *const ::std::os::raw::c_void,
                                                   arg3: SkBudgeted)
     -> sk_sp<SkImage> {
        SkImage_MakeFromDeferredTextureImageData(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn asLegacyBitmap(&self, arg1: *mut SkBitmap,
                                 arg2: SkImage_LegacyBitmapMode) -> bool {
        SkImage_asLegacyBitmap(&*self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn isLazyGenerated(&self) -> bool {
        SkImage_isLazyGenerated(&*self)
    }
}
/** \class SkPicture

    An SkPicture records drawing commands made to a canvas to be played back at a later time.
    This base class handles serialization and a few other miscellany.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkPicture {
    pub _base: SkRefCnt,
    pub fUniqueID: u32,
}
/**
     *  Function signature defining a function that sets up an SkBitmap from encoded data. On
     *  success, the SkBitmap should have its Config, width, height, rowBytes and pixelref set.
     *  If the installed pixelref has decoded the data into pixels, then the src buffer need not be
     *  copied. If the pixelref defers the actual decode until its lockPixels() is called, then it
     *  must make a copy of the src buffer.
     *  @param src Encoded data.
     *  @param length Size of the encoded data, in bytes.
     *  @param dst SkBitmap to install the pixel ref on.
     *  @param bool Whether or not a pixel ref was successfully installed.
     */
pub type SkPicture_InstallPixelRefProc =
    ::std::option::Option<unsafe extern "C" fn(src:
                                                   *const ::std::os::raw::c_void,
                                               length: usize,
                                               dst: *mut SkBitmap) -> bool>;
#[repr(C)]
pub struct SkPicture_AbortCallback__bindgen_vtable {
}
/**
    *  Subclasses of this can be passed to playback(). During the playback
    *  of the picture, this callback will periodically be invoked. If its
    *  abort() returns true, then picture playback will be interrupted.
    *
    *  The resulting drawing is undefined, as there is no guarantee how often the
    *  callback will be invoked. If the abort happens inside some level of nested
    *  calls to save(), restore will automatically be called to return the state
    *  to the same level it was before the playback call was made.
    */
#[repr(C)]
#[derive(Debug)]
pub struct SkPicture_AbortCallback {
    pub vtable_: *const SkPicture_AbortCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkPicture_AbortCallback() {
    assert_eq!(::std::mem::size_of::<SkPicture_AbortCallback>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkPicture_AbortCallback>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPicture_DeletionMessage {
    pub fUniqueID: i32,
}
#[test]
fn bindgen_test_layout_SkPicture_DeletionMessage() {
    assert_eq!(::std::mem::size_of::<SkPicture_DeletionMessage>() , 4usize);
    assert_eq!(::std::mem::align_of::<SkPicture_DeletionMessage>() , 4usize);
}
impl Clone for SkPicture_DeletionMessage {
    fn clone(&self) -> Self { *self }
}
pub const SkPicture_MIN_PICTURE_VERSION: u32 = 35;
pub const SkPicture_CURRENT_PICTURE_VERSION: u32 = 51;
#[test]
fn bindgen_test_layout_SkPicture() {
    assert_eq!(::std::mem::size_of::<SkPicture>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPicture>() , 1usize);
}
extern "C" {
    /**
     *  Recreate a picture that was serialized into a stream.
     *
     *  Any serialized images in the stream will be passed the image-deserializer, or if that is
     *  null, to the default deserializer that will call SkImage::MakeFromEncoded().
     */
    #[link_name =
          "?MakeFromStream@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEAVSkStream@@PEAVSkImageDeserializer@@@Z"]
    pub fn SkPicture_MakeFromStream(arg1: *mut SkStream,
                                    arg2: *mut SkImageDeserializer)
     -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name =
          "?MakeFromStream@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEAVSkStream@@@Z"]
    pub fn SkPicture_MakeFromStream1(arg1: *mut SkStream) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name =
          "?MakeFromData@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEBX_KPEAVSkImageDeserializer@@@Z"]
    pub fn SkPicture_MakeFromData(data: *const ::std::os::raw::c_void,
                                  size: usize, arg1: *mut SkImageDeserializer)
     -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name =
          "?MakeFromData@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEBVSkData@@PEAVSkImageDeserializer@@@Z"]
    pub fn SkPicture_MakeFromData1(data: *const SkData,
                                   arg1: *mut SkImageDeserializer)
     -> sk_sp<SkPicture>;
}
extern "C" {
    /**
     *  Recreate a picture that was serialized into a buffer. If the creation requires bitmap
     *  decoding, the decoder must be set on the SkReadBuffer parameter by calling
     *  SkReadBuffer::setBitmapDecoder() before calling SkPicture::CreateFromBuffer().
     *  @param SkReadBuffer Serialized picture data.
     *  @return A new SkPicture representing the serialized data, or NULL if the buffer is
     *          invalid.
     */
    #[link_name =
          "?MakeFromBuffer@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@AEAVSkReadBuffer@@@Z"]
    pub fn SkPicture_MakeFromBuffer(arg1: *mut SkReadBuffer)
     -> sk_sp<SkPicture>;
}
extern "C" {
    /** Returns a non-zero value unique among all pictures. */
    #[link_name = "?uniqueID@SkPicture@@QEBAIXZ"]
    pub fn SkPicture_uniqueID(this: *const SkPicture) -> u32;
}
extern "C" {
    /**
     *  Serialize the picture to SkData. If non nullptr, pixel-serializer will be used to
     *  customize how images reference by the picture are serialized/compressed.
     */
    #[link_name =
          "?serialize@SkPicture@@QEBA?AV?$sk_sp@VSkData@@@@PEAVSkPixelSerializer@@@Z"]
    pub fn SkPicture_serialize(this: *const SkPicture,
                               arg1: *mut SkPixelSerializer) -> sk_sp<SkData>;
}
extern "C" {
    /**
     *  Serialize to a stream. If non nullptr, pixel-serializer will be used to
     *  customize how images reference by the picture are serialized/compressed.
     */
    #[link_name =
          "?serialize@SkPicture@@QEBAXPEAVSkWStream@@PEAVSkPixelSerializer@@@Z"]
    pub fn SkPicture_serialize1(this: *const SkPicture, arg1: *mut SkWStream,
                                arg2: *mut SkPixelSerializer);
}
extern "C" {
    /**
     *  Serialize to a buffer.
     */
    #[link_name = "?flatten@SkPicture@@QEBAXAEAVSkWriteBuffer@@@Z"]
    pub fn SkPicture_flatten(this: *const SkPicture,
                             arg1: *mut SkWriteBuffer);
}
extern "C" {
    /** Return true if the SkStream/Buffer represents a serialized picture, and
        fills out SkPictInfo. After this function returns, the data source is not
        rewound so it will have to be manually reset before passing to
        CreateFromStream or CreateFromBuffer. Note, CreateFromStream and
        CreateFromBuffer perform this check internally so these entry points are
        intended for stand alone tools.
        If false is returned, SkPictInfo is unmodified.
    */
    #[link_name =
          "?InternalOnly_StreamIsSKP@SkPicture@@SA_NPEAVSkStream@@PEAUSkPictInfo@@@Z"]
    pub fn SkPicture_InternalOnly_StreamIsSKP(arg1: *mut SkStream,
                                              arg2: *mut SkPictInfo) -> bool;
}
extern "C" {
    #[link_name =
          "?InternalOnly_BufferIsSKP@SkPicture@@SA_NPEAVSkReadBuffer@@PEAUSkPictInfo@@@Z"]
    pub fn SkPicture_InternalOnly_BufferIsSKP(arg1: *mut SkReadBuffer,
                                              arg2: *mut SkPictInfo) -> bool;
}
extern "C" {
    #[link_name =
          "?SetPictureIOSecurityPrecautionsEnabled_Dangerous@SkPicture@@SAX_N@Z"]
    pub fn SkPicture_SetPictureIOSecurityPrecautionsEnabled_Dangerous(set:
                                                                          bool);
}
extern "C" {
    #[link_name = "?PictureIOSecurityPrecautionsEnabled@SkPicture@@SA_NXZ"]
    pub fn SkPicture_PictureIOSecurityPrecautionsEnabled() -> bool;
}
impl SkPicture {
    #[inline]
    pub unsafe fn MakeFromStream(arg1: *mut SkStream,
                                 arg2: *mut SkImageDeserializer)
     -> sk_sp<SkPicture> {
        SkPicture_MakeFromStream(arg1, arg2)
    }
    #[inline]
    pub unsafe fn MakeFromStream1(arg1: *mut SkStream) -> sk_sp<SkPicture> {
        SkPicture_MakeFromStream1(arg1)
    }
    #[inline]
    pub unsafe fn MakeFromData(data: *const ::std::os::raw::c_void,
                               size: usize, arg1: *mut SkImageDeserializer)
     -> sk_sp<SkPicture> {
        SkPicture_MakeFromData(data, size, arg1)
    }
    #[inline]
    pub unsafe fn MakeFromData1(data: *const SkData,
                                arg1: *mut SkImageDeserializer)
     -> sk_sp<SkPicture> {
        SkPicture_MakeFromData1(data, arg1)
    }
    #[inline]
    pub unsafe fn MakeFromBuffer(arg1: *mut SkReadBuffer)
     -> sk_sp<SkPicture> {
        SkPicture_MakeFromBuffer(arg1)
    }
    #[inline]
    pub unsafe fn uniqueID(&self) -> u32 { SkPicture_uniqueID(&*self) }
    #[inline]
    pub unsafe fn serialize(&self, arg1: *mut SkPixelSerializer)
     -> sk_sp<SkData> {
        SkPicture_serialize(&*self, arg1)
    }
    #[inline]
    pub unsafe fn serialize1(&self, arg1: *mut SkWStream,
                             arg2: *mut SkPixelSerializer) {
        SkPicture_serialize1(&*self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn flatten(&self, arg1: *mut SkWriteBuffer) {
        SkPicture_flatten(&*self, arg1)
    }
    #[inline]
    pub unsafe fn InternalOnly_StreamIsSKP(arg1: *mut SkStream,
                                           arg2: *mut SkPictInfo) -> bool {
        SkPicture_InternalOnly_StreamIsSKP(arg1, arg2)
    }
    #[inline]
    pub unsafe fn InternalOnly_BufferIsSKP(arg1: *mut SkReadBuffer,
                                           arg2: *mut SkPictInfo) -> bool {
        SkPicture_InternalOnly_BufferIsSKP(arg1, arg2)
    }
    #[inline]
    pub unsafe fn SetPictureIOSecurityPrecautionsEnabled_Dangerous(set:
                                                                       bool) {
        SkPicture_SetPictureIOSecurityPrecautionsEnabled_Dangerous(set)
    }
    #[inline]
    pub unsafe fn PictureIOSecurityPrecautionsEnabled() -> bool {
        SkPicture_PictureIOSecurityPrecautionsEnabled()
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRasterPipeline {
    pub _address: u8,
}
impl Clone for SkRasterPipeline {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrContext {
    pub _address: u8,
}
impl Clone for GrContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrFragmentProcessor {
    pub _address: u8,
}
impl Clone for GrFragmentProcessor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct SkImageGenerator__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkImageGenerator {
    pub vtable_: *const SkImageGenerator__bindgen_vtable,
    pub fInfo: SkImageInfo,
    pub fUniqueID: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkImageGenerator_SupportedSizes {
    pub fSizes: [SkISize; 2usize],
}
#[test]
fn bindgen_test_layout_SkImageGenerator_SupportedSizes() {
    assert_eq!(::std::mem::size_of::<SkImageGenerator_SupportedSizes>() ,
               1usize);
    assert_eq!(::std::mem::align_of::<SkImageGenerator_SupportedSizes>() ,
               1usize);
}
impl Clone for SkImageGenerator_SupportedSizes {
    fn clone(&self) -> Self { *self }
}
/**
     *  External generator API: provides efficient access to externally-managed image data.
     *
     *  Skia calls accessScaledPixels() during rasterization, to gain temporary access to
     *  the external pixel data.  When done, the provided callback is invoked to release the
     *  associated resources.
     *
     *  @param srcRect     the source rect in use for the current draw
     *  @param totalMatrix full matrix in effect (mapping srcRect -> device space)
     *  @param quality     the SkFilterQuality requested for rasterization.
     *  @param rec         out param, expected to be set when the call succeeds:
     *
     *                       - fPixmap      external pixel data
     *                       - fSrcRect     is an adjusted srcRect
     *                       - fQuality     is the adjusted filter quality
     *                       - fReleaseProc pixmap release callback, same signature as the
     *                                      SkBitmap::installPixels() callback
     *                       - fReleaseCtx  opaque release context argument
     *
     *  @return            true on success, false otherwise (error or if this API is not supported;
     *                     in this case Skia will fall back to its internal scaling and caching
     *                     heuristics)
     *
     *  Implementors can return pixmaps with a different size than requested, by adjusting the
     *  src rect.  The contract is that Skia will observe the adjusted src rect, and will map it
     *  to the same dest as the original draw (the impl doesn't get to control the destination).
     *
     */
#[repr(C)]
#[derive(Debug)]
pub struct SkImageGenerator_ScaledImageRec {
    pub fPixmap: SkPixmap,
    pub fSrcRect: SkRect,
    pub fQuality: SkFilterQuality,
    pub fReleaseProc: SkImageGenerator_ScaledImageRec_ReleaseProcT,
    pub fReleaseCtx: *mut ::std::os::raw::c_void,
}
pub type SkImageGenerator_ScaledImageRec_ReleaseProcT =
    ::std::option::Option<unsafe extern "C" fn(pixels:
                                                   *mut ::std::os::raw::c_void,
                                               releaseCtx:
                                                   *mut ::std::os::raw::c_void)>;
#[test]
fn bindgen_test_layout_SkImageGenerator_ScaledImageRec() {
    assert_eq!(::std::mem::size_of::<SkImageGenerator_ScaledImageRec>() ,
               1usize);
    assert_eq!(::std::mem::align_of::<SkImageGenerator_ScaledImageRec>() ,
               1usize);
}
pub const SkImageGenerator_kNeedNewImageUniqueID:
          SkImageGenerator__bindgen_ty_1 =
    SkImageGenerator__bindgen_ty_1::kNeedNewImageUniqueID;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkImageGenerator__bindgen_ty_1 { kNeedNewImageUniqueID = 0, }
#[test]
fn bindgen_test_layout_SkImageGenerator() {
    assert_eq!(::std::mem::size_of::<SkImageGenerator>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkImageGenerator>() , 1usize);
}
extern "C" {
    /**
     *  Decode into the given pixels, a block of memory of size at
     *  least (info.fHeight - 1) * rowBytes + (info.fWidth *
     *  bytesPerPixel)
     *
     *  Repeated calls to this function should give the same results,
     *  allowing the PixelRef to be immutable.
     *
     *  @param info A description of the format (config, size)
     *         expected by the caller.  This can simply be identical
     *         to the info returned by getInfo().
     *
     *         This contract also allows the caller to specify
     *         different output-configs, which the implementation can
     *         decide to support or not.
     *
     *         A size that does not match getInfo() implies a request
     *         to scale. If the generator cannot perform this scale,
     *         it will return kInvalidScale.
     *
     *  If info is kIndex8_SkColorType, then the caller must provide storage for up to 256
     *  SkPMColor values in ctable. On success the generator must copy N colors into that storage,
     *  (where N is the logical number of table entries) and set ctableCount to N.
     *
     *  If info is not kIndex8_SkColorType, then the last two parameters may be NULL. If ctableCount
     *  is not null, it will be set to 0.
     *
     *  @return true on success.
     */
    #[link_name =
          "?getPixels@SkImageGenerator@@QEAA_NAEBUSkImageInfo@@PEAX_KQEAIPEAH@Z"]
    pub fn SkImageGenerator_getPixels(this: *mut SkImageGenerator,
                                      info: *const SkImageInfo,
                                      pixels: *mut ::std::os::raw::c_void,
                                      rowBytes: usize, ctable: *mut SkPMColor,
                                      ctableCount: *mut ::std::os::raw::c_int)
     -> bool;
}
extern "C" {
    /**
     *  Simplified version of getPixels() that asserts that info is NOT kIndex8_SkColorType and
     *  uses the default Options.
     */
    #[link_name =
          "?getPixels@SkImageGenerator@@QEAA_NAEBUSkImageInfo@@PEAX_K@Z"]
    pub fn SkImageGenerator_getPixels1(this: *mut SkImageGenerator,
                                       info: *const SkImageInfo,
                                       pixels: *mut ::std::os::raw::c_void,
                                       rowBytes: usize) -> bool;
}
extern "C" {
    /**
     *  If decoding to YUV is supported, this returns true.  Otherwise, this
     *  returns false and does not modify any of the parameters.
     *
     *  @param sizeInfo   Output parameter indicating the sizes and required
     *                    allocation widths of the Y, U, and V planes.
     *  @param colorSpace Output parameter.
     */
    #[link_name =
          "?queryYUV8@SkImageGenerator@@QEBA_NPEAUSkYUVSizeInfo@@PEAW4SkYUVColorSpace@@@Z"]
    pub fn SkImageGenerator_queryYUV8(this: *const SkImageGenerator,
                                      sizeInfo: *mut SkYUVSizeInfo,
                                      colorSpace: *mut SkYUVColorSpace)
     -> bool;
}
extern "C" {
    /**
     *  Returns true on success and false on failure.
     *  This always attempts to perform a full decode.  If the client only
     *  wants size, it should call queryYUV8().
     *
     *  @param sizeInfo   Needs to exactly match the values returned by the
     *                    query, except the WidthBytes may be larger than the
     *                    recommendation (but not smaller).
     *  @param planes     Memory for each of the Y, U, and V planes.
     */
    #[link_name =
          "?getYUV8Planes@SkImageGenerator@@QEAA_NAEBUSkYUVSizeInfo@@QEAPEAX@Z"]
    pub fn SkImageGenerator_getYUV8Planes(this: *mut SkImageGenerator,
                                          sizeInfo: *const SkYUVSizeInfo,
                                          planes:
                                              *mut *mut ::std::os::raw::c_void)
     -> bool;
}
extern "C" {
    /**
     *  If the generator can natively/efficiently return its pixels as a GPU image (backed by a
     *  texture) this will return that image. If not, this will return NULL.
     *
     *  Regarding the GrContext parameter:
     *
     *  The caller may pass NULL for the context. In that case the generator may assume that its
     *  internal context is current. If it has no internal context, then it should just return
     *  null.
     *
     *  If the caller passes a non-null context, then the generator should only succeed if:
     *  - it has no intrinsic context, and will use the caller's
     *  - its internal context is the same
     *  - it can somehow convert its texture into one that is valid for the provided context.
     */
    #[link_name =
          "?generateTexture@SkImageGenerator@@QEAAPEAVGrTexture@@PEAVGrContext@@PEBUSkIRect@@@Z"]
    pub fn SkImageGenerator_generateTexture(this: *mut SkImageGenerator,
                                            arg1: *mut GrContext,
                                            subset: *const SkIRect)
     -> *mut GrTexture;
}
extern "C" {
    /**
     *  Some generators can efficiently scale their contents. If this is supported, the generator
     *  may only support certain scaled dimensions. Call this with the desired scale factor,
     *  and it will return true if scaling is supported, and in supportedSizes[] it will return
     *  the nearest supported dimensions.
     *
     *  If no native scaling is supported, or scale is invalid (e.g. scale <= 0 || scale > 1)
     *  this will return false, and the supportedsizes will be undefined.
     */
    #[link_name =
          "?computeScaledDimensions@SkImageGenerator@@QEAA_NMPEAUSupportedSizes@1@@Z"]
    pub fn SkImageGenerator_computeScaledDimensions(this:
                                                        *mut SkImageGenerator,
                                                    scale: SkScalar,
                                                    arg1:
                                                        *mut SkImageGenerator_SupportedSizes)
     -> bool;
}
extern "C" {
    /**
     *  Scale the generator's pixels to fit into scaledSize.
     *  This routine also support retrieving only a subset of the pixels. That subset is specified
     *  by the following rectangle (in the scaled space):
     *
     *      subset = SkIRect::MakeXYWH(subsetOrigin.x(), subsetOrigin.y(),
     *                                 subsetPixels.width(), subsetPixels.height())
     *
     *  If subset is not contained inside the scaledSize, this returns false.
     *
     *      whole = SkIRect::MakeWH(scaledSize.width(), scaledSize.height())
     *      if (!whole.contains(subset)) {
     *          return false;
     *      }
     *
     *  If the requested colortype/alphatype in pixels is not supported,
     *  or the requested scaledSize is not supported, or the generator encounters an error,
     *  this returns false.
     */
    #[link_name =
          "?generateScaledPixels@SkImageGenerator@@QEAA_NAEBU?$SkTSize@H@@AEBUSkIPoint@@AEBVSkPixmap@@@Z"]
    pub fn SkImageGenerator_generateScaledPixels(this: *mut SkImageGenerator,
                                                 scaledSize: *const SkISize,
                                                 subsetOrigin:
                                                     *const SkIPoint,
                                                 subsetPixels:
                                                     *const SkPixmap) -> bool;
}
extern "C" {
    #[link_name =
          "?accessScaledImage@SkImageGenerator@@QEAA_NAEBUSkRect@@AEBVSkMatrix@@W4SkFilterQuality@@PEAUScaledImageRec@1@@Z"]
    pub fn SkImageGenerator_accessScaledImage(this: *mut SkImageGenerator,
                                              srcRect: *const SkRect,
                                              totalMatrix: *const SkMatrix,
                                              quality: SkFilterQuality,
                                              rec:
                                                  *mut SkImageGenerator_ScaledImageRec)
     -> bool;
}
extern "C" {
    /**
     *  If the default image decoder system can interpret the specified (encoded) data, then
     *  this returns a new ImageGenerator for it. Otherwise this returns NULL. Either way
     *  the caller is still responsible for managing their ownership of the data.
     */
    #[link_name = "?NewFromEncoded@SkImageGenerator@@SAPEAV1@PEAVSkData@@@Z"]
    pub fn SkImageGenerator_NewFromEncoded(arg1: *mut SkData)
     -> *mut SkImageGenerator;
}
extern "C" {
    /** Return a new image generator backed by the specified picture.  If the size is empty or
     *  the picture is NULL, this returns NULL.
     *  The optional matrix and paint arguments are passed to drawPicture() at rasterization
     *  time.
     */
    #[link_name =
          "?NewFromPicture@SkImageGenerator@@SAPEAV1@AEBU?$SkTSize@H@@PEBVSkPicture@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
    pub fn SkImageGenerator_NewFromPicture(arg1: *const SkISize,
                                           arg2: *const SkPicture,
                                           arg3: *const SkMatrix,
                                           arg4: *const SkPaint)
     -> *mut SkImageGenerator;
}
extern "C" {
    #[link_name =
          "?tryGenerateBitmap@SkImageGenerator@@IEAA_NPEAVSkBitmap@@PEBUSkImageInfo@@PEAVAllocator@2@@Z"]
    pub fn SkImageGenerator_tryGenerateBitmap(this: *mut SkImageGenerator,
                                              bm: *mut SkBitmap,
                                              optionalInfo:
                                                  *const SkImageInfo,
                                              arg1: *mut SkBitmap_Allocator)
     -> bool;
}
impl SkImageGenerator {
    #[inline]
    pub unsafe fn getPixels(&mut self, info: *const SkImageInfo,
                            pixels: *mut ::std::os::raw::c_void,
                            rowBytes: usize, ctable: *mut SkPMColor,
                            ctableCount: *mut ::std::os::raw::c_int) -> bool {
        SkImageGenerator_getPixels(&mut *self, info, pixels, rowBytes, ctable,
                                   ctableCount)
    }
    #[inline]
    pub unsafe fn getPixels1(&mut self, info: *const SkImageInfo,
                             pixels: *mut ::std::os::raw::c_void,
                             rowBytes: usize) -> bool {
        SkImageGenerator_getPixels1(&mut *self, info, pixels, rowBytes)
    }
    #[inline]
    pub unsafe fn queryYUV8(&self, sizeInfo: *mut SkYUVSizeInfo,
                            colorSpace: *mut SkYUVColorSpace) -> bool {
        SkImageGenerator_queryYUV8(&*self, sizeInfo, colorSpace)
    }
    #[inline]
    pub unsafe fn getYUV8Planes(&mut self, sizeInfo: *const SkYUVSizeInfo,
                                planes: *mut *mut ::std::os::raw::c_void)
     -> bool {
        SkImageGenerator_getYUV8Planes(&mut *self, sizeInfo, planes)
    }
    #[inline]
    pub unsafe fn generateTexture(&mut self, arg1: *mut GrContext,
                                  subset: *const SkIRect) -> *mut GrTexture {
        SkImageGenerator_generateTexture(&mut *self, arg1, subset)
    }
    #[inline]
    pub unsafe fn computeScaledDimensions(&mut self, scale: SkScalar,
                                          arg1:
                                              *mut SkImageGenerator_SupportedSizes)
     -> bool {
        SkImageGenerator_computeScaledDimensions(&mut *self, scale, arg1)
    }
    #[inline]
    pub unsafe fn generateScaledPixels(&mut self, scaledSize: *const SkISize,
                                       subsetOrigin: *const SkIPoint,
                                       subsetPixels: *const SkPixmap)
     -> bool {
        SkImageGenerator_generateScaledPixels(&mut *self, scaledSize,
                                              subsetOrigin, subsetPixels)
    }
    #[inline]
    pub unsafe fn accessScaledImage(&mut self, srcRect: *const SkRect,
                                    totalMatrix: *const SkMatrix,
                                    quality: SkFilterQuality,
                                    rec: *mut SkImageGenerator_ScaledImageRec)
     -> bool {
        SkImageGenerator_accessScaledImage(&mut *self, srcRect, totalMatrix,
                                           quality, rec)
    }
    #[inline]
    pub unsafe fn NewFromEncoded(arg1: *mut SkData) -> *mut SkImageGenerator {
        SkImageGenerator_NewFromEncoded(arg1)
    }
    #[inline]
    pub unsafe fn NewFromPicture(arg1: *const SkISize, arg2: *const SkPicture,
                                 arg3: *const SkMatrix, arg4: *const SkPaint)
     -> *mut SkImageGenerator {
        SkImageGenerator_NewFromPicture(arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn tryGenerateBitmap(&mut self, bm: *mut SkBitmap,
                                    optionalInfo: *const SkImageInfo,
                                    arg1: *mut SkBitmap_Allocator) -> bool {
        SkImageGenerator_tryGenerateBitmap(&mut *self, bm, optionalInfo, arg1)
    }
}
/**
 *  Interface for serializing pixels, e.g. SkBitmaps in an SkPicture.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkPixelSerializer {
    pub _base: SkRefCnt,
}
#[test]
fn bindgen_test_layout_SkPixelSerializer() {
    assert_eq!(::std::mem::size_of::<SkPixelSerializer>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPixelSerializer>() , 1usize);
}
/**
 *  SkSurface represents the backend/results of drawing to a canvas. For raster
 *  drawing, the surface will be pixels, but (for example) when drawing into
 *  a PDF or Picture canvas, the surface stores the recorded commands.
 *
 *  To draw into a canvas, first create the appropriate type of Surface, and
 *  then request the canvas from the surface.
 *
 *  SkSurface always has non-zero dimensions. If there is a request for a new surface, and either
 *  of the requested dimensions are zero, then NULL will be returned.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkSurface {
    pub _base: SkRefCnt,
    pub fProps: SkSurfaceProps,
    pub fWidth: ::std::os::raw::c_int,
    pub fHeight: ::std::os::raw::c_int,
    pub fGenerationID: u32,
}
#[repr(i32)]
/**
     *  Modes that can be passed to notifyContentWillChange
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkSurface_ContentChangeMode {
    kDiscard_ContentChangeMode = 0,
    kRetain_ContentChangeMode = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkSurface_BackendHandleAccess {
    kFlushRead_BackendHandleAccess = 0,
    kFlushWrite_BackendHandleAccess = 1,
    kDiscardWrite_BackendHandleAccess = 2,
}
#[repr(i32)]
/**
     * In rare instances a client may want a unique copy of the SkSurface's contents in an image
     * snapshot. This enum can be used to enforce that the image snapshot's backing store is not
     * shared with another image snapshot or the surface's backing store. This is generally more
     * expensive. This was added for Chromium bug 585250.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkSurface_ForceUnique { kNo_ForceUnique = 0, kYes_ForceUnique = 1, }
pub type SkSurface_INHERITED = SkRefCnt;
extern "C" {
    #[link_name =
          "?kFlushRead_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"]
    pub static SkSurface_kFlushRead_TextureHandleAccess:
               SkSurface_BackendHandleAccess;
}
extern "C" {
    #[link_name =
          "?kFlushWrite_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"]
    pub static SkSurface_kFlushWrite_TextureHandleAccess:
               SkSurface_BackendHandleAccess;
}
extern "C" {
    #[link_name =
          "?kDiscardWrite_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"]
    pub static SkSurface_kDiscardWrite_TextureHandleAccess:
               SkSurface_BackendHandleAccess;
}
#[test]
fn bindgen_test_layout_SkSurface() {
    assert_eq!(::std::mem::size_of::<SkSurface>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkSurface>() , 1usize);
}
extern "C" {
    /**
     *  Create a new surface, using the specified pixels/rowbytes as its
     *  backend.
     *
     *  If the requested surface cannot be created, or the request is not a
     *  supported configuration, NULL will be returned.
     *
     *  Callers are responsible for initialiazing the surface pixels.
     */
    #[link_name =
          "?MakeRasterDirect@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEAX_KPEBVSkSurfaceProps@@@Z"]
    pub fn SkSurface_MakeRasterDirect(arg1: *const SkImageInfo,
                                      pixels: *mut ::std::os::raw::c_void,
                                      rowBytes: usize,
                                      arg2: *const SkSurfaceProps)
     -> sk_sp<SkSurface>;
}
extern "C" {
    /**
     *  The same as NewRasterDirect, but also accepts a call-back routine, which is invoked
     *  when the surface is deleted, and is passed the pixel memory and the specified context.
     */
    #[link_name =
          "?MakeRasterDirectReleaseProc@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEAX_KP6AX11@Z1PEBVSkSurfaceProps@@@Z"]
    pub fn SkSurface_MakeRasterDirectReleaseProc(arg1: *const SkImageInfo,
                                                 pixels:
                                                     *mut ::std::os::raw::c_void,
                                                 rowBytes: usize,
                                                 releaseProc:
                                                     ::std::option::Option<unsafe extern "C" fn(pixels:
                                                                                                    *mut ::std::os::raw::c_void,
                                                                                                context:
                                                                                                    *mut ::std::os::raw::c_void)>,
                                                 context:
                                                     *mut ::std::os::raw::c_void,
                                                 arg2: *const SkSurfaceProps)
     -> sk_sp<SkSurface>;
}
extern "C" {
    /**
     *  Return a new surface, with the memory for the pixels automatically allocated and
     *  zero-initialized, but respecting the specified rowBytes. If rowBytes==0, then a default
     *  value will be chosen. If a non-zero rowBytes is specified, then any images snapped off of
     *  this surface (via makeImageSnapshot()) are guaranteed to have the same rowBytes.
     *
     *  If the requested surface cannot be created, or the request is not a
     *  supported configuration, NULL will be returned.
     */
    #[link_name =
          "?MakeRaster@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@_KPEBVSkSurfaceProps@@@Z"]
    pub fn SkSurface_MakeRaster(arg1: *const SkImageInfo, rowBytes: usize,
                                arg2: *const SkSurfaceProps)
     -> sk_sp<SkSurface>;
}
extern "C" {
    /**
     *  Used to wrap a pre-existing backend 3D API texture as a SkSurface. The kRenderTarget flag
     *  must be set on GrBackendTextureDesc for this to succeed. Skia will not assume ownership
     *  of the texture and the client must ensure the texture is valid for the lifetime of the
     *  SkSurface.
     */
    #[link_name =
          "?MakeFromBackendTexture@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@@Z"]
    pub fn SkSurface_MakeFromBackendTexture(arg1: *mut GrContext,
                                            arg2: *const GrBackendTextureDesc,
                                            arg3: sk_sp<SkColorSpace>,
                                            arg4: *const SkSurfaceProps)
     -> sk_sp<SkSurface>;
}
extern "C" {
    /**
     *  Used to wrap a pre-existing 3D API rendering target as a SkSurface. Skia will not assume
     *  ownership of the render target and the client must ensure the render target is valid for the
     *  lifetime of the SkSurface.
     */
    #[link_name =
          "?MakeFromBackendRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@AEBUGrBackendRenderTargetDesc@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@@Z"]
    pub fn SkSurface_MakeFromBackendRenderTarget(arg1: *mut GrContext,
                                                 arg2:
                                                     *const GrBackendRenderTargetDesc,
                                                 arg3: sk_sp<SkColorSpace>,
                                                 arg4: *const SkSurfaceProps)
     -> sk_sp<SkSurface>;
}
extern "C" {
    /**
     *  Used to wrap a pre-existing 3D API texture as a SkSurface. Skia will treat the texture as
     *  a rendering target only, but unlike NewFromBackendRenderTarget, Skia will manage and own
     *  the associated render target objects (but not the provided texture). The kRenderTarget flag
     *  must be set on GrBackendTextureDesc for this to succeed. Skia will not assume ownership
     *  of the texture and the client must ensure the texture is valid for the lifetime of the
     *  SkSurface.
     */
    #[link_name =
          "?MakeFromBackendTextureAsRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@@Z"]
    pub fn SkSurface_MakeFromBackendTextureAsRenderTarget(arg1:
                                                              *mut GrContext,
                                                          arg2:
                                                              *const GrBackendTextureDesc,
                                                          arg3:
                                                              sk_sp<SkColorSpace>,
                                                          arg4:
                                                              *const SkSurfaceProps)
     -> sk_sp<SkSurface>;
}
extern "C" {
    /**
     *  Return a new surface whose contents will be drawn to an offscreen
     *  render target, allocated by the surface.
     */
    #[link_name =
          "?MakeRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@W4SkBudgeted@@AEBUSkImageInfo@@HW4GrSurfaceOrigin@@PEBVSkSurfaceProps@@@Z"]
    pub fn SkSurface_MakeRenderTarget(arg1: *mut GrContext, arg2: SkBudgeted,
                                      arg3: *const SkImageInfo,
                                      sampleCount: ::std::os::raw::c_int,
                                      arg4: GrSurfaceOrigin,
                                      arg5: *const SkSurfaceProps)
     -> sk_sp<SkSurface>;
}
extern "C" {
    /**
     *  Returns a unique non-zero, unique value identifying the content of this
     *  surface. Each time the content is changed changed, either by drawing
     *  into this surface, or explicitly calling notifyContentChanged()) this
     *  method will return a new value.
     *
     *  If this surface is empty (i.e. has a zero-dimention), this will return
     *  0.
     */
    #[link_name = "?generationID@SkSurface@@QEAAIXZ"]
    pub fn SkSurface_generationID(this: *mut SkSurface) -> u32;
}
extern "C" {
    /**
     *  Call this if the contents are about to change. This will (lazily) force a new
     *  value to be returned from generationID() when it is called next.
     *
     *  CAN WE DEPRECATE THIS?
     */
    #[link_name =
          "?notifyContentWillChange@SkSurface@@QEAAXW4ContentChangeMode@1@@Z"]
    pub fn SkSurface_notifyContentWillChange(this: *mut SkSurface,
                                             mode:
                                                 SkSurface_ContentChangeMode);
}
extern "C" {
    /**
     *  Retrieves the backend API handle of the texture used by this surface, or 0 if the surface
     *  is not backed by a GPU texture.
     *
     *  The returned texture-handle is only valid until the next draw-call into the surface,
     *  or the surface is deleted.
     */
    #[link_name =
          "?getTextureHandle@SkSurface@@QEAA_JW4BackendHandleAccess@1@@Z"]
    pub fn SkSurface_getTextureHandle(this: *mut SkSurface,
                                      arg1: SkSurface_BackendHandleAccess)
     -> GrBackendObject;
}
extern "C" {
    /**
     *  Retrieves the backend API handle of the RenderTarget backing this surface.  Callers must
     *  ensure this function returns 'true' or else the GrBackendObject will be invalid
     *
     *  In OpenGL this will return the FramebufferObject ID.
     */
    #[link_name =
          "?getRenderTargetHandle@SkSurface@@QEAA_NPEA_JW4BackendHandleAccess@1@@Z"]
    pub fn SkSurface_getRenderTargetHandle(this: *mut SkSurface,
                                           arg1: *mut GrBackendObject,
                                           arg2:
                                               SkSurface_BackendHandleAccess)
     -> bool;
}
extern "C" {
    /**
     *  Return a canvas that will draw into this surface. This will always
     *  return the same canvas for a given surface, and is manged/owned by the
     *  surface. It should not be used when its parent surface has gone out of
     *  scope.
     */
    #[link_name = "?getCanvas@SkSurface@@QEAAPEAVSkCanvas@@XZ"]
    pub fn SkSurface_getCanvas(this: *mut SkSurface) -> *mut SkCanvas;
}
extern "C" {
    /**
     *  Return a new surface that is "compatible" with this one, in that it will
     *  efficiently be able to be drawn into this surface. Typical calling
     *  pattern:
     *
     *  SkSurface* A = SkSurface::New...();
     *  SkCanvas* canvasA = surfaceA->newCanvas();
     *  ...
     *  SkSurface* surfaceB = surfaceA->newSurface(...);
     *  SkCanvas* canvasB = surfaceB->newCanvas();
     *  ... // draw using canvasB
     *  canvasA->drawSurface(surfaceB); // <--- this will always be optimal!
     */
    #[link_name =
          "?makeSurface@SkSurface@@QEAA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@@Z"]
    pub fn SkSurface_makeSurface(this: *mut SkSurface,
                                 arg1: *const SkImageInfo)
     -> sk_sp<SkSurface>;
}
extern "C" {
    /**
     *  Returns an image of the current state of the surface pixels up to this
     *  point. Subsequent changes to the surface (by drawing into its canvas)
     *  will not be reflected in this image. If a copy must be made the Budgeted
     *  parameter controls whether it counts against the resource budget
     *  (currently for the gpu backend only).
     */
    #[link_name =
          "?makeImageSnapshot@SkSurface@@QEAA?AV?$sk_sp@VSkImage@@@@W4SkBudgeted@@@Z"]
    pub fn SkSurface_makeImageSnapshot(this: *mut SkSurface, arg1: SkBudgeted)
     -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name =
          "?makeImageSnapshot@SkSurface@@QEAA?AV?$sk_sp@VSkImage@@@@W4SkBudgeted@@W4ForceUnique@1@@Z"]
    pub fn SkSurface_makeImageSnapshot1(this: *mut SkSurface,
                                        arg1: SkBudgeted,
                                        arg2: SkSurface_ForceUnique)
     -> sk_sp<SkImage>;
}
extern "C" {
    /**
     *  Though the caller could get a snapshot image explicitly, and draw that,
     *  it seems that directly drawing a surface into another canvas might be
     *  a common pattern, and that we could possibly be more efficient, since
     *  we'd know that the "snapshot" need only live until we've handed it off
     *  to the canvas.
     */
    #[link_name = "?draw@SkSurface@@QEAAXPEAVSkCanvas@@MMPEBVSkPaint@@@Z"]
    pub fn SkSurface_draw(this: *mut SkSurface, arg1: *mut SkCanvas,
                          x: SkScalar, y: SkScalar, arg2: *const SkPaint);
}
extern "C" {
    /**
     *  If the surface has direct access to its pixels (i.e. they are in local
     *  RAM) return true, and if not null, set the pixmap parameter to point to the information
     *  about the surface's pixels. The pixel address in the pixmap is only valid while
     *  the surface object is in scope, and no API call is made on the surface
     *  or its canvas.
     *
     *  On failure, returns false and the pixmap parameter is ignored.
     */
    #[link_name = "?peekPixels@SkSurface@@QEAA_NPEAVSkPixmap@@@Z"]
    pub fn SkSurface_peekPixels(this: *mut SkSurface, arg1: *mut SkPixmap)
     -> bool;
}
extern "C" {
    /**
     *  Copy the pixels from the surface into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (dstInfo). The surface pixels are read
     *  starting at the specified (srcX,srcY) location.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the base-layer. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the surface bounds.
     *  - If the requested colortype/alphatype cannot be converted from the surface's types.
     */
    #[link_name = "?readPixels@SkSurface@@QEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
    pub fn SkSurface_readPixels(this: *mut SkSurface,
                                dstInfo: *const SkImageInfo,
                                dstPixels: *mut ::std::os::raw::c_void,
                                dstRowBytes: usize,
                                srcX: ::std::os::raw::c_int,
                                srcY: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
     * Issue any pending surface IO to the current backend 3D API and resolve any surface MSAA.
     */
    #[link_name = "?prepareForExternalIO@SkSurface@@QEAAXXZ"]
    pub fn SkSurface_prepareForExternalIO(this: *mut SkSurface);
}
impl SkSurface {
    #[inline]
    pub unsafe fn MakeRasterDirect(arg1: *const SkImageInfo,
                                   pixels: *mut ::std::os::raw::c_void,
                                   rowBytes: usize,
                                   arg2: *const SkSurfaceProps)
     -> sk_sp<SkSurface> {
        SkSurface_MakeRasterDirect(arg1, pixels, rowBytes, arg2)
    }
    #[inline]
    pub unsafe fn MakeRasterDirectReleaseProc(arg1: *const SkImageInfo,
                                              pixels:
                                                  *mut ::std::os::raw::c_void,
                                              rowBytes: usize,
                                              releaseProc:
                                                  ::std::option::Option<unsafe extern "C" fn(pixels:
                                                                                                 *mut ::std::os::raw::c_void,
                                                                                             context:
                                                                                                 *mut ::std::os::raw::c_void)>,
                                              context:
                                                  *mut ::std::os::raw::c_void,
                                              arg2: *const SkSurfaceProps)
     -> sk_sp<SkSurface> {
        SkSurface_MakeRasterDirectReleaseProc(arg1, pixels, rowBytes,
                                              releaseProc, context, arg2)
    }
    #[inline]
    pub unsafe fn MakeRaster(arg1: *const SkImageInfo, rowBytes: usize,
                             arg2: *const SkSurfaceProps)
     -> sk_sp<SkSurface> {
        SkSurface_MakeRaster(arg1, rowBytes, arg2)
    }
    #[inline]
    pub unsafe fn MakeFromBackendTexture(arg1: *mut GrContext,
                                         arg2: *const GrBackendTextureDesc,
                                         arg3: sk_sp<SkColorSpace>,
                                         arg4: *const SkSurfaceProps)
     -> sk_sp<SkSurface> {
        SkSurface_MakeFromBackendTexture(arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn MakeFromBackendRenderTarget(arg1: *mut GrContext,
                                              arg2:
                                                  *const GrBackendRenderTargetDesc,
                                              arg3: sk_sp<SkColorSpace>,
                                              arg4: *const SkSurfaceProps)
     -> sk_sp<SkSurface> {
        SkSurface_MakeFromBackendRenderTarget(arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn MakeFromBackendTextureAsRenderTarget(arg1: *mut GrContext,
                                                       arg2:
                                                           *const GrBackendTextureDesc,
                                                       arg3:
                                                           sk_sp<SkColorSpace>,
                                                       arg4:
                                                           *const SkSurfaceProps)
     -> sk_sp<SkSurface> {
        SkSurface_MakeFromBackendTextureAsRenderTarget(arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn MakeRenderTarget(arg1: *mut GrContext, arg2: SkBudgeted,
                                   arg3: *const SkImageInfo,
                                   sampleCount: ::std::os::raw::c_int,
                                   arg4: GrSurfaceOrigin,
                                   arg5: *const SkSurfaceProps)
     -> sk_sp<SkSurface> {
        SkSurface_MakeRenderTarget(arg1, arg2, arg3, sampleCount, arg4, arg5)
    }
    #[inline]
    pub unsafe fn generationID(&mut self) -> u32 {
        SkSurface_generationID(&mut *self)
    }
    #[inline]
    pub unsafe fn notifyContentWillChange(&mut self,
                                          mode: SkSurface_ContentChangeMode) {
        SkSurface_notifyContentWillChange(&mut *self, mode)
    }
    #[inline]
    pub unsafe fn getTextureHandle(&mut self,
                                   arg1: SkSurface_BackendHandleAccess)
     -> GrBackendObject {
        SkSurface_getTextureHandle(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn getRenderTargetHandle(&mut self, arg1: *mut GrBackendObject,
                                        arg2: SkSurface_BackendHandleAccess)
     -> bool {
        SkSurface_getRenderTargetHandle(&mut *self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getCanvas(&mut self) -> *mut SkCanvas {
        SkSurface_getCanvas(&mut *self)
    }
    #[inline]
    pub unsafe fn makeSurface(&mut self, arg1: *const SkImageInfo)
     -> sk_sp<SkSurface> {
        SkSurface_makeSurface(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn makeImageSnapshot(&mut self, arg1: SkBudgeted)
     -> sk_sp<SkImage> {
        SkSurface_makeImageSnapshot(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn makeImageSnapshot1(&mut self, arg1: SkBudgeted,
                                     arg2: SkSurface_ForceUnique)
     -> sk_sp<SkImage> {
        SkSurface_makeImageSnapshot1(&mut *self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn draw(&mut self, arg1: *mut SkCanvas, x: SkScalar,
                       y: SkScalar, arg2: *const SkPaint) {
        SkSurface_draw(&mut *self, arg1, x, y, arg2)
    }
    #[inline]
    pub unsafe fn peekPixels(&mut self, arg1: *mut SkPixmap) -> bool {
        SkSurface_peekPixels(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn readPixels(&mut self, dstInfo: *const SkImageInfo,
                             dstPixels: *mut ::std::os::raw::c_void,
                             dstRowBytes: usize, srcX: ::std::os::raw::c_int,
                             srcY: ::std::os::raw::c_int) -> bool {
        SkSurface_readPixels(&mut *self, dstInfo, dstPixels, dstRowBytes,
                             srcX, srcY)
    }
    #[inline]
    pub unsafe fn prepareForExternalIO(&mut self) {
        SkSurface_prepareForExternalIO(&mut *self)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrContextThreadSafeProxy {
    pub _address: u8,
}
impl Clone for GrContextThreadSafeProxy {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrTexture {
    pub _address: u8,
}
impl Clone for GrTexture {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
/**
 *  Description of how the LCD strips are arranged for each pixel. If this is unknown, or the
 *  pixels are meant to be "portable" and/or transformed before showing (e.g. rotated, scaled)
 *  then use kUnknown_SkPixelGeometry.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPixelGeometry {
    kUnknown_SkPixelGeometry = 0,
    kRGB_H_SkPixelGeometry = 1,
    kBGR_H_SkPixelGeometry = 2,
    kRGB_V_SkPixelGeometry = 3,
    kBGR_V_SkPixelGeometry = 4,
}
extern "C" {
    #[link_name = "?SkPixelGeometryIsRGB@@YA_NW4SkPixelGeometry@@@Z"]
    pub fn SkPixelGeometryIsRGB(geo: SkPixelGeometry) -> bool;
}
extern "C" {
    #[link_name = "?SkPixelGeometryIsBGR@@YA_NW4SkPixelGeometry@@@Z"]
    pub fn SkPixelGeometryIsBGR(geo: SkPixelGeometry) -> bool;
}
extern "C" {
    #[link_name = "?SkPixelGeometryIsH@@YA_NW4SkPixelGeometry@@@Z"]
    pub fn SkPixelGeometryIsH(geo: SkPixelGeometry) -> bool;
}
extern "C" {
    #[link_name = "?SkPixelGeometryIsV@@YA_NW4SkPixelGeometry@@@Z"]
    pub fn SkPixelGeometryIsV(geo: SkPixelGeometry) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkLights {
    pub _base: SkRefCnt,
    pub fLights: ::std::os::raw::c_int,
    pub fAmbientLightColor: SkColor3f,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkLights_Light {
    pub fType: SkLights_Light_LightType,
    pub fColor: SkColor3f,
    pub fDirOrPos: SkVector3,
    pub fIntensity: SkScalar,
    pub fShadowMap: sk_sp<SkImage>,
    pub fIsRadial: bool,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkLights_Light_LightType {
    kDirectional_LightType = 0,
    kPoint_LightType = 1,
}
#[test]
fn bindgen_test_layout_SkLights_Light() {
    assert_eq!(::std::mem::size_of::<SkLights_Light>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkLights_Light>() , 1usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkLights_Builder {
    pub fLights: sk_sp<SkLights>,
}
#[test]
fn bindgen_test_layout_SkLights_Builder() {
    assert_eq!(::std::mem::size_of::<SkLights_Builder>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkLights_Builder>() , 1usize);
}
pub type SkLights_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkLights() {
    assert_eq!(::std::mem::size_of::<SkLights>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkLights>() , 1usize);
}
extern "C" {
    #[link_name =
          "?MakeFromBuffer@SkLights@@SA?AV?$sk_sp@VSkLights@@@@AEAVSkReadBuffer@@@Z"]
    pub fn SkLights_MakeFromBuffer(buf: *mut SkReadBuffer) -> sk_sp<SkLights>;
}
extern "C" {
    #[link_name = "?flatten@SkLights@@QEBAXAEAVSkWriteBuffer@@@Z"]
    pub fn SkLights_flatten(this: *const SkLights, buf: *mut SkWriteBuffer);
}
impl SkLights {
    #[inline]
    pub unsafe fn MakeFromBuffer(buf: *mut SkReadBuffer) -> sk_sp<SkLights> {
        SkLights_MakeFromBuffer(buf)
    }
    #[inline]
    pub unsafe fn flatten(&self, buf: *mut SkWriteBuffer) {
        SkLights_flatten(&*self, buf)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrRenderTargetContext {
    pub _address: u8,
}
impl Clone for GrRenderTargetContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBaseDevice {
    pub _base: SkRefCnt,
    pub fOrigin: SkIPoint,
    pub fMetaData: *mut SkMetaData,
    pub fInfo: SkImageInfo,
    pub fSurfaceProps: SkSurfaceProps,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkBaseDevice_TileUsage {
    kPossible_TileUsage = 0,
    kNever_TileUsage = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkBaseDevice_TextFlags {
    pub fFlags: u32,
}
#[test]
fn bindgen_test_layout_SkBaseDevice_TextFlags() {
    assert_eq!(::std::mem::size_of::<SkBaseDevice_TextFlags>() , 4usize);
    assert_eq!(::std::mem::align_of::<SkBaseDevice_TextFlags>() , 4usize);
}
impl Clone for SkBaseDevice_TextFlags {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBaseDevice_CreateInfo {
    pub fInfo: SkImageInfo,
    pub fTileUsage: SkBaseDevice_TileUsage,
    pub fPixelGeometry: SkPixelGeometry,
}
#[test]
fn bindgen_test_layout_SkBaseDevice_CreateInfo() {
    assert_eq!(::std::mem::size_of::<SkBaseDevice_CreateInfo>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkBaseDevice_CreateInfo>() , 1usize);
}
extern "C" {
    #[link_name =
          "?AdjustGeometry@CreateInfo@SkBaseDevice@@SA?AW4SkPixelGeometry@@AEBUSkImageInfo@@W4TileUsage@2@W43@_N@Z"]
    pub fn SkBaseDevice_CreateInfo_AdjustGeometry(arg1: *const SkImageInfo,
                                                  arg2:
                                                      SkBaseDevice_TileUsage,
                                                  arg3: SkPixelGeometry,
                                                  preserveLCDText: bool)
     -> SkPixelGeometry;
}
impl SkBaseDevice_CreateInfo {
    #[inline]
    pub unsafe fn AdjustGeometry(arg1: *const SkImageInfo,
                                 arg2: SkBaseDevice_TileUsage,
                                 arg3: SkPixelGeometry, preserveLCDText: bool)
     -> SkPixelGeometry {
        SkBaseDevice_CreateInfo_AdjustGeometry(arg1, arg2, arg3,
                                               preserveLCDText)
    }
}
pub type SkBaseDevice_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkBaseDevice() {
    assert_eq!(::std::mem::size_of::<SkBaseDevice>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkBaseDevice>() , 1usize);
}
extern "C" {
    #[link_name = "?getMetaData@SkBaseDevice@@QEAAAEAVSkMetaData@@XZ"]
    pub fn SkBaseDevice_getMetaData(this: *mut SkBaseDevice)
     -> *mut SkMetaData;
}
extern "C" {
    #[link_name =
          "?writePixels@SkBaseDevice@@QEAA_NAEBUSkImageInfo@@PEBX_KHH@Z"]
    pub fn SkBaseDevice_writePixels(this: *mut SkBaseDevice,
                                    arg1: *const SkImageInfo,
                                    arg2: *const ::std::os::raw::c_void,
                                    rowBytes: usize, x: ::std::os::raw::c_int,
                                    y: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    /**
     *  Try to get write-access to the pixels behind the device. If successful, this returns true
     *  and fills-out the pixmap parameter. On success it also bumps the genID of the underlying
     *  bitmap.
     *
     *  On failure, returns false and ignores the pixmap parameter.
     */
    #[link_name = "?accessPixels@SkBaseDevice@@QEAA_NPEAVSkPixmap@@@Z"]
    pub fn SkBaseDevice_accessPixels(this: *mut SkBaseDevice,
                                     pmap: *mut SkPixmap) -> bool;
}
extern "C" {
    /**
     *  Try to get read-only-access to the pixels behind the device. If successful, this returns
     *  true and fills-out the pixmap parameter.
     *
     *  On failure, returns false and ignores the pixmap parameter.
     */
    #[link_name = "?peekPixels@SkBaseDevice@@QEAA_NPEAVSkPixmap@@@Z"]
    pub fn SkBaseDevice_peekPixels(this: *mut SkBaseDevice,
                                   arg1: *mut SkPixmap) -> bool;
}
extern "C" {
    /**
     * Returns the text-related flags, possibly modified based on the state of the
     * device (e.g. support for LCD).
     */
    #[link_name = "?filterTextFlags@SkBaseDevice@@IEBAIAEBVSkPaint@@@Z"]
    pub fn SkBaseDevice_filterTextFlags(this: *const SkBaseDevice,
                                        arg1: *const SkPaint) -> u32;
}
extern "C" {
    #[link_name =
          "?readPixels@SkBaseDevice@@IEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
    pub fn SkBaseDevice_readPixels(this: *mut SkBaseDevice,
                                   arg1: *const SkImageInfo,
                                   dst: *mut ::std::os::raw::c_void,
                                   rowBytes: usize, x: ::std::os::raw::c_int,
                                   y: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name =
          "?LogDrawScaleFactor@SkBaseDevice@@KAXAEBVSkMatrix@@W4SkFilterQuality@@@Z"]
    pub fn SkBaseDevice_LogDrawScaleFactor(arg1: *const SkMatrix,
                                           arg2: SkFilterQuality);
}
impl SkBaseDevice {
    #[inline]
    pub unsafe fn getMetaData(&mut self) -> *mut SkMetaData {
        SkBaseDevice_getMetaData(&mut *self)
    }
    #[inline]
    pub unsafe fn writePixels(&mut self, arg1: *const SkImageInfo,
                              arg2: *const ::std::os::raw::c_void,
                              rowBytes: usize, x: ::std::os::raw::c_int,
                              y: ::std::os::raw::c_int) -> bool {
        SkBaseDevice_writePixels(&mut *self, arg1, arg2, rowBytes, x, y)
    }
    #[inline]
    pub unsafe fn accessPixels(&mut self, pmap: *mut SkPixmap) -> bool {
        SkBaseDevice_accessPixels(&mut *self, pmap)
    }
    #[inline]
    pub unsafe fn peekPixels(&mut self, arg1: *mut SkPixmap) -> bool {
        SkBaseDevice_peekPixels(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn filterTextFlags(&self, arg1: *const SkPaint) -> u32 {
        SkBaseDevice_filterTextFlags(&*self, arg1)
    }
    #[inline]
    pub unsafe fn readPixels(&mut self, arg1: *const SkImageInfo,
                             dst: *mut ::std::os::raw::c_void,
                             rowBytes: usize, x: ::std::os::raw::c_int,
                             y: ::std::os::raw::c_int) -> bool {
        SkBaseDevice_readPixels(&mut *self, arg1, dst, rowBytes, x, y)
    }
    #[inline]
    pub unsafe fn LogDrawScaleFactor(arg1: *const SkMatrix,
                                     arg2: SkFilterQuality) {
        SkBaseDevice_LogDrawScaleFactor(arg1, arg2)
    }
}
#[repr(C)]
pub struct SkCanvasClipVisitor__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvasClipVisitor {
    pub vtable_: *const SkCanvasClipVisitor__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkCanvasClipVisitor() {
    assert_eq!(::std::mem::size_of::<SkCanvasClipVisitor>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkCanvasClipVisitor>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkClipStack {
    pub fDeque: SkDeque,
    pub fSaveCount: ::std::os::raw::c_int,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkClipStack_BoundsType {
    kNormal_BoundsType = 0,
    kInsideOut_BoundsType = 1,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkClipStack_Element {
    pub fPath: SkTLazy<SkPath>,
    pub fRRect: SkRRect,
    pub fSaveCount: ::std::os::raw::c_int,
    pub fOp: SkClipOp,
    pub fType: SkClipStack_Element_Type,
    pub fDoAA: bool,
    pub fFiniteBoundType: SkClipStack_BoundsType,
    pub fFiniteBound: SkRect,
    pub fIsIntersectionOfRects: bool,
    pub fGenID: ::std::os::raw::c_int,
}
pub const SkClipStack_Element_Type_kLastType: SkClipStack_Element_Type =
    SkClipStack_Element_Type::kPath_Type;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkClipStack_Element_Type {
    kEmpty_Type = 0,
    kRect_Type = 1,
    kRRect_Type = 2,
    kPath_Type = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkClipStack_Element_FillCombo {
    kPrev_Cur_FillCombo = 0,
    kPrev_InvCur_FillCombo = 1,
    kInvPrev_Cur_FillCombo = 2,
    kInvPrev_InvCur_FillCombo = 3,
}
pub const SkClipStack_Element_kTypeCnt: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkClipStack_Element() {
    assert_eq!(::std::mem::size_of::<SkClipStack_Element>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkClipStack_Element>() , 1usize);
}
extern "C" {
    #[link_name = "?asPath@Element@SkClipStack@@QEBAXPEAVSkPath@@@Z"]
    pub fn SkClipStack_Element_asPath(this: *const SkClipStack_Element,
                                      path: *mut SkPath);
}
extern "C" {
    #[link_name = "?invertShapeFillType@Element@SkClipStack@@QEAAXXZ"]
    pub fn SkClipStack_Element_invertShapeFillType(this:
                                                       *mut SkClipStack_Element);
}
extern "C" {
    /**
        * Replay this clip into the visitor.
        */
    #[link_name =
          "?replay@Element@SkClipStack@@QEBAXPEAVSkCanvasClipVisitor@@@Z"]
    pub fn SkClipStack_Element_replay(this: *const SkClipStack_Element,
                                      arg1: *mut SkCanvasClipVisitor);
}
extern "C" {
    /**
         * Dumps the element to SkDebugf. This is intended for Skia development debugging
         * Don't rely on the existence of this function or the formatting of its output.
         */
    #[link_name = "?dump@Element@SkClipStack@@QEBAXXZ"]
    pub fn SkClipStack_Element_dump(this: *const SkClipStack_Element);
}
impl SkClipStack_Element {
    #[inline]
    pub unsafe fn asPath(&self, path: *mut SkPath) {
        SkClipStack_Element_asPath(&*self, path)
    }
    #[inline]
    pub unsafe fn invertShapeFillType(&mut self) {
        SkClipStack_Element_invertShapeFillType(&mut *self)
    }
    #[inline]
    pub unsafe fn replay(&self, arg1: *mut SkCanvasClipVisitor) {
        SkClipStack_Element_replay(&*self, arg1)
    }
    #[inline]
    pub unsafe fn dump(&self) { SkClipStack_Element_dump(&*self) }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkClipStack_Iter {
    pub fStack: *const SkClipStack,
    pub fIter: SkDeque_Iter,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkClipStack_Iter_IterStart {
    kBottom_IterStart = 0,
    kTop_IterStart = 1,
}
#[test]
fn bindgen_test_layout_SkClipStack_Iter() {
    assert_eq!(::std::mem::size_of::<SkClipStack_Iter>() , 32usize);
    assert_eq!(::std::mem::align_of::<SkClipStack_Iter>() , 8usize);
}
extern "C" {
    /**
         *  Return the clip element for this iterator. If next()/prev() returns NULL, then the
         *  iterator is done.
         */
    #[link_name = "?next@Iter@SkClipStack@@QEAAPEBVElement@2@XZ"]
    pub fn SkClipStack_Iter_next(this: *mut SkClipStack_Iter)
     -> *const SkClipStack_Element;
}
extern "C" {
    #[link_name = "?prev@Iter@SkClipStack@@QEAAPEBVElement@2@XZ"]
    pub fn SkClipStack_Iter_prev(this: *mut SkClipStack_Iter)
     -> *const SkClipStack_Element;
}
extern "C" {
    /**
         * Moves the iterator to the topmost element with the specified RegionOp and returns that
         * element. If no clip element with that op is found, the first element is returned.
         */
    #[link_name =
          "?skipToTopmost@Iter@SkClipStack@@QEAAPEBVElement@2@W4SkClipOp@@@Z"]
    pub fn SkClipStack_Iter_skipToTopmost(this: *mut SkClipStack_Iter,
                                          op: SkClipOp)
     -> *const SkClipStack_Element;
}
extern "C" {
    /**
         * Restarts the iterator on a clip stack.
         */
    #[link_name = "?reset@Iter@SkClipStack@@QEAAXAEBV2@W4IterStart@12@@Z"]
    pub fn SkClipStack_Iter_reset(this: *mut SkClipStack_Iter,
                                  stack: *const SkClipStack,
                                  startLoc: SkClipStack_Iter_IterStart);
}
impl Clone for SkClipStack_Iter {
    fn clone(&self) -> Self { *self }
}
impl SkClipStack_Iter {
    #[inline]
    pub unsafe fn next(&mut self) -> *const SkClipStack_Element {
        SkClipStack_Iter_next(&mut *self)
    }
    #[inline]
    pub unsafe fn prev(&mut self) -> *const SkClipStack_Element {
        SkClipStack_Iter_prev(&mut *self)
    }
    #[inline]
    pub unsafe fn skipToTopmost(&mut self, op: SkClipOp)
     -> *const SkClipStack_Element {
        SkClipStack_Iter_skipToTopmost(&mut *self, op)
    }
    #[inline]
    pub unsafe fn reset(&mut self, stack: *const SkClipStack,
                        startLoc: SkClipStack_Iter_IterStart) {
        SkClipStack_Iter_reset(&mut *self, stack, startLoc)
    }
}
/**
     * The B2TIter iterates from the bottom of the stack to the top.
     * It inherits privately from Iter to prevent access to reverse iteration.
     */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkClipStack_B2TIter {
    pub _base: SkClipStack_Iter,
}
pub type SkClipStack_B2TIter_INHERITED = SkClipStack_Iter;
#[test]
fn bindgen_test_layout_SkClipStack_B2TIter() {
    assert_eq!(::std::mem::size_of::<SkClipStack_B2TIter>() , 32usize);
    assert_eq!(::std::mem::align_of::<SkClipStack_B2TIter>() , 8usize);
}
impl Clone for SkClipStack_B2TIter {
    fn clone(&self) -> Self { *self }
}
pub const SkClipStack_kInvalidGenID: i32 = 0;
pub const SkClipStack_kEmptyGenID: i32 = 1;
pub const SkClipStack_kWideOpenGenID: i32 = 2;
extern "C" {
    #[link_name = "?gGenID@SkClipStack@@0HA"]
    pub static mut SkClipStack_gGenID: i32;
}
#[test]
fn bindgen_test_layout_SkClipStack() {
    assert_eq!(::std::mem::size_of::<SkClipStack>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkClipStack>() , 1usize);
}
extern "C" {
    #[link_name = "?reset@SkClipStack@@QEAAXXZ"]
    pub fn SkClipStack_reset(this: *mut SkClipStack);
}
extern "C" {
    #[link_name = "?save@SkClipStack@@QEAAXXZ"]
    pub fn SkClipStack_save(this: *mut SkClipStack);
}
extern "C" {
    #[link_name = "?restore@SkClipStack@@QEAAXXZ"]
    pub fn SkClipStack_restore(this: *mut SkClipStack);
}
extern "C" {
    /**
     * getBounds places the current finite bound in its first parameter. In its
     * second, it indicates which kind of bound is being returned. If
     * 'canvFiniteBound' is a normal bounding box then it encloses all writeable
     * pixels. If 'canvFiniteBound' is an inside out bounding box then it
     * encloses all the un-writeable pixels and the true/normal bound is the
     * infinite plane. isIntersectionOfRects is an optional parameter
     * that is true if 'canvFiniteBound' resulted from an intersection of rects.
     */
    #[link_name =
          "?getBounds@SkClipStack@@QEBAXPEAUSkRect@@PEAW4BoundsType@1@PEA_N@Z"]
    pub fn SkClipStack_getBounds(this: *const SkClipStack,
                                 canvFiniteBound: *mut SkRect,
                                 boundType: *mut SkClipStack_BoundsType,
                                 isIntersectionOfRects: *mut bool);
}
extern "C" {
    /**
     * Flattens the clip stack into a single SkPath. Returns true if any of
     * the clip stack components requires anti-aliasing.
     */
    #[link_name = "?asPath@SkClipStack@@QEBA_NPEAVSkPath@@@Z"]
    pub fn SkClipStack_asPath(this: *const SkClipStack, path: *mut SkPath)
     -> bool;
}
extern "C" {
    #[link_name =
          "?clipRect@SkClipStack@@QEAAXAEBUSkRect@@AEBVSkMatrix@@W4SkClipOp@@_N@Z"]
    pub fn SkClipStack_clipRect(this: *mut SkClipStack, arg1: *const SkRect,
                                matrix: *const SkMatrix, arg2: SkClipOp,
                                doAA: bool);
}
extern "C" {
    #[link_name =
          "?clipRRect@SkClipStack@@QEAAXAEBVSkRRect@@AEBVSkMatrix@@W4SkClipOp@@_N@Z"]
    pub fn SkClipStack_clipRRect(this: *mut SkClipStack, arg1: *const SkRRect,
                                 matrix: *const SkMatrix, arg2: SkClipOp,
                                 doAA: bool);
}
extern "C" {
    #[link_name =
          "?clipPath@SkClipStack@@QEAAXAEBVSkPath@@AEBVSkMatrix@@W4SkClipOp@@_N@Z"]
    pub fn SkClipStack_clipPath(this: *mut SkClipStack, arg1: *const SkPath,
                                matrix: *const SkMatrix, arg2: SkClipOp,
                                doAA: bool);
}
extern "C" {
    #[link_name = "?clipEmpty@SkClipStack@@QEAAXXZ"]
    pub fn SkClipStack_clipEmpty(this: *mut SkClipStack);
}
extern "C" {
    /**
     * This method quickly and conservatively determines whether the entire stack is equivalent to
     * intersection with a rrect given a bounds, where the rrect must not contain the entire bounds.
     *
     * @param bounds   A bounds on what will be drawn through the clip. The clip only need be
     *                 equivalent to a intersection with a rrect for draws within the bounds. The
     *                 returned rrect must intersect the bounds but need not be contained by the
     *                 bounds.
     * @param rrect    If return is true rrect will contain the rrect equivalent to the stack.
     * @param aa       If return is true aa will indicate whether the equivalent rrect clip is
     *                 antialiased.
     * @return true if the stack is equivalent to a single rrect intersect clip, false otherwise.
     */
    #[link_name =
          "?isRRect@SkClipStack@@QEBA_NAEBUSkRect@@PEAVSkRRect@@PEA_N@Z"]
    pub fn SkClipStack_isRRect(this: *const SkClipStack,
                               bounds: *const SkRect, rrect: *mut SkRRect,
                               aa: *mut bool) -> bool;
}
extern "C" {
    #[link_name = "?getTopmostGenID@SkClipStack@@QEBAHXZ"]
    pub fn SkClipStack_getTopmostGenID(this: *const SkClipStack) -> i32;
}
extern "C" {
    /**
     * Dumps the contents of the clip stack to SkDebugf. This is intended for Skia development
     * debugging. Don't rely on the existence of this function or the formatting of its output.
     */
    #[link_name = "?dump@SkClipStack@@QEBAXXZ"]
    pub fn SkClipStack_dump(this: *const SkClipStack);
}
extern "C" {
    /**
     * GetConservativeBounds returns a conservative bound of the current clip.
     * Since this could be the infinite plane (if inverse fills were involved) the
     * maxWidth and maxHeight parameters can be used to limit the returned bound
     * to the expected drawing area. Similarly, the offsetX and offsetY parameters
     * allow the caller to offset the returned bound to account for translated
     * drawing areas (i.e., those resulting from a saveLayer). For finite bounds,
     * the translation (+offsetX, +offsetY) is applied before the clamp to the
     * maximum rectangle: [0,maxWidth) x [0,maxHeight).
     * isIntersectionOfRects is an optional parameter that is true when
     * 'devBounds' is the result of an intersection of rects. In this case
     * 'devBounds' is the exact answer/clip.
     */
    #[link_name =
          "?getConservativeBounds@SkClipStack@@QEBAXHHHHPEAUSkRect@@PEA_N@Z"]
    pub fn SkClipStack_getConservativeBounds(this: *const SkClipStack,
                                             offsetX: ::std::os::raw::c_int,
                                             offsetY: ::std::os::raw::c_int,
                                             maxWidth: ::std::os::raw::c_int,
                                             maxHeight: ::std::os::raw::c_int,
                                             devBounds: *mut SkRect,
                                             isIntersectionOfRects:
                                                 *mut bool);
}
impl SkClipStack {
    #[inline]
    pub unsafe fn reset(&mut self) { SkClipStack_reset(&mut *self) }
    #[inline]
    pub unsafe fn save(&mut self) { SkClipStack_save(&mut *self) }
    #[inline]
    pub unsafe fn restore(&mut self) { SkClipStack_restore(&mut *self) }
    #[inline]
    pub unsafe fn getBounds(&self, canvFiniteBound: *mut SkRect,
                            boundType: *mut SkClipStack_BoundsType,
                            isIntersectionOfRects: *mut bool) {
        SkClipStack_getBounds(&*self, canvFiniteBound, boundType,
                              isIntersectionOfRects)
    }
    #[inline]
    pub unsafe fn asPath(&self, path: *mut SkPath) -> bool {
        SkClipStack_asPath(&*self, path)
    }
    #[inline]
    pub unsafe fn clipRect(&mut self, arg1: *const SkRect,
                           matrix: *const SkMatrix, arg2: SkClipOp,
                           doAA: bool) {
        SkClipStack_clipRect(&mut *self, arg1, matrix, arg2, doAA)
    }
    #[inline]
    pub unsafe fn clipRRect(&mut self, arg1: *const SkRRect,
                            matrix: *const SkMatrix, arg2: SkClipOp,
                            doAA: bool) {
        SkClipStack_clipRRect(&mut *self, arg1, matrix, arg2, doAA)
    }
    #[inline]
    pub unsafe fn clipPath(&mut self, arg1: *const SkPath,
                           matrix: *const SkMatrix, arg2: SkClipOp,
                           doAA: bool) {
        SkClipStack_clipPath(&mut *self, arg1, matrix, arg2, doAA)
    }
    #[inline]
    pub unsafe fn clipEmpty(&mut self) { SkClipStack_clipEmpty(&mut *self) }
    #[inline]
    pub unsafe fn isRRect(&self, bounds: *const SkRect, rrect: *mut SkRRect,
                          aa: *mut bool) -> bool {
        SkClipStack_isRRect(&*self, bounds, rrect, aa)
    }
    #[inline]
    pub unsafe fn getTopmostGenID(&self) -> i32 {
        SkClipStack_getTopmostGenID(&*self)
    }
    #[inline]
    pub unsafe fn dump(&self) { SkClipStack_dump(&*self) }
    #[inline]
    pub unsafe fn getConservativeBounds(&self, offsetX: ::std::os::raw::c_int,
                                        offsetY: ::std::os::raw::c_int,
                                        maxWidth: ::std::os::raw::c_int,
                                        maxHeight: ::std::os::raw::c_int,
                                        devBounds: *mut SkRect,
                                        isIntersectionOfRects: *mut bool) {
        SkClipStack_getConservativeBounds(&*self, offsetX, offsetY, maxWidth,
                                          maxHeight, devBounds,
                                          isIntersectionOfRects)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum InitStyle { kHairline_InitStyle = 0, kFill_InitStyle = 1, }
#[repr(C)]
#[derive(Debug)]
pub struct SkDraw {
    pub fDst: SkPixmap,
    pub fMatrix: *const SkMatrix,
    pub fRC: *const SkRasterClip,
    pub fClipStack: *const SkClipStack,
    pub fDevice: *mut SkBaseDevice,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkDraw_RectType {
    kHair_RectType = 0,
    kFill_RectType = 1,
    kStroke_RectType = 2,
    kPath_RectType = 3,
}
#[test]
fn bindgen_test_layout_SkDraw() {
    assert_eq!(::std::mem::size_of::<SkDraw>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkDraw>() , 1usize);
}
extern "C" {
    #[link_name = "?drawPaint@SkDraw@@QEBAXAEBVSkPaint@@@Z"]
    pub fn SkDraw_drawPaint(this: *const SkDraw, arg1: *const SkPaint);
}
extern "C" {
    #[link_name =
          "?drawPoints@SkDraw@@QEBAXW4PointMode@SkCanvas@@_KQEBUSkPoint@@AEBVSkPaint@@_N@Z"]
    pub fn SkDraw_drawPoints(this: *const SkDraw, arg1: SkCanvas_PointMode,
                             count: usize, arg2: *const SkPoint,
                             arg3: *const SkPaint, forceUseDevice: bool);
}
extern "C" {
    #[link_name =
          "?drawRect@SkDraw@@QEBAXAEBUSkRect@@AEBVSkPaint@@PEBVSkMatrix@@PEBU2@@Z"]
    pub fn SkDraw_drawRect(this: *const SkDraw, prePaintRect: *const SkRect,
                           arg1: *const SkPaint, paintMatrix: *const SkMatrix,
                           postPaintRect: *const SkRect);
}
extern "C" {
    #[link_name = "?drawRRect@SkDraw@@QEBAXAEBVSkRRect@@AEBVSkPaint@@@Z"]
    pub fn SkDraw_drawRRect(this: *const SkDraw, arg1: *const SkRRect,
                            arg2: *const SkPaint);
}
extern "C" {
    #[link_name =
          "?drawBitmap@SkDraw@@QEBAXAEBVSkBitmap@@AEBVSkMatrix@@PEBUSkRect@@AEBVSkPaint@@@Z"]
    pub fn SkDraw_drawBitmap(this: *const SkDraw, arg1: *const SkBitmap,
                             arg2: *const SkMatrix, dstOrNull: *const SkRect,
                             arg3: *const SkPaint);
}
extern "C" {
    #[link_name = "?drawSprite@SkDraw@@QEBAXAEBVSkBitmap@@HHAEBVSkPaint@@@Z"]
    pub fn SkDraw_drawSprite(this: *const SkDraw, arg1: *const SkBitmap,
                             x: ::std::os::raw::c_int,
                             y: ::std::os::raw::c_int, arg2: *const SkPaint);
}
extern "C" {
    #[link_name = "?drawText@SkDraw@@QEBAXQEBD_KMMAEBVSkPaint@@@Z"]
    pub fn SkDraw_drawText(this: *const SkDraw,
                           text: *const ::std::os::raw::c_char,
                           byteLength: usize, x: SkScalar, y: SkScalar,
                           paint: *const SkPaint);
}
extern "C" {
    #[link_name =
          "?drawPosText@SkDraw@@QEBAXQEBD_KQEBMHAEBUSkPoint@@AEBVSkPaint@@@Z"]
    pub fn SkDraw_drawPosText(this: *const SkDraw,
                              text: *const ::std::os::raw::c_char,
                              byteLength: usize, pos: *const SkScalar,
                              scalarsPerPosition: ::std::os::raw::c_int,
                              offset: *const SkPoint, paint: *const SkPaint);
}
extern "C" {
    #[link_name =
          "?drawVertices@SkDraw@@QEBAXW4VertexMode@SkCanvas@@HQEBUSkPoint@@1QEBIW4SkBlendMode@@QEBGHAEBVSkPaint@@@Z"]
    pub fn SkDraw_drawVertices(this: *const SkDraw, mode: SkCanvas_VertexMode,
                               count: ::std::os::raw::c_int,
                               vertices: *const SkPoint,
                               textures: *const SkPoint,
                               colors: *const SkColor, bmode: SkBlendMode,
                               indices: *const u16,
                               ptCount: ::std::os::raw::c_int,
                               paint: *const SkPaint);
}
extern "C" {
    /** Helper function that creates a mask from a path and an optional maskfilter.
        Note however, that the resulting mask will not have been actually filtered,
        that must be done afterwards (by calling filterMask). The maskfilter is provided
        solely to assist in computing the mask's bounds (if the mode requests that).
    */
    #[link_name =
          "?DrawToMask@SkDraw@@SA_NAEBVSkPath@@PEBUSkIRect@@PEBVSkMaskFilter@@PEBVSkMatrix@@PEAUSkMask@@W4CreateMode@6@W4InitStyle@SkStrokeRec@@@Z"]
    pub fn SkDraw_DrawToMask(devPath: *const SkPath,
                             clipBounds: *const SkIRect,
                             arg1: *const SkMaskFilter,
                             filterMatrix: *const SkMatrix, mask: *mut SkMask,
                             mode: SkMask_CreateMode, style: InitStyle)
     -> bool;
}
extern "C" {
    /**
     *  Based on the paint's style, strokeWidth, and the matrix, classify how
     *  to draw the rect. If no special-case is available, returns
     *  kPath_RectType.
     *
     *  Iff RectType == kStroke_RectType, then strokeSize is set to the device
     *  width and height of the stroke.
     */
    #[link_name =
          "?ComputeRectType@SkDraw@@SA?AW4RectType@1@AEBVSkPaint@@AEBVSkMatrix@@PEAUSkPoint@@@Z"]
    pub fn SkDraw_ComputeRectType(arg1: *const SkPaint, arg2: *const SkMatrix,
                                  strokeSize: *mut SkPoint)
     -> SkDraw_RectType;
}
extern "C" {
    #[link_name =
          "?ShouldDrawTextAsPaths@SkDraw@@SA_NAEBVSkPaint@@AEBVSkMatrix@@@Z"]
    pub fn SkDraw_ShouldDrawTextAsPaths(arg1: *const SkPaint,
                                        arg2: *const SkMatrix) -> bool;
}
extern "C" {
    #[link_name = "?drawText_asPaths@SkDraw@@QEBAXQEBD_KMMAEBVSkPaint@@@Z"]
    pub fn SkDraw_drawText_asPaths(this: *const SkDraw,
                                   text: *const ::std::os::raw::c_char,
                                   byteLength: usize, x: SkScalar,
                                   y: SkScalar, arg1: *const SkPaint);
}
extern "C" {
    #[link_name =
          "?drawPosText_asPaths@SkDraw@@QEBAXQEBD_KQEBMHAEBUSkPoint@@AEBVSkPaint@@@Z"]
    pub fn SkDraw_drawPosText_asPaths(this: *const SkDraw,
                                      text: *const ::std::os::raw::c_char,
                                      byteLength: usize, pos: *const SkScalar,
                                      scalarsPerPosition:
                                          ::std::os::raw::c_int,
                                      offset: *const SkPoint,
                                      arg1: *const SkPaint);
}
extern "C" {
    #[link_name = "?ComputeResScaleForStroking@SkDraw@@SAMAEBVSkMatrix@@@Z"]
    pub fn SkDraw_ComputeResScaleForStroking(arg1: *const SkMatrix)
     -> SkScalar;
}
extern "C" {
    #[link_name = "?validate@SkDraw@@QEBAXXZ"]
    pub fn SkDraw_validate(this: *const SkDraw);
}
impl SkDraw {
    #[inline]
    pub unsafe fn drawPaint(&self, arg1: *const SkPaint) {
        SkDraw_drawPaint(&*self, arg1)
    }
    #[inline]
    pub unsafe fn drawPoints(&self, arg1: SkCanvas_PointMode, count: usize,
                             arg2: *const SkPoint, arg3: *const SkPaint,
                             forceUseDevice: bool) {
        SkDraw_drawPoints(&*self, arg1, count, arg2, arg3, forceUseDevice)
    }
    #[inline]
    pub unsafe fn drawRect(&self, prePaintRect: *const SkRect,
                           arg1: *const SkPaint, paintMatrix: *const SkMatrix,
                           postPaintRect: *const SkRect) {
        SkDraw_drawRect(&*self, prePaintRect, arg1, paintMatrix,
                        postPaintRect)
    }
    #[inline]
    pub unsafe fn drawRRect(&self, arg1: *const SkRRect,
                            arg2: *const SkPaint) {
        SkDraw_drawRRect(&*self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn drawBitmap(&self, arg1: *const SkBitmap,
                             arg2: *const SkMatrix, dstOrNull: *const SkRect,
                             arg3: *const SkPaint) {
        SkDraw_drawBitmap(&*self, arg1, arg2, dstOrNull, arg3)
    }
    #[inline]
    pub unsafe fn drawSprite(&self, arg1: *const SkBitmap,
                             x: ::std::os::raw::c_int,
                             y: ::std::os::raw::c_int, arg2: *const SkPaint) {
        SkDraw_drawSprite(&*self, arg1, x, y, arg2)
    }
    #[inline]
    pub unsafe fn drawText(&self, text: *const ::std::os::raw::c_char,
                           byteLength: usize, x: SkScalar, y: SkScalar,
                           paint: *const SkPaint) {
        SkDraw_drawText(&*self, text, byteLength, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawPosText(&self, text: *const ::std::os::raw::c_char,
                              byteLength: usize, pos: *const SkScalar,
                              scalarsPerPosition: ::std::os::raw::c_int,
                              offset: *const SkPoint, paint: *const SkPaint) {
        SkDraw_drawPosText(&*self, text, byteLength, pos, scalarsPerPosition,
                           offset, paint)
    }
    #[inline]
    pub unsafe fn drawVertices(&self, mode: SkCanvas_VertexMode,
                               count: ::std::os::raw::c_int,
                               vertices: *const SkPoint,
                               textures: *const SkPoint,
                               colors: *const SkColor, bmode: SkBlendMode,
                               indices: *const u16,
                               ptCount: ::std::os::raw::c_int,
                               paint: *const SkPaint) {
        SkDraw_drawVertices(&*self, mode, count, vertices, textures, colors,
                            bmode, indices, ptCount, paint)
    }
    #[inline]
    pub unsafe fn DrawToMask(devPath: *const SkPath,
                             clipBounds: *const SkIRect,
                             arg1: *const SkMaskFilter,
                             filterMatrix: *const SkMatrix, mask: *mut SkMask,
                             mode: SkMask_CreateMode, style: InitStyle)
     -> bool {
        SkDraw_DrawToMask(devPath, clipBounds, arg1, filterMatrix, mask, mode,
                          style)
    }
    #[inline]
    pub unsafe fn ComputeRectType(arg1: *const SkPaint, arg2: *const SkMatrix,
                                  strokeSize: *mut SkPoint)
     -> SkDraw_RectType {
        SkDraw_ComputeRectType(arg1, arg2, strokeSize)
    }
    #[inline]
    pub unsafe fn ShouldDrawTextAsPaths(arg1: *const SkPaint,
                                        arg2: *const SkMatrix) -> bool {
        SkDraw_ShouldDrawTextAsPaths(arg1, arg2)
    }
    #[inline]
    pub unsafe fn drawText_asPaths(&self, text: *const ::std::os::raw::c_char,
                                   byteLength: usize, x: SkScalar,
                                   y: SkScalar, arg1: *const SkPaint) {
        SkDraw_drawText_asPaths(&*self, text, byteLength, x, y, arg1)
    }
    #[inline]
    pub unsafe fn drawPosText_asPaths(&self,
                                      text: *const ::std::os::raw::c_char,
                                      byteLength: usize, pos: *const SkScalar,
                                      scalarsPerPosition:
                                          ::std::os::raw::c_int,
                                      offset: *const SkPoint,
                                      arg1: *const SkPaint) {
        SkDraw_drawPosText_asPaths(&*self, text, byteLength, pos,
                                   scalarsPerPosition, offset, arg1)
    }
    #[inline]
    pub unsafe fn ComputeResScaleForStroking(arg1: *const SkMatrix)
     -> SkScalar {
        SkDraw_ComputeResScaleForStroking(arg1)
    }
    #[inline]
    pub unsafe fn validate(&self) { SkDraw_validate(&*self) }
}
/**
 *  Base-class for objects that draw into SkCanvas.
 *
 *  The object has a generation ID, which is guaranteed to be unique across all drawables. To
 *  allow for clients of the drawable that may want to cache the results, the drawable must
 *  change its generation ID whenever its internal state changes such that it will draw differently.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkDrawable {
    pub _base: SkFlattenable,
    pub fGenerationID: i32,
}
#[test]
fn bindgen_test_layout_SkDrawable() {
    assert_eq!(::std::mem::size_of::<SkDrawable>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkDrawable>() , 1usize);
}
extern "C" {
    /**
     *  Draws into the specified content. The drawing sequence will be balanced upon return
     *  (i.e. the saveLevel() on the canvas will match what it was when draw() was called,
     *  and the current matrix and clip settings will not be changed.
     */
    #[link_name = "?draw@SkDrawable@@QEAAXPEAVSkCanvas@@PEBVSkMatrix@@@Z"]
    pub fn SkDrawable_draw(this: *mut SkDrawable, arg1: *mut SkCanvas,
                           arg2: *const SkMatrix);
}
extern "C" {
    #[link_name = "?draw@SkDrawable@@QEAAXPEAVSkCanvas@@MM@Z"]
    pub fn SkDrawable_draw1(this: *mut SkDrawable, arg1: *mut SkCanvas,
                            x: SkScalar, y: SkScalar);
}
extern "C" {
    #[link_name = "?newPictureSnapshot@SkDrawable@@QEAAPEAVSkPicture@@XZ"]
    pub fn SkDrawable_newPictureSnapshot(this: *mut SkDrawable)
     -> *mut SkPicture;
}
extern "C" {
    /**
     *  Return a unique value for this instance. If two calls to this return the same value,
     *  it is presumed that calling the draw() method will render the same thing as well.
     *
     *  Subclasses that change their state should call notifyDrawingChanged() to ensure that
     *  a new value will be returned the next time it is called.
     */
    #[link_name = "?getGenerationID@SkDrawable@@QEAAIXZ"]
    pub fn SkDrawable_getGenerationID(this: *mut SkDrawable) -> u32;
}
extern "C" {
    /**
     *  Return the (conservative) bounds of what the drawable will draw. If the drawable can
     *  change what it draws (e.g. animation or in response to some external change), then this
     *  must return a bounds that is always valid for all possible states.
     */
    #[link_name = "?getBounds@SkDrawable@@QEAA?AUSkRect@@XZ"]
    pub fn SkDrawable_getBounds(this: *mut SkDrawable) -> SkRect;
}
extern "C" {
    /**
     *  Calling this invalidates the previous generation ID, and causes a new one to be computed
     *  the next time getGenerationID() is called. Typically this is called by the object itself,
     *  in response to its internal state changing.
     */
    #[link_name = "?notifyDrawingChanged@SkDrawable@@QEAAXXZ"]
    pub fn SkDrawable_notifyDrawingChanged(this: *mut SkDrawable);
}
impl SkDrawable {
    #[inline]
    pub unsafe fn draw(&mut self, arg1: *mut SkCanvas,
                       arg2: *const SkMatrix) {
        SkDrawable_draw(&mut *self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn draw1(&mut self, arg1: *mut SkCanvas, x: SkScalar,
                        y: SkScalar) {
        SkDrawable_draw1(&mut *self, arg1, x, y)
    }
    #[inline]
    pub unsafe fn newPictureSnapshot(&mut self) -> *mut SkPicture {
        SkDrawable_newPictureSnapshot(&mut *self)
    }
    #[inline]
    pub unsafe fn getGenerationID(&mut self) -> u32 {
        SkDrawable_getGenerationID(&mut *self)
    }
    #[inline]
    pub unsafe fn getBounds(&mut self) -> SkRect {
        SkDrawable_getBounds(&mut *self)
    }
    #[inline]
    pub unsafe fn notifyDrawingChanged(&mut self) {
        SkDrawable_notifyDrawingChanged(&mut *self)
    }
}
/**
 *  DEPRECATED - use SkPaintFilterCanvas instead.
 *
 *  Right before something is being draw, filter() is called with the
 *  paint. The filter may modify the paint as it wishes, which will then be
 *  used for the actual drawing. Note: this modification only lasts for the
 *  current draw, as a temporary copy of the paint is used.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkDrawFilter {
    pub _base: SkRefCnt,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkDrawFilter_Type {
    kPaint_Type = 0,
    kPoint_Type = 1,
    kLine_Type = 2,
    kBitmap_Type = 3,
    kRect_Type = 4,
    kRRect_Type = 5,
    kOval_Type = 6,
    kPath_Type = 7,
    kText_Type = 8,
}
pub const SkDrawFilter_kTypeCount: SkDrawFilter__bindgen_ty_1 =
    SkDrawFilter__bindgen_ty_1::kTypeCount;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkDrawFilter__bindgen_ty_1 { kTypeCount = 9, }
pub type SkDrawFilter_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkDrawFilter() {
    assert_eq!(::std::mem::size_of::<SkDrawFilter>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkDrawFilter>() , 1usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkMetaData {
    pub fRec: *mut SkMetaData_Rec,
}
/**
     *  Used to manage the life-cycle of a ptr in the metadata. This is option
     *  in setPtr, and is only invoked when either copying one metadata to
     *  another, or when the metadata is destroyed.
     *
     *  setPtr(name, ptr, proc) {
     *      fPtr = proc(ptr, true);
     *  }
     *
     *  copy: A = B {
     *      A.fPtr = B.fProc(B.fPtr, true);
     *  }
     *
     *  ~SkMetaData {
     *      fProc(fPtr, false);
     *  }
     */
pub type SkMetaData_PtrProc =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               doRef: bool)
                              -> *mut ::std::os::raw::c_void>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMetaData_Type {
    kS32_Type = 0,
    kScalar_Type = 1,
    kString_Type = 2,
    kPtr_Type = 3,
    kBool_Type = 4,
    kData_Type = 5,
    kTypeCount = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkMetaData_Rec {
    pub fNext: *mut SkMetaData_Rec,
    pub fDataCount: u16,
    pub fDataLen: u8,
    pub fType: u8,
}
#[test]
fn bindgen_test_layout_SkMetaData_Rec() {
    assert_eq!(::std::mem::size_of::<SkMetaData_Rec>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkMetaData_Rec>() , 8usize);
}
extern "C" {
    #[link_name = "?Alloc@Rec@SkMetaData@@SAPEAU12@_K@Z"]
    pub fn SkMetaData_Rec_Alloc(arg1: usize) -> *mut SkMetaData_Rec;
}
extern "C" {
    #[link_name = "?Free@Rec@SkMetaData@@SAXPEAU12@@Z"]
    pub fn SkMetaData_Rec_Free(arg1: *mut SkMetaData_Rec);
}
impl Clone for SkMetaData_Rec {
    fn clone(&self) -> Self { *self }
}
impl SkMetaData_Rec {
    #[inline]
    pub unsafe fn Alloc(arg1: usize) -> *mut SkMetaData_Rec {
        SkMetaData_Rec_Alloc(arg1)
    }
    #[inline]
    pub unsafe fn Free(arg1: *mut SkMetaData_Rec) {
        SkMetaData_Rec_Free(arg1)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkMetaData_Iter {
    pub fRec: *mut SkMetaData_Rec,
}
#[test]
fn bindgen_test_layout_SkMetaData_Iter() {
    assert_eq!(::std::mem::size_of::<SkMetaData_Iter>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkMetaData_Iter>() , 8usize);
}
extern "C" {
    /** Reset the iterator, so that calling next() will return the first
            data element. This is done implicitly in the constructor.
        */
    #[link_name = "?reset@Iter@SkMetaData@@QEAAXAEBV2@@Z"]
    pub fn SkMetaData_Iter_reset(this: *mut SkMetaData_Iter,
                                 arg1: *const SkMetaData);
}
extern "C" {
    /** Each time next is called, it returns the name of the next data element,
            or null when there are no more elements. If non-null is returned, then the
            element's type is returned (if not null), and the number of data values
            is returned in count (if not null).
        */
    #[link_name = "?next@Iter@SkMetaData@@QEAAPEBDPEAW4Type@2@PEAH@Z"]
    pub fn SkMetaData_Iter_next(this: *mut SkMetaData_Iter,
                                arg1: *mut SkMetaData_Type,
                                count: *mut ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
impl Clone for SkMetaData_Iter {
    fn clone(&self) -> Self { *self }
}
impl SkMetaData_Iter {
    #[inline]
    pub unsafe fn reset(&mut self, arg1: *const SkMetaData) {
        SkMetaData_Iter_reset(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn next(&mut self, arg1: *mut SkMetaData_Type,
                       count: *mut ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char {
        SkMetaData_Iter_next(&mut *self, arg1, count)
    }
}
#[test]
fn bindgen_test_layout_SkMetaData() {
    assert_eq!(::std::mem::size_of::<SkMetaData>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkMetaData>() , 8usize);
}
extern "C" {
    /**
     *  Implements PtrProc for SkRefCnt pointers
     */
    #[link_name = "?RefCntProc@SkMetaData@@SAPEAXPEAX_N@Z"]
    pub fn SkMetaData_RefCntProc(ptr: *mut ::std::os::raw::c_void,
                                 doRef: bool) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "?reset@SkMetaData@@QEAAXXZ"]
    pub fn SkMetaData_reset(this: *mut SkMetaData);
}
extern "C" {
    #[link_name = "?findS32@SkMetaData@@QEBA_NQEBDPEAH@Z"]
    pub fn SkMetaData_findS32(this: *const SkMetaData,
                              name: *const ::std::os::raw::c_char,
                              value: *mut i32) -> bool;
}
extern "C" {
    #[link_name = "?findScalar@SkMetaData@@QEBA_NQEBDPEAM@Z"]
    pub fn SkMetaData_findScalar(this: *const SkMetaData,
                                 name: *const ::std::os::raw::c_char,
                                 value: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "?findScalars@SkMetaData@@QEBAPEBMQEBDPEAHQEAM@Z"]
    pub fn SkMetaData_findScalars(this: *const SkMetaData,
                                  name: *const ::std::os::raw::c_char,
                                  count: *mut ::std::os::raw::c_int,
                                  values: *mut SkScalar) -> *const SkScalar;
}
extern "C" {
    #[link_name = "?findString@SkMetaData@@QEBAPEBDQEBD@Z"]
    pub fn SkMetaData_findString(this: *const SkMetaData,
                                 name: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name =
          "?findPtr@SkMetaData@@QEBA_NQEBDPEAPEAXPEAP6APEAXPEAX_N@Z@Z"]
    pub fn SkMetaData_findPtr(this: *const SkMetaData,
                              name: *const ::std::os::raw::c_char,
                              value: *mut *mut ::std::os::raw::c_void,
                              arg1: *mut SkMetaData_PtrProc) -> bool;
}
extern "C" {
    #[link_name = "?findBool@SkMetaData@@QEBA_NQEBDPEA_N@Z"]
    pub fn SkMetaData_findBool(this: *const SkMetaData,
                               name: *const ::std::os::raw::c_char,
                               value: *mut bool) -> bool;
}
extern "C" {
    #[link_name = "?findData@SkMetaData@@QEBAPEBXQEBDPEA_K@Z"]
    pub fn SkMetaData_findData(this: *const SkMetaData,
                               name: *const ::std::os::raw::c_char,
                               byteCount: *mut usize)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "?setS32@SkMetaData@@QEAAXQEBDH@Z"]
    pub fn SkMetaData_setS32(this: *mut SkMetaData,
                             name: *const ::std::os::raw::c_char, value: i32);
}
extern "C" {
    #[link_name = "?setScalar@SkMetaData@@QEAAXQEBDM@Z"]
    pub fn SkMetaData_setScalar(this: *mut SkMetaData,
                                name: *const ::std::os::raw::c_char,
                                value: SkScalar);
}
extern "C" {
    #[link_name = "?setScalars@SkMetaData@@QEAAPEAMQEBDHQEBM@Z"]
    pub fn SkMetaData_setScalars(this: *mut SkMetaData,
                                 name: *const ::std::os::raw::c_char,
                                 count: ::std::os::raw::c_int,
                                 values: *const SkScalar) -> *mut SkScalar;
}
extern "C" {
    #[link_name = "?setString@SkMetaData@@QEAAXQEBD0@Z"]
    pub fn SkMetaData_setString(this: *mut SkMetaData,
                                name: *const ::std::os::raw::c_char,
                                value: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "?setPtr@SkMetaData@@QEAAXQEBDPEAXP6APEAX1_N@Z@Z"]
    pub fn SkMetaData_setPtr(this: *mut SkMetaData,
                             name: *const ::std::os::raw::c_char,
                             value: *mut ::std::os::raw::c_void,
                             proc_: SkMetaData_PtrProc);
}
extern "C" {
    #[link_name = "?setBool@SkMetaData@@QEAAXQEBD_N@Z"]
    pub fn SkMetaData_setBool(this: *mut SkMetaData,
                              name: *const ::std::os::raw::c_char,
                              value: bool);
}
extern "C" {
    #[link_name = "?setData@SkMetaData@@QEAAXQEBDPEBX_K@Z"]
    pub fn SkMetaData_setData(this: *mut SkMetaData,
                              name: *const ::std::os::raw::c_char,
                              data: *const ::std::os::raw::c_void,
                              byteCount: usize);
}
extern "C" {
    #[link_name = "?removeS32@SkMetaData@@QEAA_NQEBD@Z"]
    pub fn SkMetaData_removeS32(this: *mut SkMetaData,
                                name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?removeScalar@SkMetaData@@QEAA_NQEBD@Z"]
    pub fn SkMetaData_removeScalar(this: *mut SkMetaData,
                                   name: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    #[link_name = "?removeString@SkMetaData@@QEAA_NQEBD@Z"]
    pub fn SkMetaData_removeString(this: *mut SkMetaData,
                                   name: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    #[link_name = "?removePtr@SkMetaData@@QEAA_NQEBD@Z"]
    pub fn SkMetaData_removePtr(this: *mut SkMetaData,
                                name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?removeBool@SkMetaData@@QEAA_NQEBD@Z"]
    pub fn SkMetaData_removeBool(this: *mut SkMetaData,
                                 name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?removeData@SkMetaData@@QEAA_NQEBD@Z"]
    pub fn SkMetaData_removeData(this: *mut SkMetaData,
                                 name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "?find@SkMetaData@@QEBAPEBURec@1@QEBDW4Type@1@@Z"]
    pub fn SkMetaData_find(this: *const SkMetaData,
                           name: *const ::std::os::raw::c_char,
                           arg1: SkMetaData_Type) -> *const SkMetaData_Rec;
}
extern "C" {
    #[link_name = "?set@SkMetaData@@QEAAPEAXQEBDPEBX_KW4Type@1@H@Z"]
    pub fn SkMetaData_set(this: *mut SkMetaData,
                          name: *const ::std::os::raw::c_char,
                          data: *const ::std::os::raw::c_void, len: usize,
                          arg1: SkMetaData_Type, count: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "?remove@SkMetaData@@QEAA_NQEBDW4Type@1@@Z"]
    pub fn SkMetaData_remove(this: *mut SkMetaData,
                             name: *const ::std::os::raw::c_char,
                             arg1: SkMetaData_Type) -> bool;
}
impl SkMetaData {
    #[inline]
    pub unsafe fn RefCntProc(ptr: *mut ::std::os::raw::c_void, doRef: bool)
     -> *mut ::std::os::raw::c_void {
        SkMetaData_RefCntProc(ptr, doRef)
    }
    #[inline]
    pub unsafe fn reset(&mut self) { SkMetaData_reset(&mut *self) }
    #[inline]
    pub unsafe fn findS32(&self, name: *const ::std::os::raw::c_char,
                          value: *mut i32) -> bool {
        SkMetaData_findS32(&*self, name, value)
    }
    #[inline]
    pub unsafe fn findScalar(&self, name: *const ::std::os::raw::c_char,
                             value: *mut SkScalar) -> bool {
        SkMetaData_findScalar(&*self, name, value)
    }
    #[inline]
    pub unsafe fn findScalars(&self, name: *const ::std::os::raw::c_char,
                              count: *mut ::std::os::raw::c_int,
                              values: *mut SkScalar) -> *const SkScalar {
        SkMetaData_findScalars(&*self, name, count, values)
    }
    #[inline]
    pub unsafe fn findString(&self, name: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char {
        SkMetaData_findString(&*self, name)
    }
    #[inline]
    pub unsafe fn findPtr(&self, name: *const ::std::os::raw::c_char,
                          value: *mut *mut ::std::os::raw::c_void,
                          arg1: *mut SkMetaData_PtrProc) -> bool {
        SkMetaData_findPtr(&*self, name, value, arg1)
    }
    #[inline]
    pub unsafe fn findBool(&self, name: *const ::std::os::raw::c_char,
                           value: *mut bool) -> bool {
        SkMetaData_findBool(&*self, name, value)
    }
    #[inline]
    pub unsafe fn findData(&self, name: *const ::std::os::raw::c_char,
                           byteCount: *mut usize)
     -> *const ::std::os::raw::c_void {
        SkMetaData_findData(&*self, name, byteCount)
    }
    #[inline]
    pub unsafe fn setS32(&mut self, name: *const ::std::os::raw::c_char,
                         value: i32) {
        SkMetaData_setS32(&mut *self, name, value)
    }
    #[inline]
    pub unsafe fn setScalar(&mut self, name: *const ::std::os::raw::c_char,
                            value: SkScalar) {
        SkMetaData_setScalar(&mut *self, name, value)
    }
    #[inline]
    pub unsafe fn setScalars(&mut self, name: *const ::std::os::raw::c_char,
                             count: ::std::os::raw::c_int,
                             values: *const SkScalar) -> *mut SkScalar {
        SkMetaData_setScalars(&mut *self, name, count, values)
    }
    #[inline]
    pub unsafe fn setString(&mut self, name: *const ::std::os::raw::c_char,
                            value: *const ::std::os::raw::c_char) {
        SkMetaData_setString(&mut *self, name, value)
    }
    #[inline]
    pub unsafe fn setPtr(&mut self, name: *const ::std::os::raw::c_char,
                         value: *mut ::std::os::raw::c_void,
                         proc_: SkMetaData_PtrProc) {
        SkMetaData_setPtr(&mut *self, name, value, proc_)
    }
    #[inline]
    pub unsafe fn setBool(&mut self, name: *const ::std::os::raw::c_char,
                          value: bool) {
        SkMetaData_setBool(&mut *self, name, value)
    }
    #[inline]
    pub unsafe fn setData(&mut self, name: *const ::std::os::raw::c_char,
                          data: *const ::std::os::raw::c_void,
                          byteCount: usize) {
        SkMetaData_setData(&mut *self, name, data, byteCount)
    }
    #[inline]
    pub unsafe fn removeS32(&mut self, name: *const ::std::os::raw::c_char)
     -> bool {
        SkMetaData_removeS32(&mut *self, name)
    }
    #[inline]
    pub unsafe fn removeScalar(&mut self, name: *const ::std::os::raw::c_char)
     -> bool {
        SkMetaData_removeScalar(&mut *self, name)
    }
    #[inline]
    pub unsafe fn removeString(&mut self, name: *const ::std::os::raw::c_char)
     -> bool {
        SkMetaData_removeString(&mut *self, name)
    }
    #[inline]
    pub unsafe fn removePtr(&mut self, name: *const ::std::os::raw::c_char)
     -> bool {
        SkMetaData_removePtr(&mut *self, name)
    }
    #[inline]
    pub unsafe fn removeBool(&mut self, name: *const ::std::os::raw::c_char)
     -> bool {
        SkMetaData_removeBool(&mut *self, name)
    }
    #[inline]
    pub unsafe fn removeData(&mut self, name: *const ::std::os::raw::c_char)
     -> bool {
        SkMetaData_removeData(&mut *self, name)
    }
    #[inline]
    pub unsafe fn find(&self, name: *const ::std::os::raw::c_char,
                       arg1: SkMetaData_Type) -> *const SkMetaData_Rec {
        SkMetaData_find(&*self, name, arg1)
    }
    #[inline]
    pub unsafe fn set(&mut self, name: *const ::std::os::raw::c_char,
                      data: *const ::std::os::raw::c_void, len: usize,
                      arg1: SkMetaData_Type, count: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void {
        SkMetaData_set(&mut *self, name, data, len, arg1, count)
    }
    #[inline]
    pub unsafe fn remove(&mut self, name: *const ::std::os::raw::c_char,
                         arg1: SkMetaData_Type) -> bool {
        SkMetaData_remove(&mut *self, name, arg1)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRasterClip {
    pub _address: u8,
}
impl Clone for SkRasterClip {
    fn clone(&self) -> Self { *self }
}
/** \class SkRRect

    The SkRRect class represents a rounded rect with a potentially different
    radii for each corner. It does not have a constructor so must be
    initialized with one of the initialization functions (e.g., setEmpty,
    setRectRadii, etc.)

    This class is intended to roughly match CSS' border-*-*-radius capabilities.
    This means:
        If either of a corner's radii are 0 the corner will be square.
        Negative radii are not allowed (they are clamped to zero).
        If the corner curves overlap they will be proportionally reduced to fit.
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRRect {
    pub fRect: SkRect,
    pub fRadii: [SkVector; 4usize],
    pub fType: i32,
}
#[repr(i32)]
/**
     * Enum to capture the various possible subtypes of RR. Accessed
     * by type(). The subtypes become progressively less restrictive.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkRRect_Type {
    kEmpty_Type = 0,
    kRect_Type = 1,
    kOval_Type = 2,
    kSimple_Type = 3,
    kNinePatch_Type = 4,
    kComplex_Type = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkRRect_Corner {
    kUpperLeft_Corner = 0,
    kUpperRight_Corner = 1,
    kLowerRight_Corner = 2,
    kLowerLeft_Corner = 3,
}
pub const SkRRect_kSizeInMemory: SkRRect__bindgen_ty_1 =
    SkRRect__bindgen_ty_1::kSizeInMemory;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkRRect__bindgen_ty_1 { kSizeInMemory = 48, }
#[test]
fn bindgen_test_layout_SkRRect() {
    assert_eq!(::std::mem::size_of::<SkRRect>() , 52usize);
    assert_eq!(::std::mem::align_of::<SkRRect>() , 4usize);
}
extern "C" {
    #[link_name = "?allCornersCircular@SkRRect@@QEBA_NXZ"]
    pub fn SkRRect_allCornersCircular(this: *const SkRRect) -> bool;
}
extern "C" {
    /**
     * Initialize the RR with the same radii for all four corners.
     */
    #[link_name = "?setRectXY@SkRRect@@QEAAXAEBUSkRect@@MM@Z"]
    pub fn SkRRect_setRectXY(this: *mut SkRRect, rect: *const SkRect,
                             xRad: SkScalar, yRad: SkScalar);
}
extern "C" {
    /**
     * Initialize the rr with one radius per-side.
     */
    #[link_name = "?setNinePatch@SkRRect@@QEAAXAEBUSkRect@@MMMM@Z"]
    pub fn SkRRect_setNinePatch(this: *mut SkRRect, rect: *const SkRect,
                                leftRad: SkScalar, topRad: SkScalar,
                                rightRad: SkScalar, bottomRad: SkScalar);
}
extern "C" {
    /**
     * Initialize the RR with potentially different radii for all four corners.
     */
    #[link_name = "?setRectRadii@SkRRect@@QEAAXAEBUSkRect@@QEBUSkPoint@@@Z"]
    pub fn SkRRect_setRectRadii(this: *mut SkRRect, rect: *const SkRect,
                                radii: *mut SkVector);
}
extern "C" {
    /**
     *  Call inset on the bounds, and adjust the radii to reflect what happens
     *  in stroking: If the corner is sharp (no curvature), leave it alone,
     *  otherwise we grow/shrink the radii by the amount of the inset. If a
     *  given radius becomes negative, it is pinned to 0.
     *
     *  It is valid for dst == this.
     */
    #[link_name = "?inset@SkRRect@@QEBAXMMPEAV1@@Z"]
    pub fn SkRRect_inset(this: *const SkRRect, dx: SkScalar, dy: SkScalar,
                         dst: *mut SkRRect);
}
extern "C" {
    /**
     *  Returns true if 'rect' is wholy inside the RR, and both
     *  are not empty.
     */
    #[link_name = "?contains@SkRRect@@QEBA_NAEBUSkRect@@@Z"]
    pub fn SkRRect_contains(this: *const SkRRect, rect: *const SkRect)
     -> bool;
}
extern "C" {
    #[link_name = "?isValid@SkRRect@@QEBA_NXZ"]
    pub fn SkRRect_isValid(this: *const SkRRect) -> bool;
}
extern "C" {
    /**
     *  Write the rrect into the specified buffer. This is guaranteed to always
     *  write kSizeInMemory bytes, and that value is guaranteed to always be
     *  a multiple of 4. Return kSizeInMemory.
     */
    #[link_name = "?writeToMemory@SkRRect@@QEBA_KPEAX@Z"]
    pub fn SkRRect_writeToMemory(this: *const SkRRect,
                                 buffer: *mut ::std::os::raw::c_void)
     -> usize;
}
extern "C" {
    /**
     * Reads the rrect from the specified buffer
     *
     * If the specified buffer is large enough, this will read kSizeInMemory bytes,
     * and that value is guaranteed to always be a multiple of 4.
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
    #[link_name = "?readFromMemory@SkRRect@@QEAA_KPEBX_K@Z"]
    pub fn SkRRect_readFromMemory(this: *mut SkRRect,
                                  buffer: *const ::std::os::raw::c_void,
                                  length: usize) -> usize;
}
extern "C" {
    /**
     *  Transform by the specified matrix, and put the result in dst.
     *
     *  @param matrix SkMatrix specifying the transform. Must only contain
     *      scale and/or translate, or this call will fail.
     *  @param dst SkRRect to store the result. It is an error to use this,
     *      which would make this function no longer const.
     *  @return true on success, false on failure. If false, dst is unmodified.
     */
    #[link_name = "?transform@SkRRect@@QEBA_NAEBVSkMatrix@@PEAV1@@Z"]
    pub fn SkRRect_transform(this: *const SkRRect, matrix: *const SkMatrix,
                             dst: *mut SkRRect) -> bool;
}
extern "C" {
    #[link_name = "?dump@SkRRect@@QEBAX_N@Z"]
    pub fn SkRRect_dump(this: *const SkRRect, asHex: bool);
}
impl Clone for SkRRect {
    fn clone(&self) -> Self { *self }
}
impl SkRRect {
    #[inline]
    pub unsafe fn allCornersCircular(&self) -> bool {
        SkRRect_allCornersCircular(&*self)
    }
    #[inline]
    pub unsafe fn setRectXY(&mut self, rect: *const SkRect, xRad: SkScalar,
                            yRad: SkScalar) {
        SkRRect_setRectXY(&mut *self, rect, xRad, yRad)
    }
    #[inline]
    pub unsafe fn setNinePatch(&mut self, rect: *const SkRect,
                               leftRad: SkScalar, topRad: SkScalar,
                               rightRad: SkScalar, bottomRad: SkScalar) {
        SkRRect_setNinePatch(&mut *self, rect, leftRad, topRad, rightRad,
                             bottomRad)
    }
    #[inline]
    pub unsafe fn setRectRadii(&mut self, rect: *const SkRect,
                               radii: *mut SkVector) {
        SkRRect_setRectRadii(&mut *self, rect, radii)
    }
    #[inline]
    pub unsafe fn inset(&self, dx: SkScalar, dy: SkScalar,
                        dst: *mut SkRRect) {
        SkRRect_inset(&*self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn contains(&self, rect: *const SkRect) -> bool {
        SkRRect_contains(&*self, rect)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool { SkRRect_isValid(&*self) }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::std::os::raw::c_void)
     -> usize {
        SkRRect_writeToMemory(&*self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(&mut self,
                                 buffer: *const ::std::os::raw::c_void,
                                 length: usize) -> usize {
        SkRRect_readFromMemory(&mut *self, buffer, length)
    }
    #[inline]
    pub unsafe fn transform(&self, matrix: *const SkMatrix, dst: *mut SkRRect)
     -> bool {
        SkRRect_transform(&*self, matrix, dst)
    }
    #[inline]
    pub unsafe fn dump(&self, asHex: bool) { SkRRect_dump(&*self, asHex) }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkSurface_Base {
    pub _address: u8,
}
impl Clone for SkSurface_Base {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkImageFilterCache {
    pub _address: u8,
}
impl Clone for SkImageFilterCache {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkSpecialImage {
    pub _address: u8,
}
impl Clone for SkSpecialImage {
    fn clone(&self) -> Self { *self }
}
///////////////////////////////////////////////////////////////////////////////
#[repr(C)]
#[derive(Debug)]
pub struct SkBitmapDevice {
    pub _base: SkBaseDevice,
    pub fBitmap: SkBitmap,
}
pub type SkBitmapDevice_INHERITED = SkBaseDevice;
#[test]
fn bindgen_test_layout_SkBitmapDevice() {
    assert_eq!(::std::mem::size_of::<SkBitmapDevice>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkBitmapDevice>() , 1usize);
}
extern "C" {
    /**
     * Create a new device along with its requisite pixel memory using
     * default SkSurfaceProps (i.e., kLegacyFontHost_InitType-style).
     * Note: this entry point is slated for removal - no one should call it.
     */
    #[link_name = "?Create@SkBitmapDevice@@SAPEAV1@AEBUSkImageInfo@@@Z"]
    pub fn SkBitmapDevice_Create(info: *const SkImageInfo)
     -> *mut SkBitmapDevice;
}
extern "C" {
    #[link_name =
          "?Create@SkBitmapDevice@@SAPEAV1@AEBUSkImageInfo@@AEBVSkSurfaceProps@@@Z"]
    pub fn SkBitmapDevice_Create1(arg1: *const SkImageInfo,
                                  arg2: *const SkSurfaceProps)
     -> *mut SkBitmapDevice;
}
extern "C" {
    #[link_name = "?onAccessBitmap@SkBitmapDevice@@IEAAAEBVSkBitmap@@XZ"]
    pub fn SkBitmapDevice_onAccessBitmap(this: *mut SkBitmapDevice)
     -> *const SkBitmap;
}
impl SkBitmapDevice {
    #[inline]
    pub unsafe fn Create(info: *const SkImageInfo) -> *mut SkBitmapDevice {
        SkBitmapDevice_Create(info)
    }
    #[inline]
    pub unsafe fn Create1(arg1: *const SkImageInfo,
                          arg2: *const SkSurfaceProps)
     -> *mut SkBitmapDevice {
        SkBitmapDevice_Create1(arg1, arg2)
    }
    #[inline]
    pub unsafe fn onAccessBitmap(&mut self) -> *const SkBitmap {
        SkBitmapDevice_onAccessBitmap(&mut *self)
    }
}
pub const SkBlurStyle_kLastEnum_SkBlurStyle: SkBlurStyle =
    SkBlurStyle::kInner_SkBlurStyle;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkBlurStyle {
    kNormal_SkBlurStyle = 0,
    kSolid_SkBlurStyle = 1,
    kOuter_SkBlurStyle = 2,
    kInner_SkBlurStyle = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkBlurQuality {
    kLow_SkBlurQuality = 0,
    kHigh_SkBlurQuality = 1,
    kLastEnum_SkBlurQuality = 2,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTDArray<T> {
    pub fArray: *mut T,
    pub fReserve: ::std::os::raw::c_int,
    pub fCount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRBuffer {
    pub _address: u8,
}
impl Clone for SkRBuffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkWBuffer {
    pub _address: u8,
}
impl Clone for SkWBuffer {
    fn clone(&self) -> Self { *self }
}
/**
 * Holds the path verbs and points. It is versioned by a generation ID. None of its public methods
 * modify the contents. To modify or append to the verbs/points wrap the SkPathRef in an
 * SkPathRef::Editor object. Installing the editor resets the generation ID. It also performs
 * copy-on-write if the SkPathRef is shared by multiple SkPaths. The caller passes the Editor's
 * constructor a pointer to a sk_sp<SkPathRef>, which may be updated to point to a new SkPathRef
 * after the editor's constructor returns.
 *
 * The points and verbs are stored in a single allocation. The points are at the begining of the
 * allocation while the verbs are stored at end of the allocation, in reverse order. Thus the points
 * and verbs both grow into the middle of the allocation until the meet. To access verb i in the
 * verb array use ref.verbs()[~i] (because verbs() returns a pointer just beyond the first
 * logical verb or the last verb in memory).
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkPathRef {
    pub fBounds: SkRect,
    pub fPoints: *mut SkPoint,
    pub fVerbs: *mut u8,
    pub fVerbCnt: ::std::os::raw::c_int,
    pub fPointCnt: ::std::os::raw::c_int,
    pub fFreeSpace: usize,
    pub fConicWeights: SkTDArray<f32>,
    pub fGenerationID: u32,
    pub fEditorsAttached: i32,
    pub fGenIDChangeListeners: SkTDArray<*mut SkPathRef_GenIDChangeListener>,
    pub fBoundsIsDirty: u8,
    pub fIsFinite: SkBool8,
    pub fIsOval: SkBool8,
    pub fIsRRect: SkBool8,
    pub fRRectOrOvalIsCCW: SkBool8,
    pub fRRectOrOvalStartIdx: u8,
    pub fSegmentMask: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathRef_Editor {
    pub fPathRef: *mut SkPathRef,
}
#[test]
fn bindgen_test_layout_SkPathRef_Editor() {
    assert_eq!(::std::mem::size_of::<SkPathRef_Editor>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkPathRef_Editor>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPathRef_Iter {
    pub fPts: *const SkPoint,
    pub fVerbs: *const u8,
    pub fVerbStop: *const u8,
    pub fConicWeights: *const SkScalar,
}
#[test]
fn bindgen_test_layout_SkPathRef_Iter() {
    assert_eq!(::std::mem::size_of::<SkPathRef_Iter>() , 32usize);
    assert_eq!(::std::mem::align_of::<SkPathRef_Iter>() , 8usize);
}
extern "C" {
    #[link_name = "?setPathRef@Iter@SkPathRef@@QEAAXAEBV2@@Z"]
    pub fn SkPathRef_Iter_setPathRef(this: *mut SkPathRef_Iter,
                                     arg1: *const SkPathRef);
}
extern "C" {
    /** Return the next verb in this iteration of the path. When all
            segments have been visited, return kDone_Verb.

            @param  pts The points representing the current verb and/or segment
                        This must not be NULL.
            @return The verb for the current segment
        */
    #[link_name = "?next@Iter@SkPathRef@@QEAAEQEAUSkPoint@@@Z"]
    pub fn SkPathRef_Iter_next(this: *mut SkPathRef_Iter, pts: *mut SkPoint)
     -> u8;
}
extern "C" {
    #[link_name = "?peek@Iter@SkPathRef@@QEBAEXZ"]
    pub fn SkPathRef_Iter_peek(this: *const SkPathRef_Iter) -> u8;
}
impl Clone for SkPathRef_Iter {
    fn clone(&self) -> Self { *self }
}
impl SkPathRef_Iter {
    #[inline]
    pub unsafe fn setPathRef(&mut self, arg1: *const SkPathRef) {
        SkPathRef_Iter_setPathRef(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn next(&mut self, pts: *mut SkPoint) -> u8 {
        SkPathRef_Iter_next(&mut *self, pts)
    }
    #[inline]
    pub unsafe fn peek(&self) -> u8 { SkPathRef_Iter_peek(&*self) }
}
#[repr(C)]
pub struct SkPathRef_GenIDChangeListener__bindgen_vtable {
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathRef_GenIDChangeListener {
    pub vtable_: *const SkPathRef_GenIDChangeListener__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkPathRef_GenIDChangeListener() {
    assert_eq!(::std::mem::size_of::<SkPathRef_GenIDChangeListener>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<SkPathRef_GenIDChangeListener>() ,
               8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPathRef_SerializationOffsets {
    kRRectOrOvalStartIdx_SerializationShift = 28,
    kRRectOrOvalIsCCW_SerializationShift = 27,
    kIsRRect_SerializationShift = 26,
    kIsFinite_SerializationShift = 25,
    kIsOval_SerializationShift = 24,
    kSegmentMask_SerializationShift = 0,
}
pub const SkPathRef_kMinSize: SkPathRef__bindgen_ty_1 =
    SkPathRef__bindgen_ty_1::kMinSize;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPathRef__bindgen_ty_1 { kMinSize = 256, }
pub const SkPathRef_kEmptyGenID: SkPathRef__bindgen_ty_2 =
    SkPathRef__bindgen_ty_2::kEmptyGenID;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkPathRef__bindgen_ty_2 { kEmptyGenID = 1, }
#[test]
fn bindgen_test_layout_SkPathRef() {
    assert_eq!(::std::mem::size_of::<SkPathRef>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPathRef>() , 1usize);
}
extern "C" {
    /**
     * Gets a path ref with no verbs or points.
     */
    #[link_name = "?CreateEmpty@SkPathRef@@SAPEAV1@XZ"]
    pub fn SkPathRef_CreateEmpty() -> *mut SkPathRef;
}
extern "C" {
    #[link_name = "?getRRect@SkPathRef@@QEBA?AVSkRRect@@XZ"]
    pub fn SkPathRef_getRRect(this: *const SkPathRef) -> SkRRect;
}
extern "C" {
    /**
     * Transforms a path ref by a matrix, allocating a new one only if necessary.
     */
    #[link_name =
          "?CreateTransformedCopy@SkPathRef@@SAXPEAV?$sk_sp@VSkPathRef@@@@AEBV1@AEBVSkMatrix@@@Z"]
    pub fn SkPathRef_CreateTransformedCopy(dst: *mut sk_sp<SkPathRef>,
                                           src: *const SkPathRef,
                                           matrix: *const SkMatrix);
}
extern "C" {
    #[link_name = "?CreateFromBuffer@SkPathRef@@SAPEAV1@PEAVSkRBuffer@@@Z"]
    pub fn SkPathRef_CreateFromBuffer(buffer: *mut SkRBuffer)
     -> *mut SkPathRef;
}
extern "C" {
    /**
     * Rollsback a path ref to zero verbs and points with the assumption that the path ref will be
     * repopulated with approximately the same number of verbs and points. A new path ref is created
     * only if necessary.
     */
    #[link_name = "?Rewind@SkPathRef@@SAXPEAV?$sk_sp@VSkPathRef@@@@@Z"]
    pub fn SkPathRef_Rewind(pathRef: *mut sk_sp<SkPathRef>);
}
extern "C" {
    /**
     * Writes the path points and verbs to a buffer.
     */
    #[link_name = "?writeToBuffer@SkPathRef@@QEBAXPEAVSkWBuffer@@@Z"]
    pub fn SkPathRef_writeToBuffer(this: *const SkPathRef,
                                   buffer: *mut SkWBuffer);
}
extern "C" {
    /**
     * Gets the number of bytes that would be written in writeBuffer()
     */
    #[link_name = "?writeSize@SkPathRef@@QEBAIXZ"]
    pub fn SkPathRef_writeSize(this: *const SkPathRef) -> u32;
}
extern "C" {
    #[link_name = "?interpolate@SkPathRef@@QEBAXAEBV1@MPEAV1@@Z"]
    pub fn SkPathRef_interpolate(this: *const SkPathRef,
                                 ending: *const SkPathRef, weight: SkScalar,
                                 out: *mut SkPathRef);
}
extern "C" {
    /**
     * Gets an ID that uniquely identifies the contents of the path ref. If two path refs have the
     * same ID then they have the same verbs and points. However, two path refs may have the same
     * contents but different genIDs.
     */
    #[link_name = "?genID@SkPathRef@@QEBAIXZ"]
    pub fn SkPathRef_genID(this: *const SkPathRef) -> u32;
}
extern "C" {
    #[link_name =
          "?addGenIDChangeListener@SkPathRef@@QEAAXPEAUGenIDChangeListener@1@@Z"]
    pub fn SkPathRef_addGenIDChangeListener(this: *mut SkPathRef,
                                            listener:
                                                *mut SkPathRef_GenIDChangeListener);
}
extern "C" {
    #[link_name = "?validate@SkPathRef@@QEBAXXZ"]
    pub fn SkPathRef_validate(this: *const SkPathRef);
}
impl SkPathRef {
    #[inline]
    pub unsafe fn CreateEmpty() -> *mut SkPathRef { SkPathRef_CreateEmpty() }
    #[inline]
    pub unsafe fn getRRect(&self) -> SkRRect { SkPathRef_getRRect(&*self) }
    #[inline]
    pub unsafe fn CreateTransformedCopy(dst: *mut sk_sp<SkPathRef>,
                                        src: *const SkPathRef,
                                        matrix: *const SkMatrix) {
        SkPathRef_CreateTransformedCopy(dst, src, matrix)
    }
    #[inline]
    pub unsafe fn CreateFromBuffer(buffer: *mut SkRBuffer) -> *mut SkPathRef {
        SkPathRef_CreateFromBuffer(buffer)
    }
    #[inline]
    pub unsafe fn Rewind(pathRef: *mut sk_sp<SkPathRef>) {
        SkPathRef_Rewind(pathRef)
    }
    #[inline]
    pub unsafe fn writeToBuffer(&self, buffer: *mut SkWBuffer) {
        SkPathRef_writeToBuffer(&*self, buffer)
    }
    #[inline]
    pub unsafe fn writeSize(&self) -> u32 { SkPathRef_writeSize(&*self) }
    #[inline]
    pub unsafe fn interpolate(&self, ending: *const SkPathRef,
                              weight: SkScalar, out: *mut SkPathRef) {
        SkPathRef_interpolate(&*self, ending, weight, out)
    }
    #[inline]
    pub unsafe fn genID(&self) -> u32 { SkPathRef_genID(&*self) }
    #[inline]
    pub unsafe fn addGenIDChangeListener(&mut self,
                                         listener:
                                             *mut SkPathRef_GenIDChangeListener) {
        SkPathRef_addGenIDChangeListener(&mut *self, listener)
    }
    #[inline]
    pub unsafe fn validate(&self) { SkPathRef_validate(&*self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkWriter32 {
    pub fData: *mut u8,
    pub fCapacity: usize,
    pub fUsed: usize,
    pub fExternal: *mut ::std::os::raw::c_void,
    pub fInternal: SkAutoTMalloc<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_SkWriter32() {
    assert_eq!(::std::mem::size_of::<SkWriter32>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkWriter32>() , 1usize);
}
extern "C" {
    /**
     *  Writes a string to the writer, which can be retrieved with
     *  SkReader32::readString().
     *  The length can be specified, or if -1 is passed, it will be computed by
     *  calling strlen(). The length must be < max size_t.
     *
     *  If you write NULL, it will be read as "".
     */
    #[link_name = "?writeString@SkWriter32@@QEAAXPEBD_K@Z"]
    pub fn SkWriter32_writeString(this: *mut SkWriter32,
                                  str: *const ::std::os::raw::c_char,
                                  len: usize);
}
extern "C" {
    /**
     *  Computes the size (aligned to multiple of 4) need to write the string
     *  in a call to writeString(). If the length is not specified, it will be
     *  computed by calling strlen().
     */
    #[link_name = "?WriteStringSize@SkWriter32@@SA_KPEBD_K@Z"]
    pub fn SkWriter32_WriteStringSize(str: *const ::std::os::raw::c_char,
                                      len: usize) -> usize;
}
extern "C" {
    /**
     *  Captures a snapshot of the data as it is right now, and return it.
     */
    #[link_name = "?snapshotAsData@SkWriter32@@QEBA?AV?$sk_sp@VSkData@@@@XZ"]
    pub fn SkWriter32_snapshotAsData(this: *const SkWriter32)
     -> sk_sp<SkData>;
}
impl SkWriter32 {
    #[inline]
    pub unsafe fn writeString(&mut self, str: *const ::std::os::raw::c_char,
                              len: usize) {
        SkWriter32_writeString(&mut *self, str, len)
    }
    #[inline]
    pub unsafe fn WriteStringSize(str: *const ::std::os::raw::c_char,
                                  len: usize) -> usize {
        SkWriter32_WriteStringSize(str, len)
    }
    #[inline]
    pub unsafe fn snapshotAsData(&self) -> sk_sp<SkData> {
        SkWriter32_snapshotAsData(&*self)
    }
}
/**
 *  Efficient way to defer allocating/initializing a class until it is needed
 *  (if ever).
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkTLazy<T> {
    pub fStorage: (),
    pub fPtr: *mut T,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkChunkAlloc {
    pub fBlock: *mut SkChunkAlloc_Block,
    pub fMinSize: usize,
    pub fChunkSize: usize,
    pub fTotalCapacity: usize,
    pub fTotalUsed: usize,
    pub fBlockCount: ::std::os::raw::c_int,
    pub fTotalLost: usize,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkChunkAlloc_AllocFailType {
    kReturnNil_AllocFailType = 0,
    kThrow_AllocFailType = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkChunkAlloc_Block {
    pub _address: u8,
}
impl Clone for SkChunkAlloc_Block {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SkChunkAlloc() {
    assert_eq!(::std::mem::size_of::<SkChunkAlloc>() , 56usize);
    assert_eq!(::std::mem::align_of::<SkChunkAlloc>() , 8usize);
}
extern "C" {
    /**
     *  Free up all allocated blocks. This invalidates all returned
     *  pointers.
     */
    #[link_name = "?reset@SkChunkAlloc@@QEAAXXZ"]
    pub fn SkChunkAlloc_reset(this: *mut SkChunkAlloc);
}
extern "C" {
    /**
     *  Reset to 0 used bytes preserving as much memory as possible.
     *  This invalidates all returned pointers.
     */
    #[link_name = "?rewind@SkChunkAlloc@@QEAAXXZ"]
    pub fn SkChunkAlloc_rewind(this: *mut SkChunkAlloc);
}
extern "C" {
    /**
     *  Allocates a memory block of size bytes.
     *  On success: returns a pointer to beginning of memory block that is
     *  8 byte aligned. The content of allocated block is not initialized.
     *  On failure: calls abort() if called with kThrow_AllocFailType,
     *  otherwise returns NULL pointer.
     */
    #[link_name = "?alloc@SkChunkAlloc@@QEAAPEAX_KW4AllocFailType@1@@Z"]
    pub fn SkChunkAlloc_alloc(this: *mut SkChunkAlloc, bytes: usize,
                              arg1: SkChunkAlloc_AllocFailType)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /** Call this to unalloc the most-recently allocated ptr by alloc(). On
        success, the number of bytes freed is returned, or 0 if the block could
        not be unallocated. This is a hint to the underlying allocator that
        the previous allocation may be reused, but the implementation is free
        to ignore this call (and return 0).
     */
    #[link_name = "?unalloc@SkChunkAlloc@@QEAA_KPEAX@Z"]
    pub fn SkChunkAlloc_unalloc(this: *mut SkChunkAlloc,
                                ptr: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    /**
     *  Returns true if the specified address is within one of the chunks, and
     *  has at least 1-byte following the address (i.e. if addr points to the
     *  end of a chunk, then contains() will return false).
     */
    #[link_name = "?contains@SkChunkAlloc@@QEBA_NPEBX@Z"]
    pub fn SkChunkAlloc_contains(this: *const SkChunkAlloc,
                                 addr: *const ::std::os::raw::c_void) -> bool;
}
impl SkChunkAlloc {
    #[inline]
    pub unsafe fn reset(&mut self) { SkChunkAlloc_reset(&mut *self) }
    #[inline]
    pub unsafe fn rewind(&mut self) { SkChunkAlloc_rewind(&mut *self) }
    #[inline]
    pub unsafe fn alloc(&mut self, bytes: usize,
                        arg1: SkChunkAlloc_AllocFailType)
     -> *mut ::std::os::raw::c_void {
        SkChunkAlloc_alloc(&mut *self, bytes, arg1)
    }
    #[inline]
    pub unsafe fn unalloc(&mut self, ptr: *mut ::std::os::raw::c_void)
     -> usize {
        SkChunkAlloc_unalloc(&mut *self, ptr)
    }
    #[inline]
    pub unsafe fn contains(&self, addr: *const ::std::os::raw::c_void)
     -> bool {
        SkChunkAlloc_contains(&*self, addr)
    }
}
/**
 *  Like SkData, SkDataTable holds an immutable data buffer. The data buffer is
 *  organized into a table of entries, each with a length, so the entries are
 *  not required to all be the same size.
 */
#[repr(C)]
pub struct SkDataTable {
    pub _base: SkRefCnt,
    pub fCount: ::std::os::raw::c_int,
    pub fElemSize: usize,
    pub fU: SkDataTable__bindgen_ty_1,
    pub fFreeProc: SkDataTable_FreeProc,
    pub fFreeProcContext: *mut ::std::os::raw::c_void,
}
pub type SkDataTable_FreeProc =
    ::std::option::Option<unsafe extern "C" fn(context:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDataTable_Dir {
    pub fPtr: *const ::std::os::raw::c_void,
    pub fSize: usize,
}
#[test]
fn bindgen_test_layout_SkDataTable_Dir() {
    assert_eq!(::std::mem::size_of::<SkDataTable_Dir>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkDataTable_Dir>() , 8usize);
}
impl Clone for SkDataTable_Dir {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union SkDataTable__bindgen_ty_1 {
    pub fDir: *const SkDataTable_Dir,
    pub fElems: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SkDataTable__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<SkDataTable__bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkDataTable__bindgen_ty_1>() , 8usize);
}
impl Clone for SkDataTable__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub type SkDataTable_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkDataTable() {
    assert_eq!(::std::mem::size_of::<SkDataTable>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkDataTable>() , 1usize);
}
extern "C" {
    /**
     *  Return the size of the index'th entry in the table. The caller must
     *  ensure that index is valid for this table.
     */
    #[link_name = "?atSize@SkDataTable@@QEBA_KH@Z"]
    pub fn SkDataTable_atSize(this: *const SkDataTable,
                              index: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    /**
     *  Return a pointer to the data of the index'th entry in the table.
     *  The caller must ensure that index is valid for this table.
     *
     *  @param size If non-null, this returns the byte size of this entry. This
     *              will be the same value that atSize(index) would return.
     */
    #[link_name = "?at@SkDataTable@@QEBAPEBXHPEA_K@Z"]
    pub fn SkDataTable_at(this: *const SkDataTable,
                          index: ::std::os::raw::c_int, size: *mut usize)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "?MakeEmpty@SkDataTable@@SA?AV?$sk_sp@VSkDataTable@@@@XZ"]
    pub fn SkDataTable_MakeEmpty() -> sk_sp<SkDataTable>;
}
extern "C" {
    /**
     *  Return a new DataTable that contains a copy of the data stored in each
     *  "array".
     *
     *  @param ptrs array of points to each element to be copied into the table.
     *  @param sizes array of byte-lengths for each entry in the corresponding
     *               ptrs[] array.
     *  @param count the number of array elements in ptrs[] and sizes[] to copy.
     */
    #[link_name =
          "?MakeCopyArrays@SkDataTable@@SA?AV?$sk_sp@VSkDataTable@@@@PEBQEBXQEB_KH@Z"]
    pub fn SkDataTable_MakeCopyArrays(ptrs:
                                          *const *const ::std::os::raw::c_void,
                                      sizes: *const usize,
                                      count: ::std::os::raw::c_int)
     -> sk_sp<SkDataTable>;
}
extern "C" {
    /**
     *  Return a new table that contains a copy of the data in array.
     *
     *  @param array contiguous array of data for all elements to be copied.
     *  @param elemSize byte-length for a given element.
     *  @param count the number of entries to be copied out of array. The number
     *               of bytes that will be copied is count * elemSize.
     */
    #[link_name =
          "?MakeCopyArray@SkDataTable@@SA?AV?$sk_sp@VSkDataTable@@@@PEBX_KH@Z"]
    pub fn SkDataTable_MakeCopyArray(array: *const ::std::os::raw::c_void,
                                     elemSize: usize,
                                     count: ::std::os::raw::c_int)
     -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name =
          "?MakeArrayProc@SkDataTable@@SA?AV?$sk_sp@VSkDataTable@@@@PEBX_KHP6AXPEAX@Z2@Z"]
    pub fn SkDataTable_MakeArrayProc(array: *const ::std::os::raw::c_void,
                                     elemSize: usize,
                                     count: ::std::os::raw::c_int,
                                     proc_: SkDataTable_FreeProc,
                                     context: *mut ::std::os::raw::c_void)
     -> sk_sp<SkDataTable>;
}
impl SkDataTable {
    #[inline]
    pub unsafe fn atSize(&self, index: ::std::os::raw::c_int) -> usize {
        SkDataTable_atSize(&*self, index)
    }
    #[inline]
    pub unsafe fn at(&self, index: ::std::os::raw::c_int, size: *mut usize)
     -> *const ::std::os::raw::c_void {
        SkDataTable_at(&*self, index, size)
    }
    #[inline]
    pub unsafe fn MakeEmpty() -> sk_sp<SkDataTable> {
        SkDataTable_MakeEmpty()
    }
    #[inline]
    pub unsafe fn MakeCopyArrays(ptrs: *const *const ::std::os::raw::c_void,
                                 sizes: *const usize,
                                 count: ::std::os::raw::c_int)
     -> sk_sp<SkDataTable> {
        SkDataTable_MakeCopyArrays(ptrs, sizes, count)
    }
    #[inline]
    pub unsafe fn MakeCopyArray(array: *const ::std::os::raw::c_void,
                                elemSize: usize, count: ::std::os::raw::c_int)
     -> sk_sp<SkDataTable> {
        SkDataTable_MakeCopyArray(array, elemSize, count)
    }
    #[inline]
    pub unsafe fn MakeArrayProc(array: *const ::std::os::raw::c_void,
                                elemSize: usize, count: ::std::os::raw::c_int,
                                proc_: SkDataTable_FreeProc,
                                context: *mut ::std::os::raw::c_void)
     -> sk_sp<SkDataTable> {
        SkDataTable_MakeArrayProc(array, elemSize, count, proc_, context)
    }
}
/**
 *  Helper class that allows for incrementally building up the data needed to
 *  create a SkDataTable.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkDataTableBuilder {
    pub fDir: SkTDArray<SkDataTable_Dir>,
    pub fHeap: *mut SkChunkAlloc,
    pub fMinChunkSize: usize,
}
#[test]
fn bindgen_test_layout_SkDataTableBuilder() {
    assert_eq!(::std::mem::size_of::<SkDataTableBuilder>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkDataTableBuilder>() , 1usize);
}
extern "C" {
    /**
     *  Forget any previously appended entries, setting count() back to 0.
     */
    #[link_name = "?reset@SkDataTableBuilder@@QEAAX_K@Z"]
    pub fn SkDataTableBuilder_reset(this: *mut SkDataTableBuilder,
                                    minChunkSize: usize);
}
extern "C" {
    /**
     *  Copy size-bytes from data, and append it to the growing SkDataTable.
     */
    #[link_name = "?append@SkDataTableBuilder@@QEAAXPEBX_K@Z"]
    pub fn SkDataTableBuilder_append(this: *mut SkDataTableBuilder,
                                     data: *const ::std::os::raw::c_void,
                                     size: usize);
}
extern "C" {
    /**
     *  Return an SkDataTable from the accumulated entries that were added by
     *  calls to append(). This call also clears any accumluated entries from
     *  this builder, so its count() will be 0 after this call.
     */
    #[link_name =
          "?detachDataTable@SkDataTableBuilder@@QEAA?AV?$sk_sp@VSkDataTable@@@@XZ"]
    pub fn SkDataTableBuilder_detachDataTable(this: *mut SkDataTableBuilder)
     -> sk_sp<SkDataTable>;
}
impl SkDataTableBuilder {
    #[inline]
    pub unsafe fn reset(&mut self, minChunkSize: usize) {
        SkDataTableBuilder_reset(&mut *self, minChunkSize)
    }
    #[inline]
    pub unsafe fn append(&mut self, data: *const ::std::os::raw::c_void,
                         size: usize) {
        SkDataTableBuilder_append(&mut *self, data, size)
    }
    #[inline]
    pub unsafe fn detachDataTable(&mut self) -> sk_sp<SkDataTable> {
        SkDataTableBuilder_detachDataTable(&mut *self)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkImageDeserializer {
    pub _address: u8,
}
impl Clone for SkImageDeserializer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRefCntSet {
    pub _address: u8,
}
impl Clone for SkRefCntSet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPictInfo {
    pub _address: u8,
}
impl Clone for SkPictInfo {
    fn clone(&self) -> Self { *self }
}
/** \class SkTime
    Platform-implemented utilities to return time of day, and millisecond counter.
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkTime {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkTime_DateTime {
    pub fTimeZoneMinutes: i16,
    //< e.g. 2005
    pub fYear: u16,
    //< 1..12
    pub fMonth: u8,
    //< 0..6, 0==Sunday
    pub fDayOfWeek: u8,
    //< 1..31
    pub fDay: u8,
    //< 0..23
    pub fHour: u8,
    //< 0..59
    pub fMinute: u8,
    //< 0..59
    pub fSecond: u8,
}
#[test]
fn bindgen_test_layout_SkTime_DateTime() {
    assert_eq!(::std::mem::size_of::<SkTime_DateTime>() , 10usize);
    assert_eq!(::std::mem::align_of::<SkTime_DateTime>() , 2usize);
}
extern "C" {
    #[link_name = "?toISO8601@DateTime@SkTime@@QEBAXPEAVSkString@@@Z"]
    pub fn SkTime_DateTime_toISO8601(this: *const SkTime_DateTime,
                                     dst: *mut SkString);
}
impl Clone for SkTime_DateTime {
    fn clone(&self) -> Self { *self }
}
impl SkTime_DateTime {
    #[inline]
    pub unsafe fn toISO8601(&self, dst: *mut SkString) {
        SkTime_DateTime_toISO8601(&*self, dst)
    }
}
#[test]
fn bindgen_test_layout_SkTime() {
    assert_eq!(::std::mem::size_of::<SkTime>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkTime>() , 1usize);
}
extern "C" {
    #[link_name = "?GetDateTime@SkTime@@SAXPEAUDateTime@1@@Z"]
    pub fn SkTime_GetDateTime(arg1: *mut SkTime_DateTime);
}
extern "C" {
    #[link_name = "?GetNSecs@SkTime@@SANXZ"]
    pub fn SkTime_GetNSecs() -> f64;
}
impl Clone for SkTime {
    fn clone(&self) -> Self { *self }
}
impl SkTime {
    #[inline]
    pub unsafe fn GetDateTime(arg1: *mut SkTime_DateTime) {
        SkTime_GetDateTime(arg1)
    }
    #[inline]
    pub unsafe fn GetNSecs() -> f64 { SkTime_GetNSecs() }
}
/**
 *  High-level API for creating a document-based canvas. To use..
 *
 *  1. Create a document, specifying a stream to store the output.
 *  2. For each "page" of content:
 *      a. canvas = doc->beginPage(...)
 *      b. draw_my_content(canvas);
 *      c. doc->endPage();
 *  3. Close the document with doc->close().
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkDocument {
    pub _base: SkRefCnt,
    pub fStream: *mut SkWStream,
    pub fDoneProc: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut SkWStream,
                                                              aborted: bool)>,
    pub fState: SkDocument_State,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDocument_OptionalTimestamp {
    pub fDateTime: SkTime_DateTime,
    pub fEnabled: bool,
}
#[test]
fn bindgen_test_layout_SkDocument_OptionalTimestamp() {
    assert_eq!(::std::mem::size_of::<SkDocument_OptionalTimestamp>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<SkDocument_OptionalTimestamp>() ,
               2usize);
}
impl Clone for SkDocument_OptionalTimestamp {
    fn clone(&self) -> Self { *self }
}
/**
     *  Optional metadata to be passed into the PDF factory function.
     */
#[repr(C)]
#[derive(Debug)]
pub struct SkDocument_PDFMetadata {
    /**
         * The documents title.
         */
    pub fTitle: SkString,
    /**
         * The name of the person who created the document.
         */
    pub fAuthor: SkString,
    /**
         * The subject of the document.
         */
    pub fSubject: SkString,
    /**
         * Keywords associated with the document.  Commas may be used
         * to delineate keywords within the string.
         */
    pub fKeywords: SkString,
    /**
         * If the document was converted to PDF from another format,
         * the name of the conforming product that created the
         * original document from which it was converted.
         */
    pub fCreator: SkString,
    /**
         * The product that is converting this document to PDF.
         *
         * Leave fProducer empty to get the default, correct value.
         */
    pub fProducer: SkString,
    /**
         * The date and time the document was created.
         */
    pub fCreation: SkDocument_OptionalTimestamp,
    /**
         * The date and time the document was most recently modified.
         */
    pub fModified: SkDocument_OptionalTimestamp,
}
#[test]
fn bindgen_test_layout_SkDocument_PDFMetadata() {
    assert_eq!(::std::mem::size_of::<SkDocument_PDFMetadata>() , 72usize);
    assert_eq!(::std::mem::align_of::<SkDocument_PDFMetadata>() , 8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkDocument_State {
    kBetweenPages_State = 0,
    kInPage_State = 1,
    kClosed_State = 2,
}
pub type SkDocument_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkDocument() {
    assert_eq!(::std::mem::size_of::<SkDocument>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkDocument>() , 1usize);
}
extern "C" {
    /**
     *  Create a PDF-backed document, writing the results into a
     *  SkWStream.
     *
     *  PDF pages are sized in point units. 1 pt == 1/72 inch ==
     *  127/360 mm.
     *
     *  @param stream A PDF document will be written to this
     *         stream.  The document may write to the stream at
     *         anytime during its lifetime, until either close() is
     *         called or the document is deleted.
     *  @param dpi The DPI (pixels-per-inch) at which features without
     *         native PDF support will be rasterized (e.g. draw image
     *         with perspective, draw text with perspective)  A
     *         larger DPI would create a PDF that reflects the
     *         original intent with better fidelity, but it can make
     *         for larger PDF files too, which would use more memory
     *         while rendering, and it would be slower to be processed
     *         or sent online or to printer.
     *  @param metadata a PDFmetadata object.  Any fields may be left
     *         empty.
     *  @param jpegEncoder For PDF documents, if a jpegEncoder is set,
     *         use it to encode SkImages and SkBitmaps as [JFIF]JPEGs.
     *         This feature is deprecated and is only supplied for
     *         backwards compatability.
     *         The prefered method to create PDFs with JPEG images is
     *         to use SkImage::NewFromEncoded() and not jpegEncoder.
     *         Chromium uses NewFromEncoded.
     *         If the encoder is unset, or if jpegEncoder->onEncode()
     *         returns NULL, fall back on encoding images losslessly
     *         with Deflate.
     *  @param pdfa Iff true, include XMP metadata, a document UUID,
     *         and sRGB output intent information.  This adds length
     *         to the document and makes it non-reproducable, but are
     *         necessary features for PDF/A-2b conformance
     *
     *  @returns NULL if there is an error, otherwise a newly created
     *           PDF-backed SkDocument.
     */
    #[link_name =
          "?MakePDF@SkDocument@@SA?AV?$sk_sp@VSkDocument@@@@PEAVSkWStream@@MAEBUPDFMetadata@1@V?$sk_sp@VSkPixelSerializer@@@@_N@Z"]
    pub fn SkDocument_MakePDF(stream: *mut SkWStream, dpi: SkScalar,
                              metadata: *const SkDocument_PDFMetadata,
                              jpegEncoder: sk_sp<SkPixelSerializer>,
                              pdfa: bool) -> sk_sp<SkDocument>;
}
extern "C" {
    /**
     *  Create a PDF-backed document, writing the results into a file.
     */
    #[link_name = "?MakePDF@SkDocument@@SA?AV?$sk_sp@VSkDocument@@@@QEBDM@Z"]
    pub fn SkDocument_MakePDF1(outputFilePath: *const ::std::os::raw::c_char,
                               dpi: SkScalar) -> sk_sp<SkDocument>;
}
extern "C" {
    /**
     *  Create a XPS-backed document, writing the results into the stream.
     *  Returns NULL if XPS is not supported.
     */
    #[link_name =
          "?MakeXPS@SkDocument@@SA?AV?$sk_sp@VSkDocument@@@@PEAVSkWStream@@M@Z"]
    pub fn SkDocument_MakeXPS(stream: *mut SkWStream, dpi: SkScalar)
     -> sk_sp<SkDocument>;
}
extern "C" {
    /**
     *  Create a XPS-backed document, writing the results into a file.
     *  Returns NULL if XPS is not supported.
     */
    #[link_name = "?MakeXPS@SkDocument@@SA?AV?$sk_sp@VSkDocument@@@@QEBDM@Z"]
    pub fn SkDocument_MakeXPS1(path: *const ::std::os::raw::c_char,
                               dpi: SkScalar) -> sk_sp<SkDocument>;
}
extern "C" {
    /**
     *  Begin a new page for the document, returning the canvas that will draw
     *  into the page. The document owns this canvas, and it will go out of
     *  scope when endPage() or close() is called, or the document is deleted.
     */
    #[link_name = "?beginPage@SkDocument@@QEAAPEAVSkCanvas@@MMPEBUSkRect@@@Z"]
    pub fn SkDocument_beginPage(this: *mut SkDocument, width: SkScalar,
                                height: SkScalar, content: *const SkRect)
     -> *mut SkCanvas;
}
extern "C" {
    /**
     *  Call endPage() when the content for the current page has been drawn
     *  (into the canvas returned by beginPage()). After this call the canvas
     *  returned by beginPage() will be out-of-scope.
     */
    #[link_name = "?endPage@SkDocument@@QEAAXXZ"]
    pub fn SkDocument_endPage(this: *mut SkDocument);
}
extern "C" {
    /**
     *  Call close() when all pages have been drawn. This will close the file
     *  or stream holding the document's contents. After close() the document
     *  can no longer add new pages. Deleting the document will automatically
     *  call close() if need be.
     */
    #[link_name = "?close@SkDocument@@QEAAXXZ"]
    pub fn SkDocument_close(this: *mut SkDocument);
}
extern "C" {
    /**
     *  Call abort() to stop producing the document immediately.
     *  The stream output must be ignored, and should not be trusted.
     */
    #[link_name = "?abort@SkDocument@@QEAAXXZ"]
    pub fn SkDocument_abort(this: *mut SkDocument);
}
impl SkDocument {
    #[inline]
    pub unsafe fn MakePDF(stream: *mut SkWStream, dpi: SkScalar,
                          metadata: *const SkDocument_PDFMetadata,
                          jpegEncoder: sk_sp<SkPixelSerializer>, pdfa: bool)
     -> sk_sp<SkDocument> {
        SkDocument_MakePDF(stream, dpi, metadata, jpegEncoder, pdfa)
    }
    #[inline]
    pub unsafe fn MakePDF1(outputFilePath: *const ::std::os::raw::c_char,
                           dpi: SkScalar) -> sk_sp<SkDocument> {
        SkDocument_MakePDF1(outputFilePath, dpi)
    }
    #[inline]
    pub unsafe fn MakeXPS(stream: *mut SkWStream, dpi: SkScalar)
     -> sk_sp<SkDocument> {
        SkDocument_MakeXPS(stream, dpi)
    }
    #[inline]
    pub unsafe fn MakeXPS1(path: *const ::std::os::raw::c_char, dpi: SkScalar)
     -> sk_sp<SkDocument> {
        SkDocument_MakeXPS1(path, dpi)
    }
    #[inline]
    pub unsafe fn beginPage(&mut self, width: SkScalar, height: SkScalar,
                            content: *const SkRect) -> *mut SkCanvas {
        SkDocument_beginPage(&mut *self, width, height, content)
    }
    #[inline]
    pub unsafe fn endPage(&mut self) { SkDocument_endPage(&mut *self) }
    #[inline]
    pub unsafe fn close(&mut self) { SkDocument_close(&mut *self) }
    #[inline]
    pub unsafe fn abort(&mut self) { SkDocument_abort(&mut *self) }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkStrokeRec {
    pub fResScale: SkScalar,
    pub fWidth: SkScalar,
    pub fMiterLimit: SkScalar,
    pub _bitfield_1: u32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkStrokeRec_Style {
    kHairline_Style = 0,
    kFill_Style = 1,
    kStroke_Style = 2,
    kStrokeAndFill_Style = 3,
}
pub const SkStrokeRec_kStyleCount: SkStrokeRec__bindgen_ty_1 =
    SkStrokeRec__bindgen_ty_1::kStyleCount;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkStrokeRec__bindgen_ty_1 { kStyleCount = 4, }
#[test]
fn bindgen_test_layout_SkStrokeRec() {
    assert_eq!(::std::mem::size_of::<SkStrokeRec>() , 16usize);
    assert_eq!(::std::mem::align_of::<SkStrokeRec>() , 4usize);
}
extern "C" {
    #[link_name = "?getStyle@SkStrokeRec@@QEBA?AW4Style@1@XZ"]
    pub fn SkStrokeRec_getStyle(this: *const SkStrokeRec)
     -> SkStrokeRec_Style;
}
extern "C" {
    #[link_name = "?setFillStyle@SkStrokeRec@@QEAAXXZ"]
    pub fn SkStrokeRec_setFillStyle(this: *mut SkStrokeRec);
}
extern "C" {
    #[link_name = "?setHairlineStyle@SkStrokeRec@@QEAAXXZ"]
    pub fn SkStrokeRec_setHairlineStyle(this: *mut SkStrokeRec);
}
extern "C" {
    /**
     *  Specify the strokewidth, and optionally if you want stroke + fill.
     *  Note, if width==0, then this request is taken to mean:
     *      strokeAndFill==true -> new style will be Fill
     *      strokeAndFill==false -> new style will be Hairline
     */
    #[link_name = "?setStrokeStyle@SkStrokeRec@@QEAAXM_N@Z"]
    pub fn SkStrokeRec_setStrokeStyle(this: *mut SkStrokeRec, width: SkScalar,
                                      strokeAndFill: bool);
}
extern "C" {
    /**
     *  Apply these stroke parameters to the src path, returning the result
     *  in dst.
     *
     *  If there was no change (i.e. style == hairline or fill) this returns
     *  false and dst is unchanged. Otherwise returns true and the result is
     *  stored in dst.
     *
     *  src and dst may be the same path.
     */
    #[link_name = "?applyToPath@SkStrokeRec@@QEBA_NPEAVSkPath@@AEBV2@@Z"]
    pub fn SkStrokeRec_applyToPath(this: *const SkStrokeRec, dst: *mut SkPath,
                                   src: *const SkPath) -> bool;
}
extern "C" {
    /**
     *  Apply these stroke parameters to a paint.
     */
    #[link_name = "?applyToPaint@SkStrokeRec@@QEBAXPEAVSkPaint@@@Z"]
    pub fn SkStrokeRec_applyToPaint(this: *const SkStrokeRec,
                                    paint: *mut SkPaint);
}
extern "C" {
    /**
     * Gives a conservative value for the outset that should applied to a
     * geometries bounds to account for any inflation due to applying this
     * strokeRec to the geometry.
     */
    #[link_name = "?getInflationRadius@SkStrokeRec@@QEBAMXZ"]
    pub fn SkStrokeRec_getInflationRadius(this: *const SkStrokeRec)
     -> SkScalar;
}
extern "C" {
    /**
     * Equivalent to:
     *   SkStrokeRec rec(paint, style);
     *   rec.getInflationRadius();
     * This does not account for other effects on the paint (i.e. path
     * effect).
     */
    #[link_name =
          "?GetInflationRadius@SkStrokeRec@@SAMAEBVSkPaint@@W4Style@2@@Z"]
    pub fn SkStrokeRec_GetInflationRadius(arg1: *const SkPaint,
                                          arg2: SkPaint_Style) -> SkScalar;
}
impl Clone for SkStrokeRec {
    fn clone(&self) -> Self { *self }
}
impl SkStrokeRec {
    #[inline]
    pub fn fCap(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65535usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_fCap(&mut self, val: u32) {
        self._bitfield_1 &= !(65535usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (65535usize as u32);
    }
    #[inline]
    pub fn fJoin(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147418112usize as u32)) >> 16u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_fJoin(&mut self, val: u32) {
        self._bitfield_1 &= !(2147418112usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (2147418112usize as u32);
    }
    #[inline]
    pub fn fStrokeAndFill(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147483648usize as u32)) >> 31u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_fStrokeAndFill(&mut self, val: u32) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
    #[inline]
    pub unsafe fn getStyle(&self) -> SkStrokeRec_Style {
        SkStrokeRec_getStyle(&*self)
    }
    #[inline]
    pub unsafe fn setFillStyle(&mut self) {
        SkStrokeRec_setFillStyle(&mut *self)
    }
    #[inline]
    pub unsafe fn setHairlineStyle(&mut self) {
        SkStrokeRec_setHairlineStyle(&mut *self)
    }
    #[inline]
    pub unsafe fn setStrokeStyle(&mut self, width: SkScalar,
                                 strokeAndFill: bool) {
        SkStrokeRec_setStrokeStyle(&mut *self, width, strokeAndFill)
    }
    #[inline]
    pub unsafe fn applyToPath(&self, dst: *mut SkPath, src: *const SkPath)
     -> bool {
        SkStrokeRec_applyToPath(&*self, dst, src)
    }
    #[inline]
    pub unsafe fn applyToPaint(&self, paint: *mut SkPaint) {
        SkStrokeRec_applyToPaint(&*self, paint)
    }
    #[inline]
    pub unsafe fn getInflationRadius(&self) -> SkScalar {
        SkStrokeRec_getInflationRadius(&*self)
    }
    #[inline]
    pub unsafe fn GetInflationRadius(arg1: *const SkPaint,
                                     arg2: SkPaint_Style) -> SkScalar {
        SkStrokeRec_GetInflationRadius(arg1, arg2)
    }
}
extern "C" {
    #[link_name =
          "?SkValidatingSerializeFlattenable@@YAPEAVSkData@@PEAVSkFlattenable@@@Z"]
    pub fn SkValidatingSerializeFlattenable(arg1: *mut SkFlattenable)
     -> *mut SkData;
}
extern "C" {
    #[link_name =
          "?SkValidatingDeserializeFlattenable@@YAPEAVSkFlattenable@@PEBX_KW4Type@1@@Z"]
    pub fn SkValidatingDeserializeFlattenable(data:
                                                  *const ::std::os::raw::c_void,
                                              size: usize,
                                              type_: SkFlattenable_Type)
     -> *mut SkFlattenable;
}
extern "C" {
    #[link_name =
          "?SkValidatingDeserializeImageFilter@@YA?AV?$sk_sp@VSkImageFilter@@@@PEBX_K@Z"]
    pub fn SkValidatingDeserializeImageFilter(data:
                                                  *const ::std::os::raw::c_void,
                                              size: usize)
     -> sk_sp<SkImageFilter>;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkTextEncoding {
    kUTF8_SkTextEncoding = 0,
    kUTF16_SkTextEncoding = 1,
    kUTF32_SkTextEncoding = 2,
    kGlyphID_SkTextEncoding = 3,
}
#[repr(C)]
pub struct SkFont {
    pub _base: SkRefCnt,
    pub fTypeface: sk_sp<SkTypeface>,
    pub fSize: SkScalar,
    pub fScaleX: SkScalar,
    pub fSkewX: SkScalar,
    pub fFlags: u16,
    pub fMaskType: u8,
}
pub const SkFont_Flags_kEnableAutoHints_Flag: SkFont_Flags = SkFont_Flags(1);
pub const SkFont_Flags_kEnableByteCodeHints_Flag: SkFont_Flags =
    SkFont_Flags(2);
pub const SkFont_Flags_kEmbeddedBitmaps_Flag: SkFont_Flags = SkFont_Flags(4);
pub const SkFont_Flags_kUseNonlinearMetrics_Flag: SkFont_Flags =
    SkFont_Flags(8);
pub const SkFont_Flags_kVertical_Flag: SkFont_Flags = SkFont_Flags(16);
pub const SkFont_Flags_kGenA8FromLCD_Flag: SkFont_Flags = SkFont_Flags(32);
pub const SkFont_Flags_kEmbolden_Flag: SkFont_Flags = SkFont_Flags(64);
pub const SkFont_Flags_kDevKern_Flag: SkFont_Flags = SkFont_Flags(128);
impl ::std::ops::BitOr<SkFont_Flags> for SkFont_Flags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { SkFont_Flags(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkFont_Flags(pub i32);
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkFont_MaskType {
    kBW_MaskType = 0,
    kA8_MaskType = 1,
    kLCD_MaskType = 2,
}
pub const SkFont_kAllFlags: SkFont__bindgen_ty_1 =
    SkFont__bindgen_ty_1::kAllFlags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkFont__bindgen_ty_1 { kAllFlags = 255, }
#[test]
fn bindgen_test_layout_SkFont() {
    assert_eq!(::std::mem::size_of::<SkFont>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkFont>() , 1usize);
}
extern "C" {
    #[link_name =
          "?Make@SkFont@@SA?AV?$sk_sp@VSkFont@@@@V?$sk_sp@VSkTypeface@@@@MW4MaskType@1@I@Z"]
    pub fn SkFont_Make(arg1: sk_sp<SkTypeface>, size: SkScalar,
                       arg2: SkFont_MaskType, flags: u32) -> sk_sp<SkFont>;
}
extern "C" {
    #[link_name =
          "?Make@SkFont@@SA?AV?$sk_sp@VSkFont@@@@V?$sk_sp@VSkTypeface@@@@MMMW4MaskType@1@I@Z"]
    pub fn SkFont_Make1(arg1: sk_sp<SkTypeface>, size: SkScalar,
                        scaleX: SkScalar, skewX: SkScalar,
                        arg2: SkFont_MaskType, flags: u32) -> sk_sp<SkFont>;
}
extern "C" {
    /**
     *  Return a font with the same attributes of this font, but with the specified size.
     *  If size is not supported (e.g. <= 0 or non-finite) NULL will be returned.
     */
    #[link_name = "?makeWithSize@SkFont@@QEBA?AV?$sk_sp@VSkFont@@@@M@Z"]
    pub fn SkFont_makeWithSize(this: *const SkFont, size: SkScalar)
     -> sk_sp<SkFont>;
}
extern "C" {
    /**
     *  Return a font with the same attributes of this font, but with the flags.
     */
    #[link_name = "?makeWithFlags@SkFont@@QEBA?AV?$sk_sp@VSkFont@@@@I@Z"]
    pub fn SkFont_makeWithFlags(this: *const SkFont, newFlags: u32)
     -> sk_sp<SkFont>;
}
extern "C" {
    #[link_name =
          "?textToGlyphs@SkFont@@QEBAHPEBX_KW4SkTextEncoding@@QEAGH@Z"]
    pub fn SkFont_textToGlyphs(this: *const SkFont,
                               text: *const ::std::os::raw::c_void,
                               byteLength: usize, arg1: SkTextEncoding,
                               glyphs: *mut SkGlyphID,
                               maxGlyphCount: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "?measureText@SkFont@@QEBAMPEBX_KW4SkTextEncoding@@@Z"]
    pub fn SkFont_measureText(this: *const SkFont,
                              text: *const ::std::os::raw::c_void,
                              byteLength: usize, arg1: SkTextEncoding)
     -> SkScalar;
}
extern "C" {
    #[link_name =
          "?Testing_CreateFromPaint@SkFont@@SA?AV?$sk_sp@VSkFont@@@@AEBVSkPaint@@@Z"]
    pub fn SkFont_Testing_CreateFromPaint(arg1: *const SkPaint)
     -> sk_sp<SkFont>;
}
impl SkFont {
    #[inline]
    pub unsafe fn Make(arg1: sk_sp<SkTypeface>, size: SkScalar,
                       arg2: SkFont_MaskType, flags: u32) -> sk_sp<SkFont> {
        SkFont_Make(arg1, size, arg2, flags)
    }
    #[inline]
    pub unsafe fn Make1(arg1: sk_sp<SkTypeface>, size: SkScalar,
                        scaleX: SkScalar, skewX: SkScalar,
                        arg2: SkFont_MaskType, flags: u32) -> sk_sp<SkFont> {
        SkFont_Make1(arg1, size, scaleX, skewX, arg2, flags)
    }
    #[inline]
    pub unsafe fn makeWithSize(&self, size: SkScalar) -> sk_sp<SkFont> {
        SkFont_makeWithSize(&*self, size)
    }
    #[inline]
    pub unsafe fn makeWithFlags(&self, newFlags: u32) -> sk_sp<SkFont> {
        SkFont_makeWithFlags(&*self, newFlags)
    }
    #[inline]
    pub unsafe fn textToGlyphs(&self, text: *const ::std::os::raw::c_void,
                               byteLength: usize, arg1: SkTextEncoding,
                               glyphs: *mut SkGlyphID,
                               maxGlyphCount: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int {
        SkFont_textToGlyphs(&*self, text, byteLength, arg1, glyphs,
                            maxGlyphCount)
    }
    #[inline]
    pub unsafe fn measureText(&self, text: *const ::std::os::raw::c_void,
                              byteLength: usize, arg1: SkTextEncoding)
     -> SkScalar {
        SkFont_measureText(&*self, text, byteLength, arg1)
    }
    #[inline]
    pub unsafe fn Testing_CreateFromPaint(arg1: *const SkPaint)
     -> sk_sp<SkFont> {
        SkFont_Testing_CreateFromPaint(arg1)
    }
}
#[repr(C)]
pub struct SkTraceMemoryDump__bindgen_vtable {
}
/**
 * Interface for memory tracing.
 * This interface is meant to be passed as argument to the memory dump methods of Skia objects.
 * The implementation of this interface is provided by the embedder.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkTraceMemoryDump {
    pub vtable_: *const SkTraceMemoryDump__bindgen_vtable,
}
#[repr(i32)]
/**
     * Enum to specify the level of the requested details for the dump from the Skia objects.
     */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkTraceMemoryDump_LevelOfDetail {
    kLight_LevelOfDetail = 0,
    kObjectsBreakdowns_LevelOfDetail = 1,
}
#[test]
fn bindgen_test_layout_SkTraceMemoryDump() {
    assert_eq!(::std::mem::size_of::<SkTraceMemoryDump>() , 8usize);
    assert_eq!(::std::mem::align_of::<SkTraceMemoryDump>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBaseSemaphore {
    pub fCount: std_atomic<::std::os::raw::c_int>,
    pub fOSSemaphoreOnce: SkOnce,
    pub fOSSemaphore: *mut SkBaseSemaphore_OSSemaphore,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkBaseSemaphore_OSSemaphore {
    pub _address: u8,
}
impl Clone for SkBaseSemaphore_OSSemaphore {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SkBaseSemaphore() {
    assert_eq!(::std::mem::size_of::<SkBaseSemaphore>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkBaseSemaphore>() , 1usize);
}
extern "C" {
    #[link_name = "?signal@SkBaseSemaphore@@QEAAXH@Z"]
    pub fn SkBaseSemaphore_signal(this: *mut SkBaseSemaphore,
                                  n: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "?wait@SkBaseSemaphore@@QEAAXXZ"]
    pub fn SkBaseSemaphore_wait(this: *mut SkBaseSemaphore);
}
extern "C" {
    #[link_name = "?cleanup@SkBaseSemaphore@@QEAAXXZ"]
    pub fn SkBaseSemaphore_cleanup(this: *mut SkBaseSemaphore);
}
impl SkBaseSemaphore {
    #[inline]
    pub unsafe fn signal(&mut self, n: ::std::os::raw::c_int) {
        SkBaseSemaphore_signal(&mut *self, n)
    }
    #[inline]
    pub unsafe fn wait(&mut self) { SkBaseSemaphore_wait(&mut *self) }
    #[inline]
    pub unsafe fn cleanup(&mut self) { SkBaseSemaphore_cleanup(&mut *self) }
}
pub type SkThreadID = i64;
extern "C" {
    #[link_name = "?SkGetThreadID@@YA_JXZ"]
    pub fn SkGetThreadID() -> SkThreadID;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBaseMutex {
    pub fSemaphore: SkBaseSemaphore,
    pub fOwner: SkThreadID,
}
#[test]
fn bindgen_test_layout_SkBaseMutex() {
    assert_eq!(::std::mem::size_of::<SkBaseMutex>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkBaseMutex>() , 1usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkMutex {
    pub _base: SkBaseMutex,
}
#[test]
fn bindgen_test_layout_SkMutex() {
    assert_eq!(::std::mem::size_of::<SkMutex>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkMutex>() , 1usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkYUVSizeInfo {
    pub fSizes: [SkISize; 3usize],
    /**
     * While the widths of the Y, U, and V planes are not restricted, the
     * implementation often requires that the width of the memory allocated
     * for each plane be a multiple of 8.
     *
     * This struct allows us to inform the client how many "widthBytes"
     * that we need.  Note that we use the new idea of "widthBytes"
     * because this idea is distinct from "rowBytes" (used elsewhere in
     * Skia).  "rowBytes" allow the last row of the allocation to not
     * include any extra padding, while, in this case, every single row of
     * the allocation must be at least "widthBytes".
     */
    pub fWidthBytes: [usize; 3usize],
}
pub const SkYUVSizeInfo_kY: SkYUVSizeInfo__bindgen_ty_1 =
    SkYUVSizeInfo__bindgen_ty_1::kY;
pub const SkYUVSizeInfo_kU: SkYUVSizeInfo__bindgen_ty_1 =
    SkYUVSizeInfo__bindgen_ty_1::kU;
pub const SkYUVSizeInfo_kV: SkYUVSizeInfo__bindgen_ty_1 =
    SkYUVSizeInfo__bindgen_ty_1::kV;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkYUVSizeInfo__bindgen_ty_1 { kY = 0, kU = 1, kV = 2, }
#[test]
fn bindgen_test_layout_SkYUVSizeInfo() {
    assert_eq!(::std::mem::size_of::<SkYUVSizeInfo>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkYUVSizeInfo>() , 1usize);
}
impl Clone for SkYUVSizeInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDiscardableMemory {
    pub _address: u8,
}
impl Clone for SkDiscardableMemory {
    fn clone(&self) -> Self { *self }
}
/** We explicitly use the same allocator for our pixels that SkMask does,
    so that we can freely assign memory allocated by one class to the other.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkMallocPixelRef {
    pub _base: SkPixelRef,
    pub fStorage: *mut ::std::os::raw::c_void,
    pub fCTable: *mut SkColorTable,
    pub fRB: usize,
    pub fReleaseProc: SkMallocPixelRef_ReleaseProc,
    pub fReleaseProcContext: *mut ::std::os::raw::c_void,
}
/**
     *  Return a new SkMallocPixelRef with the provided pixel storage,
     *  rowBytes, and optional colortable. On destruction, ReleaseProc
     *  will be called.
     *
     *  This pixelref will ref() the specified colortable (if not NULL).
     *
     *  If ReleaseProc is NULL, the pixels will never be released. This
     *  can be useful if the pixels were stack allocated. However, such an
     *  SkMallocPixelRef must not live beyond its pixels (e.g. by copying
     *  an SkBitmap pointing to it, or drawing to an SkPicture).
     *
     *  Returns NULL on failure.
     */
pub type SkMallocPixelRef_ReleaseProc =
    ::std::option::Option<unsafe extern "C" fn(addr:
                                                   *mut ::std::os::raw::c_void,
                                               context:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct SkMallocPixelRef_PRFactory {
    pub _base: SkPixelRefFactory,
}
#[test]
fn bindgen_test_layout_SkMallocPixelRef_PRFactory() {
    assert_eq!(::std::mem::size_of::<SkMallocPixelRef_PRFactory>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkMallocPixelRef_PRFactory>() , 1usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkMallocPixelRef_ZeroedPRFactory {
    pub _base: SkPixelRefFactory,
}
#[test]
fn bindgen_test_layout_SkMallocPixelRef_ZeroedPRFactory() {
    assert_eq!(::std::mem::size_of::<SkMallocPixelRef_ZeroedPRFactory>() ,
               1usize);
    assert_eq!(::std::mem::align_of::<SkMallocPixelRef_ZeroedPRFactory>() ,
               1usize);
}
pub type SkMallocPixelRef_INHERITED = SkPixelRef;
#[test]
fn bindgen_test_layout_SkMallocPixelRef() {
    assert_eq!(::std::mem::size_of::<SkMallocPixelRef>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkMallocPixelRef>() , 1usize);
}
extern "C" {
    /**
     *  Return a new SkMallocPixelRef with the provided pixel storage, rowBytes,
     *  and optional colortable. The caller is responsible for managing the
     *  lifetime of the pixel storage buffer, as this pixelref will not try
     *  to delete it.
     *
     *  The pixelref will ref() the colortable (if not NULL).
     *
     *  Returns NULL on failure.
     */
    #[link_name =
          "?NewDirect@SkMallocPixelRef@@SAPEAV1@AEBUSkImageInfo@@PEAX_KPEAVSkColorTable@@@Z"]
    pub fn SkMallocPixelRef_NewDirect(arg1: *const SkImageInfo,
                                      addr: *mut ::std::os::raw::c_void,
                                      rowBytes: usize,
                                      arg2: *mut SkColorTable)
     -> *mut SkMallocPixelRef;
}
extern "C" {
    /**
     *  Return a new SkMallocPixelRef, automatically allocating storage for the
     *  pixels. If rowBytes are 0, an optimal value will be chosen automatically.
     *  If rowBytes is > 0, then it will be respected, or NULL will be returned
     *  if rowBytes is invalid for the specified info.
     *
     *  This pixelref will ref() the specified colortable (if not NULL).
     *
     *  Returns NULL on failure.
     */
    #[link_name =
          "?NewAllocate@SkMallocPixelRef@@SAPEAV1@AEBUSkImageInfo@@_KPEAVSkColorTable@@@Z"]
    pub fn SkMallocPixelRef_NewAllocate(info: *const SkImageInfo,
                                        rowBytes: usize,
                                        arg1: *mut SkColorTable)
     -> *mut SkMallocPixelRef;
}
extern "C" {
    /**
     *  Identical to NewAllocate, except all pixel bytes are zeroed.
     */
    #[link_name =
          "?NewZeroed@SkMallocPixelRef@@SAPEAV1@AEBUSkImageInfo@@_KPEAVSkColorTable@@@Z"]
    pub fn SkMallocPixelRef_NewZeroed(info: *const SkImageInfo,
                                      rowBytes: usize,
                                      arg1: *mut SkColorTable)
     -> *mut SkMallocPixelRef;
}
extern "C" {
    #[link_name =
          "?NewWithProc@SkMallocPixelRef@@SAPEAV1@AEBUSkImageInfo@@_KPEAVSkColorTable@@PEAXP6AX33@Z3@Z"]
    pub fn SkMallocPixelRef_NewWithProc(info: *const SkImageInfo,
                                        rowBytes: usize,
                                        arg1: *mut SkColorTable,
                                        addr: *mut ::std::os::raw::c_void,
                                        proc_: SkMallocPixelRef_ReleaseProc,
                                        context: *mut ::std::os::raw::c_void)
     -> *mut SkMallocPixelRef;
}
extern "C" {
    /**
     *  Return a new SkMallocPixelRef that will use the provided
     *  SkData, rowBytes, and optional colortable as pixel storage.
     *  The SkData will be ref()ed and on destruction of the PielRef,
     *  the SkData will be unref()ed.
     *
     *  This pixelref will ref() the specified colortable (if not NULL).
     *
     *  Returns NULL on failure.
     */
    #[link_name =
          "?NewWithData@SkMallocPixelRef@@SAPEAV1@AEBUSkImageInfo@@_KPEAVSkColorTable@@PEAVSkData@@@Z"]
    pub fn SkMallocPixelRef_NewWithData(info: *const SkImageInfo,
                                        rowBytes: usize,
                                        ctable: *mut SkColorTable,
                                        data: *mut SkData)
     -> *mut SkMallocPixelRef;
}
impl SkMallocPixelRef {
    #[inline]
    pub unsafe fn NewDirect(arg1: *const SkImageInfo,
                            addr: *mut ::std::os::raw::c_void,
                            rowBytes: usize, arg2: *mut SkColorTable)
     -> *mut SkMallocPixelRef {
        SkMallocPixelRef_NewDirect(arg1, addr, rowBytes, arg2)
    }
    #[inline]
    pub unsafe fn NewAllocate(info: *const SkImageInfo, rowBytes: usize,
                              arg1: *mut SkColorTable)
     -> *mut SkMallocPixelRef {
        SkMallocPixelRef_NewAllocate(info, rowBytes, arg1)
    }
    #[inline]
    pub unsafe fn NewZeroed(info: *const SkImageInfo, rowBytes: usize,
                            arg1: *mut SkColorTable)
     -> *mut SkMallocPixelRef {
        SkMallocPixelRef_NewZeroed(info, rowBytes, arg1)
    }
    #[inline]
    pub unsafe fn NewWithProc(info: *const SkImageInfo, rowBytes: usize,
                              arg1: *mut SkColorTable,
                              addr: *mut ::std::os::raw::c_void,
                              proc_: SkMallocPixelRef_ReleaseProc,
                              context: *mut ::std::os::raw::c_void)
     -> *mut SkMallocPixelRef {
        SkMallocPixelRef_NewWithProc(info, rowBytes, arg1, addr, proc_,
                                     context)
    }
    #[inline]
    pub unsafe fn NewWithData(info: *const SkImageInfo, rowBytes: usize,
                              ctable: *mut SkColorTable, data: *mut SkData)
     -> *mut SkMallocPixelRef {
        SkMallocPixelRef_NewWithData(info, rowBytes, ctable, data)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrClip {
    pub _address: u8,
}
impl Clone for GrClip {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrPaint {
    pub _address: u8,
}
impl Clone for GrPaint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrTextureProvider {
    pub _address: u8,
}
impl Clone for GrTextureProvider {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkCachedData {
    pub _address: u8,
}
impl Clone for SkCachedData {
    fn clone(&self) -> Self { *self }
}
/** \class SkMultiPictureDraw

    The MultiPictureDraw object accepts several picture/canvas pairs and
    then attempts to optimally draw the pictures into the canvases, sharing
    as many resources as possible.
*/
#[repr(C)]
#[derive(Debug)]
pub struct SkMultiPictureDraw {
    pub fThreadSafeDrawData: SkTDArray<SkMultiPictureDraw_DrawData>,
    pub fGPUDrawData: SkTDArray<SkMultiPictureDraw_DrawData>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkMultiPictureDraw_DrawData {
    pub fCanvas: *mut SkCanvas,
    pub fPicture: *const SkPicture,
    pub fMatrix: SkMatrix,
    pub fPaint: *mut SkPaint,
}
#[test]
fn bindgen_test_layout_SkMultiPictureDraw_DrawData() {
    assert_eq!(::std::mem::size_of::<SkMultiPictureDraw_DrawData>() ,
               64usize);
    assert_eq!(::std::mem::align_of::<SkMultiPictureDraw_DrawData>() ,
               8usize);
}
extern "C" {
    #[link_name =
          "?init@DrawData@SkMultiPictureDraw@@QEAAXPEAVSkCanvas@@PEBVSkPicture@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
    pub fn SkMultiPictureDraw_DrawData_init(this:
                                                *mut SkMultiPictureDraw_DrawData,
                                            arg1: *mut SkCanvas,
                                            arg2: *const SkPicture,
                                            arg3: *const SkMatrix,
                                            arg4: *const SkPaint);
}
extern "C" {
    #[link_name = "?draw@DrawData@SkMultiPictureDraw@@QEAAXXZ"]
    pub fn SkMultiPictureDraw_DrawData_draw(this:
                                                *mut SkMultiPictureDraw_DrawData);
}
extern "C" {
    #[link_name =
          "?Reset@DrawData@SkMultiPictureDraw@@SAXAEAV?$SkTDArray@UDrawData@SkMultiPictureDraw@@@@@Z"]
    pub fn SkMultiPictureDraw_DrawData_Reset(arg1:
                                                 *mut SkTDArray<SkMultiPictureDraw_DrawData>);
}
impl Clone for SkMultiPictureDraw_DrawData {
    fn clone(&self) -> Self { *self }
}
impl SkMultiPictureDraw_DrawData {
    #[inline]
    pub unsafe fn init(&mut self, arg1: *mut SkCanvas, arg2: *const SkPicture,
                       arg3: *const SkMatrix, arg4: *const SkPaint) {
        SkMultiPictureDraw_DrawData_init(&mut *self, arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn draw(&mut self) {
        SkMultiPictureDraw_DrawData_draw(&mut *self)
    }
    #[inline]
    pub unsafe fn Reset(arg1: *mut SkTDArray<SkMultiPictureDraw_DrawData>) {
        SkMultiPictureDraw_DrawData_Reset(arg1)
    }
}
#[test]
fn bindgen_test_layout_SkMultiPictureDraw() {
    assert_eq!(::std::mem::size_of::<SkMultiPictureDraw>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkMultiPictureDraw>() , 1usize);
}
extern "C" {
    /**
     *  Add a canvas/picture pair for later rendering.
     *  @param canvas   the canvas in which to draw picture
     *  @param picture  the picture to draw into canvas
     *  @param matrix   if non-NULL, applied to the CTM when drawing
     *  @param paint    if non-NULL, draw picture to a temporary buffer
     *                  and then apply the paint when the result is drawn
     */
    #[link_name =
          "?add@SkMultiPictureDraw@@QEAAXPEAVSkCanvas@@PEBVSkPicture@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
    pub fn SkMultiPictureDraw_add(this: *mut SkMultiPictureDraw,
                                  canvas: *mut SkCanvas,
                                  picture: *const SkPicture,
                                  matrix: *const SkMatrix,
                                  paint: *const SkPaint);
}
extern "C" {
    /**
     *  Perform all the previously added draws. This will reset the state
     *  of this object. If flush is true, all canvases are flushed after
     *  draw.
     */
    #[link_name = "?draw@SkMultiPictureDraw@@QEAAX_N@Z"]
    pub fn SkMultiPictureDraw_draw(this: *mut SkMultiPictureDraw,
                                   flush: bool);
}
extern "C" {
    /**
     *  Abandon all buffered draws and reset to the initial state.
     */
    #[link_name = "?reset@SkMultiPictureDraw@@QEAAXXZ"]
    pub fn SkMultiPictureDraw_reset(this: *mut SkMultiPictureDraw);
}
impl SkMultiPictureDraw {
    #[inline]
    pub unsafe fn add(&mut self, canvas: *mut SkCanvas,
                      picture: *const SkPicture, matrix: *const SkMatrix,
                      paint: *const SkPaint) {
        SkMultiPictureDraw_add(&mut *self, canvas, picture, matrix, paint)
    }
    #[inline]
    pub unsafe fn draw(&mut self, flush: bool) {
        SkMultiPictureDraw_draw(&mut *self, flush)
    }
    #[inline]
    pub unsafe fn reset(&mut self) { SkMultiPictureDraw_reset(&mut *self) }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathMeasure {
    pub fIter: SkPath_Iter,
    pub fPath: *const SkPath,
    pub fTolerance: SkScalar,
    pub fLength: SkScalar,
    pub fFirstPtIndex: ::std::os::raw::c_int,
    pub fIsClosed: bool,
    pub fForceClosed: bool,
    pub fSegments: SkTDArray<SkPathMeasure_Segment>,
    pub fPts: SkTDArray<SkPoint>,
}
pub const SkPathMeasure_MatrixFlags_kGetPosition_MatrixFlag:
          SkPathMeasure_MatrixFlags =
    SkPathMeasure_MatrixFlags(1);
pub const SkPathMeasure_MatrixFlags_kGetTangent_MatrixFlag:
          SkPathMeasure_MatrixFlags =
    SkPathMeasure_MatrixFlags(2);
pub const SkPathMeasure_MatrixFlags_kGetPosAndTan_MatrixFlag:
          SkPathMeasure_MatrixFlags =
    SkPathMeasure_MatrixFlags(3);
impl ::std::ops::BitOr<SkPathMeasure_MatrixFlags> for
 SkPathMeasure_MatrixFlags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkPathMeasure_MatrixFlags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkPathMeasure_MatrixFlags(pub i32);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkPathMeasure_Segment {
    pub fDistance: SkScalar,
    pub fPtIndex: ::std::os::raw::c_uint,
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_SkPathMeasure_Segment() {
    assert_eq!(::std::mem::size_of::<SkPathMeasure_Segment>() , 12usize);
    assert_eq!(::std::mem::align_of::<SkPathMeasure_Segment>() , 4usize);
}
extern "C" {
    #[link_name = "?getScalarT@Segment@SkPathMeasure@@QEBAMXZ"]
    pub fn SkPathMeasure_Segment_getScalarT(this:
                                                *const SkPathMeasure_Segment)
     -> SkScalar;
}
impl Clone for SkPathMeasure_Segment {
    fn clone(&self) -> Self { *self }
}
impl SkPathMeasure_Segment {
    #[inline]
    pub fn fTValue(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (1073741823usize as u32)) >> 0u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_fTValue(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1073741823usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (1073741823usize as u32);
    }
    #[inline]
    pub fn fType(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (3221225472usize as u32)) >> 30u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_fType(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3221225472usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (3221225472usize as u32);
    }
    #[inline]
    pub unsafe fn getScalarT(&self) -> SkScalar {
        SkPathMeasure_Segment_getScalarT(&*self)
    }
}
#[test]
fn bindgen_test_layout_SkPathMeasure() {
    assert_eq!(::std::mem::size_of::<SkPathMeasure>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPathMeasure>() , 1usize);
}
extern "C" {
    /** Reset the pathmeasure with the specified path. The path must remain valid
        for the lifetime of the measure object, or until setPath() is called with
        a different path (or null), since the measure object keeps a pointer to the
        path object (does not copy its data).
    */
    #[link_name = "?setPath@SkPathMeasure@@QEAAXPEBVSkPath@@_N@Z"]
    pub fn SkPathMeasure_setPath(this: *mut SkPathMeasure,
                                 arg1: *const SkPath, forceClosed: bool);
}
extern "C" {
    /** Return the total length of the current contour, or 0 if no path
        is associated (e.g. resetPath(null))
    */
    #[link_name = "?getLength@SkPathMeasure@@QEAAMXZ"]
    pub fn SkPathMeasure_getLength(this: *mut SkPathMeasure) -> SkScalar;
}
extern "C" {
    /** Pins distance to 0 <= distance <= getLength(), and then computes
        the corresponding position and tangent.
        Returns false if there is no path, or a zero-length path was specified, in which case
        position and tangent are unchanged.
    */
    #[link_name = "?getPosTan@SkPathMeasure@@QEAA_NMPEAUSkPoint@@0@Z"]
    pub fn SkPathMeasure_getPosTan(this: *mut SkPathMeasure,
                                   distance: SkScalar, position: *mut SkPoint,
                                   tangent: *mut SkVector) -> bool;
}
extern "C" {
    /** Pins distance to 0 <= distance <= getLength(), and then computes
        the corresponding matrix (by calling getPosTan).
        Returns false if there is no path, or a zero-length path was specified, in which case
        matrix is unchanged.
    */
    #[link_name =
          "?getMatrix@SkPathMeasure@@QEAA_NMPEAVSkMatrix@@W4MatrixFlags@1@@Z"]
    pub fn SkPathMeasure_getMatrix(this: *mut SkPathMeasure,
                                   distance: SkScalar, matrix: *mut SkMatrix,
                                   flags: SkPathMeasure_MatrixFlags) -> bool;
}
extern "C" {
    /** Given a start and stop distance, return in dst the intervening segment(s).
        If the segment is zero-length, return false, else return true.
        startD and stopD are pinned to legal values (0..getLength()). If startD > stopD
        then return false (and leave dst untouched).
        Begin the segment with a moveTo if startWithMoveTo is true
    */
    #[link_name = "?getSegment@SkPathMeasure@@QEAA_NMMPEAVSkPath@@_N@Z"]
    pub fn SkPathMeasure_getSegment(this: *mut SkPathMeasure,
                                    startD: SkScalar, stopD: SkScalar,
                                    dst: *mut SkPath, startWithMoveTo: bool)
     -> bool;
}
extern "C" {
    /** Return true if the current contour is closed()
    */
    #[link_name = "?isClosed@SkPathMeasure@@QEAA_NXZ"]
    pub fn SkPathMeasure_isClosed(this: *mut SkPathMeasure) -> bool;
}
extern "C" {
    /** Move to the next contour in the path. Return true if one exists, or false if
        we're done with the path.
    */
    #[link_name = "?nextContour@SkPathMeasure@@QEAA_NXZ"]
    pub fn SkPathMeasure_nextContour(this: *mut SkPathMeasure) -> bool;
}
extern "C" {
    #[link_name = "?dump@SkPathMeasure@@QEAAXXZ"]
    pub fn SkPathMeasure_dump(this: *mut SkPathMeasure);
}
impl SkPathMeasure {
    #[inline]
    pub unsafe fn setPath(&mut self, arg1: *const SkPath, forceClosed: bool) {
        SkPathMeasure_setPath(&mut *self, arg1, forceClosed)
    }
    #[inline]
    pub unsafe fn getLength(&mut self) -> SkScalar {
        SkPathMeasure_getLength(&mut *self)
    }
    #[inline]
    pub unsafe fn getPosTan(&mut self, distance: SkScalar,
                            position: *mut SkPoint, tangent: *mut SkVector)
     -> bool {
        SkPathMeasure_getPosTan(&mut *self, distance, position, tangent)
    }
    #[inline]
    pub unsafe fn getMatrix(&mut self, distance: SkScalar,
                            matrix: *mut SkMatrix,
                            flags: SkPathMeasure_MatrixFlags) -> bool {
        SkPathMeasure_getMatrix(&mut *self, distance, matrix, flags)
    }
    #[inline]
    pub unsafe fn getSegment(&mut self, startD: SkScalar, stopD: SkScalar,
                             dst: *mut SkPath, startWithMoveTo: bool)
     -> bool {
        SkPathMeasure_getSegment(&mut *self, startD, stopD, dst,
                                 startWithMoveTo)
    }
    #[inline]
    pub unsafe fn isClosed(&mut self) -> bool {
        SkPathMeasure_isClosed(&mut *self)
    }
    #[inline]
    pub unsafe fn nextContour(&mut self) -> bool {
        SkPathMeasure_nextContour(&mut *self)
    }
    #[inline]
    pub unsafe fn dump(&mut self) { SkPathMeasure_dump(&mut *self) }
}
/** \class SkTextBlobBuilder

    Helper class for constructing SkTextBlobs.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlobBuilder {
    pub fStorage: SkAutoTMalloc<::std::os::raw::c_uchar>,
    pub fStorageSize: usize,
    pub fStorageUsed: usize,
    pub fBounds: SkRect,
    pub fRunCount: ::std::os::raw::c_int,
    pub fDeferredBounds: bool,
    pub fLastRun: usize,
    pub fCurrentRunBuffer: SkTextBlobBuilder_RunBuffer,
}
/**
     *  Glyph and position buffers associated with a run.
     *
     *  A run is a sequence of glyphs sharing the same font metrics
     *  and positioning mode.
     *
     *  If textByteCount is 0, utf8text and clusters will be NULL (no
     *  character information will be associated with the glyphs).
     *
     *  utf8text will point to a buffer of size textByteCount bytes.
     *
     *  clusters (if not NULL) will point to an array of size count.
     *  For each glyph, give the byte-offset into the text for the
     *  first byte in the first character in that glyph's cluster.
     *  Each value in the array should be an integer less than
     *  textByteCount.  Values in the array should either be
     *  monotonically increasing (left-to-right text) or monotonically
     *  decreasing (right-to-left text).  This definiton is conviently
     *  the same as used by Harfbuzz's hb_glyph_info_t::cluster field,
     *  except that Harfbuzz interleaves glyphs and clusters.
     */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkTextBlobBuilder_RunBuffer {
    pub glyphs: *mut SkGlyphID,
    pub pos: *mut SkScalar,
    pub utf8text: *mut ::std::os::raw::c_char,
    pub clusters: *mut u32,
}
#[test]
fn bindgen_test_layout_SkTextBlobBuilder_RunBuffer() {
    assert_eq!(::std::mem::size_of::<SkTextBlobBuilder_RunBuffer>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<SkTextBlobBuilder_RunBuffer>() ,
               8usize);
}
impl Clone for SkTextBlobBuilder_RunBuffer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SkTextBlobBuilder() {
    assert_eq!(::std::mem::size_of::<SkTextBlobBuilder>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkTextBlobBuilder>() , 1usize);
}
extern "C" {
    /**
     *  Returns an immutable SkTextBlob for the current runs/glyphs. The builder is reset and
     *  can be reused.
     */
    #[link_name = "?make@SkTextBlobBuilder@@QEAA?AV?$sk_sp@VSkTextBlob@@@@XZ"]
    pub fn SkTextBlobBuilder_make(this: *mut SkTextBlobBuilder)
     -> sk_sp<SkTextBlob>;
}
extern "C" {
    /**
     *  Allocates a new default-positioned run and returns its writable glyph buffer
     *  for direct manipulation.
     *
     *  @param font    The font to be used for this run.
     *  @param count   Number of glyphs.
     *  @param x,y     Position within the blob.
     *  @param textByteCount length of the original UTF-8 text that
     *                 corresponds to this sequence of glyphs.  If 0,
     *                 text will not be included in the textblob.
     *  @param lang    Language code, currently unimplemented.
     *  @param bounds  Optional run bounding box. If known in advance (!= NULL), it will
     *                 be used when computing the blob bounds, to avoid re-measuring.
     *
     *  @return        A writable glyph buffer, valid until the next allocRun() or
     *                 build() call. The buffer is guaranteed to hold @count@ glyphs.
     */
    #[link_name =
          "?allocRunText@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkPaint@@HMMHVSkString@@PEBUSkRect@@@Z"]
    pub fn SkTextBlobBuilder_allocRunText(this: *mut SkTextBlobBuilder,
                                          font: *const SkPaint,
                                          count: ::std::os::raw::c_int,
                                          x: SkScalar, y: SkScalar,
                                          textByteCount:
                                              ::std::os::raw::c_int,
                                          lang: SkString,
                                          bounds: *const SkRect)
     -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    /**
     *  Allocates a new horizontally-positioned run and returns its writable glyph and position
     *  buffers for direct manipulation.
     *
     *  @param font    The font to be used for this run.
     *  @param count   Number of glyphs.
     *  @param y       Vertical offset within the blob.
     *  @param textByteCount length of the original UTF-8 text that
     *                 corresponds to this sequence of glyphs.  If 0,
     *                 text will not be included in the textblob.
     *  @param lang    Language code, currently unimplemented.
     *  @param bounds  Optional run bounding box. If known in advance (!= NULL), it will
     *                 be used when computing the blob bounds, to avoid re-measuring.
     *
     *  @return        Writable glyph and position buffers, valid until the next allocRun()
     *                 or build() call. The buffers are guaranteed to hold @count@ elements.
     */
    #[link_name =
          "?allocRunTextPosH@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkPaint@@HMHVSkString@@PEBUSkRect@@@Z"]
    pub fn SkTextBlobBuilder_allocRunTextPosH(this: *mut SkTextBlobBuilder,
                                              font: *const SkPaint,
                                              count: ::std::os::raw::c_int,
                                              y: SkScalar,
                                              textByteCount:
                                                  ::std::os::raw::c_int,
                                              lang: SkString,
                                              bounds: *const SkRect)
     -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    /**
     *  Allocates a new fully-positioned run and returns its writable glyph and position
     *  buffers for direct manipulation.
     *
     *  @param font   The font to be used for this run.
     *  @param count  Number of glyphs.
     *  @param textByteCount length of the original UTF-8 text that
     *                 corresponds to this sequence of glyphs.  If 0,
     *                 text will not be included in the textblob.
     *  @param lang    Language code, currently unimplemented.
     *  @param bounds Optional run bounding box. If known in advance (!= NULL), it will
     *                be used when computing the blob bounds, to avoid re-measuring.
     *
     *  @return       Writable glyph and position buffers, valid until the next allocRun()
     *                or build() call. The glyph buffer and position buffer are
     *                guaranteed to hold @count@ and 2 * @count@ elements, respectively.
     */
    #[link_name =
          "?allocRunTextPos@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkPaint@@HHVSkString@@PEBUSkRect@@@Z"]
    pub fn SkTextBlobBuilder_allocRunTextPos(this: *mut SkTextBlobBuilder,
                                             font: *const SkPaint,
                                             count: ::std::os::raw::c_int,
                                             textByteCount:
                                                 ::std::os::raw::c_int,
                                             lang: SkString,
                                             bounds: *const SkRect)
     -> *const SkTextBlobBuilder_RunBuffer;
}
impl SkTextBlobBuilder {
    #[inline]
    pub unsafe fn make(&mut self) -> sk_sp<SkTextBlob> {
        SkTextBlobBuilder_make(&mut *self)
    }
    #[inline]
    pub unsafe fn allocRunText(&mut self, font: *const SkPaint,
                               count: ::std::os::raw::c_int, x: SkScalar,
                               y: SkScalar,
                               textByteCount: ::std::os::raw::c_int,
                               lang: SkString, bounds: *const SkRect)
     -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunText(&mut *self, font, count, x, y,
                                       textByteCount, lang, bounds)
    }
    #[inline]
    pub unsafe fn allocRunTextPosH(&mut self, font: *const SkPaint,
                                   count: ::std::os::raw::c_int, y: SkScalar,
                                   textByteCount: ::std::os::raw::c_int,
                                   lang: SkString, bounds: *const SkRect)
     -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunTextPosH(&mut *self, font, count, y,
                                           textByteCount, lang, bounds)
    }
    #[inline]
    pub unsafe fn allocRunTextPos(&mut self, font: *const SkPaint,
                                  count: ::std::os::raw::c_int,
                                  textByteCount: ::std::os::raw::c_int,
                                  lang: SkString, bounds: *const SkRect)
     -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunTextPos(&mut *self, font, count,
                                          textByteCount, lang, bounds)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkMiniRecorder {
    pub fState: SkMiniRecorder_State,
    pub fBuffer: ::std::os::raw::c_int,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SkMiniRecorder_State {
    kEmpty = 0,
    kDrawPath = 1,
    kDrawRect = 2,
    kDrawTextBlob = 3,
}
extern "C" {
    #[link_name = "?kInlineStorage@SkMiniRecorder@@0_KB"]
    pub static SkMiniRecorder_kInlineStorage: usize;
}
#[test]
fn bindgen_test_layout_SkMiniRecorder() {
    assert_eq!(::std::mem::size_of::<SkMiniRecorder>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkMiniRecorder>() , 1usize);
}
extern "C" {
    #[link_name =
          "?drawPath@SkMiniRecorder@@QEAA_NAEBVSkPath@@AEBVSkPaint@@@Z"]
    pub fn SkMiniRecorder_drawPath(this: *mut SkMiniRecorder,
                                   arg1: *const SkPath, arg2: *const SkPaint)
     -> bool;
}
extern "C" {
    #[link_name =
          "?drawRect@SkMiniRecorder@@QEAA_NAEBUSkRect@@AEBVSkPaint@@@Z"]
    pub fn SkMiniRecorder_drawRect(this: *mut SkMiniRecorder,
                                   arg1: *const SkRect, arg2: *const SkPaint)
     -> bool;
}
extern "C" {
    #[link_name =
          "?drawTextBlob@SkMiniRecorder@@QEAA_NPEBVSkTextBlob@@MMAEBVSkPaint@@@Z"]
    pub fn SkMiniRecorder_drawTextBlob(this: *mut SkMiniRecorder,
                                       arg1: *const SkTextBlob, x: SkScalar,
                                       y: SkScalar, arg2: *const SkPaint)
     -> bool;
}
extern "C" {
    #[link_name =
          "?detachAsPicture@SkMiniRecorder@@QEAA?AV?$sk_sp@VSkPicture@@@@AEBUSkRect@@@Z"]
    pub fn SkMiniRecorder_detachAsPicture(this: *mut SkMiniRecorder,
                                          cull: *const SkRect)
     -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "?flushAndReset@SkMiniRecorder@@QEAAXPEAVSkCanvas@@@Z"]
    pub fn SkMiniRecorder_flushAndReset(this: *mut SkMiniRecorder,
                                        arg1: *mut SkCanvas);
}
impl SkMiniRecorder {
    #[inline]
    pub unsafe fn drawPath(&mut self, arg1: *const SkPath,
                           arg2: *const SkPaint) -> bool {
        SkMiniRecorder_drawPath(&mut *self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn drawRect(&mut self, arg1: *const SkRect,
                           arg2: *const SkPaint) -> bool {
        SkMiniRecorder_drawRect(&mut *self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn drawTextBlob(&mut self, arg1: *const SkTextBlob,
                               x: SkScalar, y: SkScalar, arg2: *const SkPaint)
     -> bool {
        SkMiniRecorder_drawTextBlob(&mut *self, arg1, x, y, arg2)
    }
    #[inline]
    pub unsafe fn detachAsPicture(&mut self, cull: *const SkRect)
     -> sk_sp<SkPicture> {
        SkMiniRecorder_detachAsPicture(&mut *self, cull)
    }
    #[inline]
    pub unsafe fn flushAndReset(&mut self, arg1: *mut SkCanvas) {
        SkMiniRecorder_flushAndReset(&mut *self, arg1)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkRecord {
    pub _address: u8,
}
impl Clone for SkRecord {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPictureRecorder {
    pub fActivelyRecording: bool,
    pub fFlags: u32,
    pub fCullRect: SkRect,
    pub fBBH: sk_sp<SkBBoxHierarchy>,
    pub fRecorder: ::std::os::raw::c_int,
    pub fRecord: sk_sp<SkRecord>,
    pub fMiniRecorder: SkMiniRecorder,
}
pub const SkPictureRecorder_RecordFlags_kPlaybackDrawPicture_RecordFlag:
          SkPictureRecorder_RecordFlags =
    SkPictureRecorder_RecordFlags(1);
impl ::std::ops::BitOr<SkPictureRecorder_RecordFlags> for
 SkPictureRecorder_RecordFlags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkPictureRecorder_RecordFlags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkPictureRecorder_RecordFlags(pub i32);
pub const SkPictureRecorder_FinishFlags_kReturnNullForEmpty_FinishFlag:
          SkPictureRecorder_FinishFlags =
    SkPictureRecorder_FinishFlags(1);
impl ::std::ops::BitOr<SkPictureRecorder_FinishFlags> for
 SkPictureRecorder_FinishFlags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkPictureRecorder_FinishFlags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkPictureRecorder_FinishFlags(pub i32);
pub type SkPictureRecorder_INHERITED = SkNoncopyable;
#[test]
fn bindgen_test_layout_SkPictureRecorder() {
    assert_eq!(::std::mem::size_of::<SkPictureRecorder>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkPictureRecorder>() , 1usize);
}
extern "C" {
    /** Returns the canvas that records the drawing commands.
        @param bounds the cull rect used when recording this picture. Any drawing the falls outside
                      of this rect is undefined, and may be drawn or it may not.
        @param bbhFactory factory to create desired acceleration structure
        @param recordFlags optional flags that control recording.
        @return the canvas.
    */
    #[link_name =
          "?beginRecording@SkPictureRecorder@@QEAAPEAVSkCanvas@@AEBUSkRect@@PEAVSkBBHFactory@@I@Z"]
    pub fn SkPictureRecorder_beginRecording(this: *mut SkPictureRecorder,
                                            bounds: *const SkRect,
                                            bbhFactory: *mut SkBBHFactory,
                                            recordFlags: u32)
     -> *mut SkCanvas;
}
extern "C" {
    /** Returns the recording canvas if one is active, or NULL if recording is
        not active. This does not alter the refcnt on the canvas (if present).
    */
    #[link_name =
          "?getRecordingCanvas@SkPictureRecorder@@QEAAPEAVSkCanvas@@XZ"]
    pub fn SkPictureRecorder_getRecordingCanvas(this: *mut SkPictureRecorder)
     -> *mut SkCanvas;
}
extern "C" {
    /**
     *  Signal that the caller is done recording. This invalidates the canvas returned by
     *  beginRecording/getRecordingCanvas. Ownership of the object is passed to the caller, who
     *  must call unref() when they are done using it.
     *
     *  The returned picture is immutable. If during recording drawables were added to the canvas,
     *  these will have been "drawn" into a recording canvas, so that this resulting picture will
     *  reflect their current state, but will not contain a live reference to the drawables
     *  themselves.
     */
    #[link_name =
          "?finishRecordingAsPicture@SkPictureRecorder@@QEAA?AV?$sk_sp@VSkPicture@@@@I@Z"]
    pub fn SkPictureRecorder_finishRecordingAsPicture(this:
                                                          *mut SkPictureRecorder,
                                                      endFlags: u32)
     -> sk_sp<SkPicture>;
}
extern "C" {
    /**
     *  Signal that the caller is done recording, and update the cull rect to use for bounding
     *  box hierarchy (BBH) generation. The behavior is the same as calling
     *  endRecordingAsPicture(), except that this method updates the cull rect initially passed
     *  into beginRecording.
     *  @param cullRect the new culling rectangle to use as the overall bound for BBH generation
     *                  and subsequent culling operations.
     *  @return the picture containing the recorded content.
     */
    #[link_name =
          "?finishRecordingAsPictureWithCull@SkPictureRecorder@@QEAA?AV?$sk_sp@VSkPicture@@@@AEBUSkRect@@I@Z"]
    pub fn SkPictureRecorder_finishRecordingAsPictureWithCull(this:
                                                                  *mut SkPictureRecorder,
                                                              cullRect:
                                                                  *const SkRect,
                                                              endFlags: u32)
     -> sk_sp<SkPicture>;
}
extern "C" {
    /**
     *  Signal that the caller is done recording. This invalidates the canvas returned by
     *  beginRecording/getRecordingCanvas. Ownership of the object is passed to the caller, who
     *  must call unref() when they are done using it.
     *
     *  Unlike endRecordingAsPicture(), which returns an immutable picture, the returned drawable
     *  may contain live references to other drawables (if they were added to the recording canvas)
     *  and therefore this drawable will reflect the current state of those nested drawables anytime
     *  it is drawn or a new picture is snapped from it (by calling drawable->newPictureSnapshot()).
     */
    #[link_name =
          "?finishRecordingAsDrawable@SkPictureRecorder@@QEAA?AV?$sk_sp@VSkDrawable@@@@I@Z"]
    pub fn SkPictureRecorder_finishRecordingAsDrawable(this:
                                                           *mut SkPictureRecorder,
                                                       endFlags: u32)
     -> sk_sp<SkDrawable>;
}
impl SkPictureRecorder {
    #[inline]
    pub unsafe fn beginRecording(&mut self, bounds: *const SkRect,
                                 bbhFactory: *mut SkBBHFactory,
                                 recordFlags: u32) -> *mut SkCanvas {
        SkPictureRecorder_beginRecording(&mut *self, bounds, bbhFactory,
                                         recordFlags)
    }
    #[inline]
    pub unsafe fn getRecordingCanvas(&mut self) -> *mut SkCanvas {
        SkPictureRecorder_getRecordingCanvas(&mut *self)
    }
    #[inline]
    pub unsafe fn finishRecordingAsPicture(&mut self, endFlags: u32)
     -> sk_sp<SkPicture> {
        SkPictureRecorder_finishRecordingAsPicture(&mut *self, endFlags)
    }
    #[inline]
    pub unsafe fn finishRecordingAsPictureWithCull(&mut self,
                                                   cullRect: *const SkRect,
                                                   endFlags: u32)
     -> sk_sp<SkPicture> {
        SkPictureRecorder_finishRecordingAsPictureWithCull(&mut *self,
                                                           cullRect, endFlags)
    }
    #[inline]
    pub unsafe fn finishRecordingAsDrawable(&mut self, endFlags: u32)
     -> sk_sp<SkDrawable> {
        SkPictureRecorder_finishRecordingAsDrawable(&mut *self, endFlags)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkBufferBlock {
    pub _address: u8,
}
impl Clone for SkBufferBlock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkBufferHead {
    pub _address: u8,
}
impl Clone for SkBufferHead {
    fn clone(&self) -> Self { *self }
}
/**
 *  Accumulates bytes of memory that are "appended" to it, growing internal storage as needed.
 *  The growth is done such that at any time in the writer's thread, an RBuffer or StreamAsset
 *  can be snapped off (and safely passed to another thread). The RBuffer/StreamAsset snapshot
 *  can see the previously stored bytes, but will be unaware of any future writes.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkRWBuffer {
    pub fHead: *mut SkBufferHead,
    pub fTail: *mut SkBufferBlock,
    pub fTotalUsed: usize,
}
#[test]
fn bindgen_test_layout_SkRWBuffer() {
    assert_eq!(::std::mem::size_of::<SkRWBuffer>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkRWBuffer>() , 8usize);
}
extern "C" {
    /**
     *  Append |length| bytes from |buffer|.
     *
     *  If the caller knows in advance how much more data they are going to append, they can
     *  pass a |reserve| hint (representing the number of upcoming bytes *in addition* to the
     *  current append), to minimize the number of internal allocations.
     */
    #[link_name = "?append@SkRWBuffer@@QEAAXPEBX_K1@Z"]
    pub fn SkRWBuffer_append(this: *mut SkRWBuffer,
                             buffer: *const ::std::os::raw::c_void,
                             length: usize, reserve: usize);
}
extern "C" {
    #[link_name = "?newRBufferSnapshot@SkRWBuffer@@QEBAPEAVSkROBuffer@@XZ"]
    pub fn SkRWBuffer_newRBufferSnapshot(this: *const SkRWBuffer)
     -> *mut SkROBuffer;
}
extern "C" {
    #[link_name = "?newStreamSnapshot@SkRWBuffer@@QEBAPEAVSkStreamAsset@@XZ"]
    pub fn SkRWBuffer_newStreamSnapshot(this: *const SkRWBuffer)
     -> *mut SkStreamAsset;
}
extern "C" {
    #[link_name = "?validate@SkRWBuffer@@QEBAXXZ"]
    pub fn SkRWBuffer_validate(this: *const SkRWBuffer);
}
impl SkRWBuffer {
    #[inline]
    pub unsafe fn append(&mut self, buffer: *const ::std::os::raw::c_void,
                         length: usize, reserve: usize) {
        SkRWBuffer_append(&mut *self, buffer, length, reserve)
    }
    #[inline]
    pub unsafe fn newRBufferSnapshot(&self) -> *mut SkROBuffer {
        SkRWBuffer_newRBufferSnapshot(&*self)
    }
    #[inline]
    pub unsafe fn newStreamSnapshot(&self) -> *mut SkStreamAsset {
        SkRWBuffer_newStreamSnapshot(&*self)
    }
    #[inline]
    pub unsafe fn validate(&self) { SkRWBuffer_validate(&*self) }
}
/**
 *  Contains a read-only, thread-sharable block of memory. To access the memory, the caller must
 *  instantiate a local iterator, as the memory is stored in 1 or more contiguous blocks.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkROBuffer {
    pub _base: SkRefCnt,
    pub fHead: *const SkBufferHead,
    pub fAvailable: usize,
    pub fTail: *const SkBufferBlock,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkROBuffer_Iter {
    pub fBlock: *const SkBufferBlock,
    pub fRemaining: usize,
    pub fBuffer: *const SkROBuffer,
}
#[test]
fn bindgen_test_layout_SkROBuffer_Iter() {
    assert_eq!(::std::mem::size_of::<SkROBuffer_Iter>() , 24usize);
    assert_eq!(::std::mem::align_of::<SkROBuffer_Iter>() , 8usize);
}
extern "C" {
    #[link_name = "?reset@Iter@SkROBuffer@@QEAAXPEBV2@@Z"]
    pub fn SkROBuffer_Iter_reset(this: *mut SkROBuffer_Iter,
                                 arg1: *const SkROBuffer);
}
extern "C" {
    /**
         *  Return the current continuous block of memory, or nullptr if the iterator is exhausted
         */
    #[link_name = "?data@Iter@SkROBuffer@@QEBAPEBXXZ"]
    pub fn SkROBuffer_Iter_data(this: *const SkROBuffer_Iter)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
         *  Returns the number of bytes in the current continguous block of memory, or 0 if the
         *  iterator is exhausted.
         */
    #[link_name = "?size@Iter@SkROBuffer@@QEBA_KXZ"]
    pub fn SkROBuffer_Iter_size(this: *const SkROBuffer_Iter) -> usize;
}
extern "C" {
    /**
         *  Advance to the next contiguous block of memory, returning true if there is another
         *  block, or false if the iterator is exhausted.
         */
    #[link_name = "?next@Iter@SkROBuffer@@QEAA_NXZ"]
    pub fn SkROBuffer_Iter_next(this: *mut SkROBuffer_Iter) -> bool;
}
impl Clone for SkROBuffer_Iter {
    fn clone(&self) -> Self { *self }
}
impl SkROBuffer_Iter {
    #[inline]
    pub unsafe fn reset(&mut self, arg1: *const SkROBuffer) {
        SkROBuffer_Iter_reset(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn data(&self) -> *const ::std::os::raw::c_void {
        SkROBuffer_Iter_data(&*self)
    }
    #[inline]
    pub unsafe fn size(&self) -> usize { SkROBuffer_Iter_size(&*self) }
    #[inline]
    pub unsafe fn next(&mut self) -> bool { SkROBuffer_Iter_next(&mut *self) }
}
#[test]
fn bindgen_test_layout_SkROBuffer() {
    assert_eq!(::std::mem::size_of::<SkROBuffer>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkROBuffer>() , 1usize);
}
extern "C" {
    /**
  Swizzles byte order of |count| 32-bit pixels, swapping R and B.
  (RGBA <-> BGRA)
*/
    #[link_name = "?SkSwapRB@@YAXPEAIPEBIH@Z"]
    pub fn SkSwapRB(dest: *mut u32, src: *const u32,
                    count: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkFontDescriptor {
    pub _address: u8,
}
impl Clone for SkFontDescriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkScalerContext {
    pub _address: u8,
}
impl Clone for SkScalerContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkScalerContextRec {
    pub _address: u8,
}
impl Clone for SkScalerContextRec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkAdvancedTypefaceMetrics {
    pub _address: u8,
}
impl Clone for SkAdvancedTypefaceMetrics {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkDeduper {
    pub _address: u8,
}
impl Clone for SkDeduper {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SkFactorySet {
    pub _address: u8,
}
impl Clone for SkFactorySet {
    fn clone(&self) -> Self { *self }
}
/**
 * Concrete implementation that serializes to a flat binary blob.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SkBinaryWriteBuffer {
    pub _base: SkWriteBuffer,
    pub fFlags: u32,
    pub fFactorySet: *mut SkFactorySet,
    pub fWriter: SkWriter32,
    pub fTFSet: *mut SkRefCntSet,
    pub fPixelSerializer: sk_sp<SkPixelSerializer>,
    pub fFlattenableDict: ::std::os::raw::c_int,
}
pub const SkBinaryWriteBuffer_Flags_kCrossProcess_Flag:
          SkBinaryWriteBuffer_Flags =
    SkBinaryWriteBuffer_Flags(1);
impl ::std::ops::BitOr<SkBinaryWriteBuffer_Flags> for
 SkBinaryWriteBuffer_Flags {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SkBinaryWriteBuffer_Flags(self.0 | other.0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SkBinaryWriteBuffer_Flags(pub i32);
#[test]
fn bindgen_test_layout_SkBinaryWriteBuffer() {
    assert_eq!(::std::mem::size_of::<SkBinaryWriteBuffer>() , 1usize);
    assert_eq!(::std::mem::align_of::<SkBinaryWriteBuffer>() , 1usize);
}
extern "C" {
    #[link_name =
          "?writeToStream@SkBinaryWriteBuffer@@QEAA_NPEAVSkWStream@@@Z"]
    pub fn SkBinaryWriteBuffer_writeToStream(this: *mut SkBinaryWriteBuffer,
                                             arg1: *mut SkWStream) -> bool;
}
extern "C" {
    #[link_name =
          "?setFactoryRecorder@SkBinaryWriteBuffer@@QEAAPEAVSkFactorySet@@PEAV2@@Z"]
    pub fn SkBinaryWriteBuffer_setFactoryRecorder(this:
                                                      *mut SkBinaryWriteBuffer,
                                                  arg1: *mut SkFactorySet)
     -> *mut SkFactorySet;
}
extern "C" {
    #[link_name =
          "?setTypefaceRecorder@SkBinaryWriteBuffer@@QEAAPEAVSkRefCntSet@@PEAV2@@Z"]
    pub fn SkBinaryWriteBuffer_setTypefaceRecorder(this:
                                                       *mut SkBinaryWriteBuffer,
                                                   arg1: *mut SkRefCntSet)
     -> *mut SkRefCntSet;
}
extern "C" {
    /**
     * Set an SkPixelSerializer to store an encoded representation of pixels,
     * e.g. SkBitmaps.
     *
     * TODO: Encode SkImage pixels as well.
     */
    #[link_name =
          "?setPixelSerializer@SkBinaryWriteBuffer@@QEAAXV?$sk_sp@VSkPixelSerializer@@@@@Z"]
    pub fn SkBinaryWriteBuffer_setPixelSerializer(this:
                                                      *mut SkBinaryWriteBuffer,
                                                  arg1:
                                                      sk_sp<SkPixelSerializer>);
}
impl SkBinaryWriteBuffer {
    #[inline]
    pub unsafe fn writeToStream(&mut self, arg1: *mut SkWStream) -> bool {
        SkBinaryWriteBuffer_writeToStream(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setFactoryRecorder(&mut self, arg1: *mut SkFactorySet)
     -> *mut SkFactorySet {
        SkBinaryWriteBuffer_setFactoryRecorder(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setTypefaceRecorder(&mut self, arg1: *mut SkRefCntSet)
     -> *mut SkRefCntSet {
        SkBinaryWriteBuffer_setTypefaceRecorder(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn setPixelSerializer(&mut self,
                                     arg1: sk_sp<SkPixelSerializer>) {
        SkBinaryWriteBuffer_setPixelSerializer(&mut *self, arg1)
    }
}
