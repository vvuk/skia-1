/* automatically generated by rust-bindgen */

pub use self::root::*;

pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    /// <div rustbindgen replaces="SkOnce"></div>
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkOnce {
        pub v: ::std::os::raw::c_uchar,
    }
    #[test]
    fn bindgen_test_layout_SkOnce() {
        assert_eq!(::std::mem::size_of::<SkOnce>() , 1usize);
        assert_eq!(::std::mem::align_of::<SkOnce>() , 1usize);
    }
    impl Clone for SkOnce {
        fn clone(&self) -> Self { *self }
    }
    /// <div rustbindgen replaces="sk_sp"></div>
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_sp<T> {
        pub ptr: *mut T,
        pub dummy: *mut ::std::os::raw::c_void,
    }
    pub type va_list = *mut ::std::os::raw::c_char;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod tr1 {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_delete<_Ty> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<_Ty>,
        }
        /// <div rustbindgen replaces="std::unique_ptr"></div>
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unique_ptr<T, D> {
            pub ptr: *mut T,
            pub _phantom_1: ::std::marker::PhantomData<D>,
        }
    }
    /** 32 bit integer to hold a unicode value
*/
    pub type SkUnichar = i32;
    pub type SkScalar = f32;
    /** \class SkString

    Light weight class for managing strings. Uses reference
    counting to make string assignments and copies very fast
    with no extra RAM cost. Assumes UTF8 encoding.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkString {
        pub fRec: *mut root::SkString_Rec,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkString_Rec {
        pub fLength: u32,
        pub fRefCnt: i32,
        pub fBeginningOfData: ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_SkString_Rec() {
        assert_eq!(::std::mem::size_of::<SkString_Rec>() , 12usize);
        assert_eq!(::std::mem::align_of::<SkString_Rec>() , 4usize);
    }
    impl Clone for SkString_Rec {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "?gEmptyRec@SkString@@0URec@1@B"]
        pub static SkString_gEmptyRec: root::SkString_Rec;
    }
    #[test]
    fn bindgen_test_layout_SkString() {
        assert_eq!(::std::mem::size_of::<SkString>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkString>() , 8usize);
    }
    extern "C" {
        #[link_name = "?equals@SkString@@QEBA_NAEBV1@@Z"]
        pub fn SkString_equals(this: *const root::SkString,
                               arg1: *const root::SkString) -> bool;
    }
    extern "C" {
        #[link_name = "?equals@SkString@@QEBA_NQEBD@Z"]
        pub fn SkString_equals1(this: *const root::SkString,
                                text: *const ::std::os::raw::c_char) -> bool;
    }
    extern "C" {
        #[link_name = "?equals@SkString@@QEBA_NQEBD_K@Z"]
        pub fn SkString_equals2(this: *const root::SkString,
                                text: *const ::std::os::raw::c_char,
                                len: usize) -> bool;
    }
    extern "C" {
        #[link_name = "?writable_str@SkString@@QEAAPEADXZ"]
        pub fn SkString_writable_str(this: *mut root::SkString)
         -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "?reset@SkString@@QEAAXXZ"]
        pub fn SkString_reset(this: *mut root::SkString);
    }
    extern "C" {
        #[link_name = "?set@SkString@@QEAAXQEBD@Z"]
        pub fn SkString_set(this: *mut root::SkString,
                            text: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?set@SkString@@QEAAXQEBD_K@Z"]
        pub fn SkString_set1(this: *mut root::SkString,
                             text: *const ::std::os::raw::c_char, len: usize);
    }
    extern "C" {
        #[link_name = "?setUTF16@SkString@@QEAAXQEBG@Z"]
        pub fn SkString_setUTF16(this: *mut root::SkString, arg1: *const u16);
    }
    extern "C" {
        #[link_name = "?setUTF16@SkString@@QEAAXQEBG_K@Z"]
        pub fn SkString_setUTF161(this: *mut root::SkString, arg1: *const u16,
                                  len: usize);
    }
    extern "C" {
        #[link_name = "?insert@SkString@@QEAAX_KQEBD@Z"]
        pub fn SkString_insert(this: *mut root::SkString, offset: usize,
                               text: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?insert@SkString@@QEAAX_KQEBD0@Z"]
        pub fn SkString_insert1(this: *mut root::SkString, offset: usize,
                                text: *const ::std::os::raw::c_char,
                                len: usize);
    }
    extern "C" {
        #[link_name = "?insertUnichar@SkString@@QEAAX_KH@Z"]
        pub fn SkString_insertUnichar(this: *mut root::SkString,
                                      offset: usize, arg1: root::SkUnichar);
    }
    extern "C" {
        #[link_name = "?insertS32@SkString@@QEAAX_KH@Z"]
        pub fn SkString_insertS32(this: *mut root::SkString, offset: usize,
                                  value: i32);
    }
    extern "C" {
        #[link_name = "?insertS64@SkString@@QEAAX_K_JH@Z"]
        pub fn SkString_insertS64(this: *mut root::SkString, offset: usize,
                                  value: i64,
                                  minDigits: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "?insertU32@SkString@@QEAAX_KI@Z"]
        pub fn SkString_insertU32(this: *mut root::SkString, offset: usize,
                                  value: u32);
    }
    extern "C" {
        #[link_name = "?insertU64@SkString@@QEAAX_K0H@Z"]
        pub fn SkString_insertU64(this: *mut root::SkString, offset: usize,
                                  value: u64,
                                  minDigits: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "?insertHex@SkString@@QEAAX_KIH@Z"]
        pub fn SkString_insertHex(this: *mut root::SkString, offset: usize,
                                  value: u32,
                                  minDigits: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "?insertScalar@SkString@@QEAAX_KM@Z"]
        pub fn SkString_insertScalar(this: *mut root::SkString, offset: usize,
                                     arg1: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?printf@SkString@@QEAAXQEBDZZ"]
        pub fn SkString_printf(this: *mut root::SkString,
                               format: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?appendf@SkString@@QEAAXQEBDZZ"]
        pub fn SkString_appendf(this: *mut root::SkString,
                                format: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?appendVAList@SkString@@QEAAXQEBDPEAD@Z"]
        pub fn SkString_appendVAList(this: *mut root::SkString,
                                     format: *const ::std::os::raw::c_char,
                                     arg1: root::va_list);
    }
    extern "C" {
        #[link_name = "?prependf@SkString@@QEAAXQEBDZZ"]
        pub fn SkString_prependf(this: *mut root::SkString,
                                 format: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?prependVAList@SkString@@QEAAXQEBDPEAD@Z"]
        pub fn SkString_prependVAList(this: *mut root::SkString,
                                      format: *const ::std::os::raw::c_char,
                                      arg1: root::va_list);
    }
    extern "C" {
        #[link_name = "?remove@SkString@@QEAAX_K0@Z"]
        pub fn SkString_remove(this: *mut root::SkString, offset: usize,
                               length: usize);
    }
    extern "C" {
        /**
     *  Swap contents between this and other. This function is guaranteed
     *  to never fail or throw.
     */
        #[link_name = "?swap@SkString@@QEAAXAEAV1@@Z"]
        pub fn SkString_swap(this: *mut root::SkString,
                             other: *mut root::SkString);
    }
    impl SkString {
        #[inline]
        pub unsafe fn equals(&self, arg1: *const root::SkString) -> bool {
            SkString_equals(&*self, arg1)
        }
        #[inline]
        pub unsafe fn equals1(&self, text: *const ::std::os::raw::c_char)
         -> bool {
            SkString_equals1(&*self, text)
        }
        #[inline]
        pub unsafe fn equals2(&self, text: *const ::std::os::raw::c_char,
                              len: usize) -> bool {
            SkString_equals2(&*self, text, len)
        }
        #[inline]
        pub unsafe fn writable_str(&mut self) -> *mut ::std::os::raw::c_char {
            SkString_writable_str(&mut *self)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkString_reset(&mut *self) }
        #[inline]
        pub unsafe fn set(&mut self, text: *const ::std::os::raw::c_char) {
            SkString_set(&mut *self, text)
        }
        #[inline]
        pub unsafe fn set1(&mut self, text: *const ::std::os::raw::c_char,
                           len: usize) {
            SkString_set1(&mut *self, text, len)
        }
        #[inline]
        pub unsafe fn setUTF16(&mut self, arg1: *const u16) {
            SkString_setUTF16(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setUTF161(&mut self, arg1: *const u16, len: usize) {
            SkString_setUTF161(&mut *self, arg1, len)
        }
        #[inline]
        pub unsafe fn insert(&mut self, offset: usize,
                             text: *const ::std::os::raw::c_char) {
            SkString_insert(&mut *self, offset, text)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, offset: usize,
                              text: *const ::std::os::raw::c_char,
                              len: usize) {
            SkString_insert1(&mut *self, offset, text, len)
        }
        #[inline]
        pub unsafe fn insertUnichar(&mut self, offset: usize,
                                    arg1: root::SkUnichar) {
            SkString_insertUnichar(&mut *self, offset, arg1)
        }
        #[inline]
        pub unsafe fn insertS32(&mut self, offset: usize, value: i32) {
            SkString_insertS32(&mut *self, offset, value)
        }
        #[inline]
        pub unsafe fn insertS64(&mut self, offset: usize, value: i64,
                                minDigits: ::std::os::raw::c_int) {
            SkString_insertS64(&mut *self, offset, value, minDigits)
        }
        #[inline]
        pub unsafe fn insertU32(&mut self, offset: usize, value: u32) {
            SkString_insertU32(&mut *self, offset, value)
        }
        #[inline]
        pub unsafe fn insertU64(&mut self, offset: usize, value: u64,
                                minDigits: ::std::os::raw::c_int) {
            SkString_insertU64(&mut *self, offset, value, minDigits)
        }
        #[inline]
        pub unsafe fn insertHex(&mut self, offset: usize, value: u32,
                                minDigits: ::std::os::raw::c_int) {
            SkString_insertHex(&mut *self, offset, value, minDigits)
        }
        #[inline]
        pub unsafe fn insertScalar(&mut self, offset: usize,
                                   arg1: root::SkScalar) {
            SkString_insertScalar(&mut *self, offset, arg1)
        }
        #[inline]
        pub unsafe fn printf(&mut self,
                             format: *const ::std::os::raw::c_char) {
            SkString_printf(&mut *self, format)
        }
        #[inline]
        pub unsafe fn appendf(&mut self,
                              format: *const ::std::os::raw::c_char) {
            SkString_appendf(&mut *self, format)
        }
        #[inline]
        pub unsafe fn appendVAList(&mut self,
                                   format: *const ::std::os::raw::c_char,
                                   arg1: root::va_list) {
            SkString_appendVAList(&mut *self, format, arg1)
        }
        #[inline]
        pub unsafe fn prependf(&mut self,
                               format: *const ::std::os::raw::c_char) {
            SkString_prependf(&mut *self, format)
        }
        #[inline]
        pub unsafe fn prependVAList(&mut self,
                                    format: *const ::std::os::raw::c_char,
                                    arg1: root::va_list) {
            SkString_prependVAList(&mut *self, format, arg1)
        }
        #[inline]
        pub unsafe fn remove(&mut self, offset: usize, length: usize) {
            SkString_remove(&mut *self, offset, length)
        }
        #[inline]
        pub unsafe fn swap(&mut self, other: *mut root::SkString) {
            SkString_swap(&mut *self, other)
        }
    }
    /**
 *  Fast type for unsigned 8 bits. Use for parameter passing and local
 *  variables, not for storage
 */
    pub type U8CPU = ::std::os::raw::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct _iobuf {
        pub _Placeholder: *mut ::std::os::raw::c_void,
    }
    impl Clone for _iobuf {
        fn clone(&self) -> Self { *self }
    }
    pub type FILE = root::_iobuf;
    pub mod sktfitsin {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    /** 16 bit unsigned integer to hold a glyph index
*/
    pub type SkGlyphID = u16;
    #[repr(u8)]
    /**
 *  Indicates whether an allocation should count against a cache budget.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkBudgeted { kNo = 0, kYes = 1, }
    /** \class SkNoncopyable

SkNoncopyable is the base class for objects that do not want to
be copied. It hides its copy-constructor and its assignment-operator.
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkNoncopyable {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_SkNoncopyable() {
        assert_eq!(::std::mem::size_of::<SkNoncopyable>() , 1usize);
        assert_eq!(::std::mem::align_of::<SkNoncopyable>() , 1usize);
    }
    impl Clone for SkNoncopyable {
        fn clone(&self) -> Self { *self }
    }
    pub const SkFilterQuality_kLast_SkFilterQuality: root::SkFilterQuality =
        SkFilterQuality::kHigh_SkFilterQuality;
    #[repr(i32)]
    /**
 *  Controls how much filtering to be done when scaling/transforming complex colors
 *  e.g. images
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkFilterQuality {
        kNone_SkFilterQuality = 0,
        kLow_SkFilterQuality = 1,
        kMedium_SkFilterQuality = 2,
        kHigh_SkFilterQuality = 3,
    }
    /** \struct SkIPoint

    SkIPoint holds two 32 bit integer coordinates
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkIPoint {
        pub fX: i32,
        pub fY: i32,
    }
    #[test]
    fn bindgen_test_layout_SkIPoint() {
        assert_eq!(::std::mem::size_of::<SkIPoint>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkIPoint>() , 4usize);
    }
    extern "C" {
        /** Rotate the point clockwise, writing the new point into dst
        It is legal for dst == this
    */
        #[link_name = "?rotateCW@SkIPoint@@QEBAXPEAU1@@Z"]
        pub fn SkIPoint_rotateCW(this: *const root::SkIPoint,
                                 dst: *mut root::SkIPoint);
    }
    extern "C" {
        /** Rotate the point counter-clockwise, writing the new point into dst.
        It is legal for dst == this
    */
        #[link_name = "?rotateCCW@SkIPoint@@QEBAXPEAU1@@Z"]
        pub fn SkIPoint_rotateCCW(this: *const root::SkIPoint,
                                  dst: *mut root::SkIPoint);
    }
    impl Clone for SkIPoint {
        fn clone(&self) -> Self { *self }
    }
    impl SkIPoint {
        #[inline]
        pub unsafe fn rotateCW(&self, dst: *mut root::SkIPoint) {
            SkIPoint_rotateCW(&*self, dst)
        }
        #[inline]
        pub unsafe fn rotateCCW(&self, dst: *mut root::SkIPoint) {
            SkIPoint_rotateCCW(&*self, dst)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPoint {
        pub fX: root::SkScalar,
        pub fY: root::SkScalar,
    }
    #[repr(i32)]
    /**
     * The side of a point relative to a line. If the line is from a to b then
     * the values are consistent with the sign of (b-a) cross (pt-a)
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPoint_Side { kLeft_Side = -1, kOn_Side = 0, kRight_Side = 1, }
    #[test]
    fn bindgen_test_layout_SkPoint() {
        assert_eq!(::std::mem::size_of::<SkPoint>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkPoint>() , 4usize);
    }
    extern "C" {
        #[link_name = "?setIRectFan@SkPoint@@QEAAXHHHH_K@Z"]
        pub fn SkPoint_setIRectFan(this: *mut root::SkPoint,
                                   l: ::std::os::raw::c_int,
                                   t: ::std::os::raw::c_int,
                                   r: ::std::os::raw::c_int,
                                   b: ::std::os::raw::c_int, stride: usize);
    }
    extern "C" {
        /** Set the point (vector) to be unit-length in the same direction as it
        already points.  If the point has a degenerate length (i.e. nearly 0)
        then set it to (0,0) and return false; otherwise return true.
    */
        #[link_name = "?normalize@SkPoint@@QEAA_NXZ"]
        pub fn SkPoint_normalize(this: *mut root::SkPoint) -> bool;
    }
    extern "C" {
        /** Set the point (vector) to be unit-length in the same direction as the
        x,y params. If the vector (x,y) has a degenerate length (i.e. nearly 0)
        then set it to (0,0) and return false, otherwise return true.
    */
        #[link_name = "?setNormalize@SkPoint@@QEAA_NMM@Z"]
        pub fn SkPoint_setNormalize(this: *mut root::SkPoint,
                                    x: root::SkScalar, y: root::SkScalar)
         -> bool;
    }
    extern "C" {
        /** Scale the point (vector) to have the specified length, and return that
        length. If the original length is degenerately small (nearly zero),
        set it to (0,0) and return false, otherwise return true.
    */
        #[link_name = "?setLength@SkPoint@@QEAA_NM@Z"]
        pub fn SkPoint_setLength(this: *mut root::SkPoint,
                                 length: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Set the point (vector) to have the specified length in the same
     direction as (x,y). If the vector (x,y) has a degenerate length
     (i.e. nearly 0) then set it to (0,0) and return false, otherwise return true.
    */
        #[link_name = "?setLength@SkPoint@@QEAA_NMMM@Z"]
        pub fn SkPoint_setLength1(this: *mut root::SkPoint, x: root::SkScalar,
                                  y: root::SkScalar, length: root::SkScalar)
         -> bool;
    }
    extern "C" {
        /** Same as setLength, but favoring speed over accuracy.
    */
        #[link_name = "?setLengthFast@SkPoint@@QEAA_NM@Z"]
        pub fn SkPoint_setLengthFast(this: *mut root::SkPoint,
                                     length: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Same as setLength, but favoring speed over accuracy.
    */
        #[link_name = "?setLengthFast@SkPoint@@QEAA_NMMM@Z"]
        pub fn SkPoint_setLengthFast1(this: *mut root::SkPoint,
                                      x: root::SkScalar, y: root::SkScalar,
                                      length: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Scale the point's coordinates by scale, writing the answer into dst.
        It is legal for dst == this.
    */
        #[link_name = "?scale@SkPoint@@QEBAXMPEAU1@@Z"]
        pub fn SkPoint_scale(this: *const root::SkPoint,
                             scale: root::SkScalar, dst: *mut root::SkPoint);
    }
    extern "C" {
        /** Rotate the point clockwise by 90 degrees, writing the answer into dst.
        It is legal for dst == this.
    */
        #[link_name = "?rotateCW@SkPoint@@QEBAXPEAU1@@Z"]
        pub fn SkPoint_rotateCW(this: *const root::SkPoint,
                                dst: *mut root::SkPoint);
    }
    extern "C" {
        /** Rotate the point counter-clockwise by 90 degrees, writing the answer
        into dst. It is legal for dst == this.
    */
        #[link_name = "?rotateCCW@SkPoint@@QEBAXPEAU1@@Z"]
        pub fn SkPoint_rotateCCW(this: *const root::SkPoint,
                                 dst: *mut root::SkPoint);
    }
    extern "C" {
        /** Returns the euclidian distance from (0,0) to (x,y)
    */
        #[link_name = "?Length@SkPoint@@SAMMM@Z"]
        pub fn SkPoint_Length(x: root::SkScalar, y: root::SkScalar)
         -> root::SkScalar;
    }
    extern "C" {
        /** Normalize pt, returning its previous length. If the prev length is too
        small (degenerate), set pt to (0,0) and return 0. This uses the same
        tolerance as CanNormalize.

        Note that this method may be significantly more expensive than
        the non-static normalize(), because it has to return the previous length
        of the point.  If you don't need the previous length, call the
        non-static normalize() method instead.
     */
        #[link_name = "?Normalize@SkPoint@@SAMPEAU1@@Z"]
        pub fn SkPoint_Normalize(pt: *mut root::SkPoint) -> root::SkScalar;
    }
    extern "C" {
        /**
     * Returns the squared distance to the infinite line between two pts. Also
     * optionally returns the side of the line that the pt falls on (looking
     * along line from a to b)
     */
        #[link_name =
              "?distanceToLineBetweenSqd@SkPoint@@QEBAMAEBU1@0PEAW4Side@1@@Z"]
        pub fn SkPoint_distanceToLineBetweenSqd(this: *const root::SkPoint,
                                                a: *const root::SkPoint,
                                                b: *const root::SkPoint,
                                                side: *mut root::SkPoint_Side)
         -> root::SkScalar;
    }
    extern "C" {
        /**
     * Returns the squared distance to the line segment between pts a and b
     */
        #[link_name =
              "?distanceToLineSegmentBetweenSqd@SkPoint@@QEBAMAEBU1@0@Z"]
        pub fn SkPoint_distanceToLineSegmentBetweenSqd(this:
                                                           *const root::SkPoint,
                                                       a:
                                                           *const root::SkPoint,
                                                       b:
                                                           *const root::SkPoint)
         -> root::SkScalar;
    }
    impl Clone for SkPoint {
        fn clone(&self) -> Self { *self }
    }
    impl SkPoint {
        #[inline]
        pub unsafe fn setIRectFan(&mut self, l: ::std::os::raw::c_int,
                                  t: ::std::os::raw::c_int,
                                  r: ::std::os::raw::c_int,
                                  b: ::std::os::raw::c_int, stride: usize) {
            SkPoint_setIRectFan(&mut *self, l, t, r, b, stride)
        }
        #[inline]
        pub unsafe fn normalize(&mut self) -> bool {
            SkPoint_normalize(&mut *self)
        }
        #[inline]
        pub unsafe fn setNormalize(&mut self, x: root::SkScalar,
                                   y: root::SkScalar) -> bool {
            SkPoint_setNormalize(&mut *self, x, y)
        }
        #[inline]
        pub unsafe fn setLength(&mut self, length: root::SkScalar) -> bool {
            SkPoint_setLength(&mut *self, length)
        }
        #[inline]
        pub unsafe fn setLength1(&mut self, x: root::SkScalar,
                                 y: root::SkScalar, length: root::SkScalar)
         -> bool {
            SkPoint_setLength1(&mut *self, x, y, length)
        }
        #[inline]
        pub unsafe fn setLengthFast(&mut self, length: root::SkScalar)
         -> bool {
            SkPoint_setLengthFast(&mut *self, length)
        }
        #[inline]
        pub unsafe fn setLengthFast1(&mut self, x: root::SkScalar,
                                     y: root::SkScalar,
                                     length: root::SkScalar) -> bool {
            SkPoint_setLengthFast1(&mut *self, x, y, length)
        }
        #[inline]
        pub unsafe fn scale(&self, scale: root::SkScalar,
                            dst: *mut root::SkPoint) {
            SkPoint_scale(&*self, scale, dst)
        }
        #[inline]
        pub unsafe fn rotateCW(&self, dst: *mut root::SkPoint) {
            SkPoint_rotateCW(&*self, dst)
        }
        #[inline]
        pub unsafe fn rotateCCW(&self, dst: *mut root::SkPoint) {
            SkPoint_rotateCCW(&*self, dst)
        }
        #[inline]
        pub unsafe fn Length(x: root::SkScalar, y: root::SkScalar)
         -> root::SkScalar {
            SkPoint_Length(x, y)
        }
        #[inline]
        pub unsafe fn Normalize(pt: *mut root::SkPoint) -> root::SkScalar {
            SkPoint_Normalize(pt)
        }
        #[inline]
        pub unsafe fn distanceToLineBetweenSqd(&self, a: *const root::SkPoint,
                                               b: *const root::SkPoint,
                                               side: *mut root::SkPoint_Side)
         -> root::SkScalar {
            SkPoint_distanceToLineBetweenSqd(&*self, a, b, side)
        }
        #[inline]
        pub unsafe fn distanceToLineSegmentBetweenSqd(&self,
                                                      a: *const root::SkPoint,
                                                      b: *const root::SkPoint)
         -> root::SkScalar {
            SkPoint_distanceToLineSegmentBetweenSqd(&*self, a, b)
        }
    }
    pub type SkVector = root::SkPoint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct SkTSize<T> {
        pub fWidth: T,
        pub fHeight: T,
    }
    ///////////////////////////////////////////////////////////////////////////////
    pub type SkISize = root::SkTSize<::std::os::raw::c_int>;
    #[test]
    fn __bindgen_test_layout_template_1() {
        assert_eq!(::std::mem::size_of::<root::SkTSize<f32>>() , 8usize);
        assert_eq!(::std::mem::align_of::<root::SkTSize<f32>>() , 4usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkSize {
        pub _base: root::SkTSize<f32>,
    }
    #[test]
    fn bindgen_test_layout_SkSize() {
        assert_eq!(::std::mem::size_of::<SkSize>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkSize>() , 4usize);
    }
    impl Clone for SkSize {
        fn clone(&self) -> Self { *self }
    }
    /** \struct SkRect
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRect {
        pub fLeft: root::SkScalar,
        pub fTop: root::SkScalar,
        pub fRight: root::SkScalar,
        pub fBottom: root::SkScalar,
    }
    #[test]
    fn bindgen_test_layout_SkRect() {
        assert_eq!(::std::mem::size_of::<SkRect>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkRect>() , 4usize);
    }
    extern "C" {
        /** return the 4 points that enclose the rectangle (top-left, top-right, bottom-right,
        bottom-left). TODO: Consider adding param to control whether quad is CW or CCW.
     */
        #[link_name = "?toQuad@SkRect@@QEBAXQEAUSkPoint@@@Z"]
        pub fn SkRect_toQuad(this: *const root::SkRect,
                             quad: *mut root::SkPoint);
    }
    extern "C" {
        /**
     *  Compute the bounds of the array of points, and set this rect to that
     *  bounds and return true... unless a non-finite value is encountered,
     *  in which case this rect is set to empty and false is returned.
     */
        #[link_name = "?setBoundsCheck@SkRect@@QEAA_NQEBUSkPoint@@H@Z"]
        pub fn SkRect_setBoundsCheck(this: *mut root::SkRect,
                                     pts: *const root::SkPoint,
                                     count: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** If this rectangle intersects r, return true and set this rectangle to that
        intersection, otherwise return false and do not change this rectangle.
        If either rectangle is empty, do nothing and return false.
    */
        #[link_name = "?intersect@SkRect@@QEAA_NAEBU1@@Z"]
        pub fn SkRect_intersect(this: *mut root::SkRect,
                                r: *const root::SkRect) -> bool;
    }
    extern "C" {
        /** If this rectangle intersects the rectangle specified by left, top, right, bottom,
        return true and set this rectangle to that intersection, otherwise return false
        and do not change this rectangle.
        If either rectangle is empty, do nothing and return false.
    */
        #[link_name = "?intersect@SkRect@@QEAA_NMMMM@Z"]
        pub fn SkRect_intersect1(this: *mut root::SkRect,
                                 left: root::SkScalar, top: root::SkScalar,
                                 right: root::SkScalar,
                                 bottom: root::SkScalar) -> bool;
    }
    extern "C" {
        /**
     *  If rectangles a and b intersect, return true and set this rectangle to
     *  that intersection, otherwise return false and do not change this
     *  rectangle. If either rectangle is empty, do nothing and return false.
     */
        #[link_name = "?intersect@SkRect@@QEAA_NAEBU1@0@Z"]
        pub fn SkRect_intersect2(this: *mut root::SkRect,
                                 a: *const root::SkRect,
                                 b: *const root::SkRect) -> bool;
    }
    extern "C" {
        /**
     *  Update this rectangle to enclose itself and the specified rectangle.
     *  If this rectangle is empty, just set it to the specified rectangle.
     *  If the specified rectangle is empty, do nothing.
     */
        #[link_name = "?join@SkRect@@QEAAXMMMM@Z"]
        pub fn SkRect_join(this: *mut root::SkRect, left: root::SkScalar,
                           top: root::SkScalar, right: root::SkScalar,
                           bottom: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?dump@SkRect@@QEBAX_N@Z"]
        pub fn SkRect_dump(this: *const root::SkRect, asHex: bool);
    }
    impl Clone for SkRect {
        fn clone(&self) -> Self { *self }
    }
    impl SkRect {
        #[inline]
        pub unsafe fn toQuad(&self, quad: *mut root::SkPoint) {
            SkRect_toQuad(&*self, quad)
        }
        #[inline]
        pub unsafe fn setBoundsCheck(&mut self, pts: *const root::SkPoint,
                                     count: ::std::os::raw::c_int) -> bool {
            SkRect_setBoundsCheck(&mut *self, pts, count)
        }
        #[inline]
        pub unsafe fn intersect(&mut self, r: *const root::SkRect) -> bool {
            SkRect_intersect(&mut *self, r)
        }
        #[inline]
        pub unsafe fn intersect1(&mut self, left: root::SkScalar,
                                 top: root::SkScalar, right: root::SkScalar,
                                 bottom: root::SkScalar) -> bool {
            SkRect_intersect1(&mut *self, left, top, right, bottom)
        }
        #[inline]
        pub unsafe fn intersect2(&mut self, a: *const root::SkRect,
                                 b: *const root::SkRect) -> bool {
            SkRect_intersect2(&mut *self, a, b)
        }
        #[inline]
        pub unsafe fn join(&mut self, left: root::SkScalar,
                           top: root::SkScalar, right: root::SkScalar,
                           bottom: root::SkScalar) {
            SkRect_join(&mut *self, left, top, right, bottom)
        }
        #[inline]
        pub unsafe fn dump(&self, asHex: bool) { SkRect_dump(&*self, asHex) }
    }
    /** \struct SkIRect

    SkIRect holds four 32 bit integer coordinates for a rectangle
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkIRect {
        pub fLeft: i32,
        pub fTop: i32,
        pub fRight: i32,
        pub fBottom: i32,
    }
    #[test]
    fn bindgen_test_layout_SkIRect() {
        assert_eq!(::std::mem::size_of::<SkIRect>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkIRect>() , 4usize);
    }
    extern "C" {
        /** Returns true if the specified rectangle r is inside or equal to this rectangle.
    */
        #[link_name = "?contains@SkIRect@@QEBA_NAEBUSkRect@@@Z"]
        pub fn SkIRect_contains(this: *const root::SkIRect,
                                r: *const root::SkRect) -> bool;
    }
    extern "C" {
        /** Update this rectangle to enclose itself and the specified rectangle.
        If this rectangle is empty, just set it to the specified rectangle. If the specified
        rectangle is empty, do nothing.
    */
        #[link_name = "?join@SkIRect@@QEAAXHHHH@Z"]
        pub fn SkIRect_join(this: *mut root::SkIRect, left: i32, top: i32,
                            right: i32, bottom: i32);
    }
    extern "C" {
        /** Swap top/bottom or left/right if there are flipped.
        This can be called if the edges are computed separately,
        and may have crossed over each other.
        When this returns, left <= right && top <= bottom
    */
        #[link_name = "?sort@SkIRect@@QEAAXXZ"]
        pub fn SkIRect_sort(this: *mut root::SkIRect);
    }
    impl Clone for SkIRect {
        fn clone(&self) -> Self { *self }
    }
    impl SkIRect {
        #[inline]
        pub unsafe fn contains(&self, r: *const root::SkRect) -> bool {
            SkIRect_contains(&*self, r)
        }
        #[inline]
        pub unsafe fn join(&mut self, left: i32, top: i32, right: i32,
                           bottom: i32) {
            SkIRect_join(&mut *self, left, top, right, bottom)
        }
        #[inline]
        pub unsafe fn sort(&mut self) { SkIRect_sort(&mut *self) }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRSXform {
        pub _address: u8,
    }
    impl Clone for SkRSXform {
        fn clone(&self) -> Self { *self }
    }
    /** \class SkMatrix

    The SkMatrix class holds a 3x3 matrix for transforming coordinates.
    SkMatrix does not have a constructor, so it must be explicitly initialized
    using either reset() - to construct an identity matrix, or one of the set
    functions (e.g. setTranslate, setRotate, etc.).
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMatrix {
        pub fMat: [root::SkScalar; 9usize],
        pub fTypeMask: u32,
    }
    #[repr(i32)]
    /** Enum of bit fields for the mask return by getType().
        Use this to identify the complexity of the matrix.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix_TypeMask {
        kIdentity_Mask = 0,
        kTranslate_Mask = 1,
        kScale_Mask = 2,
        kAffine_Mask = 4,
        kPerspective_Mask = 8,
    }
    pub const SkMatrix_kMScaleX: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMScaleX;
    pub const SkMatrix_kMSkewX: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMSkewX;
    pub const SkMatrix_kMTransX: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMTransX;
    pub const SkMatrix_kMSkewY: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMSkewY;
    pub const SkMatrix_kMScaleY: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMScaleY;
    pub const SkMatrix_kMTransY: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMTransY;
    pub const SkMatrix_kMPersp0: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMPersp0;
    pub const SkMatrix_kMPersp1: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMPersp1;
    pub const SkMatrix_kMPersp2: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMPersp2;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix__bindgen_ty_1 {
        kMScaleX = 0,
        kMSkewX = 1,
        kMTransX = 2,
        kMSkewY = 3,
        kMScaleY = 4,
        kMTransY = 5,
        kMPersp0 = 6,
        kMPersp1 = 7,
        kMPersp2 = 8,
    }
    pub const SkMatrix_kAScaleX: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kAScaleX;
    pub const SkMatrix_kASkewY: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kASkewY;
    pub const SkMatrix_kASkewX: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kASkewX;
    pub const SkMatrix_kAScaleY: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kAScaleY;
    pub const SkMatrix_kATransX: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kATransX;
    pub const SkMatrix_kATransY: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kATransY;
    #[repr(i32)]
    /** Affine arrays are in column major order
        because that's how PDF and XPS like it.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix__bindgen_ty_2 {
        kAScaleX = 0,
        kASkewY = 1,
        kASkewX = 2,
        kAScaleY = 3,
        kATransX = 4,
        kATransY = 5,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix_ScaleToFit {
        kFill_ScaleToFit = 0,
        kStart_ScaleToFit = 1,
        kCenter_ScaleToFit = 2,
        kEnd_ScaleToFit = 3,
    }
    pub type SkMatrix_MapXYProc =
        ::std::option::Option<unsafe extern "C" fn(mat: *const root::SkMatrix,
                                                   x: root::SkScalar,
                                                   y: root::SkScalar,
                                                   result:
                                                       *mut root::SkPoint)>;
    pub type SkMatrix_MapPtsProc =
        ::std::option::Option<unsafe extern "C" fn(mat: *const root::SkMatrix,
                                                   dst: *mut root::SkPoint,
                                                   src: *const root::SkPoint,
                                                   count:
                                                       ::std::os::raw::c_int)>;
    pub const SkMatrix_kMaxFlattenSize: root::SkMatrix__bindgen_ty_3 =
        SkMatrix__bindgen_ty_3::kMaxFlattenSize;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix__bindgen_ty_3 { kMaxFlattenSize = 40, }
    pub const SkMatrix_kRectStaysRect_Mask: root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kRectStaysRect_Mask;
    pub const SkMatrix_kOnlyPerspectiveValid_Mask:
              root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kOnlyPerspectiveValid_Mask;
    pub const SkMatrix_kUnknown_Mask: root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kUnknown_Mask;
    pub const SkMatrix_kORableMasks: root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kORableMasks;
    pub const SkMatrix_kAllMasks: root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kAllMasks;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix__bindgen_ty_4 {
        kRectStaysRect_Mask = 16,
        kOnlyPerspectiveValid_Mask = 64,
        kUnknown_Mask = 128,
        kORableMasks = 15,
        kAllMasks = 31,
    }
    extern "C" {
        #[link_name =
              "?gMapXYProcs@SkMatrix@@0QBQ6AXAEBV1@MMPEAUSkPoint@@@ZB"]
        pub static mut SkMatrix_gMapXYProcs: *const root::SkMatrix_MapXYProc;
    }
    extern "C" {
        #[link_name =
              "?gMapPtsProcs@SkMatrix@@0QBQ6AXAEBV1@QEAUSkPoint@@QEBU2@H@ZB"]
        pub static mut SkMatrix_gMapPtsProcs:
                   *const root::SkMatrix_MapPtsProc;
    }
    #[test]
    fn bindgen_test_layout_SkMatrix() {
        assert_eq!(::std::mem::size_of::<SkMatrix>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkMatrix>() , 4usize);
    }
    extern "C" {
        /** Returns true if the matrix contains only translation, rotation/reflection or uniform scale
        Returns false if other transformation types are included or is degenerate
     */
        #[link_name = "?isSimilarity@SkMatrix@@QEBA_NM@Z"]
        pub fn SkMatrix_isSimilarity(this: *const root::SkMatrix,
                                     tol: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Returns true if the matrix contains only translation, rotation/reflection or scale
        (non-uniform scale is allowed).
        Returns false if other transformation types are included or is degenerate
     */
        #[link_name = "?preservesRightAngles@SkMatrix@@QEBA_NM@Z"]
        pub fn SkMatrix_preservesRightAngles(this: *const root::SkMatrix,
                                             tol: root::SkScalar) -> bool;
    }
    extern "C" {
        /**
     *  Set this matrix to the 9 scalars from the buffer, in the same order as the kMScaleX
     *  enum... scalex, skewx, transx, skewy, scaley, transy, persp0, persp1, persp2
     *
     *  Note: calling set9 followed by get9 may not return the exact same values. Since the matrix
     *  is used to map non-homogeneous coordinates, it is free to rescale the 9 values as needed.
     */
        #[link_name = "?set9@SkMatrix@@QEAAXQEBM@Z"]
        pub fn SkMatrix_set9(this: *mut root::SkMatrix,
                             buffer: *mut root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to identity
    */
        #[link_name = "?reset@SkMatrix@@QEAAXXZ"]
        pub fn SkMatrix_reset(this: *mut root::SkMatrix);
    }
    extern "C" {
        /** Set the matrix to translate by (dx, dy).
    */
        #[link_name = "?setTranslate@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_setTranslate(this: *mut root::SkMatrix,
                                     dx: root::SkScalar, dy: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to scale by sx and sy, with a pivot point at (px, py).
        The pivot point is the coordinate that should remain unchanged by the
        specified transformation.
    */
        #[link_name = "?setScale@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_setScale(this: *mut root::SkMatrix,
                                 sx: root::SkScalar, sy: root::SkScalar,
                                 px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to scale by sx and sy.
    */
        #[link_name = "?setScale@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_setScale1(this: *mut root::SkMatrix,
                                  sx: root::SkScalar, sy: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to scale by 1/divx and 1/divy. Returns false and doesn't
        touch the matrix if either divx or divy is zero.
    */
        #[link_name = "?setIDiv@SkMatrix@@QEAA_NHH@Z"]
        pub fn SkMatrix_setIDiv(this: *mut root::SkMatrix,
                                divx: ::std::os::raw::c_int,
                                divy: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** Set the matrix to rotate by the specified number of degrees, with a
        pivot point at (px, py). The pivot point is the coordinate that should
        remain unchanged by the specified transformation.
    */
        #[link_name = "?setRotate@SkMatrix@@QEAAXMMM@Z"]
        pub fn SkMatrix_setRotate(this: *mut root::SkMatrix,
                                  degrees: root::SkScalar, px: root::SkScalar,
                                  py: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to rotate about (0,0) by the specified number of degrees.
    */
        #[link_name = "?setRotate@SkMatrix@@QEAAXM@Z"]
        pub fn SkMatrix_setRotate1(this: *mut root::SkMatrix,
                                   degrees: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to rotate by the specified sine and cosine values, with
        a pivot point at (px, py). The pivot point is the coordinate that
        should remain unchanged by the specified transformation.
    */
        #[link_name = "?setSinCos@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_setSinCos(this: *mut root::SkMatrix,
                                  sinValue: root::SkScalar,
                                  cosValue: root::SkScalar,
                                  px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to rotate by the specified sine and cosine values.
    */
        #[link_name = "?setSinCos@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_setSinCos1(this: *mut root::SkMatrix,
                                   sinValue: root::SkScalar,
                                   cosValue: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?setRSXform@SkMatrix@@QEAAAEAV1@AEBUSkRSXform@@@Z"]
        pub fn SkMatrix_setRSXform(this: *mut root::SkMatrix,
                                   arg1: *const root::SkRSXform)
         -> *mut root::SkMatrix;
    }
    extern "C" {
        /** Set the matrix to skew by sx and sy, with a pivot point at (px, py).
        The pivot point is the coordinate that should remain unchanged by the
        specified transformation.
    */
        #[link_name = "?setSkew@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_setSkew(this: *mut root::SkMatrix, kx: root::SkScalar,
                                ky: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to skew by sx and sy.
    */
        #[link_name = "?setSkew@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_setSkew1(this: *mut root::SkMatrix,
                                 kx: root::SkScalar, ky: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to the concatenation of the two specified matrices.
        Either of the two matrices may also be the target matrix.
        *this = a * b;
    */
        #[link_name = "?setConcat@SkMatrix@@QEAAXAEBV1@0@Z"]
        pub fn SkMatrix_setConcat(this: *mut root::SkMatrix,
                                  a: *const root::SkMatrix,
                                  b: *const root::SkMatrix);
    }
    extern "C" {
        /** Preconcats the matrix with the specified translation.
        M' = M * T(dx, dy)
    */
        #[link_name = "?preTranslate@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_preTranslate(this: *mut root::SkMatrix,
                                     dx: root::SkScalar, dy: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified scale.
        M' = M * S(sx, sy, px, py)
    */
        #[link_name = "?preScale@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_preScale(this: *mut root::SkMatrix,
                                 sx: root::SkScalar, sy: root::SkScalar,
                                 px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified scale.
        M' = M * S(sx, sy)
    */
        #[link_name = "?preScale@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_preScale1(this: *mut root::SkMatrix,
                                  sx: root::SkScalar, sy: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified rotation.
        M' = M * R(degrees, px, py)
    */
        #[link_name = "?preRotate@SkMatrix@@QEAAXMMM@Z"]
        pub fn SkMatrix_preRotate(this: *mut root::SkMatrix,
                                  degrees: root::SkScalar, px: root::SkScalar,
                                  py: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified rotation.
        M' = M * R(degrees)
    */
        #[link_name = "?preRotate@SkMatrix@@QEAAXM@Z"]
        pub fn SkMatrix_preRotate1(this: *mut root::SkMatrix,
                                   degrees: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified skew.
        M' = M * K(kx, ky, px, py)
    */
        #[link_name = "?preSkew@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_preSkew(this: *mut root::SkMatrix, kx: root::SkScalar,
                                ky: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified skew.
        M' = M * K(kx, ky)
    */
        #[link_name = "?preSkew@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_preSkew1(this: *mut root::SkMatrix,
                                 kx: root::SkScalar, ky: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified matrix.
        M' = M * other
    */
        #[link_name = "?preConcat@SkMatrix@@QEAAXAEBV1@@Z"]
        pub fn SkMatrix_preConcat(this: *mut root::SkMatrix,
                                  other: *const root::SkMatrix);
    }
    extern "C" {
        /** Postconcats the matrix with the specified translation.
        M' = T(dx, dy) * M
    */
        #[link_name = "?postTranslate@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_postTranslate(this: *mut root::SkMatrix,
                                      dx: root::SkScalar, dy: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified scale.
        M' = S(sx, sy, px, py) * M
    */
        #[link_name = "?postScale@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_postScale(this: *mut root::SkMatrix,
                                  sx: root::SkScalar, sy: root::SkScalar,
                                  px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified scale.
        M' = S(sx, sy) * M
    */
        #[link_name = "?postScale@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_postScale1(this: *mut root::SkMatrix,
                                   sx: root::SkScalar, sy: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix by dividing it by the specified integers.
        M' = S(1/divx, 1/divy, 0, 0) * M
    */
        #[link_name = "?postIDiv@SkMatrix@@QEAA_NHH@Z"]
        pub fn SkMatrix_postIDiv(this: *mut root::SkMatrix,
                                 divx: ::std::os::raw::c_int,
                                 divy: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** Postconcats the matrix with the specified rotation.
        M' = R(degrees, px, py) * M
    */
        #[link_name = "?postRotate@SkMatrix@@QEAAXMMM@Z"]
        pub fn SkMatrix_postRotate(this: *mut root::SkMatrix,
                                   degrees: root::SkScalar,
                                   px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified rotation.
        M' = R(degrees) * M
    */
        #[link_name = "?postRotate@SkMatrix@@QEAAXM@Z"]
        pub fn SkMatrix_postRotate1(this: *mut root::SkMatrix,
                                    degrees: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified skew.
        M' = K(kx, ky, px, py) * M
    */
        #[link_name = "?postSkew@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_postSkew(this: *mut root::SkMatrix,
                                 kx: root::SkScalar, ky: root::SkScalar,
                                 px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified skew.
        M' = K(kx, ky) * M
    */
        #[link_name = "?postSkew@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_postSkew1(this: *mut root::SkMatrix,
                                  kx: root::SkScalar, ky: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified matrix.
        M' = other * M
    */
        #[link_name = "?postConcat@SkMatrix@@QEAAXAEBV1@@Z"]
        pub fn SkMatrix_postConcat(this: *mut root::SkMatrix,
                                   other: *const root::SkMatrix);
    }
    extern "C" {
        /** Set the matrix to the scale and translate values that map the source
        rectangle to the destination rectangle, returning true if the the result
        can be represented.
        @param src the source rectangle to map from.
        @param dst the destination rectangle to map to.
        @param stf the ScaleToFit option
        @return true if the matrix can be represented by the rectangle mapping.
    */
        #[link_name =
              "?setRectToRect@SkMatrix@@QEAA_NAEBUSkRect@@0W4ScaleToFit@1@@Z"]
        pub fn SkMatrix_setRectToRect(this: *mut root::SkMatrix,
                                      src: *const root::SkRect,
                                      dst: *const root::SkRect,
                                      stf: root::SkMatrix_ScaleToFit) -> bool;
    }
    extern "C" {
        /** Set the matrix such that the specified src points would map to the
        specified dst points. count must be within [0..4].
        @param src  The array of src points
        @param dst  The array of dst points
        @param count The number of points to use for the transformation
        @return true if the matrix was set to the specified transformation
    */
        #[link_name = "?setPolyToPoly@SkMatrix@@QEAA_NQEBUSkPoint@@0H@Z"]
        pub fn SkMatrix_setPolyToPoly(this: *mut root::SkMatrix,
                                      src: *const root::SkPoint,
                                      dst: *const root::SkPoint,
                                      count: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** Fills the passed array with affine identity values
        in column major order.
        @param affine  The array to fill with affine identity values.
        Must not be NULL.
    */
        #[link_name = "?SetAffineIdentity@SkMatrix@@SAXQEAM@Z"]
        pub fn SkMatrix_SetAffineIdentity(affine: *mut root::SkScalar);
    }
    extern "C" {
        /** Fills the passed array with the affine values in column major order.
        If the matrix is a perspective transform, returns false
        and does not change the passed array.
        @param affine  The array to fill with affine values. Ignored if NULL.
    */
        #[link_name = "?asAffine@SkMatrix@@QEBA_NQEAM@Z"]
        pub fn SkMatrix_asAffine(this: *const root::SkMatrix,
                                 affine: *mut root::SkScalar) -> bool;
    }
    extern "C" {
        /** Set the matrix to the specified affine values.
     *  Note: these are passed in column major order.
     */
        #[link_name = "?setAffine@SkMatrix@@QEAAXQEBM@Z"]
        pub fn SkMatrix_setAffine(this: *mut root::SkMatrix,
                                  affine: *mut root::SkScalar);
    }
    extern "C" {
        /** Apply this matrix to the array of homogeneous points, specified by src,
        where a homogeneous point is defined by 3 contiguous scalar values,
        and write the transformed points into the array of scalars specified by dst.
        dst[] = M * src[]
        @param dst  Where the transformed coordinates are written. It must
                    contain at least 3 * count entries
        @param src  The original coordinates that are to be transformed. It
                    must contain at least 3 * count entries
        @param count The number of triples (homogeneous points) in src to read,
                     and then transform into dst.
    */
        #[link_name = "?mapHomogeneousPoints@SkMatrix@@QEBAXQEAMQEBMH@Z"]
        pub fn SkMatrix_mapHomogeneousPoints(this: *const root::SkMatrix,
                                             dst: *mut root::SkScalar,
                                             src: *const root::SkScalar,
                                             count: ::std::os::raw::c_int);
    }
    extern "C" {
        /** Apply this matrix to the array of vectors specified by src, and write
        the transformed vectors into the array of vectors specified by dst.
        This is similar to mapPoints, but ignores any translation in the matrix.
        @param dst  Where the transformed coordinates are written. It must
                    contain at least count entries
        @param src  The original coordinates that are to be transformed. It
                    must contain at least count entries
        @param count The number of vectors in src to read, and then transform
                     into dst.
    */
        #[link_name = "?mapVectors@SkMatrix@@QEBAXQEAUSkPoint@@QEBU2@H@Z"]
        pub fn SkMatrix_mapVectors(this: *const root::SkMatrix,
                                   dst: *mut root::SkVector,
                                   src: *const root::SkVector,
                                   count: ::std::os::raw::c_int);
    }
    extern "C" {
        /** Apply this matrix to the src rectangle, and write the transformed
        rectangle into dst. This is accomplished by transforming the 4 corners
        of src, and then setting dst to the bounds of those points.
        @param dst  Where the transformed rectangle is written.
        @param src  The original rectangle to be transformed.
        @return the result of calling rectStaysRect()
    */
        #[link_name = "?mapRect@SkMatrix@@QEBA_NPEAUSkRect@@AEBU2@@Z"]
        pub fn SkMatrix_mapRect(this: *const root::SkMatrix,
                                dst: *mut root::SkRect,
                                src: *const root::SkRect) -> bool;
    }
    extern "C" {
        /**
     *  Maps a rect to another rect, asserting (in debug mode) that the matrix only contains
     *  scale and translate elements. If it contains other elements, the results are undefined.
     */
        #[link_name =
              "?mapRectScaleTranslate@SkMatrix@@QEBAXPEAUSkRect@@AEBU2@@Z"]
        pub fn SkMatrix_mapRectScaleTranslate(this: *const root::SkMatrix,
                                              dst: *mut root::SkRect,
                                              src: *const root::SkRect);
    }
    extern "C" {
        /** Return the mean radius of a circle after it has been mapped by
        this matrix. NOTE: in perspective this value assumes the circle
        has its center at the origin.
    */
        #[link_name = "?mapRadius@SkMatrix@@QEBAMM@Z"]
        pub fn SkMatrix_mapRadius(this: *const root::SkMatrix,
                                  radius: root::SkScalar) -> root::SkScalar;
    }
    extern "C" {
        /** Returns true if the matrix can be stepped in X (not complex
        perspective).
    */
        #[link_name = "?isFixedStepInX@SkMatrix@@QEBA_NXZ"]
        pub fn SkMatrix_isFixedStepInX(this: *const root::SkMatrix) -> bool;
    }
    extern "C" {
        /** If the matrix can be stepped in X (not complex perspective)
        then return the step value.
        If it cannot, behavior is undefined.
    */
        #[link_name = "?fixedStepInX@SkMatrix@@QEBA?AUSkPoint@@M@Z"]
        pub fn SkMatrix_fixedStepInX(this: *const root::SkMatrix,
                                     y: root::SkScalar) -> root::SkVector;
    }
    extern "C" {
        #[link_name = "?writeToMemory@SkMatrix@@QEBA_KPEAX@Z"]
        pub fn SkMatrix_writeToMemory(this: *const root::SkMatrix,
                                      buffer: *mut ::std::os::raw::c_void)
         -> usize;
    }
    extern "C" {
        /**
     * Reads data from the buffer parameter
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
        #[link_name = "?readFromMemory@SkMatrix@@QEAA_KPEBX_K@Z"]
        pub fn SkMatrix_readFromMemory(this: *mut root::SkMatrix,
                                       buffer: *const ::std::os::raw::c_void,
                                       length: usize) -> usize;
    }
    extern "C" {
        #[link_name = "?dump@SkMatrix@@QEBAXXZ"]
        pub fn SkMatrix_dump(this: *const root::SkMatrix);
    }
    extern "C" {
        #[link_name = "?toString@SkMatrix@@QEBAXPEAVSkString@@@Z"]
        pub fn SkMatrix_toString(this: *const root::SkMatrix,
                                 arg1: *mut root::SkString);
    }
    extern "C" {
        /**
     * Calculates the minimum scaling factor of the matrix as computed from the SVD of the upper
     * left 2x2. If the max scale factor cannot be computed (for example overflow or perspective)
     * -1 is returned.
     *
     * @return minimum scale factor
     */
        #[link_name = "?getMinScale@SkMatrix@@QEBAMXZ"]
        pub fn SkMatrix_getMinScale(this: *const root::SkMatrix)
         -> root::SkScalar;
    }
    extern "C" {
        /**
     * Calculates the maximum scaling factor of the matrix as computed from the SVD of the upper
     * left 2x2. If the max scale factor cannot be computed (for example overflow or perspective)
     * -1 is returned.
     *
     * @return maximum scale factor
     */
        #[link_name = "?getMaxScale@SkMatrix@@QEBAMXZ"]
        pub fn SkMatrix_getMaxScale(this: *const root::SkMatrix)
         -> root::SkScalar;
    }
    extern "C" {
        /**
     * Gets both the min and max scale factors. The min scale factor is scaleFactors[0] and the max
     * is scaleFactors[1]. If the min/max scale factors cannot be computed false is returned and the
     * values of scaleFactors[] are undefined.
     */
        #[link_name = "?getMinMaxScales@SkMatrix@@QEBA_NQEAM@Z"]
        pub fn SkMatrix_getMinMaxScales(this: *const root::SkMatrix,
                                        scaleFactors: *mut root::SkScalar)
         -> bool;
    }
    extern "C" {
        /**
     *  Attempt to decompose this matrix into a scale-only component and whatever remains, where
     *  the scale component is to be applied first.
     *
     *  M -> Remaining * Scale
     *
     *  On success, return true and assign the scale and remaining components (assuming their
     *  respective parameters are not null). On failure return false and ignore the parameters.
     *
     *  Possible reasons to fail: perspective, one or more scale factors are zero.
     */
        #[link_name = "?decomposeScale@SkMatrix@@QEBA_NPEAUSkSize@@PEAV1@@Z"]
        pub fn SkMatrix_decomposeScale(this: *const root::SkMatrix,
                                       scale: *mut root::SkSize,
                                       remaining: *mut root::SkMatrix)
         -> bool;
    }
    extern "C" {
        /**
     *  Return a reference to a const identity matrix
     */
        #[link_name = "?I@SkMatrix@@SAAEBV1@XZ"]
        pub fn SkMatrix_I() -> *const root::SkMatrix;
    }
    extern "C" {
        /**
     *  Return a reference to a const matrix that is "invalid", one that could
     *  never be used.
     */
        #[link_name = "?InvalidMatrix@SkMatrix@@SAAEBV1@XZ"]
        pub fn SkMatrix_InvalidMatrix() -> *const root::SkMatrix;
    }
    impl Clone for SkMatrix {
        fn clone(&self) -> Self { *self }
    }
    impl SkMatrix {
        #[inline]
        pub unsafe fn isSimilarity(&self, tol: root::SkScalar) -> bool {
            SkMatrix_isSimilarity(&*self, tol)
        }
        #[inline]
        pub unsafe fn preservesRightAngles(&self, tol: root::SkScalar)
         -> bool {
            SkMatrix_preservesRightAngles(&*self, tol)
        }
        #[inline]
        pub unsafe fn set9(&mut self, buffer: *mut root::SkScalar) {
            SkMatrix_set9(&mut *self, buffer)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkMatrix_reset(&mut *self) }
        #[inline]
        pub unsafe fn setTranslate(&mut self, dx: root::SkScalar,
                                   dy: root::SkScalar) {
            SkMatrix_setTranslate(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn setScale(&mut self, sx: root::SkScalar,
                               sy: root::SkScalar, px: root::SkScalar,
                               py: root::SkScalar) {
            SkMatrix_setScale(&mut *self, sx, sy, px, py)
        }
        #[inline]
        pub unsafe fn setScale1(&mut self, sx: root::SkScalar,
                                sy: root::SkScalar) {
            SkMatrix_setScale1(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn setIDiv(&mut self, divx: ::std::os::raw::c_int,
                              divy: ::std::os::raw::c_int) -> bool {
            SkMatrix_setIDiv(&mut *self, divx, divy)
        }
        #[inline]
        pub unsafe fn setRotate(&mut self, degrees: root::SkScalar,
                                px: root::SkScalar, py: root::SkScalar) {
            SkMatrix_setRotate(&mut *self, degrees, px, py)
        }
        #[inline]
        pub unsafe fn setRotate1(&mut self, degrees: root::SkScalar) {
            SkMatrix_setRotate1(&mut *self, degrees)
        }
        #[inline]
        pub unsafe fn setSinCos(&mut self, sinValue: root::SkScalar,
                                cosValue: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar) {
            SkMatrix_setSinCos(&mut *self, sinValue, cosValue, px, py)
        }
        #[inline]
        pub unsafe fn setSinCos1(&mut self, sinValue: root::SkScalar,
                                 cosValue: root::SkScalar) {
            SkMatrix_setSinCos1(&mut *self, sinValue, cosValue)
        }
        #[inline]
        pub unsafe fn setRSXform(&mut self, arg1: *const root::SkRSXform)
         -> *mut root::SkMatrix {
            SkMatrix_setRSXform(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setSkew(&mut self, kx: root::SkScalar,
                              ky: root::SkScalar, px: root::SkScalar,
                              py: root::SkScalar) {
            SkMatrix_setSkew(&mut *self, kx, ky, px, py)
        }
        #[inline]
        pub unsafe fn setSkew1(&mut self, kx: root::SkScalar,
                               ky: root::SkScalar) {
            SkMatrix_setSkew1(&mut *self, kx, ky)
        }
        #[inline]
        pub unsafe fn setConcat(&mut self, a: *const root::SkMatrix,
                                b: *const root::SkMatrix) {
            SkMatrix_setConcat(&mut *self, a, b)
        }
        #[inline]
        pub unsafe fn preTranslate(&mut self, dx: root::SkScalar,
                                   dy: root::SkScalar) {
            SkMatrix_preTranslate(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn preScale(&mut self, sx: root::SkScalar,
                               sy: root::SkScalar, px: root::SkScalar,
                               py: root::SkScalar) {
            SkMatrix_preScale(&mut *self, sx, sy, px, py)
        }
        #[inline]
        pub unsafe fn preScale1(&mut self, sx: root::SkScalar,
                                sy: root::SkScalar) {
            SkMatrix_preScale1(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn preRotate(&mut self, degrees: root::SkScalar,
                                px: root::SkScalar, py: root::SkScalar) {
            SkMatrix_preRotate(&mut *self, degrees, px, py)
        }
        #[inline]
        pub unsafe fn preRotate1(&mut self, degrees: root::SkScalar) {
            SkMatrix_preRotate1(&mut *self, degrees)
        }
        #[inline]
        pub unsafe fn preSkew(&mut self, kx: root::SkScalar,
                              ky: root::SkScalar, px: root::SkScalar,
                              py: root::SkScalar) {
            SkMatrix_preSkew(&mut *self, kx, ky, px, py)
        }
        #[inline]
        pub unsafe fn preSkew1(&mut self, kx: root::SkScalar,
                               ky: root::SkScalar) {
            SkMatrix_preSkew1(&mut *self, kx, ky)
        }
        #[inline]
        pub unsafe fn preConcat(&mut self, other: *const root::SkMatrix) {
            SkMatrix_preConcat(&mut *self, other)
        }
        #[inline]
        pub unsafe fn postTranslate(&mut self, dx: root::SkScalar,
                                    dy: root::SkScalar) {
            SkMatrix_postTranslate(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn postScale(&mut self, sx: root::SkScalar,
                                sy: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar) {
            SkMatrix_postScale(&mut *self, sx, sy, px, py)
        }
        #[inline]
        pub unsafe fn postScale1(&mut self, sx: root::SkScalar,
                                 sy: root::SkScalar) {
            SkMatrix_postScale1(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn postIDiv(&mut self, divx: ::std::os::raw::c_int,
                               divy: ::std::os::raw::c_int) -> bool {
            SkMatrix_postIDiv(&mut *self, divx, divy)
        }
        #[inline]
        pub unsafe fn postRotate(&mut self, degrees: root::SkScalar,
                                 px: root::SkScalar, py: root::SkScalar) {
            SkMatrix_postRotate(&mut *self, degrees, px, py)
        }
        #[inline]
        pub unsafe fn postRotate1(&mut self, degrees: root::SkScalar) {
            SkMatrix_postRotate1(&mut *self, degrees)
        }
        #[inline]
        pub unsafe fn postSkew(&mut self, kx: root::SkScalar,
                               ky: root::SkScalar, px: root::SkScalar,
                               py: root::SkScalar) {
            SkMatrix_postSkew(&mut *self, kx, ky, px, py)
        }
        #[inline]
        pub unsafe fn postSkew1(&mut self, kx: root::SkScalar,
                                ky: root::SkScalar) {
            SkMatrix_postSkew1(&mut *self, kx, ky)
        }
        #[inline]
        pub unsafe fn postConcat(&mut self, other: *const root::SkMatrix) {
            SkMatrix_postConcat(&mut *self, other)
        }
        #[inline]
        pub unsafe fn setRectToRect(&mut self, src: *const root::SkRect,
                                    dst: *const root::SkRect,
                                    stf: root::SkMatrix_ScaleToFit) -> bool {
            SkMatrix_setRectToRect(&mut *self, src, dst, stf)
        }
        #[inline]
        pub unsafe fn setPolyToPoly(&mut self, src: *const root::SkPoint,
                                    dst: *const root::SkPoint,
                                    count: ::std::os::raw::c_int) -> bool {
            SkMatrix_setPolyToPoly(&mut *self, src, dst, count)
        }
        #[inline]
        pub unsafe fn SetAffineIdentity(affine: *mut root::SkScalar) {
            SkMatrix_SetAffineIdentity(affine)
        }
        #[inline]
        pub unsafe fn asAffine(&self, affine: *mut root::SkScalar) -> bool {
            SkMatrix_asAffine(&*self, affine)
        }
        #[inline]
        pub unsafe fn setAffine(&mut self, affine: *mut root::SkScalar) {
            SkMatrix_setAffine(&mut *self, affine)
        }
        #[inline]
        pub unsafe fn mapHomogeneousPoints(&self, dst: *mut root::SkScalar,
                                           src: *const root::SkScalar,
                                           count: ::std::os::raw::c_int) {
            SkMatrix_mapHomogeneousPoints(&*self, dst, src, count)
        }
        #[inline]
        pub unsafe fn mapVectors(&self, dst: *mut root::SkVector,
                                 src: *const root::SkVector,
                                 count: ::std::os::raw::c_int) {
            SkMatrix_mapVectors(&*self, dst, src, count)
        }
        #[inline]
        pub unsafe fn mapRect(&self, dst: *mut root::SkRect,
                              src: *const root::SkRect) -> bool {
            SkMatrix_mapRect(&*self, dst, src)
        }
        #[inline]
        pub unsafe fn mapRectScaleTranslate(&self, dst: *mut root::SkRect,
                                            src: *const root::SkRect) {
            SkMatrix_mapRectScaleTranslate(&*self, dst, src)
        }
        #[inline]
        pub unsafe fn mapRadius(&self, radius: root::SkScalar)
         -> root::SkScalar {
            SkMatrix_mapRadius(&*self, radius)
        }
        #[inline]
        pub unsafe fn isFixedStepInX(&self) -> bool {
            SkMatrix_isFixedStepInX(&*self)
        }
        #[inline]
        pub unsafe fn fixedStepInX(&self, y: root::SkScalar)
         -> root::SkVector {
            SkMatrix_fixedStepInX(&*self, y)
        }
        #[inline]
        pub unsafe fn writeToMemory(&self,
                                    buffer: *mut ::std::os::raw::c_void)
         -> usize {
            SkMatrix_writeToMemory(&*self, buffer)
        }
        #[inline]
        pub unsafe fn readFromMemory(&mut self,
                                     buffer: *const ::std::os::raw::c_void,
                                     length: usize) -> usize {
            SkMatrix_readFromMemory(&mut *self, buffer, length)
        }
        #[inline]
        pub unsafe fn dump(&self) { SkMatrix_dump(&*self) }
        #[inline]
        pub unsafe fn toString(&self, arg1: *mut root::SkString) {
            SkMatrix_toString(&*self, arg1)
        }
        #[inline]
        pub unsafe fn getMinScale(&self) -> root::SkScalar {
            SkMatrix_getMinScale(&*self)
        }
        #[inline]
        pub unsafe fn getMaxScale(&self) -> root::SkScalar {
            SkMatrix_getMaxScale(&*self)
        }
        #[inline]
        pub unsafe fn getMinMaxScales(&self,
                                      scaleFactors: *mut root::SkScalar)
         -> bool {
            SkMatrix_getMinMaxScales(&*self, scaleFactors)
        }
        #[inline]
        pub unsafe fn decomposeScale(&self, scale: *mut root::SkSize,
                                     remaining: *mut root::SkMatrix) -> bool {
            SkMatrix_decomposeScale(&*self, scale, remaining)
        }
        #[inline]
        pub unsafe fn I() -> *const root::SkMatrix { SkMatrix_I() }
        #[inline]
        pub unsafe fn InvalidMatrix() -> *const root::SkMatrix {
            SkMatrix_InvalidMatrix()
        }
    }
    pub type SkMScalar = f32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMatrix44 {
        pub fMat: [[root::SkMScalar; 4usize]; 4usize],
        pub fTypeMask: ::std::os::raw::c_uint,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix44_Uninitialized_Constructor {
        kUninitialized_Constructor = 0,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix44_Identity_Constructor { kIdentity_Constructor = 0, }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix44_TypeMask {
        kIdentity_Mask = 0,
        kTranslate_Mask = 1,
        kScale_Mask = 2,
        kAffine_Mask = 4,
        kPerspective_Mask = 8,
    }
    pub const SkMatrix44_kUnknown_Mask: root::SkMatrix44__bindgen_ty_1 =
        SkMatrix44__bindgen_ty_1::kUnknown_Mask;
    pub const SkMatrix44_kAllPublic_Masks: root::SkMatrix44__bindgen_ty_1 =
        SkMatrix44__bindgen_ty_1::kAllPublic_Masks;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix44__bindgen_ty_1 {
        kUnknown_Mask = 128,
        kAllPublic_Masks = 15,
    }
    #[test]
    fn bindgen_test_layout_SkMatrix44() {
        assert_eq!(::std::mem::size_of::<SkMatrix44>() , 68usize);
        assert_eq!(::std::mem::align_of::<SkMatrix44>() , 4usize);
    }
    extern "C" {
        /**
     *  Return a reference to a const identity matrix
     */
        #[link_name = "?I@SkMatrix44@@SAAEBV1@XZ"]
        pub fn SkMatrix44_I() -> *const root::SkMatrix44;
    }
    extern "C" {
        #[link_name = "?setIdentity@SkMatrix44@@QEAAXXZ"]
        pub fn SkMatrix44_setIdentity(this: *mut root::SkMatrix44);
    }
    extern "C" {
        /** These methods allow one to efficiently read matrix entries into an
     *  array. The given array must have room for exactly 16 entries. Whenever
     *  possible, they will try to use memcpy rather than an entry-by-entry
     *  copy.
     *
     *  Col major indicates that consecutive elements of columns will be stored
     *  contiguously in memory.  Row major indicates that consecutive elements
     *  of rows will be stored contiguously in memory.
     */
        #[link_name = "?asColMajorf@SkMatrix44@@QEBAXQEAM@Z"]
        pub fn SkMatrix44_asColMajorf(this: *const root::SkMatrix44,
                                      arg1: *mut f32);
    }
    extern "C" {
        #[link_name = "?asColMajord@SkMatrix44@@QEBAXQEAN@Z"]
        pub fn SkMatrix44_asColMajord(this: *const root::SkMatrix44,
                                      arg1: *mut f64);
    }
    extern "C" {
        #[link_name = "?asRowMajorf@SkMatrix44@@QEBAXQEAM@Z"]
        pub fn SkMatrix44_asRowMajorf(this: *const root::SkMatrix44,
                                      arg1: *mut f32);
    }
    extern "C" {
        #[link_name = "?asRowMajord@SkMatrix44@@QEBAXQEAN@Z"]
        pub fn SkMatrix44_asRowMajord(this: *const root::SkMatrix44,
                                      arg1: *mut f64);
    }
    extern "C" {
        /** These methods allow one to efficiently set all matrix entries from an
     *  array. The given array must have room for exactly 16 entries. Whenever
     *  possible, they will try to use memcpy rather than an entry-by-entry
     *  copy.
     *
     *  Col major indicates that input memory will be treated as if consecutive
     *  elements of columns are stored contiguously in memory.  Row major
     *  indicates that input memory will be treated as if consecutive elements
     *  of rows are stored contiguously in memory.
     */
        #[link_name = "?setColMajorf@SkMatrix44@@QEAAXQEBM@Z"]
        pub fn SkMatrix44_setColMajorf(this: *mut root::SkMatrix44,
                                       arg1: *const f32);
    }
    extern "C" {
        #[link_name = "?setColMajord@SkMatrix44@@QEAAXQEBN@Z"]
        pub fn SkMatrix44_setColMajord(this: *mut root::SkMatrix44,
                                       arg1: *const f64);
    }
    extern "C" {
        #[link_name = "?setRowMajorf@SkMatrix44@@QEAAXQEBM@Z"]
        pub fn SkMatrix44_setRowMajorf(this: *mut root::SkMatrix44,
                                       arg1: *const f32);
    }
    extern "C" {
        #[link_name = "?setRowMajord@SkMatrix44@@QEAAXQEBN@Z"]
        pub fn SkMatrix44_setRowMajord(this: *mut root::SkMatrix44,
                                       arg1: *const f64);
    }
    extern "C" {
        #[link_name = "?set3x3@SkMatrix44@@QEAAXMMMMMMMMM@Z"]
        pub fn SkMatrix44_set3x3(this: *mut root::SkMatrix44,
                                 m00: root::SkMScalar, m01: root::SkMScalar,
                                 m02: root::SkMScalar, m10: root::SkMScalar,
                                 m11: root::SkMScalar, m12: root::SkMScalar,
                                 m20: root::SkMScalar, m21: root::SkMScalar,
                                 m22: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?set3x3RowMajorf@SkMatrix44@@QEAAXQEBM@Z"]
        pub fn SkMatrix44_set3x3RowMajorf(this: *mut root::SkMatrix44,
                                          arg1: *const f32);
    }
    extern "C" {
        #[link_name = "?setTranslate@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_setTranslate(this: *mut root::SkMatrix44,
                                       dx: root::SkMScalar,
                                       dy: root::SkMScalar,
                                       dz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?preTranslate@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_preTranslate(this: *mut root::SkMatrix44,
                                       dx: root::SkMScalar,
                                       dy: root::SkMScalar,
                                       dz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?postTranslate@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_postTranslate(this: *mut root::SkMatrix44,
                                        dx: root::SkMScalar,
                                        dy: root::SkMScalar,
                                        dz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?setScale@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_setScale(this: *mut root::SkMatrix44,
                                   sx: root::SkMScalar, sy: root::SkMScalar,
                                   sz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?preScale@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_preScale(this: *mut root::SkMatrix44,
                                   sx: root::SkMScalar, sy: root::SkMScalar,
                                   sz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?postScale@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_postScale(this: *mut root::SkMatrix44,
                                    sx: root::SkMScalar, sy: root::SkMScalar,
                                    sz: root::SkMScalar);
    }
    extern "C" {
        /** Rotate about the vector [x,y,z]. If that vector is not unit-length,
        it will be automatically resized.
     */
        #[link_name = "?setRotateAbout@SkMatrix44@@QEAAXMMMM@Z"]
        pub fn SkMatrix44_setRotateAbout(this: *mut root::SkMatrix44,
                                         x: root::SkMScalar,
                                         y: root::SkMScalar,
                                         z: root::SkMScalar,
                                         radians: root::SkMScalar);
    }
    extern "C" {
        /** Rotate about the vector [x,y,z]. Does not check the length of the
        vector, assuming it is unit-length.
     */
        #[link_name = "?setRotateAboutUnit@SkMatrix44@@QEAAXMMMM@Z"]
        pub fn SkMatrix44_setRotateAboutUnit(this: *mut root::SkMatrix44,
                                             x: root::SkMScalar,
                                             y: root::SkMScalar,
                                             z: root::SkMScalar,
                                             radians: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?setConcat@SkMatrix44@@QEAAXAEBV1@0@Z"]
        pub fn SkMatrix44_setConcat(this: *mut root::SkMatrix44,
                                    a: *const root::SkMatrix44,
                                    b: *const root::SkMatrix44);
    }
    extern "C" {
        /** If this is invertible, return that in inverse and return true. If it is
        not invertible, return false and leave the inverse parameter in an
        unspecified state.
     */
        #[link_name = "?invert@SkMatrix44@@QEBA_NPEAV1@@Z"]
        pub fn SkMatrix44_invert(this: *const root::SkMatrix44,
                                 inverse: *mut root::SkMatrix44) -> bool;
    }
    extern "C" {
        /** Transpose this matrix in place. */
        #[link_name = "?transpose@SkMatrix44@@QEAAXXZ"]
        pub fn SkMatrix44_transpose(this: *mut root::SkMatrix44);
    }
    extern "C" {
        /** Apply the matrix to the src vector, returning the new vector in dst.
        It is legal for src and dst to point to the same memory.
     */
        #[link_name = "?mapScalars@SkMatrix44@@QEBAXQEBMQEAM@Z"]
        pub fn SkMatrix44_mapScalars(this: *const root::SkMatrix44,
                                     src: *mut root::SkScalar,
                                     dst: *mut root::SkScalar);
    }
    extern "C" {
        /**
     *  map an array of [x, y, 0, 1] through the matrix, returning an array
     *  of [x', y', z', w'].
     *
     *  @param src2     array of [x, y] pairs, with implied z=0 and w=1
     *  @param count    number of [x, y] pairs in src2
     *  @param dst4     array of [x', y', z', w'] quads as the output.
     */
        #[link_name = "?map2@SkMatrix44@@QEBAXQEBMHQEAM@Z"]
        pub fn SkMatrix44_map2(this: *const root::SkMatrix44,
                               src2: *const f32, count: ::std::os::raw::c_int,
                               dst4: *mut f32);
    }
    extern "C" {
        #[link_name = "?map2@SkMatrix44@@QEBAXQEBNHQEAN@Z"]
        pub fn SkMatrix44_map21(this: *const root::SkMatrix44,
                                src2: *const f64,
                                count: ::std::os::raw::c_int, dst4: *mut f64);
    }
    extern "C" {
        /** Returns true if transformating an axis-aligned square in 2d by this matrix
        will produce another 2d axis-aligned square; typically means the matrix
        is a scale with perhaps a 90-degree rotation. A 3d rotation through 90
        degrees into a perpendicular plane collapses a square to a line, but
        is still considered to be axis-aligned.

        By default, tolerates very slight error due to float imprecisions;
        a 90-degree rotation can still end up with 10^-17 of
        "non-axis-aligned" result.
     */
        #[link_name = "?preserves2dAxisAlignment@SkMatrix44@@QEBA_NM@Z"]
        pub fn SkMatrix44_preserves2dAxisAlignment(this:
                                                       *const root::SkMatrix44,
                                                   epsilon: root::SkMScalar)
         -> bool;
    }
    extern "C" {
        #[link_name = "?dump@SkMatrix44@@QEBAXXZ"]
        pub fn SkMatrix44_dump(this: *const root::SkMatrix44);
    }
    extern "C" {
        #[link_name = "?determinant@SkMatrix44@@QEBANXZ"]
        pub fn SkMatrix44_determinant(this: *const root::SkMatrix44) -> f64;
    }
    impl Clone for SkMatrix44 {
        fn clone(&self) -> Self { *self }
    }
    impl SkMatrix44 {
        #[inline]
        pub unsafe fn I() -> *const root::SkMatrix44 { SkMatrix44_I() }
        #[inline]
        pub unsafe fn setIdentity(&mut self) {
            SkMatrix44_setIdentity(&mut *self)
        }
        #[inline]
        pub unsafe fn asColMajorf(&self, arg1: *mut f32) {
            SkMatrix44_asColMajorf(&*self, arg1)
        }
        #[inline]
        pub unsafe fn asColMajord(&self, arg1: *mut f64) {
            SkMatrix44_asColMajord(&*self, arg1)
        }
        #[inline]
        pub unsafe fn asRowMajorf(&self, arg1: *mut f32) {
            SkMatrix44_asRowMajorf(&*self, arg1)
        }
        #[inline]
        pub unsafe fn asRowMajord(&self, arg1: *mut f64) {
            SkMatrix44_asRowMajord(&*self, arg1)
        }
        #[inline]
        pub unsafe fn setColMajorf(&mut self, arg1: *const f32) {
            SkMatrix44_setColMajorf(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setColMajord(&mut self, arg1: *const f64) {
            SkMatrix44_setColMajord(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setRowMajorf(&mut self, arg1: *const f32) {
            SkMatrix44_setRowMajorf(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setRowMajord(&mut self, arg1: *const f64) {
            SkMatrix44_setRowMajord(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn set3x3(&mut self, m00: root::SkMScalar,
                             m01: root::SkMScalar, m02: root::SkMScalar,
                             m10: root::SkMScalar, m11: root::SkMScalar,
                             m12: root::SkMScalar, m20: root::SkMScalar,
                             m21: root::SkMScalar, m22: root::SkMScalar) {
            SkMatrix44_set3x3(&mut *self, m00, m01, m02, m10, m11, m12, m20,
                              m21, m22)
        }
        #[inline]
        pub unsafe fn set3x3RowMajorf(&mut self, arg1: *const f32) {
            SkMatrix44_set3x3RowMajorf(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setTranslate(&mut self, dx: root::SkMScalar,
                                   dy: root::SkMScalar, dz: root::SkMScalar) {
            SkMatrix44_setTranslate(&mut *self, dx, dy, dz)
        }
        #[inline]
        pub unsafe fn preTranslate(&mut self, dx: root::SkMScalar,
                                   dy: root::SkMScalar, dz: root::SkMScalar) {
            SkMatrix44_preTranslate(&mut *self, dx, dy, dz)
        }
        #[inline]
        pub unsafe fn postTranslate(&mut self, dx: root::SkMScalar,
                                    dy: root::SkMScalar,
                                    dz: root::SkMScalar) {
            SkMatrix44_postTranslate(&mut *self, dx, dy, dz)
        }
        #[inline]
        pub unsafe fn setScale(&mut self, sx: root::SkMScalar,
                               sy: root::SkMScalar, sz: root::SkMScalar) {
            SkMatrix44_setScale(&mut *self, sx, sy, sz)
        }
        #[inline]
        pub unsafe fn preScale(&mut self, sx: root::SkMScalar,
                               sy: root::SkMScalar, sz: root::SkMScalar) {
            SkMatrix44_preScale(&mut *self, sx, sy, sz)
        }
        #[inline]
        pub unsafe fn postScale(&mut self, sx: root::SkMScalar,
                                sy: root::SkMScalar, sz: root::SkMScalar) {
            SkMatrix44_postScale(&mut *self, sx, sy, sz)
        }
        #[inline]
        pub unsafe fn setRotateAbout(&mut self, x: root::SkMScalar,
                                     y: root::SkMScalar, z: root::SkMScalar,
                                     radians: root::SkMScalar) {
            SkMatrix44_setRotateAbout(&mut *self, x, y, z, radians)
        }
        #[inline]
        pub unsafe fn setRotateAboutUnit(&mut self, x: root::SkMScalar,
                                         y: root::SkMScalar,
                                         z: root::SkMScalar,
                                         radians: root::SkMScalar) {
            SkMatrix44_setRotateAboutUnit(&mut *self, x, y, z, radians)
        }
        #[inline]
        pub unsafe fn setConcat(&mut self, a: *const root::SkMatrix44,
                                b: *const root::SkMatrix44) {
            SkMatrix44_setConcat(&mut *self, a, b)
        }
        #[inline]
        pub unsafe fn invert(&self, inverse: *mut root::SkMatrix44) -> bool {
            SkMatrix44_invert(&*self, inverse)
        }
        #[inline]
        pub unsafe fn transpose(&mut self) {
            SkMatrix44_transpose(&mut *self)
        }
        #[inline]
        pub unsafe fn mapScalars(&self, src: *mut root::SkScalar,
                                 dst: *mut root::SkScalar) {
            SkMatrix44_mapScalars(&*self, src, dst)
        }
        #[inline]
        pub unsafe fn map2(&self, src2: *const f32,
                           count: ::std::os::raw::c_int, dst4: *mut f32) {
            SkMatrix44_map2(&*self, src2, count, dst4)
        }
        #[inline]
        pub unsafe fn map21(&self, src2: *const f64,
                            count: ::std::os::raw::c_int, dst4: *mut f64) {
            SkMatrix44_map21(&*self, src2, count, dst4)
        }
        #[inline]
        pub unsafe fn preserves2dAxisAlignment(&self,
                                               epsilon: root::SkMScalar)
         -> bool {
            SkMatrix44_preserves2dAxisAlignment(&*self, epsilon)
        }
        #[inline]
        pub unsafe fn dump(&self) { SkMatrix44_dump(&*self) }
        #[inline]
        pub unsafe fn determinant(&self) -> f64 {
            SkMatrix44_determinant(&*self)
        }
    }
    #[repr(C)]
    pub struct SkRefCntBase__bindgen_vtable {
    }
    /** \class SkRefCntBase

    SkRefCntBase is the base class for objects that may be shared by multiple
    objects. When an existing owner wants to share a reference, it calls ref().
    When an owner wants to release its reference, it calls unref(). When the
    shared object's reference count goes to zero as the result of an unref()
    call, its (virtual) destructor is called. It is an error for the
    destructor to be called explicitly (or via the object going out of scope on
    the stack or calling delete) if getRefCnt() > 1.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkRefCntBase {
        pub vtable_: *const SkRefCntBase__bindgen_vtable,
        pub fRefCnt: u32,
    }
    pub type SkRefCntBase_INHERITED = root::SkNoncopyable;
    #[test]
    fn bindgen_test_layout_SkRefCntBase() {
        assert_eq!(::std::mem::size_of::<SkRefCntBase>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkRefCntBase>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkRefCnt {
        pub _base: root::SkRefCntBase,
    }
    #[test]
    fn bindgen_test_layout_SkRefCnt() {
        assert_eq!(::std::mem::size_of::<SkRefCnt>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkRefCnt>() , 8usize);
    }
    ///////////////////////////////////////////////////////////////////////////////
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkNVRefCnt<Derived> {
        pub fRefCnt: u32,
        pub _phantom_0: ::std::marker::PhantomData<Derived>,
    }
    #[test]
    fn __bindgen_test_layout_template_2() {
        assert_eq!(::std::mem::size_of::<root::SkNVRefCnt<root::SkData>>() ,
                   4usize);
        assert_eq!(::std::mem::align_of::<root::SkNVRefCnt<root::SkData>>() ,
                   4usize);
    }
    #[test]
    fn __bindgen_test_layout_template_3() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkData>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkData>>() ,
                   8usize);
    }
    /**
 *  SkData holds an immutable data buffer. Not only is the data immutable,
 *  but the actual ptr that is returned (by data() or bytes()) is guaranteed
 *  to always be the same for the life of this instance.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkData {
        pub _base: root::SkNVRefCnt<root::SkData>,
        pub fReleaseProc: root::SkData_ReleaseProc,
        pub fReleaseProcContext: *mut ::std::os::raw::c_void,
        pub fPtr: *mut ::std::os::raw::c_void,
        pub fSize: usize,
    }
    /**
     *  Function that, if provided, will be called when the SkData goes out
     *  of scope, allowing for custom allocation/freeing of the data's contents.
     */
    pub type SkData_ReleaseProc =
        ::std::option::Option<unsafe extern "C" fn(ptr:
                                                       *const ::std::os::raw::c_void,
                                                   context:
                                                       *mut ::std::os::raw::c_void)>;
    pub type SkData_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkData() {
        assert_eq!(::std::mem::size_of::<SkData>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkData>() , 8usize);
    }
    extern "C" {
        /**
     *  Helper to copy a range of the data into a caller-provided buffer.
     *  Returns the actual number of bytes copied, after clamping offset and
     *  length to the size of the data. If buffer is NULL, it is ignored, and
     *  only the computed number of bytes is returned.
     */
        #[link_name = "?copyRange@SkData@@QEBA_K_K0PEAX@Z"]
        pub fn SkData_copyRange(this: *const root::SkData, offset: usize,
                                length: usize,
                                buffer: *mut ::std::os::raw::c_void) -> usize;
    }
    extern "C" {
        /**
     *  Returns true if these two objects have the same length and contents,
     *  effectively returning 0 == memcmp(...)
     */
        #[link_name = "?equals@SkData@@QEBA_NPEBV1@@Z"]
        pub fn SkData_equals(this: *const root::SkData,
                             other: *const root::SkData) -> bool;
    }
    extern "C" {
        /**
     *  Create a new dataref by copying the specified data
     */
        #[link_name =
              "?MakeWithCopy@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_K@Z"]
        pub fn SkData_MakeWithCopy(data: *const ::std::os::raw::c_void,
                                   length: usize)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new data with uninitialized contents. The caller should call writable_data()
     *  to write into the buffer, but this must be done before another ref() is made.
     */
        #[link_name =
              "?MakeUninitialized@SkData@@SA?AV?$sk_sp@VSkData@@@@_K@Z"]
        pub fn SkData_MakeUninitialized(length: usize)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref by copying the specified c-string
     *  (a null-terminated array of bytes). The returned SkData will have size()
     *  equal to strlen(cstr) + 1. If cstr is NULL, it will be treated the same
     *  as "".
     */
        #[link_name =
              "?MakeWithCString@SkData@@SA?AV?$sk_sp@VSkData@@@@QEBD@Z"]
        pub fn SkData_MakeWithCString(cstr: *const ::std::os::raw::c_char)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref, taking the ptr as is, and using the
     *  releaseproc to free it. The proc may be NULL.
     */
        #[link_name =
              "?MakeWithProc@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_KP6AX0PEAX@Z2@Z"]
        pub fn SkData_MakeWithProc(ptr: *const ::std::os::raw::c_void,
                                   length: usize,
                                   proc_: root::SkData_ReleaseProc,
                                   ctx: *mut ::std::os::raw::c_void)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref from a pointer allocated by malloc. The Data object
     *  takes ownership of that allocation, and will handling calling sk_free.
     */
        #[link_name =
              "?MakeFromMalloc@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_K@Z"]
        pub fn SkData_MakeFromMalloc(data: *const ::std::os::raw::c_void,
                                     length: usize)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref the file with the specified path.
     *  If the file cannot be opened, this returns NULL.
     */
        #[link_name =
              "?MakeFromFileName@SkData@@SA?AV?$sk_sp@VSkData@@@@QEBD@Z"]
        pub fn SkData_MakeFromFileName(path: *const ::std::os::raw::c_char)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref from a stdio FILE.
     *  This does not take ownership of the FILE, nor close it.
     *  The caller is free to close the FILE at its convenience.
     *  The FILE must be open for reading only.
     *  Returns NULL on failure.
     */
        #[link_name =
              "?MakeFromFILE@SkData@@SA?AV?$sk_sp@VSkData@@@@PEAU_iobuf@@@Z"]
        pub fn SkData_MakeFromFILE(f: *mut root::FILE)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref from a file descriptor.
     *  This does not take ownership of the file descriptor, nor close it.
     *  The caller is free to close the file descriptor at its convenience.
     *  The file descriptor must be open for reading only.
     *  Returns NULL on failure.
     */
        #[link_name = "?MakeFromFD@SkData@@SA?AV?$sk_sp@VSkData@@@@H@Z"]
        pub fn SkData_MakeFromFD(fd: ::std::os::raw::c_int)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Attempt to read size bytes into a SkData. If the read succeeds, return the data,
     *  else return NULL. Either way the stream's cursor may have been changed as a result
     *  of calling read().
     */
        #[link_name =
              "?MakeFromStream@SkData@@SA?AV?$sk_sp@VSkData@@@@PEAVSkStream@@_K@Z"]
        pub fn SkData_MakeFromStream(arg1: *mut root::SkStream, size: usize)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref using a subset of the data in the specified
     *  src dataref.
     */
        #[link_name =
              "?MakeSubset@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBV1@_K1@Z"]
        pub fn SkData_MakeSubset(src: *const root::SkData, offset: usize,
                                 length: usize) -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Returns a new empty dataref (or a reference to a shared empty dataref).
     *  New or shared, the caller must see that unref() is eventually called.
     */
        #[link_name = "?MakeEmpty@SkData@@SA?AV?$sk_sp@VSkData@@@@XZ"]
        pub fn SkData_MakeEmpty() -> root::sk_sp<root::SkData>;
    }
    impl SkData {
        #[inline]
        pub unsafe fn copyRange(&self, offset: usize, length: usize,
                                buffer: *mut ::std::os::raw::c_void)
         -> usize {
            SkData_copyRange(&*self, offset, length, buffer)
        }
        #[inline]
        pub unsafe fn equals(&self, other: *const root::SkData) -> bool {
            SkData_equals(&*self, other)
        }
        #[inline]
        pub unsafe fn MakeWithCopy(data: *const ::std::os::raw::c_void,
                                   length: usize)
         -> root::sk_sp<root::SkData> {
            SkData_MakeWithCopy(data, length)
        }
        #[inline]
        pub unsafe fn MakeUninitialized(length: usize)
         -> root::sk_sp<root::SkData> {
            SkData_MakeUninitialized(length)
        }
        #[inline]
        pub unsafe fn MakeWithCString(cstr: *const ::std::os::raw::c_char)
         -> root::sk_sp<root::SkData> {
            SkData_MakeWithCString(cstr)
        }
        #[inline]
        pub unsafe fn MakeWithProc(ptr: *const ::std::os::raw::c_void,
                                   length: usize,
                                   proc_: root::SkData_ReleaseProc,
                                   ctx: *mut ::std::os::raw::c_void)
         -> root::sk_sp<root::SkData> {
            SkData_MakeWithProc(ptr, length, proc_, ctx)
        }
        #[inline]
        pub unsafe fn MakeFromMalloc(data: *const ::std::os::raw::c_void,
                                     length: usize)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromMalloc(data, length)
        }
        #[inline]
        pub unsafe fn MakeFromFileName(path: *const ::std::os::raw::c_char)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromFileName(path)
        }
        #[inline]
        pub unsafe fn MakeFromFILE(f: *mut root::FILE)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromFILE(f)
        }
        #[inline]
        pub unsafe fn MakeFromFD(fd: ::std::os::raw::c_int)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromFD(fd)
        }
        #[inline]
        pub unsafe fn MakeFromStream(arg1: *mut root::SkStream, size: usize)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromStream(arg1, size)
        }
        #[inline]
        pub unsafe fn MakeSubset(src: *const root::SkData, offset: usize,
                                 length: usize) -> root::sk_sp<root::SkData> {
            SkData_MakeSubset(src, offset, length)
        }
        #[inline]
        pub unsafe fn MakeEmpty() -> root::sk_sp<root::SkData> {
            SkData_MakeEmpty()
        }
    }
    /**
 *  Contains the coefficients for a common transfer function equation, specified as
 *  a transformation from a curved space to linear.
 *
 *  LinearVal = E*InputVal + F        , for 0.0f <= InputVal <  D
 *  LinearVal = (A*InputVal + B)^G + C, for D    <= InputVal <= 1.0f
 *
 *  Function is undefined if InputVal is not in [ 0.0f, 1.0f ].
 *  Resulting LinearVals must be in [ 0.0f, 1.0f ].
 *  Function must be positive and increasing.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkColorSpaceTransferFn {
        pub fG: f32,
        pub fA: f32,
        pub fB: f32,
        pub fC: f32,
        pub fD: f32,
        pub fE: f32,
        pub fF: f32,
    }
    #[test]
    fn bindgen_test_layout_SkColorSpaceTransferFn() {
        assert_eq!(::std::mem::size_of::<SkColorSpaceTransferFn>() , 28usize);
        assert_eq!(::std::mem::align_of::<SkColorSpaceTransferFn>() , 4usize);
    }
    impl Clone for SkColorSpaceTransferFn {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_4() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkColorSpace>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkColorSpace>>() ,
                   8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkColorSpace {
        pub _base: root::SkRefCnt,
    }
    #[repr(u8)]
    /**
     *  Common, named profiles that we can recognize.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkColorSpace_Named {
        kSRGB_Named = 0,
        kAdobeRGB_Named = 1,
        kSRGBLinear_Named = 2,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkColorSpace_RenderTargetGamma {
        kLinear_RenderTargetGamma = 0,
        kSRGB_RenderTargetGamma = 1,
    }
    #[test]
    fn bindgen_test_layout_SkColorSpace() {
        assert_eq!(::std::mem::size_of::<SkColorSpace>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkColorSpace>() , 8usize);
    }
    extern "C" {
        /**
     *  Create an SkColorSpace from a transfer function and a color gamut.
     *
     *  Transfer function can be specified as a render target, as the coefficients to an equation,
     *  or as three exponents (R, G, B).
     *  Gamut is specified using the matrix transformation to XYZ D50.
     */
        #[link_name =
              "?MakeRGB@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@W4RenderTargetGamma@1@AEBVSkMatrix44@@@Z"]
        pub fn SkColorSpace_MakeRGB(gamma:
                                        root::SkColorSpace_RenderTargetGamma,
                                    toXYZD50: *const root::SkMatrix44)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        #[link_name =
              "?MakeRGB@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@AEBUSkColorSpaceTransferFn@@AEBVSkMatrix44@@@Z"]
        pub fn SkColorSpace_MakeRGB1(coeffs:
                                         *const root::SkColorSpaceTransferFn,
                                     toXYZD50: *const root::SkMatrix44)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        /**
     *  Create a common, named SkColorSpace.
     */
        #[link_name =
              "?MakeNamed@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@W4Named@1@@Z"]
        pub fn SkColorSpace_MakeNamed(arg1: root::SkColorSpace_Named)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        /**
     *  Create an SkColorSpace from an ICC profile.
     */
        #[link_name =
              "?MakeICC@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@PEBX_K@Z"]
        pub fn SkColorSpace_MakeICC(arg1: *const ::std::os::raw::c_void,
                                    arg2: usize)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        /**
     *  Returns true if the color space gamma is near enough to be approximated as sRGB.
     */
        #[link_name = "?gammaCloseToSRGB@SkColorSpace@@QEBA_NXZ"]
        pub fn SkColorSpace_gammaCloseToSRGB(this: *const root::SkColorSpace)
         -> bool;
    }
    extern "C" {
        /**
     *  Returns true if the color space gamma is linear.
     */
        #[link_name = "?gammaIsLinear@SkColorSpace@@QEBA_NXZ"]
        pub fn SkColorSpace_gammaIsLinear(this: *const root::SkColorSpace)
         -> bool;
    }
    extern "C" {
        /**
     *  Returns nullptr on failure.  Fails when we fallback to serializing ICC data and
     *  the data is too large to serialize.
     */
        #[link_name = "?serialize@SkColorSpace@@QEBA?AV?$sk_sp@VSkData@@@@XZ"]
        pub fn SkColorSpace_serialize(this: *const root::SkColorSpace)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  If |memory| is nullptr, returns the size required to serialize.
     *  Otherwise, serializes into |memory| and returns the size.
     */
        #[link_name = "?writeToMemory@SkColorSpace@@QEBA_KPEAX@Z"]
        pub fn SkColorSpace_writeToMemory(this: *const root::SkColorSpace,
                                          memory: *mut ::std::os::raw::c_void)
         -> usize;
    }
    extern "C" {
        #[link_name =
              "?Deserialize@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@PEBX_K@Z"]
        pub fn SkColorSpace_Deserialize(data: *const ::std::os::raw::c_void,
                                        length: usize)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        /**
     *  If both are null, we return true.  If one is null and the other is not, we return false.
     *  If both are non-null, we do a deeper compare.
     */
        #[link_name = "?Equals@SkColorSpace@@SA_NPEBV1@0@Z"]
        pub fn SkColorSpace_Equals(src: *const root::SkColorSpace,
                                   dst: *const root::SkColorSpace) -> bool;
    }
    impl SkColorSpace {
        #[inline]
        pub unsafe fn MakeRGB(gamma: root::SkColorSpace_RenderTargetGamma,
                              toXYZD50: *const root::SkMatrix44)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_MakeRGB(gamma, toXYZD50)
        }
        #[inline]
        pub unsafe fn MakeRGB1(coeffs: *const root::SkColorSpaceTransferFn,
                               toXYZD50: *const root::SkMatrix44)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_MakeRGB1(coeffs, toXYZD50)
        }
        #[inline]
        pub unsafe fn MakeNamed(arg1: root::SkColorSpace_Named)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_MakeNamed(arg1)
        }
        #[inline]
        pub unsafe fn MakeICC(arg1: *const ::std::os::raw::c_void,
                              arg2: usize)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_MakeICC(arg1, arg2)
        }
        #[inline]
        pub unsafe fn gammaCloseToSRGB(&self) -> bool {
            SkColorSpace_gammaCloseToSRGB(&*self)
        }
        #[inline]
        pub unsafe fn gammaIsLinear(&self) -> bool {
            SkColorSpace_gammaIsLinear(&*self)
        }
        #[inline]
        pub unsafe fn serialize(&self) -> root::sk_sp<root::SkData> {
            SkColorSpace_serialize(&*self)
        }
        #[inline]
        pub unsafe fn writeToMemory(&self,
                                    memory: *mut ::std::os::raw::c_void)
         -> usize {
            SkColorSpace_writeToMemory(&*self, memory)
        }
        #[inline]
        pub unsafe fn Deserialize(data: *const ::std::os::raw::c_void,
                                  length: usize)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_Deserialize(data, length)
        }
        #[inline]
        pub unsafe fn Equals(src: *const root::SkColorSpace,
                             dst: *const root::SkColorSpace) -> bool {
            SkColorSpace_Equals(src, dst)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkReadBuffer {
        pub _address: u8,
    }
    impl Clone for SkReadBuffer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkWriteBuffer {
        pub _address: u8,
    }
    impl Clone for SkWriteBuffer {
        fn clone(&self) -> Self { *self }
    }
    pub const SkAlphaType_kLastEnum_SkAlphaType: root::SkAlphaType =
        SkAlphaType::kUnpremul_SkAlphaType;
    #[repr(i32)]
    /**
 *  Describes how to interpret the alpha component of a pixel.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkAlphaType {
        kUnknown_SkAlphaType = 0,
        kOpaque_SkAlphaType = 1,
        kPremul_SkAlphaType = 2,
        kUnpremul_SkAlphaType = 3,
    }
    pub const SkColorType_kLastEnum_SkColorType: root::SkColorType =
        SkColorType::kRGBA_F16_SkColorType;
    pub const SkColorType_kN32_SkColorType: root::SkColorType =
        SkColorType::kBGRA_8888_SkColorType;
    #[repr(i32)]
    /**
 *  Describes how to interpret the components of a pixel.
 *
 *  kN32_SkColorType is an alias for whichever 32bit ARGB format is the "native"
 *  form for skia's blitters. Use this if you don't have a swizzle preference
 *  for 32bit pixels.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkColorType {
        kUnknown_SkColorType = 0,
        kAlpha_8_SkColorType = 1,
        kRGB_565_SkColorType = 2,
        kARGB_4444_SkColorType = 3,
        kRGBA_8888_SkColorType = 4,
        kBGRA_8888_SkColorType = 5,
        kIndex_8_SkColorType = 6,
        kGray_8_SkColorType = 7,
        kRGBA_F16_SkColorType = 8,
    }
    pub const SkYUVColorSpace_kLastEnum_SkYUVColorSpace: root::SkYUVColorSpace
              =
        SkYUVColorSpace::kRec709_SkYUVColorSpace;
    #[repr(i32)]
    /**
 *  Describes the color space a YUV pixel.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkYUVColorSpace {
        kJPEG_SkYUVColorSpace = 0,
        kRec601_SkYUVColorSpace = 1,
        kRec709_SkYUVColorSpace = 2,
    }
    #[repr(i32)]
    ///////////////////////////////////////////////////////////////////////////////
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkDestinationSurfaceColorMode {
        kLegacy = 0,
        kGammaAndColorSpaceAware = 1,
    }
    /**
 *  Describe an image's dimensions and pixel type.
 *  Used for both src images and render-targets (surfaces).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkImageInfo {
        pub fColorSpace: root::sk_sp<root::SkColorSpace>,
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fColorType: root::SkColorType,
        pub fAlphaType: root::SkAlphaType,
    }
    #[test]
    fn bindgen_test_layout_SkImageInfo() {
        assert_eq!(::std::mem::size_of::<SkImageInfo>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkImageInfo>() , 8usize);
    }
    extern "C" {
        /**
     *  Create an ImageInfo marked as SRGB with N32 swizzle.
     */
        #[link_name = "?MakeS32@SkImageInfo@@SA?AU1@HHW4SkAlphaType@@@Z"]
        pub fn SkImageInfo_MakeS32(width: ::std::os::raw::c_int,
                                   height: ::std::os::raw::c_int,
                                   at: root::SkAlphaType)
         -> root::SkImageInfo;
    }
    extern "C" {
        #[link_name = "?unflatten@SkImageInfo@@QEAAXAEAVSkReadBuffer@@@Z"]
        pub fn SkImageInfo_unflatten(this: *mut root::SkImageInfo,
                                     arg1: *mut root::SkReadBuffer);
    }
    extern "C" {
        #[link_name = "?flatten@SkImageInfo@@QEBAXAEAVSkWriteBuffer@@@Z"]
        pub fn SkImageInfo_flatten(this: *const root::SkImageInfo,
                                   arg1: *mut root::SkWriteBuffer);
    }
    extern "C" {
        #[link_name = "?validate@SkImageInfo@@QEBAXXZ"]
        pub fn SkImageInfo_validate(this: *const root::SkImageInfo);
    }
    impl SkImageInfo {
        #[inline]
        pub unsafe fn MakeS32(width: ::std::os::raw::c_int,
                              height: ::std::os::raw::c_int,
                              at: root::SkAlphaType) -> root::SkImageInfo {
            SkImageInfo_MakeS32(width, height, at)
        }
        #[inline]
        pub unsafe fn unflatten(&mut self, arg1: *mut root::SkReadBuffer) {
            SkImageInfo_unflatten(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn flatten(&self, arg1: *mut root::SkWriteBuffer) {
            SkImageInfo_flatten(&*self, arg1)
        }
        #[inline]
        pub unsafe fn validate(&self) { SkImageInfo_validate(&*self) }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPoint3 {
        pub fX: root::SkScalar,
        pub fY: root::SkScalar,
        pub fZ: root::SkScalar,
    }
    #[test]
    fn bindgen_test_layout_SkPoint3() {
        assert_eq!(::std::mem::size_of::<SkPoint3>() , 12usize);
        assert_eq!(::std::mem::align_of::<SkPoint3>() , 4usize);
    }
    extern "C" {
        /** Returns the Euclidian distance from (0,0,0) to (x,y,z)
    */
        #[link_name = "?Length@SkPoint3@@SAMMMM@Z"]
        pub fn SkPoint3_Length(x: root::SkScalar, y: root::SkScalar,
                               z: root::SkScalar) -> root::SkScalar;
    }
    extern "C" {
        /** Set the point (vector) to be unit-length in the same direction as it
        already points.  If the point has a degenerate length (i.e., nearly 0)
        then set it to (0,0,0) and return false; otherwise return true.
    */
        #[link_name = "?normalize@SkPoint3@@QEAA_NXZ"]
        pub fn SkPoint3_normalize(this: *mut root::SkPoint3) -> bool;
    }
    impl Clone for SkPoint3 {
        fn clone(&self) -> Self { *self }
    }
    impl SkPoint3 {
        #[inline]
        pub unsafe fn Length(x: root::SkScalar, y: root::SkScalar,
                             z: root::SkScalar) -> root::SkScalar {
            SkPoint3_Length(x, y, z)
        }
        #[inline]
        pub unsafe fn normalize(&mut self) -> bool {
            SkPoint3_normalize(&mut *self)
        }
    }
    pub type SkColor3f = root::SkPoint3;
    /** 8-bit type for an alpha value. 0xFF is 100% opaque, 0x00 is 100% transparent.
*/
    pub type SkAlpha = u8;
    /** 32 bit ARGB color value, not premultiplied. The color components are always in
    a known order. This is different from SkPMColor, which has its bytes in a configuration
    dependent order, to match the format of kARGB32 bitmaps. SkColor is the type used to
    specify colors in SkPaint and in gradients.
*/
    pub type SkColor = u32;
    /** 32 bit ARGB color value, premultiplied. The byte order for this value is
    configuration dependent, matching the format of kARGB32 bitmaps. This is different
    from SkColor, which is nonpremultiplied, and is always in the same byte order.
*/
    pub type SkPMColor = u32;
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPM4f {
        pub _address: u8,
    }
    impl Clone for SkPM4f {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkColor4f {
        pub fR: f32,
        pub fG: f32,
        pub fB: f32,
        pub fA: f32,
    }
    #[test]
    fn bindgen_test_layout_SkColor4f() {
        assert_eq!(::std::mem::size_of::<SkColor4f>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkColor4f>() , 4usize);
    }
    extern "C" {
        #[link_name = "?Pin@SkColor4f@@SA?AU1@MMMM@Z"]
        pub fn SkColor4f_Pin(r: f32, g: f32, b: f32, a: f32)
         -> root::SkColor4f;
    }
    extern "C" {
        /** Convert to SkColor4f, assuming SkColor is sRGB */
        #[link_name = "?FromColor@SkColor4f@@SA?AU1@I@Z"]
        pub fn SkColor4f_FromColor(arg1: root::SkColor) -> root::SkColor4f;
    }
    extern "C" {
        #[link_name = "?FromColor3f@SkColor4f@@SA?AU1@USkPoint3@@M@Z"]
        pub fn SkColor4f_FromColor3f(arg1: root::SkColor3f, a: f32)
         -> root::SkColor4f;
    }
    extern "C" {
        #[link_name = "?toSkColor@SkColor4f@@QEBAIXZ"]
        pub fn SkColor4f_toSkColor(this: *const root::SkColor4f)
         -> root::SkColor;
    }
    extern "C" {
        #[link_name = "?premul@SkColor4f@@QEBA?AUSkPM4f@@XZ"]
        pub fn SkColor4f_premul(this: *const root::SkColor4f) -> root::SkPM4f;
    }
    impl Clone for SkColor4f {
        fn clone(&self) -> Self { *self }
    }
    impl SkColor4f {
        #[inline]
        pub unsafe fn Pin(r: f32, g: f32, b: f32, a: f32) -> root::SkColor4f {
            SkColor4f_Pin(r, g, b, a)
        }
        #[inline]
        pub unsafe fn FromColor(arg1: root::SkColor) -> root::SkColor4f {
            SkColor4f_FromColor(arg1)
        }
        #[inline]
        pub unsafe fn FromColor3f(arg1: root::SkColor3f, a: f32)
         -> root::SkColor4f {
            SkColor4f_FromColor3f(arg1, a)
        }
        #[inline]
        pub unsafe fn toSkColor(&self) -> root::SkColor {
            SkColor4f_toSkColor(&*self)
        }
        #[inline]
        pub unsafe fn premul(&self) -> root::SkPM4f {
            SkColor4f_premul(&*self)
        }
    }
    /** \class SkFlattenable

 SkFlattenable is the base class for objects that need to be flattened
 into a data stream for either transport or as part of the key to the
 font cache.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkFlattenable {
        pub _base: root::SkRefCnt,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkFlattenable_Type {
        kSkColorFilter_Type = 0,
        kSkDrawable_Type = 1,
        kSkDrawLooper_Type = 2,
        kSkImageFilter_Type = 3,
        kSkMaskFilter_Type = 4,
        kSkPathEffect_Type = 5,
        kSkPixelRef_Type = 6,
        kSkRasterizer_Type = 7,
        kSkShader_Type = 8,
        kSkUnused_Type = 9,
        kSkXfermode_Type = 10,
        kSkNormalSource_Type = 11,
    }
    pub type SkFlattenable_Factory =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::SkReadBuffer)
                                  -> root::sk_sp<root::SkFlattenable>>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkFlattenable_PrivateInitializer {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_SkFlattenable_PrivateInitializer() {
        assert_eq!(::std::mem::size_of::<SkFlattenable_PrivateInitializer>() ,
                   1usize);
        assert_eq!(::std::mem::align_of::<SkFlattenable_PrivateInitializer>()
                   , 1usize);
    }
    extern "C" {
        #[link_name = "?InitCore@PrivateInitializer@SkFlattenable@@SAXXZ"]
        pub fn SkFlattenable_PrivateInitializer_InitCore();
    }
    extern "C" {
        #[link_name = "?InitEffects@PrivateInitializer@SkFlattenable@@SAXXZ"]
        pub fn SkFlattenable_PrivateInitializer_InitEffects();
    }
    impl Clone for SkFlattenable_PrivateInitializer {
        fn clone(&self) -> Self { *self }
    }
    impl SkFlattenable_PrivateInitializer {
        #[inline]
        pub unsafe fn InitCore() {
            SkFlattenable_PrivateInitializer_InitCore()
        }
        #[inline]
        pub unsafe fn InitEffects() {
            SkFlattenable_PrivateInitializer_InitEffects()
        }
    }
    pub type SkFlattenable_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkFlattenable() {
        assert_eq!(::std::mem::size_of::<SkFlattenable>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkFlattenable>() , 8usize);
    }
    extern "C" {
        #[link_name =
              "?NameToFactory@SkFlattenable@@SAP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@ZQEBD@Z"]
        pub fn SkFlattenable_NameToFactory(name:
                                               *const ::std::os::raw::c_char)
         -> root::SkFlattenable_Factory;
    }
    extern "C" {
        #[link_name =
              "?FactoryToName@SkFlattenable@@SAPEBDP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@Z@Z"]
        pub fn SkFlattenable_FactoryToName(arg1: root::SkFlattenable_Factory)
         -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "?NameToType@SkFlattenable@@SA_NQEBDPEAW4Type@1@@Z"]
        pub fn SkFlattenable_NameToType(name: *const ::std::os::raw::c_char,
                                        type_: *mut root::SkFlattenable_Type)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?Register@SkFlattenable@@SAXQEBDP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@ZW4Type@1@@Z"]
        pub fn SkFlattenable_Register(name: *const ::std::os::raw::c_char,
                                      arg1: root::SkFlattenable_Factory,
                                      arg2: root::SkFlattenable_Type);
    }
    impl SkFlattenable {
        #[inline]
        pub unsafe fn NameToFactory(name: *const ::std::os::raw::c_char)
         -> root::SkFlattenable_Factory {
            SkFlattenable_NameToFactory(name)
        }
        #[inline]
        pub unsafe fn FactoryToName(arg1: root::SkFlattenable_Factory)
         -> *const ::std::os::raw::c_char {
            SkFlattenable_FactoryToName(arg1)
        }
        #[inline]
        pub unsafe fn NameToType(name: *const ::std::os::raw::c_char,
                                 type_: *mut root::SkFlattenable_Type)
         -> bool {
            SkFlattenable_NameToType(name, type_)
        }
        #[inline]
        pub unsafe fn Register(name: *const ::std::os::raw::c_char,
                               arg1: root::SkFlattenable_Factory,
                               arg2: root::SkFlattenable_Type) {
            SkFlattenable_Register(name, arg1, arg2)
        }
    }
    /** \class SkColorTable

    SkColorTable holds an array SkPMColors (premultiplied 32-bit colors) used by
    8-bit bitmaps, where the bitmap bytes are interpreted as indices into the colortable.

    SkColorTable is thread-safe.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkColorTable {
        pub _base: root::SkRefCnt,
        pub fColors: *mut root::SkPMColor,
        pub f16BitCache: *mut u16,
        pub f16BitCacheOnce: root::SkOnce,
        pub fCount: ::std::os::raw::c_int,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkColorTable_AllocatedWithMalloc { kAllocatedWithMalloc = 0, }
    pub type SkColorTable_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkColorTable() {
        assert_eq!(::std::mem::size_of::<SkColorTable>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkColorTable>() , 8usize);
    }
    extern "C" {
        /** read16BitCache() returns the array of RGB16 colors that mirror the 32bit colors.
     */
        #[link_name = "?read16BitCache@SkColorTable@@QEBAPEBGXZ"]
        pub fn SkColorTable_read16BitCache(this: *const root::SkColorTable)
         -> *const u16;
    }
    extern "C" {
        #[link_name =
              "?writeToBuffer@SkColorTable@@QEBAXAEAVSkWriteBuffer@@@Z"]
        pub fn SkColorTable_writeToBuffer(this: *const root::SkColorTable,
                                          arg1: *mut root::SkWriteBuffer);
    }
    extern "C" {
        #[link_name = "?Create@SkColorTable@@SAPEAV1@AEAVSkReadBuffer@@@Z"]
        pub fn SkColorTable_Create(arg1: *mut root::SkReadBuffer)
         -> *mut root::SkColorTable;
    }
    impl SkColorTable {
        #[inline]
        pub unsafe fn read16BitCache(&self) -> *const u16 {
            SkColorTable_read16BitCache(&*self)
        }
        #[inline]
        pub unsafe fn writeToBuffer(&self, arg1: *mut root::SkWriteBuffer) {
            SkColorTable_writeToBuffer(&*self, arg1)
        }
        #[inline]
        pub unsafe fn Create(arg1: *mut root::SkReadBuffer)
         -> *mut root::SkColorTable {
            SkColorTable_Create(arg1)
        }
    }
    /** \class SkMask
    SkMask is used to describe alpha bitmaps, either 1bit, 8bit, or
    the 3-channel 3D format. These are passed to SkMaskFilter objects.
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMask {
        pub fImage: *mut u8,
        pub fBounds: root::SkIRect,
        pub fRowBytes: u32,
        pub fFormat: root::SkMask_Format,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMask_Format {
        kBW_Format = 0,
        kA8_Format = 1,
        k3D_Format = 2,
        kARGB32_Format = 3,
        kLCD16_Format = 4,
    }
    pub const SkMask_kCountMaskFormats: root::SkMask__bindgen_ty_1 =
        SkMask__bindgen_ty_1::kCountMaskFormats;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMask__bindgen_ty_1 { kCountMaskFormats = 5, }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMask_CreateMode {
        kJustComputeBounds_CreateMode = 0,
        kJustRenderImage_CreateMode = 1,
        kComputeBoundsAndRenderImage_CreateMode = 2,
    }
    #[test]
    fn bindgen_test_layout_SkMask() {
        assert_eq!(::std::mem::size_of::<SkMask>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkMask>() , 8usize);
    }
    extern "C" {
        /** Return the byte size of the mask, assuming only 1 plane.
        Does not account for k3D_Format. For that, use computeTotalImageSize().
        If there is an overflow of 32bits, then returns 0.
    */
        #[link_name = "?computeImageSize@SkMask@@QEBA_KXZ"]
        pub fn SkMask_computeImageSize(this: *const root::SkMask) -> usize;
    }
    extern "C" {
        /** Return the byte size of the mask, taking into account
        any extra planes (e.g. k3D_Format).
        If there is an overflow of 32bits, then returns 0.
    */
        #[link_name = "?computeTotalImageSize@SkMask@@QEBA_KXZ"]
        pub fn SkMask_computeTotalImageSize(this: *const root::SkMask)
         -> usize;
    }
    extern "C" {
        /**
     *  Returns the address of the specified pixel, computing the pixel-size
     *  at runtime based on the mask format. This will be slightly slower than
     *  using one of the routines where the format is implied by the name
     *  e.g. getAddr8 or getAddr32.
     *
     *  x,y must be contained by the mask's bounds (this is asserted in the
     *  debug build, but not checked in the release build.)
     *
     *  This should not be called with kBW_Format, as it will give unspecified
     *  results (and assert in the debug build).
     */
        #[link_name = "?getAddr@SkMask@@QEBAPEAXHH@Z"]
        pub fn SkMask_getAddr(this: *const root::SkMask,
                              x: ::std::os::raw::c_int,
                              y: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?AllocImage@SkMask@@SAPEAE_K@Z"]
        pub fn SkMask_AllocImage(bytes: usize) -> *mut u8;
    }
    extern "C" {
        #[link_name = "?FreeImage@SkMask@@SAXPEAX@Z"]
        pub fn SkMask_FreeImage(image: *mut ::std::os::raw::c_void);
    }
    impl Clone for SkMask {
        fn clone(&self) -> Self { *self }
    }
    impl SkMask {
        #[inline]
        pub unsafe fn computeImageSize(&self) -> usize {
            SkMask_computeImageSize(&*self)
        }
        #[inline]
        pub unsafe fn computeTotalImageSize(&self) -> usize {
            SkMask_computeTotalImageSize(&*self)
        }
        #[inline]
        pub unsafe fn getAddr(&self, x: ::std::os::raw::c_int,
                              y: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void {
            SkMask_getAddr(&*self, x, y)
        }
        #[inline]
        pub unsafe fn AllocImage(bytes: usize) -> *mut u8 {
            SkMask_AllocImage(bytes)
        }
        #[inline]
        pub unsafe fn FreeImage(image: *mut ::std::os::raw::c_void) {
            SkMask_FreeImage(image)
        }
    }
    /**
 *  Pairs SkImageInfo with actual pixels and rowbytes. This class does not try to manage the
 *  lifetime of the pixel memory (nor the colortable if provided).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPixmap {
        pub fPixels: *const ::std::os::raw::c_void,
        pub fCTable: *mut root::SkColorTable,
        pub fRowBytes: usize,
        pub fInfo: root::SkImageInfo,
    }
    #[test]
    fn bindgen_test_layout_SkPixmap() {
        assert_eq!(::std::mem::size_of::<SkPixmap>() , 48usize);
        assert_eq!(::std::mem::align_of::<SkPixmap>() , 8usize);
    }
    extern "C" {
        #[link_name = "?reset@SkPixmap@@QEAAXXZ"]
        pub fn SkPixmap_reset(this: *mut root::SkPixmap);
    }
    extern "C" {
        #[link_name =
              "?reset@SkPixmap@@QEAAXAEBUSkImageInfo@@PEBX_KPEAVSkColorTable@@@Z"]
        pub fn SkPixmap_reset1(this: *mut root::SkPixmap,
                               info: *const root::SkImageInfo,
                               addr: *const ::std::os::raw::c_void,
                               rowBytes: usize,
                               ctable: *mut root::SkColorTable);
    }
    extern "C" {
        #[link_name =
              "?setColorSpace@SkPixmap@@QEAAXV?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkPixmap_setColorSpace(this: *mut root::SkPixmap,
                                      arg1: root::sk_sp<root::SkColorSpace>);
    }
    extern "C" {
        /**
     *  If supported, set this pixmap to point to the pixels in the specified mask and return true.
     *  On failure, return false and set this pixmap to empty.
     */
        #[link_name = "?reset@SkPixmap@@QEAA_NAEBUSkMask@@@Z"]
        pub fn SkPixmap_reset2(this: *mut root::SkPixmap,
                               arg1: *const root::SkMask) -> bool;
    }
    extern "C" {
        /**
     *  Computes the intersection of area and this pixmap. If that intersection is non-empty,
     *  set subset to that intersection and return true.
     *
     *  On failure, return false and ignore the subset parameter.
     */
        #[link_name = "?extractSubset@SkPixmap@@QEBA_NPEAV1@AEBUSkIRect@@@Z"]
        pub fn SkPixmap_extractSubset(this: *const root::SkPixmap,
                                      subset: *mut root::SkPixmap,
                                      area: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /**
     *  This will brute-force return true if all of the pixels in the pixmap
     *  are opaque. If there are no pixels, or encounters an error, returns false.
     */
        #[link_name = "?computeIsOpaque@SkPixmap@@QEBA_NXZ"]
        pub fn SkPixmap_computeIsOpaque(this: *const root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Converts the pixel at the specified coordinate to an unpremultiplied
     *  SkColor. Note: this ignores any SkColorSpace information, and may return
     *  lower precision data than is actually in the pixel. Alpha only
     *  colortypes (e.g. kAlpha_8_SkColorType) return black with the appropriate
     *  alpha set.  The value is undefined for kUnknown_SkColorType or if x or y
     *  are out of bounds, or if the pixtap does not have any pixels.
     */
        #[link_name = "?getColor@SkPixmap@@QEBAIHH@Z"]
        pub fn SkPixmap_getColor(this: *const root::SkPixmap,
                                 x: ::std::os::raw::c_int,
                                 y: ::std::os::raw::c_int) -> root::SkColor;
    }
    extern "C" {
        #[link_name =
              "?readPixels@SkPixmap@@QEBA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
        pub fn SkPixmap_readPixels(this: *const root::SkPixmap,
                                   dstInfo: *const root::SkImageInfo,
                                   dstPixels: *mut ::std::os::raw::c_void,
                                   dstRowBytes: usize,
                                   srcX: ::std::os::raw::c_int,
                                   srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Copy the pixels from this pixmap into the dst pixmap, converting as needed into dst's
     *  colortype/alphatype. If the conversion cannot be performed, false is returned.
     *
     *  If dst's dimensions differ from the src dimension, the image will be scaled, applying the
     *  specified filter-quality.
     */
        #[link_name =
              "?scalePixels@SkPixmap@@QEBA_NAEBV1@W4SkFilterQuality@@@Z"]
        pub fn SkPixmap_scalePixels(this: *const root::SkPixmap,
                                    dst: *const root::SkPixmap,
                                    arg1: root::SkFilterQuality) -> bool;
    }
    extern "C" {
        /**
     *  Returns true if pixels were written to (e.g. if colorType is kUnknown_SkColorType, this
     *  will return false). If subset does not intersect the bounds of this pixmap, returns false.
     */
        #[link_name = "?erase@SkPixmap@@QEBA_NIAEBUSkIRect@@@Z"]
        pub fn SkPixmap_erase(this: *const root::SkPixmap,
                              arg1: root::SkColor,
                              subset: *const root::SkIRect) -> bool;
    }
    extern "C" {
        #[link_name = "?erase@SkPixmap@@QEBA_NAEBUSkColor4f@@PEBUSkIRect@@@Z"]
        pub fn SkPixmap_erase1(this: *const root::SkPixmap,
                               arg1: *const root::SkColor4f,
                               subset: *const root::SkIRect) -> bool;
    }
    impl SkPixmap {
        #[inline]
        pub unsafe fn reset(&mut self) { SkPixmap_reset(&mut *self) }
        #[inline]
        pub unsafe fn reset1(&mut self, info: *const root::SkImageInfo,
                             addr: *const ::std::os::raw::c_void,
                             rowBytes: usize,
                             ctable: *mut root::SkColorTable) {
            SkPixmap_reset1(&mut *self, info, addr, rowBytes, ctable)
        }
        #[inline]
        pub unsafe fn setColorSpace(&mut self,
                                    arg1: root::sk_sp<root::SkColorSpace>) {
            SkPixmap_setColorSpace(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn reset2(&mut self, arg1: *const root::SkMask) -> bool {
            SkPixmap_reset2(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn extractSubset(&self, subset: *mut root::SkPixmap,
                                    area: *const root::SkIRect) -> bool {
            SkPixmap_extractSubset(&*self, subset, area)
        }
        #[inline]
        pub unsafe fn computeIsOpaque(&self) -> bool {
            SkPixmap_computeIsOpaque(&*self)
        }
        #[inline]
        pub unsafe fn getColor(&self, x: ::std::os::raw::c_int,
                               y: ::std::os::raw::c_int) -> root::SkColor {
            SkPixmap_getColor(&*self, x, y)
        }
        #[inline]
        pub unsafe fn readPixels(&self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int) -> bool {
            SkPixmap_readPixels(&*self, dstInfo, dstPixels, dstRowBytes, srcX,
                                srcY)
        }
        #[inline]
        pub unsafe fn scalePixels(&self, dst: *const root::SkPixmap,
                                  arg1: root::SkFilterQuality) -> bool {
            SkPixmap_scalePixels(&*self, dst, arg1)
        }
        #[inline]
        pub unsafe fn erase(&self, arg1: root::SkColor,
                            subset: *const root::SkIRect) -> bool {
            SkPixmap_erase(&*self, arg1, subset)
        }
        #[inline]
        pub unsafe fn erase1(&self, arg1: *const root::SkColor4f,
                             subset: *const root::SkIRect) -> bool {
            SkPixmap_erase1(&*self, arg1, subset)
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkAutoPixmapUnlock {
        pub fUnlockProc: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::std::os::raw::c_void)>,
        pub fUnlockContext: *mut ::std::os::raw::c_void,
        pub fPixmap: root::SkPixmap,
        pub fIsLocked: bool,
    }
    #[test]
    fn bindgen_test_layout_SkAutoPixmapUnlock() {
        assert_eq!(::std::mem::size_of::<SkAutoPixmapUnlock>() , 72usize);
        assert_eq!(::std::mem::align_of::<SkAutoPixmapUnlock>() , 8usize);
    }
    extern "C" {
        /**
     *  If there is a currently locked pixmap, unlock it, then copy the specified pixmap
     *  and (optional) unlock proc/context.
     */
        #[link_name =
              "?reset@SkAutoPixmapUnlock@@QEAAXAEBVSkPixmap@@P6AXPEAX@Z1@Z"]
        pub fn SkAutoPixmapUnlock_reset(this: *mut root::SkAutoPixmapUnlock,
                                        pm: *const root::SkPixmap,
                                        unlock:
                                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                           *mut ::std::os::raw::c_void)>,
                                        ctx: *mut ::std::os::raw::c_void);
    }
    impl SkAutoPixmapUnlock {
        #[inline]
        pub unsafe fn reset(&mut self, pm: *const root::SkPixmap,
                            unlock:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut ::std::os::raw::c_void)>,
                            ctx: *mut ::std::os::raw::c_void) {
            SkAutoPixmapUnlock_reset(&mut *self, pm, unlock, ctx)
        }
    }
    #[test]
    fn __bindgen_test_layout_template_5() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkShader>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkShader>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_6() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkColorFilter>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkColorFilter>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_7() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkPathEffect>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkPathEffect>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_8() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkMaskFilter>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkMaskFilter>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_9() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkTypeface>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkTypeface>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_10() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkRasterizer>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkRasterizer>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_11() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkImageFilter>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkImageFilter>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_12() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkDrawLooper>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkDrawLooper>>() ,
                   8usize);
    }
    /** \class SkPaint

    The SkPaint class holds the style and color information about how to draw
    geometries, text and bitmaps.
*/
    #[repr(C)]
    pub struct SkPaint {
        pub fTypeface: root::sk_sp<root::SkTypeface>,
        pub fPathEffect: root::sk_sp<root::SkPathEffect>,
        pub fShader: root::sk_sp<root::SkShader>,
        pub fMaskFilter: root::sk_sp<root::SkMaskFilter>,
        pub fColorFilter: root::sk_sp<root::SkColorFilter>,
        pub fRasterizer: root::sk_sp<root::SkRasterizer>,
        pub fDrawLooper: root::sk_sp<root::SkDrawLooper>,
        pub fImageFilter: root::sk_sp<root::SkImageFilter>,
        pub fTextSize: root::SkScalar,
        pub fTextScaleX: root::SkScalar,
        pub fTextSkewX: root::SkScalar,
        pub fColor: root::SkColor,
        pub fWidth: root::SkScalar,
        pub fMiterLimit: root::SkScalar,
        pub fBlendMode: u32,
        pub __bindgen_anon_1: root::SkPaint__bindgen_ty_1,
    }
    #[repr(i32)]
    /** Specifies the level of hinting to be performed. These names are taken
        from the Gnome/Cairo names for the same. They are translated into
        Freetype concepts the same as in cairo-ft-font.c:
           kNo_Hinting     -> FT_LOAD_NO_HINTING
           kSlight_Hinting -> FT_LOAD_TARGET_LIGHT
           kNormal_Hinting -> <default, no option>
           kFull_Hinting   -> <same as kNormalHinting, unless we are rendering
                              subpixel glyphs, in which case TARGET_LCD or
                              TARGET_LCD_V is used>
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Hinting {
        kNo_Hinting = 0,
        kSlight_Hinting = 1,
        kNormal_Hinting = 2,
        kFull_Hinting = 3,
    }
    pub const SkPaint_Flags_kAntiAlias_Flag: root::SkPaint_Flags =
        SkPaint_Flags(1);
    pub const SkPaint_Flags_kDither_Flag: root::SkPaint_Flags =
        SkPaint_Flags(4);
    pub const SkPaint_Flags_kUnderlineText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(8);
    pub const SkPaint_Flags_kStrikeThruText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(16);
    pub const SkPaint_Flags_kFakeBoldText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(32);
    pub const SkPaint_Flags_kLinearText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(64);
    pub const SkPaint_Flags_kSubpixelText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(128);
    pub const SkPaint_Flags_kDevKernText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(256);
    pub const SkPaint_Flags_kLCDRenderText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(512);
    pub const SkPaint_Flags_kEmbeddedBitmapText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(1024);
    pub const SkPaint_Flags_kAutoHinting_Flag: root::SkPaint_Flags =
        SkPaint_Flags(2048);
    pub const SkPaint_Flags_kVerticalText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(4096);
    pub const SkPaint_Flags_kGenA8FromLCD_Flag: root::SkPaint_Flags =
        SkPaint_Flags(8192);
    pub const SkPaint_Flags_kAllFlags: root::SkPaint_Flags =
        SkPaint_Flags(65535);
    impl ::std::ops::BitOr<root::SkPaint_Flags> for root::SkPaint_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkPaint_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    /** Specifies the bit values that are stored in the paint's flags.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkPaint_Flags(pub i32);
    #[repr(i32)]
    /** Styles apply to rect, oval, path, and text.
        Bitmaps are always drawn in "fill", and lines are always drawn in
        "stroke".

        Note: strokeandfill implicitly draws the result with
        SkPath::kWinding_FillType, so if the original path is even-odd, the
        results may not appear the same as if it was drawn twice, filled and
        then stroked.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Style {
        kFill_Style = 0,
        kStroke_Style = 1,
        kStrokeAndFill_Style = 2,
    }
    pub const SkPaint_kStyleCount: root::SkPaint__bindgen_ty_2 =
        SkPaint__bindgen_ty_2::kStyleCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint__bindgen_ty_2 { kStyleCount = 3, }
    pub const SkPaint_Cap_kLast_Cap: root::SkPaint_Cap =
        SkPaint_Cap::kSquare_Cap;
    pub const SkPaint_Cap_kDefault_Cap: root::SkPaint_Cap =
        SkPaint_Cap::kButt_Cap;
    #[repr(i32)]
    /** Cap enum specifies the settings for the paint's strokecap. This is the
        treatment that is applied to the beginning and end of each non-closed
        contour (e.g. lines).

        If the cap is round or square, the caps are drawn when the contour has
        a zero length. Zero length contours can be created by following moveTo
        with a lineTo at the same point, or a moveTo followed by a close.

        A dash with an on interval of zero also creates a zero length contour.

        The zero length contour draws the square cap without rotation, since
        the no direction can be inferred.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Cap { kButt_Cap = 0, kRound_Cap = 1, kSquare_Cap = 2, }
    pub const SkPaint_Join_kLast_Join: root::SkPaint_Join =
        SkPaint_Join::kBevel_Join;
    pub const SkPaint_Join_kDefault_Join: root::SkPaint_Join =
        SkPaint_Join::kMiter_Join;
    #[repr(i32)]
    /** Join enum specifies the settings for the paint's strokejoin. This is
        the treatment that is applied to corners in paths and rectangles.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Join {
        kMiter_Join = 0,
        kRound_Join = 1,
        kBevel_Join = 2,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Align {
        kLeft_Align = 0,
        kCenter_Align = 1,
        kRight_Align = 2,
    }
    pub const SkPaint_kAlignCount: root::SkPaint__bindgen_ty_3 =
        SkPaint__bindgen_ty_3::kAlignCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint__bindgen_ty_3 { kAlignCount = 3, }
    #[repr(i32)]
    /** Describes how to interpret the text parameters that are passed to paint
        methods like measureText() and getTextWidths().
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_TextEncoding {
        kUTF8_TextEncoding = 0,
        kUTF16_TextEncoding = 1,
        kUTF32_TextEncoding = 2,
        kGlyphID_TextEncoding = 3,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPaint_FontMetrics {
        //< Bit field to identify which values are unknown
        pub fFlags: u32,
        //< The greatest distance above the baseline for any glyph (will be <= 0)
        pub fTop: root::SkScalar,
        //< The recommended distance above the baseline (will be <= 0)
        pub fAscent: root::SkScalar,
        //< The recommended distance below the baseline (will be >= 0)
        pub fDescent: root::SkScalar,
        //< The greatest distance below the baseline for any glyph (will be >= 0)
        pub fBottom: root::SkScalar,
        //< The recommended distance to add between lines of text (will be >= 0)
        pub fLeading: root::SkScalar,
        //< the average character width (>= 0)
        pub fAvgCharWidth: root::SkScalar,
        //< the max character width (>= 0)
        pub fMaxCharWidth: root::SkScalar,
        //< The minimum bounding box x value for all glyphs
        pub fXMin: root::SkScalar,
        //< The maximum bounding box x value for all glyphs
        pub fXMax: root::SkScalar,
        //< The height of an 'x' in px, or 0 if no 'x' in face
        pub fXHeight: root::SkScalar,
        //< The cap height (> 0), or 0 if cannot be determined.
        pub fCapHeight: root::SkScalar,
        //< underline thickness, or 0 if cannot be determined
        pub fUnderlineThickness: root::SkScalar,
        //< underline position, or 0 if cannot be determined
        pub fUnderlinePosition: root::SkScalar,
    }
    pub const SkPaint_FontMetrics_FontMetricsFlags_kUnderlineThinknessIsValid_Flag:
              root::SkPaint_FontMetrics_FontMetricsFlags =
        SkPaint_FontMetrics_FontMetricsFlags(1);
    pub const SkPaint_FontMetrics_FontMetricsFlags_kUnderlinePositionIsValid_Flag:
              root::SkPaint_FontMetrics_FontMetricsFlags =
        SkPaint_FontMetrics_FontMetricsFlags(2);
    impl ::std::ops::BitOr<root::SkPaint_FontMetrics_FontMetricsFlags> for
     root::SkPaint_FontMetrics_FontMetricsFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkPaint_FontMetrics_FontMetricsFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    /** Flags which indicate the confidence level of various metrics.
            A set flag indicates that the metric may be trusted.
        */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkPaint_FontMetrics_FontMetricsFlags(pub i32);
    #[test]
    fn bindgen_test_layout_SkPaint_FontMetrics() {
        assert_eq!(::std::mem::size_of::<SkPaint_FontMetrics>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkPaint_FontMetrics>() , 4usize);
    }
    impl Clone for SkPaint_FontMetrics {
        fn clone(&self) -> Self { *self }
    }
    pub type SkPaint_GlyphCacheProc =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::SkGlyphCache,
                                                   arg2:
                                                       *mut *const ::std::os::raw::c_char)
                                  -> *const root::SkGlyph>;
    #[repr(C)]
    #[derive(Copy)]
    pub union SkPaint__bindgen_ty_1 {
        pub fBitfields: root::SkPaint__bindgen_ty_1__bindgen_ty_1,
        pub fBitfieldsUInt: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPaint__bindgen_ty_1__bindgen_ty_1 {
        pub _bitfield_1: u32,
    }
    #[test]
    fn bindgen_test_layout_SkPaint__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>()
                   , 4usize);
        assert_eq!(::std::mem::align_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>()
                   , 4usize);
    }
    impl Clone for SkPaint__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    impl SkPaint__bindgen_ty_1__bindgen_ty_1 {
        #[inline]
        pub fn fFlags(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (65535usize as u32)) >> 0u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_fFlags(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(65535usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 0u32) & (65535usize as u32);
        }
        #[inline]
        pub fn fTextAlign(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (196608usize as u32)) >> 16u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_fTextAlign(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(196608usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 16u32) & (196608usize as u32);
        }
        #[inline]
        pub fn fCapType(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (786432usize as u32)) >> 18u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_fCapType(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(786432usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 18u32) & (786432usize as u32);
        }
        #[inline]
        pub fn fJoinType(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (3145728usize as u32)) >> 20u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fJoinType(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(3145728usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 20u32) & (3145728usize as u32);
        }
        #[inline]
        pub fn fStyle(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (12582912usize as u32)) >> 22u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fStyle(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(12582912usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 22u32) & (12582912usize as u32);
        }
        #[inline]
        pub fn fTextEncoding(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (50331648usize as u32)) >> 24u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fTextEncoding(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(50331648usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 24u32) & (50331648usize as u32);
        }
        #[inline]
        pub fn fHinting(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (201326592usize as u32)) >> 26u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fHinting(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(201326592usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 26u32) & (201326592usize as u32);
        }
        #[inline]
        pub fn fFilterQuality(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (805306368usize as u32)) >> 28u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fFilterQuality(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(805306368usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 28u32) & (805306368usize as u32);
        }
    }
    #[test]
    fn bindgen_test_layout_SkPaint__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<SkPaint__bindgen_ty_1>() , 4usize);
        assert_eq!(::std::mem::align_of::<SkPaint__bindgen_ty_1>() , 4usize);
    }
    impl Clone for SkPaint__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    pub const SkPaint_ScalerContextFlags_kNone_ScalerContextFlags:
              root::SkPaint_ScalerContextFlags =
        SkPaint_ScalerContextFlags(0);
    pub const SkPaint_ScalerContextFlags_kFakeGamma_ScalerContextFlag:
              root::SkPaint_ScalerContextFlags =
        SkPaint_ScalerContextFlags(1);
    pub const SkPaint_ScalerContextFlags_kBoostContrast_ScalerContextFlag:
              root::SkPaint_ScalerContextFlags =
        SkPaint_ScalerContextFlags(2);
    pub const SkPaint_ScalerContextFlags_kFakeGammaAndBoostContrast_ScalerContextFlags:
              root::SkPaint_ScalerContextFlags =
        SkPaint_ScalerContextFlags(3);
    impl ::std::ops::BitOr<root::SkPaint_ScalerContextFlags> for
     root::SkPaint_ScalerContextFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkPaint_ScalerContextFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkPaint_ScalerContextFlags(pub u32);
    pub const SkPaint_kCanonicalTextSizeForPaths: root::SkPaint__bindgen_ty_4
              =
        SkPaint__bindgen_ty_4::kCanonicalTextSizeForPaths;
    pub const SkPaint_kMaxSizeForGlyphCache: root::SkPaint__bindgen_ty_4 =
        SkPaint__bindgen_ty_4::kMaxSizeForGlyphCache;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint__bindgen_ty_4 {
        kCanonicalTextSizeForPaths = 64,
        kMaxSizeForGlyphCache = 256,
    }
    pub const SkPaint_kCapCount: ::std::os::raw::c_int = 3;
    pub const SkPaint_kJoinCount: ::std::os::raw::c_int = 3;
    #[test]
    fn bindgen_test_layout_SkPaint() {
        assert_eq!(::std::mem::size_of::<SkPaint>() , 96usize);
        assert_eq!(::std::mem::align_of::<SkPaint>() , 8usize);
    }
    extern "C" {
        /** getHash() is a shallow hash, with the same limitations as operator==.
     *  If operator== returns true for two paints, getHash() returns the same value for each.
     */
        #[link_name = "?getHash@SkPaint@@QEBAIXZ"]
        pub fn SkPaint_getHash(this: *const root::SkPaint) -> u32;
    }
    extern "C" {
        #[link_name = "?flatten@SkPaint@@QEBAXAEAVSkWriteBuffer@@@Z"]
        pub fn SkPaint_flatten(this: *const root::SkPaint,
                               arg1: *mut root::SkWriteBuffer);
    }
    extern "C" {
        #[link_name = "?unflatten@SkPaint@@QEAAXAEAVSkReadBuffer@@@Z"]
        pub fn SkPaint_unflatten(this: *mut root::SkPaint,
                                 arg1: *mut root::SkReadBuffer);
    }
    extern "C" {
        /** Restores the paint to its initial settings.
    */
        #[link_name = "?reset@SkPaint@@QEAAXXZ"]
        pub fn SkPaint_reset(this: *mut root::SkPaint);
    }
    extern "C" {
        #[link_name = "?setHinting@SkPaint@@QEAAXW4Hinting@1@@Z"]
        pub fn SkPaint_setHinting(this: *mut root::SkPaint,
                                  hintingLevel: root::SkPaint_Hinting);
    }
    extern "C" {
        /** Set the paint's flags. Use the Flag enum to specific flag values.
        @param flags    The new flag bits for the paint (see Flags enum)
    */
        #[link_name = "?setFlags@SkPaint@@QEAAXI@Z"]
        pub fn SkPaint_setFlags(this: *mut root::SkPaint, flags: u32);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kAntiAlias_Flag bit
        @param aa   true to enable antialiasing, false to disable it
        */
        #[link_name = "?setAntiAlias@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setAntiAlias(this: *mut root::SkPaint, aa: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kDither_Flag bit
        @param dither   true to enable dithering, false to disable it
        */
        #[link_name = "?setDither@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setDither(this: *mut root::SkPaint, dither: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kLinearText_Flag bit
        @param linearText true to set the linearText bit in the paint's flags,
                          false to clear it.
    */
        #[link_name = "?setLinearText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setLinearText(this: *mut root::SkPaint,
                                     linearText: bool);
    }
    extern "C" {
        /**
     *  Helper for setFlags(), setting or clearing the kSubpixelText_Flag.
     *  @param subpixelText true to set the subpixelText bit in the paint's
     *                      flags, false to clear it.
     */
        #[link_name = "?setSubpixelText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setSubpixelText(this: *mut root::SkPaint,
                                       subpixelText: bool);
    }
    extern "C" {
        /**
     *  Helper for setFlags(), setting or clearing the kLCDRenderText_Flag.
     *  Note: antialiasing must also be on for lcd rendering
     *  @param lcdText true to set the LCDRenderText bit in the paint's flags,
     *                 false to clear it.
     */
        #[link_name = "?setLCDRenderText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setLCDRenderText(this: *mut root::SkPaint,
                                        lcdText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kEmbeddedBitmapText_Flag bit
        @param useEmbeddedBitmapText true to set the kEmbeddedBitmapText bit in the paint's flags,
                                     false to clear it.
    */
        #[link_name = "?setEmbeddedBitmapText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setEmbeddedBitmapText(this: *mut root::SkPaint,
                                             useEmbeddedBitmapText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kAutoHinting_Flag bit
        @param useAutohinter true to set the kEmbeddedBitmapText bit in the
                                  paint's flags,
                             false to clear it.
    */
        #[link_name = "?setAutohinted@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setAutohinted(this: *mut root::SkPaint,
                                     useAutohinter: bool);
    }
    extern "C" {
        /**
     *  Helper for setting or clearing the kVerticalText_Flag bit in
     *  setFlags(...).
     *
     *  If this bit is set, then advances are treated as Y values rather than
     *  X values, and drawText will places its glyphs vertically rather than
     *  horizontally.
     */
        #[link_name = "?setVerticalText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setVerticalText(this: *mut root::SkPaint, arg1: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kUnderlineText_Flag bit
        @param underlineText true to set the underlineText bit in the paint's
                             flags, false to clear it.
    */
        #[link_name = "?setUnderlineText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setUnderlineText(this: *mut root::SkPaint,
                                        underlineText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kStrikeThruText_Flag bit
        @param strikeThruText   true to set the strikeThruText bit in the
                                paint's flags, false to clear it.
    */
        #[link_name = "?setStrikeThruText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setStrikeThruText(this: *mut root::SkPaint,
                                         strikeThruText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kFakeBoldText_Flag bit
        @param fakeBoldText true to set the kFakeBoldText_Flag bit in the paint's
                            flags, false to clear it.
    */
        #[link_name = "?setFakeBoldText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setFakeBoldText(this: *mut root::SkPaint,
                                       fakeBoldText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kKernText_Flag bit
        @param kernText true to set the kKernText_Flag bit in the paint's
                            flags, false to clear it.
    */
        #[link_name = "?setDevKernText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setDevKernText(this: *mut root::SkPaint,
                                      devKernText: bool);
    }
    extern "C" {
        /**
     *  Set the filter quality. This affects the quality (and performance) of
     *  drawing scaled images.
     */
        #[link_name = "?setFilterQuality@SkPaint@@QEAAXW4SkFilterQuality@@@Z"]
        pub fn SkPaint_setFilterQuality(this: *mut root::SkPaint,
                                        quality: root::SkFilterQuality);
    }
    extern "C" {
        /** Set the paint's style, used for controlling how primitives'
        geometries are interpreted (except for drawBitmap, which always assumes
        Fill).
        @param style    The new style to set in the paint
    */
        #[link_name = "?setStyle@SkPaint@@QEAAXW4Style@1@@Z"]
        pub fn SkPaint_setStyle(this: *mut root::SkPaint,
                                style: root::SkPaint_Style);
    }
    extern "C" {
        /** Set the paint's color. Note that the color is a 32bit value containing
        alpha as well as r,g,b. This 32bit value is not premultiplied, meaning
        that its alpha can be any value, regardless of the values of r,g,b.
        @param color    The new color (including alpha) to set in the paint.
    */
        #[link_name = "?setColor@SkPaint@@QEAAXI@Z"]
        pub fn SkPaint_setColor(this: *mut root::SkPaint,
                                color: root::SkColor);
    }
    extern "C" {
        /** Helper to setColor(), that only assigns the color's alpha value,
        leaving its r,g,b values unchanged.
        @param a    set the alpha component (0..255) of the paint's color.
    */
        #[link_name = "?setAlpha@SkPaint@@QEAAXI@Z"]
        pub fn SkPaint_setAlpha(this: *mut root::SkPaint, a: root::U8CPU);
    }
    extern "C" {
        /** Helper to setColor(), that takes a,r,g,b and constructs the color value
        using SkColorSetARGB()
        @param a    The new alpha component (0..255) of the paint's color.
        @param r    The new red component (0..255) of the paint's color.
        @param g    The new green component (0..255) of the paint's color.
        @param b    The new blue component (0..255) of the paint's color.
    */
        #[link_name = "?setARGB@SkPaint@@QEAAXIIII@Z"]
        pub fn SkPaint_setARGB(this: *mut root::SkPaint, a: root::U8CPU,
                               r: root::U8CPU, g: root::U8CPU,
                               b: root::U8CPU);
    }
    extern "C" {
        /** Set the width for stroking.
        Pass 0 to stroke in hairline mode.
        Hairlines always draw 1-pixel wide, regardless of the matrix.
        @param width set the paint's stroke width, used whenever the paint's
                     style is Stroke or StrokeAndFill.
    */
        #[link_name = "?setStrokeWidth@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setStrokeWidth(this: *mut root::SkPaint,
                                      width: root::SkScalar);
    }
    extern "C" {
        /** Set the paint's stroke miter value. This is used to control the
        behavior of miter joins when the joins angle is sharp. This value must
        be >= 0.
        @param miter    set the miter limit on the paint, used whenever the
                        paint's style is Stroke or StrokeAndFill.
    */
        #[link_name = "?setStrokeMiter@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setStrokeMiter(this: *mut root::SkPaint,
                                      miter: root::SkScalar);
    }
    extern "C" {
        /** Set the paint's stroke cap type.
        @param cap  set the paint's line cap style, used whenever the paint's
                    style is Stroke or StrokeAndFill.
    */
        #[link_name = "?setStrokeCap@SkPaint@@QEAAXW4Cap@1@@Z"]
        pub fn SkPaint_setStrokeCap(this: *mut root::SkPaint,
                                    cap: root::SkPaint_Cap);
    }
    extern "C" {
        /** Set the paint's stroke join type.
        @param join set the paint's line join style, used whenever the paint's
                    style is Stroke or StrokeAndFill.
    */
        #[link_name = "?setStrokeJoin@SkPaint@@QEAAXW4Join@1@@Z"]
        pub fn SkPaint_setStrokeJoin(this: *mut root::SkPaint,
                                     join: root::SkPaint_Join);
    }
    extern "C" {
        /**
     *  Applies any/all effects (patheffect, stroking) to src, returning the
     *  result in dst. The result is that drawing src with this paint will be
     *  the same as drawing dst with a default paint (at least from the
     *  geometric perspective).
     *
     *  @param src  input path
     *  @param dst  output path (may be the same as src)
     *  @param cullRect If not null, the dst path may be culled to this rect.
     *  @param resScale If > 1, increase precision, else if (0 < res < 1) reduce precision
     *              in favor of speed/size.
     *  @return     true if the path should be filled, or false if it should be
     *              drawn with a hairline (width == 0)
     */
        #[link_name =
              "?getFillPath@SkPaint@@QEBA_NAEBVSkPath@@PEAV2@PEBUSkRect@@M@Z"]
        pub fn SkPaint_getFillPath(this: *const root::SkPaint,
                                   src: *const root::SkPath,
                                   dst: *mut root::SkPath,
                                   cullRect: *const root::SkRect,
                                   resScale: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Set or clear the shader object.
     *  Shaders specify the source color(s) for what is being drawn. If a paint
     *  has no shader, then the paint's color is used. If the paint has a
     *  shader, then the shader's color(s) are use instead, but they are
     *  modulated by the paint's alpha. This makes it easy to create a shader
     *  once (e.g. bitmap tiling or gradient) and then change its transparency
     *  w/o having to modify the original shader... only the paint's alpha needs
     *  to be modified.
     *
     *  There is an exception to this only-respect-paint's-alpha rule: If the shader only generates
     *  alpha (e.g. SkShader::CreateBitmapShader(bitmap) where bitmap's colortype is kAlpha_8)
     *  then the shader will use the paint's entire color to "colorize" its output (modulating the
     *  bitmap's alpha with the paint's color+alpha).
     *
     *  Pass NULL to clear any previous shader.
     *  As a convenience, the parameter passed is also returned.
     *  If a previous shader exists, its reference count is decremented.
     *  If shader is not NULL, its reference count is incremented.
     *  @param shader   May be NULL. The shader to be installed in the paint
     */
        #[link_name = "?setShader@SkPaint@@QEAAXV?$sk_sp@VSkShader@@@@@Z"]
        pub fn SkPaint_setShader(this: *mut root::SkPaint,
                                 arg1: root::sk_sp<root::SkShader>);
    }
    extern "C" {
        /** Set or clear the paint's colorfilter.
        <p />
        If the paint already has a filter, its reference count is decremented.
        If filter is not NULL, its reference count is incremented.
        @param filter   May be NULL. The filter to be installed in the paint
    */
        #[link_name =
              "?setColorFilter@SkPaint@@QEAAXV?$sk_sp@VSkColorFilter@@@@@Z"]
        pub fn SkPaint_setColorFilter(this: *mut root::SkPaint,
                                      arg1: root::sk_sp<root::SkColorFilter>);
    }
    extern "C" {
        /** Set or clear the patheffect object.
        <p />
        Pass NULL to clear any previous patheffect.
        As a convenience, the parameter passed is also returned.
        If a previous patheffect exists, its reference count is decremented.
        If patheffect is not NULL, its reference count is incremented.
        @param effect   May be NULL. The new patheffect to be installed in the
                        paint
        @return         effect
    */
        #[link_name =
              "?setPathEffect@SkPaint@@QEAAXV?$sk_sp@VSkPathEffect@@@@@Z"]
        pub fn SkPaint_setPathEffect(this: *mut root::SkPaint,
                                     arg1: root::sk_sp<root::SkPathEffect>);
    }
    extern "C" {
        /** Set or clear the maskfilter object.
        <p />
        Pass NULL to clear any previous maskfilter.
        As a convenience, the parameter passed is also returned.
        If a previous maskfilter exists, its reference count is decremented.
        If maskfilter is not NULL, its reference count is incremented.
        @param maskfilter   May be NULL. The new maskfilter to be installed in
                            the paint
        @return             maskfilter
    */
        #[link_name =
              "?setMaskFilter@SkPaint@@QEAAXV?$sk_sp@VSkMaskFilter@@@@@Z"]
        pub fn SkPaint_setMaskFilter(this: *mut root::SkPaint,
                                     arg1: root::sk_sp<root::SkMaskFilter>);
    }
    extern "C" {
        /** Set or clear the typeface object.
        <p />
        Pass NULL to clear any previous typeface.
        As a convenience, the parameter passed is also returned.
        If a previous typeface exists, its reference count is decremented.
        If typeface is not NULL, its reference count is incremented.
        @param typeface May be NULL. The new typeface to be installed in the
                        paint
        @return         typeface
    */
        #[link_name = "?setTypeface@SkPaint@@QEAAXV?$sk_sp@VSkTypeface@@@@@Z"]
        pub fn SkPaint_setTypeface(this: *mut root::SkPaint,
                                   arg1: root::sk_sp<root::SkTypeface>);
    }
    extern "C" {
        /** Set or clear the rasterizer object.
        <p />
        Pass NULL to clear any previous rasterizer.
        As a convenience, the parameter passed is also returned.
        If a previous rasterizer exists in the paint, its reference count is
        decremented. If rasterizer is not NULL, its reference count is
        incremented.
        @param rasterizer May be NULL. The new rasterizer to be installed in
                          the paint.
        @return           rasterizer
    */
        #[link_name =
              "?setRasterizer@SkPaint@@QEAAXV?$sk_sp@VSkRasterizer@@@@@Z"]
        pub fn SkPaint_setRasterizer(this: *mut root::SkPaint,
                                     arg1: root::sk_sp<root::SkRasterizer>);
    }
    extern "C" {
        #[link_name =
              "?setImageFilter@SkPaint@@QEAAXV?$sk_sp@VSkImageFilter@@@@@Z"]
        pub fn SkPaint_setImageFilter(this: *mut root::SkPaint,
                                      arg1: root::sk_sp<root::SkImageFilter>);
    }
    extern "C" {
        /**
     *  Set or clear the looper object.
     *  <p />
     *  Pass NULL to clear any previous looper.
     *  If a previous looper exists in the paint, its reference count is
     *  decremented. If looper is not NULL, its reference count is
     *  incremented.
     *  @param looper May be NULL. The new looper to be installed in the paint.
     */
        #[link_name =
              "?setDrawLooper@SkPaint@@QEAAXV?$sk_sp@VSkDrawLooper@@@@@Z"]
        pub fn SkPaint_setDrawLooper(this: *mut root::SkPaint,
                                     arg1: root::sk_sp<root::SkDrawLooper>);
    }
    extern "C" {
        #[link_name = "?setLooper@SkPaint@@QEAAXV?$sk_sp@VSkDrawLooper@@@@@Z"]
        pub fn SkPaint_setLooper(this: *mut root::SkPaint,
                                 arg1: root::sk_sp<root::SkDrawLooper>);
    }
    extern "C" {
        /** Set the paint's text alignment.
        @param align set the paint's Align value for drawing text.
    */
        #[link_name = "?setTextAlign@SkPaint@@QEAAXW4Align@1@@Z"]
        pub fn SkPaint_setTextAlign(this: *mut root::SkPaint,
                                    align: root::SkPaint_Align);
    }
    extern "C" {
        /** Set the paint's text size. This value must be > 0
        @param textSize set the paint's text size.
    */
        #[link_name = "?setTextSize@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setTextSize(this: *mut root::SkPaint,
                                   textSize: root::SkScalar);
    }
    extern "C" {
        /** Set the paint's horizontal scale factor for text. The default value
        is 1.0. Values > 1.0 will stretch the text wider. Values < 1.0 will
        stretch the text narrower.
        @param scaleX   set the paint's scale factor in X for drawing/measuring
                        text.
    */
        #[link_name = "?setTextScaleX@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setTextScaleX(this: *mut root::SkPaint,
                                     scaleX: root::SkScalar);
    }
    extern "C" {
        /** Set the paint's horizontal skew factor for text. The default value
        is 0. For approximating oblique text, use values around -0.25.
        @param skewX set the paint's skew factor in X for drawing text.
    */
        #[link_name = "?setTextSkewX@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setTextSkewX(this: *mut root::SkPaint,
                                    skewX: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?setTextEncoding@SkPaint@@QEAAXW4TextEncoding@1@@Z"]
        pub fn SkPaint_setTextEncoding(this: *mut root::SkPaint,
                                       encoding: root::SkPaint_TextEncoding);
    }
    extern "C" {
        /** Return the recommend spacing between lines (which will be
        fDescent - fAscent + fLeading).
        If metrics is not null, return in it the font metrics for the
        typeface/pointsize/etc. currently set in the paint.
        @param metrics      If not null, returns the font metrics for the
                            current typeface/pointsize/etc setting in this
                            paint.
        @param scale        If not 0, return width as if the canvas were scaled
                            by this value
        @param return the recommended spacing between lines
    */
        #[link_name = "?getFontMetrics@SkPaint@@QEBAMPEAUFontMetrics@1@M@Z"]
        pub fn SkPaint_getFontMetrics(this: *const root::SkPaint,
                                      metrics: *mut root::SkPaint_FontMetrics,
                                      scale: root::SkScalar)
         -> root::SkScalar;
    }
    extern "C" {
        /** Convert the specified text into glyph IDs, returning the number of
        glyphs ID written. If glyphs is NULL, it is ignore and only the count
        is returned.
    */
        #[link_name = "?textToGlyphs@SkPaint@@QEBAHPEBX_KQEAG@Z"]
        pub fn SkPaint_textToGlyphs(this: *const root::SkPaint,
                                    text: *const ::std::os::raw::c_void,
                                    byteLength: usize,
                                    glyphs: *mut root::SkGlyphID)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return true if all of the specified text has a corresponding non-zero
        glyph ID. If any of the code-points in the text are not supported in
        the typeface (i.e. the glyph ID would be zero), then return false.

        If the text encoding for the paint is kGlyph_TextEncoding, then this
        returns true if all of the specified glyph IDs are non-zero.
     */
        #[link_name = "?containsText@SkPaint@@QEBA_NPEBX_K@Z"]
        pub fn SkPaint_containsText(this: *const root::SkPaint,
                                    text: *const ::std::os::raw::c_void,
                                    byteLength: usize) -> bool;
    }
    extern "C" {
        /** Convert the glyph array into Unichars. Unconvertable glyphs are mapped
        to zero. Note: this does not look at the text-encoding setting in the
        paint, only at the typeface.
    */
        #[link_name = "?glyphsToUnichars@SkPaint@@QEBAXQEBGHQEAH@Z"]
        pub fn SkPaint_glyphsToUnichars(this: *const root::SkPaint,
                                        glyphs: *const root::SkGlyphID,
                                        count: ::std::os::raw::c_int,
                                        text: *mut root::SkUnichar);
    }
    extern "C" {
        /** Return the width of the text. This will return the vertical measure
     *  if isVerticalText() is true, in which case the returned value should
     *  be treated has a height instead of a width.
     *
     *  @param text         The text to be measured
     *  @param length       Number of bytes of text to measure
     *  @param bounds       If not NULL, returns the bounds of the text,
     *                      relative to (0, 0).
     *  @return             The advance width of the text
     */
        #[link_name = "?measureText@SkPaint@@QEBAMPEBX_KPEAUSkRect@@@Z"]
        pub fn SkPaint_measureText(this: *const root::SkPaint,
                                   text: *const ::std::os::raw::c_void,
                                   length: usize, bounds: *mut root::SkRect)
         -> root::SkScalar;
    }
    extern "C" {
        /** Return the number of bytes of text that were measured. If
     *  isVerticalText() is true, then the vertical advances are used for
     *  the measurement.
     *
     *  @param text     The text to be measured
     *  @param length   Number of bytes of text to measure
     *  @param maxWidth Maximum width. Only the subset of text whose accumulated
     *                  widths are <= maxWidth are measured.
     *  @param measuredWidth Optional. If non-null, this returns the actual
     *                  width of the measured text.
     *  @return         The number of bytes of text that were measured. Will be
     *                  <= length.
     */
        #[link_name = "?breakText@SkPaint@@QEBA_KPEBX_KMPEAM@Z"]
        pub fn SkPaint_breakText(this: *const root::SkPaint,
                                 text: *const ::std::os::raw::c_void,
                                 length: usize, maxWidth: root::SkScalar,
                                 measuredWidth: *mut root::SkScalar) -> usize;
    }
    extern "C" {
        /** Return the advances for the text. These will be vertical advances if
     *  isVerticalText() returns true.
     *
     *  @param text         the text
     *  @param byteLength   number of bytes to of text
     *  @param widths       If not null, returns the array of advances for
     *                      the glyphs. If not NULL, must be at least a large
     *                      as the number of unichars in the specified text.
     *  @param bounds       If not null, returns the bounds for each of
     *                      character, relative to (0, 0)
     *  @return the number of unichars in the specified text.
     */
        #[link_name = "?getTextWidths@SkPaint@@QEBAHPEBX_KQEAMQEAUSkRect@@@Z"]
        pub fn SkPaint_getTextWidths(this: *const root::SkPaint,
                                     text: *const ::std::os::raw::c_void,
                                     byteLength: usize,
                                     widths: *mut root::SkScalar,
                                     bounds: *mut root::SkRect)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the path (outline) for the specified text.
     *  Note: just like SkCanvas::drawText, this will respect the Align setting
     *        in the paint.
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param x            The x-coordinate of the origin of the text.
     *  @param y            The y-coordinate of the origin of the text.
     *  @param path         The outline of the text.
     */
        #[link_name = "?getTextPath@SkPaint@@QEBAXPEBX_KMMPEAVSkPath@@@Z"]
        pub fn SkPaint_getTextPath(this: *const root::SkPaint,
                                   text: *const ::std::os::raw::c_void,
                                   length: usize, x: root::SkScalar,
                                   y: root::SkScalar,
                                   path: *mut root::SkPath);
    }
    extern "C" {
        /** Return the path (outline) for the specified text.
     *  Note: just like SkCanvas::drawText, this will respect the Align setting
     *        in the paint.
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param pos          array of positions, used to position each character
     *  @param path         The outline of the text.
     */
        #[link_name =
              "?getPosTextPath@SkPaint@@QEBAXPEBX_KQEBUSkPoint@@PEAVSkPath@@@Z"]
        pub fn SkPaint_getPosTextPath(this: *const root::SkPaint,
                                      text: *const ::std::os::raw::c_void,
                                      length: usize,
                                      pos: *const root::SkPoint,
                                      path: *mut root::SkPath);
    }
    extern "C" {
        /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  the string. The caller may pass nullptr for intervals to determine the size of the interval
     *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
     *  intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders. 
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param x            The x-coordinate of the origin of the text.
     *  @param y            The y-coordinate of the origin of the text.
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the found intersections.
     *
     *  @return             The number of intersections, which may be zero.
     */
        #[link_name = "?getTextIntercepts@SkPaint@@QEBAHPEBX_KMMQEBMPEAM@Z"]
        pub fn SkPaint_getTextIntercepts(this: *const root::SkPaint,
                                         text: *const ::std::os::raw::c_void,
                                         length: usize, x: root::SkScalar,
                                         y: root::SkScalar,
                                         bounds: *mut root::SkScalar,
                                         intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  string. The caller may pass nullptr for intervals to determine the size of the interval
     *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
     *  intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders. 
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param pos          array of positions, used to position each character
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
     *
     *  @return             The number of intersections, which may be zero.
     */
        #[link_name =
              "?getPosTextIntercepts@SkPaint@@QEBAHPEBX_KQEBUSkPoint@@QEBMPEAM@Z"]
        pub fn SkPaint_getPosTextIntercepts(this: *const root::SkPaint,
                                            text:
                                                *const ::std::os::raw::c_void,
                                            length: usize,
                                            pos: *const root::SkPoint,
                                            bounds: *mut root::SkScalar,
                                            intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  string. The caller may pass nullptr for intervals to determine the size of the interval
     *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
     *  intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders.
     *
     *  @param text         The text.
     *  @param length       Number of bytes of text.
     *  @param xpos         Array of x-positions, used to position each character.
     *  @param constY       The shared Y coordinate for all of the positions.
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
     *
     *  @return             The number of intersections, which may be zero.
     */
        #[link_name =
              "?getPosTextHIntercepts@SkPaint@@QEBAHPEBX_KQEBMM2PEAM@Z"]
        pub fn SkPaint_getPosTextHIntercepts(this: *const root::SkPaint,
                                             text:
                                                 *const ::std::os::raw::c_void,
                                             length: usize,
                                             xpos: *const root::SkScalar,
                                             constY: root::SkScalar,
                                             bounds: *mut root::SkScalar,
                                             intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  text blob. The caller may pass nullptr for intervals to determine the size of the interval
     *  array. The computed intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders.
     *
     *  @param blob         The text blob.
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
     *
     *  @return             The number of intersections, which may be zero.
     */
        #[link_name =
              "?getTextBlobIntercepts@SkPaint@@QEBAHPEBVSkTextBlob@@QEBMPEAM@Z"]
        pub fn SkPaint_getTextBlobIntercepts(this: *const root::SkPaint,
                                             blob: *const root::SkTextBlob,
                                             bounds: *mut root::SkScalar,
                                             intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /**
     *  Return a rectangle that represents the union of the bounds of all
     *  of the glyphs, but each one positioned at (0,0). This may be conservatively large, and
     *  will not take into account any hinting, but will respect any text-scale-x or text-skew-x
     *  on this paint.
     */
        #[link_name = "?getFontBounds@SkPaint@@QEBA?AUSkRect@@XZ"]
        pub fn SkPaint_getFontBounds(this: *const root::SkPaint)
         -> root::SkRect;
    }
    extern "C" {
        #[link_name = "?nothingToDraw@SkPaint@@QEBA_NXZ"]
        pub fn SkPaint_nothingToDraw(this: *const root::SkPaint) -> bool;
    }
    extern "C" {
        /** Returns true if the current paint settings allow for fast computation of
     bounds (i.e. there is nothing complex like a patheffect that would make
     the bounds computation expensive.
     */
        #[link_name = "?canComputeFastBounds@SkPaint@@QEBA_NXZ"]
        pub fn SkPaint_canComputeFastBounds(this: *const root::SkPaint)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?doComputeFastBounds@SkPaint@@QEBAAEBUSkRect@@AEBU2@PEAU2@W4Style@1@@Z"]
        pub fn SkPaint_doComputeFastBounds(this: *const root::SkPaint,
                                           orig: *const root::SkRect,
                                           storage: *mut root::SkRect,
                                           arg1: root::SkPaint_Style)
         -> *const root::SkRect;
    }
    extern "C" {
        #[link_name = "?toString@SkPaint@@QEBAXPEAVSkString@@@Z"]
        pub fn SkPaint_toString(this: *const root::SkPaint,
                                str: *mut root::SkString);
    }
    impl SkPaint {
        #[inline]
        pub unsafe fn getHash(&self) -> u32 { SkPaint_getHash(&*self) }
        #[inline]
        pub unsafe fn flatten(&self, arg1: *mut root::SkWriteBuffer) {
            SkPaint_flatten(&*self, arg1)
        }
        #[inline]
        pub unsafe fn unflatten(&mut self, arg1: *mut root::SkReadBuffer) {
            SkPaint_unflatten(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkPaint_reset(&mut *self) }
        #[inline]
        pub unsafe fn setHinting(&mut self,
                                 hintingLevel: root::SkPaint_Hinting) {
            SkPaint_setHinting(&mut *self, hintingLevel)
        }
        #[inline]
        pub unsafe fn setFlags(&mut self, flags: u32) {
            SkPaint_setFlags(&mut *self, flags)
        }
        #[inline]
        pub unsafe fn setAntiAlias(&mut self, aa: bool) {
            SkPaint_setAntiAlias(&mut *self, aa)
        }
        #[inline]
        pub unsafe fn setDither(&mut self, dither: bool) {
            SkPaint_setDither(&mut *self, dither)
        }
        #[inline]
        pub unsafe fn setLinearText(&mut self, linearText: bool) {
            SkPaint_setLinearText(&mut *self, linearText)
        }
        #[inline]
        pub unsafe fn setSubpixelText(&mut self, subpixelText: bool) {
            SkPaint_setSubpixelText(&mut *self, subpixelText)
        }
        #[inline]
        pub unsafe fn setLCDRenderText(&mut self, lcdText: bool) {
            SkPaint_setLCDRenderText(&mut *self, lcdText)
        }
        #[inline]
        pub unsafe fn setEmbeddedBitmapText(&mut self,
                                            useEmbeddedBitmapText: bool) {
            SkPaint_setEmbeddedBitmapText(&mut *self, useEmbeddedBitmapText)
        }
        #[inline]
        pub unsafe fn setAutohinted(&mut self, useAutohinter: bool) {
            SkPaint_setAutohinted(&mut *self, useAutohinter)
        }
        #[inline]
        pub unsafe fn setVerticalText(&mut self, arg1: bool) {
            SkPaint_setVerticalText(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setUnderlineText(&mut self, underlineText: bool) {
            SkPaint_setUnderlineText(&mut *self, underlineText)
        }
        #[inline]
        pub unsafe fn setStrikeThruText(&mut self, strikeThruText: bool) {
            SkPaint_setStrikeThruText(&mut *self, strikeThruText)
        }
        #[inline]
        pub unsafe fn setFakeBoldText(&mut self, fakeBoldText: bool) {
            SkPaint_setFakeBoldText(&mut *self, fakeBoldText)
        }
        #[inline]
        pub unsafe fn setDevKernText(&mut self, devKernText: bool) {
            SkPaint_setDevKernText(&mut *self, devKernText)
        }
        #[inline]
        pub unsafe fn setFilterQuality(&mut self,
                                       quality: root::SkFilterQuality) {
            SkPaint_setFilterQuality(&mut *self, quality)
        }
        #[inline]
        pub unsafe fn setStyle(&mut self, style: root::SkPaint_Style) {
            SkPaint_setStyle(&mut *self, style)
        }
        #[inline]
        pub unsafe fn setColor(&mut self, color: root::SkColor) {
            SkPaint_setColor(&mut *self, color)
        }
        #[inline]
        pub unsafe fn setAlpha(&mut self, a: root::U8CPU) {
            SkPaint_setAlpha(&mut *self, a)
        }
        #[inline]
        pub unsafe fn setARGB(&mut self, a: root::U8CPU, r: root::U8CPU,
                              g: root::U8CPU, b: root::U8CPU) {
            SkPaint_setARGB(&mut *self, a, r, g, b)
        }
        #[inline]
        pub unsafe fn setStrokeWidth(&mut self, width: root::SkScalar) {
            SkPaint_setStrokeWidth(&mut *self, width)
        }
        #[inline]
        pub unsafe fn setStrokeMiter(&mut self, miter: root::SkScalar) {
            SkPaint_setStrokeMiter(&mut *self, miter)
        }
        #[inline]
        pub unsafe fn setStrokeCap(&mut self, cap: root::SkPaint_Cap) {
            SkPaint_setStrokeCap(&mut *self, cap)
        }
        #[inline]
        pub unsafe fn setStrokeJoin(&mut self, join: root::SkPaint_Join) {
            SkPaint_setStrokeJoin(&mut *self, join)
        }
        #[inline]
        pub unsafe fn getFillPath(&self, src: *const root::SkPath,
                                  dst: *mut root::SkPath,
                                  cullRect: *const root::SkRect,
                                  resScale: root::SkScalar) -> bool {
            SkPaint_getFillPath(&*self, src, dst, cullRect, resScale)
        }
        #[inline]
        pub unsafe fn setShader(&mut self,
                                arg1: root::sk_sp<root::SkShader>) {
            SkPaint_setShader(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setColorFilter(&mut self,
                                     arg1: root::sk_sp<root::SkColorFilter>) {
            SkPaint_setColorFilter(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setPathEffect(&mut self,
                                    arg1: root::sk_sp<root::SkPathEffect>) {
            SkPaint_setPathEffect(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setMaskFilter(&mut self,
                                    arg1: root::sk_sp<root::SkMaskFilter>) {
            SkPaint_setMaskFilter(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setTypeface(&mut self,
                                  arg1: root::sk_sp<root::SkTypeface>) {
            SkPaint_setTypeface(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setRasterizer(&mut self,
                                    arg1: root::sk_sp<root::SkRasterizer>) {
            SkPaint_setRasterizer(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setImageFilter(&mut self,
                                     arg1: root::sk_sp<root::SkImageFilter>) {
            SkPaint_setImageFilter(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setDrawLooper(&mut self,
                                    arg1: root::sk_sp<root::SkDrawLooper>) {
            SkPaint_setDrawLooper(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setLooper(&mut self,
                                arg1: root::sk_sp<root::SkDrawLooper>) {
            SkPaint_setLooper(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setTextAlign(&mut self, align: root::SkPaint_Align) {
            SkPaint_setTextAlign(&mut *self, align)
        }
        #[inline]
        pub unsafe fn setTextSize(&mut self, textSize: root::SkScalar) {
            SkPaint_setTextSize(&mut *self, textSize)
        }
        #[inline]
        pub unsafe fn setTextScaleX(&mut self, scaleX: root::SkScalar) {
            SkPaint_setTextScaleX(&mut *self, scaleX)
        }
        #[inline]
        pub unsafe fn setTextSkewX(&mut self, skewX: root::SkScalar) {
            SkPaint_setTextSkewX(&mut *self, skewX)
        }
        #[inline]
        pub unsafe fn setTextEncoding(&mut self,
                                      encoding: root::SkPaint_TextEncoding) {
            SkPaint_setTextEncoding(&mut *self, encoding)
        }
        #[inline]
        pub unsafe fn getFontMetrics(&self,
                                     metrics: *mut root::SkPaint_FontMetrics,
                                     scale: root::SkScalar)
         -> root::SkScalar {
            SkPaint_getFontMetrics(&*self, metrics, scale)
        }
        #[inline]
        pub unsafe fn textToGlyphs(&self, text: *const ::std::os::raw::c_void,
                                   byteLength: usize,
                                   glyphs: *mut root::SkGlyphID)
         -> ::std::os::raw::c_int {
            SkPaint_textToGlyphs(&*self, text, byteLength, glyphs)
        }
        #[inline]
        pub unsafe fn containsText(&self, text: *const ::std::os::raw::c_void,
                                   byteLength: usize) -> bool {
            SkPaint_containsText(&*self, text, byteLength)
        }
        #[inline]
        pub unsafe fn glyphsToUnichars(&self, glyphs: *const root::SkGlyphID,
                                       count: ::std::os::raw::c_int,
                                       text: *mut root::SkUnichar) {
            SkPaint_glyphsToUnichars(&*self, glyphs, count, text)
        }
        #[inline]
        pub unsafe fn measureText(&self, text: *const ::std::os::raw::c_void,
                                  length: usize, bounds: *mut root::SkRect)
         -> root::SkScalar {
            SkPaint_measureText(&*self, text, length, bounds)
        }
        #[inline]
        pub unsafe fn breakText(&self, text: *const ::std::os::raw::c_void,
                                length: usize, maxWidth: root::SkScalar,
                                measuredWidth: *mut root::SkScalar) -> usize {
            SkPaint_breakText(&*self, text, length, maxWidth, measuredWidth)
        }
        #[inline]
        pub unsafe fn getTextWidths(&self,
                                    text: *const ::std::os::raw::c_void,
                                    byteLength: usize,
                                    widths: *mut root::SkScalar,
                                    bounds: *mut root::SkRect)
         -> ::std::os::raw::c_int {
            SkPaint_getTextWidths(&*self, text, byteLength, widths, bounds)
        }
        #[inline]
        pub unsafe fn getTextPath(&self, text: *const ::std::os::raw::c_void,
                                  length: usize, x: root::SkScalar,
                                  y: root::SkScalar,
                                  path: *mut root::SkPath) {
            SkPaint_getTextPath(&*self, text, length, x, y, path)
        }
        #[inline]
        pub unsafe fn getPosTextPath(&self,
                                     text: *const ::std::os::raw::c_void,
                                     length: usize, pos: *const root::SkPoint,
                                     path: *mut root::SkPath) {
            SkPaint_getPosTextPath(&*self, text, length, pos, path)
        }
        #[inline]
        pub unsafe fn getTextIntercepts(&self,
                                        text: *const ::std::os::raw::c_void,
                                        length: usize, x: root::SkScalar,
                                        y: root::SkScalar,
                                        bounds: *mut root::SkScalar,
                                        intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int {
            SkPaint_getTextIntercepts(&*self, text, length, x, y, bounds,
                                      intervals)
        }
        #[inline]
        pub unsafe fn getPosTextIntercepts(&self,
                                           text:
                                               *const ::std::os::raw::c_void,
                                           length: usize,
                                           pos: *const root::SkPoint,
                                           bounds: *mut root::SkScalar,
                                           intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int {
            SkPaint_getPosTextIntercepts(&*self, text, length, pos, bounds,
                                         intervals)
        }
        #[inline]
        pub unsafe fn getPosTextHIntercepts(&self,
                                            text:
                                                *const ::std::os::raw::c_void,
                                            length: usize,
                                            xpos: *const root::SkScalar,
                                            constY: root::SkScalar,
                                            bounds: *mut root::SkScalar,
                                            intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int {
            SkPaint_getPosTextHIntercepts(&*self, text, length, xpos, constY,
                                          bounds, intervals)
        }
        #[inline]
        pub unsafe fn getTextBlobIntercepts(&self,
                                            blob: *const root::SkTextBlob,
                                            bounds: *mut root::SkScalar,
                                            intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int {
            SkPaint_getTextBlobIntercepts(&*self, blob, bounds, intervals)
        }
        #[inline]
        pub unsafe fn getFontBounds(&self) -> root::SkRect {
            SkPaint_getFontBounds(&*self)
        }
        #[inline]
        pub unsafe fn nothingToDraw(&self) -> bool {
            SkPaint_nothingToDraw(&*self)
        }
        #[inline]
        pub unsafe fn canComputeFastBounds(&self) -> bool {
            SkPaint_canComputeFastBounds(&*self)
        }
        #[inline]
        pub unsafe fn doComputeFastBounds(&self, orig: *const root::SkRect,
                                          storage: *mut root::SkRect,
                                          arg1: root::SkPaint_Style)
         -> *const root::SkRect {
            SkPaint_doComputeFastBounds(&*self, orig, storage, arg1)
        }
        #[inline]
        pub unsafe fn toString(&self, str: *mut root::SkString) {
            SkPaint_toString(&*self, str)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPixelRef {
        pub _address: u8,
    }
    impl Clone for SkPixelRef {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPixelRefFactory {
        pub _address: u8,
    }
    impl Clone for SkPixelRefFactory {
        fn clone(&self) -> Self { *self }
    }
    /** \class SkRegion

    The SkRegion class encapsulates the geometric region used to specify
    clipping areas for drawing.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkRegion {
        pub fBounds: root::SkIRect,
        pub fRunHead: *mut root::SkRegion_RunHead,
    }
    pub type SkRegion_RunType = i32;
    pub const SkRegion_kRunTypeSentinel: root::SkRegion__bindgen_ty_1 =
        SkRegion__bindgen_ty_1::kRunTypeSentinel;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRegion__bindgen_ty_1 { kRunTypeSentinel = 2147483647, }
    pub const SkRegion_Op_kLastOp: root::SkRegion_Op =
        SkRegion_Op::kReplace_Op;
    #[repr(i32)]
    /**
     *  The logical operations that can be performed when combining two regions.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRegion_Op {
        kDifference_Op = 0,
        kIntersect_Op = 1,
        kUnion_Op = 2,
        kXOR_Op = 3,
        kReverseDifference_Op = 4,
        kReplace_Op = 5,
    }
    /**
     *  Returns the sequence of rectangles, sorted in Y and X, that make up
     *  this region.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRegion_Iterator {
        pub fRgn: *const root::SkRegion,
        pub fRuns: *const root::SkRegion_RunType,
        pub fRect: root::SkIRect,
        pub fDone: bool,
    }
    #[test]
    fn bindgen_test_layout_SkRegion_Iterator() {
        assert_eq!(::std::mem::size_of::<SkRegion_Iterator>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkRegion_Iterator>() , 8usize);
    }
    extern "C" {
        #[link_name = "?rewind@Iterator@SkRegion@@QEAA_NXZ"]
        pub fn SkRegion_Iterator_rewind(this: *mut root::SkRegion_Iterator)
         -> bool;
    }
    extern "C" {
        #[link_name = "?reset@Iterator@SkRegion@@QEAAXAEBV2@@Z"]
        pub fn SkRegion_Iterator_reset(this: *mut root::SkRegion_Iterator,
                                       arg1: *const root::SkRegion);
    }
    extern "C" {
        #[link_name = "?next@Iterator@SkRegion@@QEAAXXZ"]
        pub fn SkRegion_Iterator_next(this: *mut root::SkRegion_Iterator);
    }
    impl Clone for SkRegion_Iterator {
        fn clone(&self) -> Self { *self }
    }
    impl SkRegion_Iterator {
        #[inline]
        pub unsafe fn rewind(&mut self) -> bool {
            SkRegion_Iterator_rewind(&mut *self)
        }
        #[inline]
        pub unsafe fn reset(&mut self, arg1: *const root::SkRegion) {
            SkRegion_Iterator_reset(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn next(&mut self) { SkRegion_Iterator_next(&mut *self) }
    }
    /**
     *  Returns the sequence of rectangles, sorted in Y and X, that make up
     *  this region intersected with the specified clip rectangle.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRegion_Cliperator {
        pub fIter: root::SkRegion_Iterator,
        pub fClip: root::SkIRect,
        pub fRect: root::SkIRect,
        pub fDone: bool,
    }
    #[test]
    fn bindgen_test_layout_SkRegion_Cliperator() {
        assert_eq!(::std::mem::size_of::<SkRegion_Cliperator>() , 80usize);
        assert_eq!(::std::mem::align_of::<SkRegion_Cliperator>() , 8usize);
    }
    extern "C" {
        #[link_name = "?next@Cliperator@SkRegion@@QEAAXXZ"]
        pub fn SkRegion_Cliperator_next(this: *mut root::SkRegion_Cliperator);
    }
    impl Clone for SkRegion_Cliperator {
        fn clone(&self) -> Self { *self }
    }
    impl SkRegion_Cliperator {
        #[inline]
        pub unsafe fn next(&mut self) { SkRegion_Cliperator_next(&mut *self) }
    }
    /**
     *  Returns the sequence of runs that make up this region for the specified
     *  Y scanline, clipped to the specified left and right X values.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRegion_Spanerator {
        pub fRuns: *const root::SkRegion_RunType,
        pub fLeft: ::std::os::raw::c_int,
        pub fRight: ::std::os::raw::c_int,
        pub fDone: bool,
    }
    #[test]
    fn bindgen_test_layout_SkRegion_Spanerator() {
        assert_eq!(::std::mem::size_of::<SkRegion_Spanerator>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkRegion_Spanerator>() , 8usize);
    }
    extern "C" {
        #[link_name = "?next@Spanerator@SkRegion@@QEAA_NPEAH0@Z"]
        pub fn SkRegion_Spanerator_next(this: *mut root::SkRegion_Spanerator,
                                        left: *mut ::std::os::raw::c_int,
                                        right: *mut ::std::os::raw::c_int)
         -> bool;
    }
    impl Clone for SkRegion_Spanerator {
        fn clone(&self) -> Self { *self }
    }
    impl SkRegion_Spanerator {
        #[inline]
        pub unsafe fn next(&mut self, left: *mut ::std::os::raw::c_int,
                           right: *mut ::std::os::raw::c_int) -> bool {
            SkRegion_Spanerator_next(&mut *self, left, right)
        }
    }
    pub const SkRegion_kOpCount: root::SkRegion__bindgen_ty_2 =
        SkRegion__bindgen_ty_2::kOpCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRegion__bindgen_ty_2 { kOpCount = 6, }
    pub const SkRegion_kRectRegionRuns: root::SkRegion__bindgen_ty_3 =
        SkRegion__bindgen_ty_3::kRectRegionRuns;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRegion__bindgen_ty_3 { kRectRegionRuns = 7, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRegion_RunHead {
        pub _address: u8,
    }
    impl Clone for SkRegion_RunHead {
        fn clone(&self) -> Self { *self }
    }
    pub const SkRegion_kOpCnt: ::std::os::raw::c_int = 6;
    #[test]
    fn bindgen_test_layout_SkRegion() {
        assert_eq!(::std::mem::size_of::<SkRegion>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkRegion>() , 8usize);
    }
    extern "C" {
        /**
     *  Swap the contents of this and the specified region. This operation
     *  is gauarenteed to never fail.
     */
        #[link_name = "?swap@SkRegion@@QEAAXAEAV1@@Z"]
        pub fn SkRegion_swap(this: *mut root::SkRegion,
                             arg1: *mut root::SkRegion);
    }
    extern "C" {
        /**
     *  Returns a value that grows approximately linearly with the number of
     *  intervals comprised in the region. Empty region will return 0, Rect
     *  will return 1, Complex will return a value > 1.
     *
     *  Use this to compare two regions, where the larger count likely
     *  indicates a more complex region.
     */
        #[link_name = "?computeRegionComplexity@SkRegion@@QEBAHXZ"]
        pub fn SkRegion_computeRegionComplexity(this: *const root::SkRegion)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /**
     *  Returns true if the region is non-empty, and if so, appends the
     *  boundary(s) of the region to the specified path.
     *  If the region is empty, returns false, and path is left unmodified.
     */
        #[link_name = "?getBoundaryPath@SkRegion@@QEBA_NPEAVSkPath@@@Z"]
        pub fn SkRegion_getBoundaryPath(this: *const root::SkRegion,
                                        path: *mut root::SkPath) -> bool;
    }
    extern "C" {
        /**
     *  Set the region to be empty, and return false, since the resulting
     *  region is empty
     */
        #[link_name = "?setEmpty@SkRegion@@QEAA_NXZ"]
        pub fn SkRegion_setEmpty(this: *mut root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  If rect is non-empty, set this region to that rectangle and return true,
     *  otherwise set this region to empty and return false.
     */
        #[link_name = "?setRect@SkRegion@@QEAA_NAEBUSkIRect@@@Z"]
        pub fn SkRegion_setRect(this: *mut root::SkRegion,
                                arg1: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /**
     *  If left < right and top < bottom, set this region to that rectangle and
     *  return true, otherwise set this region to empty and return false.
     */
        #[link_name = "?setRect@SkRegion@@QEAA_NHHHH@Z"]
        pub fn SkRegion_setRect1(this: *mut root::SkRegion, left: i32,
                                 top: i32, right: i32, bottom: i32) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the union of an array of rects. This is generally
     *  faster than calling region.op(rect, kUnion_Op) in a loop. If count is
     *  0, then this region is set to the empty region.
     *  @return true if the resulting region is non-empty
     */
        #[link_name = "?setRects@SkRegion@@QEAA_NQEBUSkIRect@@H@Z"]
        pub fn SkRegion_setRects(this: *mut root::SkRegion,
                                 rects: *const root::SkIRect,
                                 count: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the specified region, and return true if it is
     *  non-empty.
     */
        #[link_name = "?setRegion@SkRegion@@QEAA_NAEBV1@@Z"]
        pub fn SkRegion_setRegion(this: *mut root::SkRegion,
                                  arg1: *const root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the area described by the path, clipped.
     *  Return true if the resulting region is non-empty.
     *  This produces a region that is identical to the pixels that would be
     *  drawn by the path (with no antialiasing) with the specified clip.
     */
        #[link_name = "?setPath@SkRegion@@QEAA_NAEBVSkPath@@AEBV1@@Z"]
        pub fn SkRegion_setPath(this: *mut root::SkRegion,
                                arg1: *const root::SkPath,
                                clip: *const root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  Returns true if the specified rectangle has a non-empty intersection
     *  with this region.
     */
        #[link_name = "?intersects@SkRegion@@QEBA_NAEBUSkIRect@@@Z"]
        pub fn SkRegion_intersects(this: *const root::SkRegion,
                                   arg1: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /**
     *  Returns true if the specified region has a non-empty intersection
     *  with this region.
     */
        #[link_name = "?intersects@SkRegion@@QEBA_NAEBV1@@Z"]
        pub fn SkRegion_intersects1(this: *const root::SkRegion,
                                    arg1: *const root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  Return true if the specified x,y coordinate is inside the region.
     */
        #[link_name = "?contains@SkRegion@@QEBA_NHH@Z"]
        pub fn SkRegion_contains(this: *const root::SkRegion, x: i32, y: i32)
         -> bool;
    }
    extern "C" {
        /**
     *  Return true if the specified rectangle is completely inside the region.
     *  This works for simple (rectangular) and complex regions, and always
     *  returns the correct result. Note: if either this region or the rectangle
     *  is empty, contains() returns false.
     */
        #[link_name = "?contains@SkRegion@@QEBA_NAEBUSkIRect@@@Z"]
        pub fn SkRegion_contains1(this: *const root::SkRegion,
                                  arg1: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /**
     *  Return true if the specified region is completely inside the region.
     *  This works for simple (rectangular) and complex regions, and always
     *  returns the correct result. Note: if either region is empty, contains()
     *  returns false.
     */
        #[link_name = "?contains@SkRegion@@QEBA_NAEBV1@@Z"]
        pub fn SkRegion_contains2(this: *const root::SkRegion,
                                  arg1: *const root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  Translate the region by the specified (dx, dy) amount, writing the
     *  resulting region into dst. Note: it is legal to pass this region as the
     *  dst parameter, effectively translating the region in place. If dst is
     *  null, nothing happens.
     */
        #[link_name = "?translate@SkRegion@@QEBAXHHPEAV1@@Z"]
        pub fn SkRegion_translate(this: *const root::SkRegion,
                                  dx: ::std::os::raw::c_int,
                                  dy: ::std::os::raw::c_int,
                                  dst: *mut root::SkRegion);
    }
    extern "C" {
        /**
     *  Set this region to the result of applying the Op to the specified
     *  rectangle and region: this = (rect op rgn).
     *  Return true if the resulting region is non-empty.
     */
        #[link_name = "?op@SkRegion@@QEAA_NAEBUSkIRect@@AEBV1@W4Op@1@@Z"]
        pub fn SkRegion_op(this: *mut root::SkRegion,
                           rect: *const root::SkIRect,
                           rgn: *const root::SkRegion,
                           arg1: root::SkRegion_Op) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the result of applying the Op to the specified
     *  region and rectangle: this = (rgn op rect).
     *  Return true if the resulting region is non-empty.
     */
        #[link_name = "?op@SkRegion@@QEAA_NAEBV1@AEBUSkIRect@@W4Op@1@@Z"]
        pub fn SkRegion_op1(this: *mut root::SkRegion,
                            rgn: *const root::SkRegion,
                            rect: *const root::SkIRect,
                            arg1: root::SkRegion_Op) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the result of applying the Op to the specified
     *  regions: this = (rgna op rgnb).
     *  Return true if the resulting region is non-empty.
     */
        #[link_name = "?op@SkRegion@@QEAA_NAEBV1@0W4Op@1@@Z"]
        pub fn SkRegion_op2(this: *mut root::SkRegion,
                            rgna: *const root::SkRegion,
                            rgnb: *const root::SkRegion,
                            op: root::SkRegion_Op) -> bool;
    }
    extern "C" {
        /**
     *  Write the region to the buffer, and return the number of bytes written.
     *  If buffer is NULL, it still returns the number of bytes.
     */
        #[link_name = "?writeToMemory@SkRegion@@QEBA_KPEAX@Z"]
        pub fn SkRegion_writeToMemory(this: *const root::SkRegion,
                                      buffer: *mut ::std::os::raw::c_void)
         -> usize;
    }
    extern "C" {
        /**
     * Initializes the region from the buffer
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
        #[link_name = "?readFromMemory@SkRegion@@QEAA_KPEBX_K@Z"]
        pub fn SkRegion_readFromMemory(this: *mut root::SkRegion,
                                       buffer: *const ::std::os::raw::c_void,
                                       length: usize) -> usize;
    }
    extern "C" {
        /**
     *  Returns a reference to a global empty region. Just a convenience for
     *  callers that need a const empty region.
     */
        #[link_name = "?GetEmptyRegion@SkRegion@@SAAEBV1@XZ"]
        pub fn SkRegion_GetEmptyRegion() -> *const root::SkRegion;
    }
    extern "C" {
        #[link_name = "?dump@SkRegion@@QEBAXXZ"]
        pub fn SkRegion_dump(this: *const root::SkRegion);
    }
    extern "C" {
        #[link_name = "?validate@SkRegion@@QEBAXXZ"]
        pub fn SkRegion_validate(this: *const root::SkRegion);
    }
    extern "C" {
        #[link_name = "?UnitTest@SkRegion@@SAXXZ"]
        pub fn SkRegion_UnitTest();
    }
    extern "C" {
        #[link_name = "?debugSetRuns@SkRegion@@QEAA_NQEBHH@Z"]
        pub fn SkRegion_debugSetRuns(this: *mut root::SkRegion,
                                     runs: *const root::SkRegion_RunType,
                                     count: ::std::os::raw::c_int) -> bool;
    }
    impl SkRegion {
        #[inline]
        pub unsafe fn swap(&mut self, arg1: *mut root::SkRegion) {
            SkRegion_swap(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn computeRegionComplexity(&self)
         -> ::std::os::raw::c_int {
            SkRegion_computeRegionComplexity(&*self)
        }
        #[inline]
        pub unsafe fn getBoundaryPath(&self, path: *mut root::SkPath)
         -> bool {
            SkRegion_getBoundaryPath(&*self, path)
        }
        #[inline]
        pub unsafe fn setEmpty(&mut self) -> bool {
            SkRegion_setEmpty(&mut *self)
        }
        #[inline]
        pub unsafe fn setRect(&mut self, arg1: *const root::SkIRect) -> bool {
            SkRegion_setRect(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setRect1(&mut self, left: i32, top: i32, right: i32,
                               bottom: i32) -> bool {
            SkRegion_setRect1(&mut *self, left, top, right, bottom)
        }
        #[inline]
        pub unsafe fn setRects(&mut self, rects: *const root::SkIRect,
                               count: ::std::os::raw::c_int) -> bool {
            SkRegion_setRects(&mut *self, rects, count)
        }
        #[inline]
        pub unsafe fn setRegion(&mut self, arg1: *const root::SkRegion)
         -> bool {
            SkRegion_setRegion(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setPath(&mut self, arg1: *const root::SkPath,
                              clip: *const root::SkRegion) -> bool {
            SkRegion_setPath(&mut *self, arg1, clip)
        }
        #[inline]
        pub unsafe fn intersects(&self, arg1: *const root::SkIRect) -> bool {
            SkRegion_intersects(&*self, arg1)
        }
        #[inline]
        pub unsafe fn intersects1(&self, arg1: *const root::SkRegion)
         -> bool {
            SkRegion_intersects1(&*self, arg1)
        }
        #[inline]
        pub unsafe fn contains(&self, x: i32, y: i32) -> bool {
            SkRegion_contains(&*self, x, y)
        }
        #[inline]
        pub unsafe fn contains1(&self, arg1: *const root::SkIRect) -> bool {
            SkRegion_contains1(&*self, arg1)
        }
        #[inline]
        pub unsafe fn contains2(&self, arg1: *const root::SkRegion) -> bool {
            SkRegion_contains2(&*self, arg1)
        }
        #[inline]
        pub unsafe fn translate(&self, dx: ::std::os::raw::c_int,
                                dy: ::std::os::raw::c_int,
                                dst: *mut root::SkRegion) {
            SkRegion_translate(&*self, dx, dy, dst)
        }
        #[inline]
        pub unsafe fn op(&mut self, rect: *const root::SkIRect,
                         rgn: *const root::SkRegion, arg1: root::SkRegion_Op)
         -> bool {
            SkRegion_op(&mut *self, rect, rgn, arg1)
        }
        #[inline]
        pub unsafe fn op1(&mut self, rgn: *const root::SkRegion,
                          rect: *const root::SkIRect, arg1: root::SkRegion_Op)
         -> bool {
            SkRegion_op1(&mut *self, rgn, rect, arg1)
        }
        #[inline]
        pub unsafe fn op2(&mut self, rgna: *const root::SkRegion,
                          rgnb: *const root::SkRegion, op: root::SkRegion_Op)
         -> bool {
            SkRegion_op2(&mut *self, rgna, rgnb, op)
        }
        #[inline]
        pub unsafe fn writeToMemory(&self,
                                    buffer: *mut ::std::os::raw::c_void)
         -> usize {
            SkRegion_writeToMemory(&*self, buffer)
        }
        #[inline]
        pub unsafe fn readFromMemory(&mut self,
                                     buffer: *const ::std::os::raw::c_void,
                                     length: usize) -> usize {
            SkRegion_readFromMemory(&mut *self, buffer, length)
        }
        #[inline]
        pub unsafe fn GetEmptyRegion() -> *const root::SkRegion {
            SkRegion_GetEmptyRegion()
        }
        #[inline]
        pub unsafe fn dump(&self) { SkRegion_dump(&*self) }
        #[inline]
        pub unsafe fn validate(&self) { SkRegion_validate(&*self) }
        #[inline]
        pub unsafe fn UnitTest() { SkRegion_UnitTest() }
        #[inline]
        pub unsafe fn debugSetRuns(&mut self,
                                   runs: *const root::SkRegion_RunType,
                                   count: ::std::os::raw::c_int) -> bool {
            SkRegion_debugSetRuns(&mut *self, runs, count)
        }
    }
    /** \class SkBitmap

    The SkBitmap class specifies a raster bitmap. A bitmap has an integer width
    and height, and a format (colortype), and a pointer to the actual pixels.
    Bitmaps can be drawn into a SkCanvas, but they are also used to specify the
    target of a SkCanvas' drawing operations.
    A const SkBitmap exposes getAddr(), which lets a caller write its pixels;
    the constness is considered to apply to the bitmap's configuration, not
    its contents.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBitmap {
        pub fPixelRef: *mut root::SkPixelRef,
        pub fPixelLockCount: ::std::os::raw::c_int,
        pub fPixels: *mut ::std::os::raw::c_void,
        pub fColorTable: *mut root::SkColorTable,
        pub fPixelRefOrigin: root::SkIPoint,
        pub fInfo: root::SkImageInfo,
        pub fRowBytes: u32,
        pub fFlags: u8,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBitmap_Allocator {
        pub _base: root::SkRefCnt,
    }
    pub type SkBitmap_Allocator_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkBitmap_Allocator() {
        assert_eq!(::std::mem::size_of::<SkBitmap_Allocator>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkBitmap_Allocator>() , 8usize);
    }
    /** Subclass of Allocator that returns a pixelref that allocates its pixel
        memory from the heap. This is the default Allocator invoked by
        allocPixels().
    */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBitmap_HeapAllocator {
        pub _base: root::SkBitmap_Allocator,
    }
    #[test]
    fn bindgen_test_layout_SkBitmap_HeapAllocator() {
        assert_eq!(::std::mem::size_of::<SkBitmap_HeapAllocator>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkBitmap_HeapAllocator>() , 8usize);
    }
    #[repr(C)]
    pub struct SkBitmap_RLEPixels__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBitmap_RLEPixels {
        pub vtable_: *const SkBitmap_RLEPixels__bindgen_vtable,
        pub fYPtrs: *mut *mut u8,
        pub fHeight: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_SkBitmap_RLEPixels() {
        assert_eq!(::std::mem::size_of::<SkBitmap_RLEPixels>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkBitmap_RLEPixels>() , 8usize);
    }
    pub const SkBitmap_Flags_kImageIsVolatile_Flag: root::SkBitmap_Flags =
        SkBitmap_Flags(2);
    impl ::std::ops::BitOr<root::SkBitmap_Flags> for root::SkBitmap_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkBitmap_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkBitmap_Flags(pub i32);
    #[test]
    fn bindgen_test_layout_SkBitmap() {
        assert_eq!(::std::mem::size_of::<SkBitmap>() , 72usize);
        assert_eq!(::std::mem::align_of::<SkBitmap>() , 8usize);
    }
    extern "C" {
        /** Swap the fields of the two bitmaps. This routine is guaranteed to never fail or throw.
    */
        #[link_name = "?swap@SkBitmap@@QEAAXAEAV1@@Z"]
        pub fn SkBitmap_swap(this: *mut root::SkBitmap,
                             other: *mut root::SkBitmap);
    }
    extern "C" {
        /**
     *  Set the bitmap's alphaType, returning true on success. If false is
     *  returned, then the specified new alphaType is incompatible with the
     *  colortype, and the current alphaType is unchanged.
     *
     *  Note: this changes the alphatype for the underlying pixels, which means
     *  that all bitmaps that might be sharing (subsets of) the pixels will
     *  be affected.
     */
        #[link_name = "?setAlphaType@SkBitmap@@QEAA_NW4SkAlphaType@@@Z"]
        pub fn SkBitmap_setAlphaType(this: *mut root::SkBitmap,
                                     arg1: root::SkAlphaType) -> bool;
    }
    extern "C" {
        /** Returns true if this bitmap is marked as immutable, meaning that the
        contents of its pixels will not change for the lifetime of the bitmap.
    */
        #[link_name = "?isImmutable@SkBitmap@@QEBA_NXZ"]
        pub fn SkBitmap_isImmutable(this: *const root::SkBitmap) -> bool;
    }
    extern "C" {
        /** Marks this bitmap as immutable, meaning that the contents of its
        pixels will not change for the lifetime of the bitmap and of the
        underlying pixelref. This state can be set, but it cannot be
        cleared once it is set. This state propagates to all other bitmaps
        that share the same pixelref.
    */
        #[link_name = "?setImmutable@SkBitmap@@QEAAXXZ"]
        pub fn SkBitmap_setImmutable(this: *mut root::SkBitmap);
    }
    extern "C" {
        /** Returns true if the bitmap is volatile (i.e. should not be cached by devices.)
    */
        #[link_name = "?isVolatile@SkBitmap@@QEBA_NXZ"]
        pub fn SkBitmap_isVolatile(this: *const root::SkBitmap) -> bool;
    }
    extern "C" {
        /** Specify whether this bitmap is volatile. Bitmaps are not volatile by
        default. Temporary bitmaps that are discarded after use should be
        marked as volatile. This provides a hint to the device that the bitmap
        should not be cached. Providing this hint when appropriate can
        improve performance by avoiding unnecessary overhead and resource
        consumption on the device.
    */
        #[link_name = "?setIsVolatile@SkBitmap@@QEAAX_N@Z"]
        pub fn SkBitmap_setIsVolatile(this: *mut root::SkBitmap, arg1: bool);
    }
    extern "C" {
        /** Reset the bitmap to its initial state (see default constructor). If we are a (shared)
        owner of the pixels, that ownership is decremented.
    */
        #[link_name = "?reset@SkBitmap@@QEAAXXZ"]
        pub fn SkBitmap_reset(this: *mut root::SkBitmap);
    }
    extern "C" {
        /**
     *  Return the bitmap's bounds [0, 0, width, height] as an SkRect
     */
        #[link_name = "?getBounds@SkBitmap@@QEBAXPEAUSkRect@@@Z"]
        pub fn SkBitmap_getBounds(this: *const root::SkBitmap,
                                  bounds: *mut root::SkRect);
    }
    extern "C" {
        #[link_name = "?getBounds@SkBitmap@@QEBAXPEAUSkIRect@@@Z"]
        pub fn SkBitmap_getBounds1(this: *const root::SkBitmap,
                                   bounds: *mut root::SkIRect);
    }
    extern "C" {
        #[link_name = "?setInfo@SkBitmap@@QEAA_NAEBUSkImageInfo@@_K@Z"]
        pub fn SkBitmap_setInfo(this: *mut root::SkBitmap,
                                arg1: *const root::SkImageInfo,
                                rowBytes: usize) -> bool;
    }
    extern "C" {
        /**
     *  Allocate the bitmap's pixels to match the requested image info. If the Factory
     *  is non-null, call it to allcoate the pixelref. If the ImageInfo requires
     *  a colortable, then ColorTable must be non-null, and will be ref'd.
     *  On failure, the bitmap will be set to empty and return false.
     */
        #[link_name =
              "?tryAllocPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@PEAVSkPixelRefFactory@@PEAVSkColorTable@@@Z"]
        pub fn SkBitmap_tryAllocPixels(this: *mut root::SkBitmap,
                                       arg1: *const root::SkImageInfo,
                                       arg2: *mut root::SkPixelRefFactory,
                                       arg3: *mut root::SkColorTable) -> bool;
    }
    extern "C" {
        /**
     *  Allocate the bitmap's pixels to match the requested image info and
     *  rowBytes. If the request cannot be met (e.g. the info is invalid or
     *  the requested rowBytes are not compatible with the info
     *  (e.g. rowBytes < info.minRowBytes() or rowBytes is not aligned with
     *  the pixel size specified by info.colorType()) then false is returned
     *  and the bitmap is set to empty.
     */
        #[link_name = "?tryAllocPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@_K@Z"]
        pub fn SkBitmap_tryAllocPixels1(this: *mut root::SkBitmap,
                                        info: *const root::SkImageInfo,
                                        rowBytes: usize) -> bool;
    }
    extern "C" {
        /**
     *  Install a pixelref that wraps the specified pixels and rowBytes, and
     *  optional ReleaseProc and context. When the pixels are no longer
     *  referenced, if releaseProc is not null, it will be called with the
     *  pixels and context as parameters.
     *  On failure, the bitmap will be set to empty and return false.
     *
     *  If specified, the releaseProc will always be called, even on failure. It is also possible
     *  for success but the releaseProc is immediately called (e.g. valid Info but NULL pixels).
     */
        #[link_name =
              "?installPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@PEAX_KPEAVSkColorTable@@P6AX11@Z1@Z"]
        pub fn SkBitmap_installPixels(this: *mut root::SkBitmap,
                                      arg1: *const root::SkImageInfo,
                                      pixels: *mut ::std::os::raw::c_void,
                                      rowBytes: usize,
                                      arg2: *mut root::SkColorTable,
                                      releaseProc:
                                          ::std::option::Option<unsafe extern "C" fn(addr:
                                                                                         *mut ::std::os::raw::c_void,
                                                                                     context:
                                                                                         *mut ::std::os::raw::c_void)>,
                                      context: *mut ::std::os::raw::c_void)
         -> bool;
    }
    extern "C" {
        /**
     *  Call installPixels with no ReleaseProc specified. This means
     *  that the caller must ensure that the specified pixels and
     *  colortable are valid for the lifetime of the created bitmap
     *  (and its pixelRef).
     */
        #[link_name = "?installPixels@SkBitmap@@QEAA_NAEBVSkPixmap@@@Z"]
        pub fn SkBitmap_installPixels1(this: *mut root::SkBitmap,
                                       arg1: *const root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Calls installPixels() with the value in the SkMask. The caller must
     *  ensure that the specified mask pixels are valid for the lifetime
     *  of the created bitmap (and its pixelRef).
     */
        #[link_name = "?installMaskPixels@SkBitmap@@QEAA_NAEBUSkMask@@@Z"]
        pub fn SkBitmap_installMaskPixels(this: *mut root::SkBitmap,
                                          arg1: *const root::SkMask) -> bool;
    }
    extern "C" {
        /** Use this to assign a new pixel address for an existing bitmap. This
        will automatically release any pixelref previously installed. Only call
        this if you are handling ownership/lifetime of the pixel memory.

        If the bitmap retains a reference to the colortable (assuming it is
        not null) it will take care of incrementing the reference count.

        @param pixels   Address for the pixels, managed by the caller.
        @param ctable   ColorTable (or null) that matches the specified pixels
    */
        #[link_name = "?setPixels@SkBitmap@@QEAAXPEAXPEAVSkColorTable@@@Z"]
        pub fn SkBitmap_setPixels(this: *mut root::SkBitmap,
                                  p: *mut ::std::os::raw::c_void,
                                  ctable: *mut root::SkColorTable);
    }
    extern "C" {
        /** Copies the bitmap's pixels to the location pointed at by dst and returns
        true if possible, returns false otherwise.

        In the case when the dstRowBytes matches the bitmap's rowBytes, the copy
        may be made faster by copying over the dst's per-row padding (for all
        rows but the last). By setting preserveDstPad to true the caller can
        disable this optimization and ensure that pixels in the padding are not
        overwritten.

        Always returns false for RLE formats.

        @param dst      Location of destination buffer.
        @param dstSize  Size of destination buffer. Must be large enough to hold
                        pixels using indicated stride.
        @param dstRowBytes  Width of each line in the buffer. If 0, uses
                            bitmap's internal stride.
        @param preserveDstPad Must we preserve padding in the dst
    */
        #[link_name = "?copyPixelsTo@SkBitmap@@QEBA_NQEAX_K1_N@Z"]
        pub fn SkBitmap_copyPixelsTo(this: *const root::SkBitmap,
                                     dst: *const ::std::os::raw::c_void,
                                     dstSize: usize, dstRowBytes: usize,
                                     preserveDstPad: bool) -> bool;
    }
    extern "C" {
        /** Use the specified Allocator to create the pixelref that manages the
        pixel memory. It will be sized based on the current ImageInfo.
        If this is called multiple times, a new pixelref object will be created
        each time.

        If the bitmap retains a reference to the colortable (assuming it is
        not null) it will take care of incrementing the reference count.

        @param allocator The Allocator to use to create a pixelref that can
                         manage the pixel memory for the current ImageInfo.
                         If allocator is NULL, the standard HeapAllocator will be used.
        @param ctable   ColorTable (or null) to use with the pixels that will
                        be allocated. Only used if colortype == kIndex_8_SkColorType.
                        If it is non-null and the colortype is not indexed, it will
                        be ignored.
        @return true if the allocation succeeds. If not the pixelref field of
                     the bitmap will be unchanged.
    */
        #[link_name =
              "?tryAllocPixels@SkBitmap@@QEAA_NPEAVAllocator@1@PEAVSkColorTable@@@Z"]
        pub fn SkBitmap_tryAllocPixels2(this: *mut root::SkBitmap,
                                        allocator:
                                            *mut root::SkBitmap_Allocator,
                                        ctable: *mut root::SkColorTable)
         -> bool;
    }
    extern "C" {
        /**
     *  Assign a pixelref and origin to the bitmap. Pixelrefs are reference,
     *  so the existing one (if any) will be unref'd and the new one will be
     *  ref'd. (x,y) specify the offset within the pixelref's pixels for the
     *  top/left corner of the bitmap. For a bitmap that encompases the entire
     *  pixels of the pixelref, these will be (0,0).
     */
        #[link_name = "?setPixelRef@SkBitmap@@QEAAPEAVSkPixelRef@@PEAV2@HH@Z"]
        pub fn SkBitmap_setPixelRef(this: *mut root::SkBitmap,
                                    pr: *mut root::SkPixelRef,
                                    dx: ::std::os::raw::c_int,
                                    dy: ::std::os::raw::c_int)
         -> *mut root::SkPixelRef;
    }
    extern "C" {
        /** Call this to ensure that the bitmap points to the current pixel address
        in the pixelref. Balance it with a call to unlockPixels(). These calls
        are harmless if there is no pixelref.
    */
        #[link_name = "?lockPixels@SkBitmap@@QEBAXXZ"]
        pub fn SkBitmap_lockPixels(this: *const root::SkBitmap);
    }
    extern "C" {
        /** When you are finished access the pixel memory, call this to balance a
        previous call to lockPixels(). This allows pixelrefs that implement
        cached/deferred image decoding to know when there are active clients of
        a given image.
    */
        #[link_name = "?unlockPixels@SkBitmap@@QEBAXXZ"]
        pub fn SkBitmap_unlockPixels(this: *const root::SkBitmap);
    }
    extern "C" {
        /**
     *  Some bitmaps can return a copy of their pixels for lockPixels(), but
     *  that copy, if modified, will not be pushed back. These bitmaps should
     *  not be used as targets for a raster device/canvas (since all pixels
     *  modifications will be lost when unlockPixels() is called.)
     */
        #[link_name = "?lockPixelsAreWritable@SkBitmap@@QEBA_NXZ"]
        pub fn SkBitmap_lockPixelsAreWritable(this: *const root::SkBitmap)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?requestLock@SkBitmap@@QEBA_NPEAVSkAutoPixmapUnlock@@@Z"]
        pub fn SkBitmap_requestLock(this: *const root::SkBitmap,
                                    result: *mut root::SkAutoPixmapUnlock)
         -> bool;
    }
    extern "C" {
        /** Returns a non-zero, unique value corresponding to the pixels in our
        pixelref. Each time the pixels are changed (and notifyPixelsChanged
        is called), a different generation ID will be returned. Finally, if
        there is no pixelRef then zero is returned.
    */
        #[link_name = "?getGenerationID@SkBitmap@@QEBAIXZ"]
        pub fn SkBitmap_getGenerationID(this: *const root::SkBitmap) -> u32;
    }
    extern "C" {
        /** Call this if you have changed the contents of the pixels. This will in-
        turn cause a different generation ID value to be returned from
        getGenerationID().
    */
        #[link_name = "?notifyPixelsChanged@SkBitmap@@QEBAXXZ"]
        pub fn SkBitmap_notifyPixelsChanged(this: *const root::SkBitmap);
    }
    extern "C" {
        /**
     *  Fill the entire bitmap with the specified color.
     *  If the bitmap's colortype does not support alpha (e.g. 565) then the alpha
     *  of the color is ignored (treated as opaque). If the colortype only supports
     *  alpha (e.g. A1 or A8) then the color's r,g,b components are ignored.
     */
        #[link_name = "?eraseColor@SkBitmap@@QEBAXI@Z"]
        pub fn SkBitmap_eraseColor(this: *const root::SkBitmap,
                                   c: root::SkColor);
    }
    extern "C" {
        /**
     *  Fill the specified area of this bitmap with the specified color.
     *  If the bitmap's colortype does not support alpha (e.g. 565) then the alpha
     *  of the color is ignored (treated as opaque). If the colortype only supports
     *  alpha (e.g. A1 or A8) then the color's r,g,b components are ignored.
     */
        #[link_name = "?erase@SkBitmap@@QEBAXIAEBUSkIRect@@@Z"]
        pub fn SkBitmap_erase(this: *const root::SkBitmap, c: root::SkColor,
                              area: *const root::SkIRect);
    }
    extern "C" {
        /** Returns the address of the specified pixel. This performs a runtime
        check to know the size of the pixels, and will return the same answer
        as the corresponding size-specific method (e.g. getAddr16). Since the
        check happens at runtime, it is much slower than using a size-specific
        version. Unlike the size-specific methods, this routine also checks if
        getPixels() returns null, and returns that. The size-specific routines
        perform a debugging assert that getPixels() is not null, but they do
        not do any runtime checks.
    */
        #[link_name = "?getAddr@SkBitmap@@QEBAPEAXHH@Z"]
        pub fn SkBitmap_getAddr(this: *const root::SkBitmap,
                                x: ::std::os::raw::c_int,
                                y: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        /** Set dst to be a setset of this bitmap. If possible, it will share the
        pixel memory, and just point into a subset of it. However, if the colortype
        does not support this, a local copy will be made and associated with
        the dst bitmap. If the subset rectangle, intersected with the bitmap's
        dimensions is empty, or if there is an unsupported colortype, false will be
        returned and dst will be untouched.
        @param dst  The bitmap that will be set to a subset of this bitmap
        @param subset The rectangle of pixels in this bitmap that dst will
                      reference.
        @return true if the subset copy was successfully made.
    */
        #[link_name = "?extractSubset@SkBitmap@@QEBA_NPEAV1@AEBUSkIRect@@@Z"]
        pub fn SkBitmap_extractSubset(this: *const root::SkBitmap,
                                      dst: *mut root::SkBitmap,
                                      subset: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /** Makes a deep copy of this bitmap, respecting the requested colorType,
     *  and allocating the dst pixels on the cpu.
     *  Returns false if either there is an error (i.e. the src does not have
     *  pixels) or the request cannot be satisfied (e.g. the src has per-pixel
     *  alpha, and the requested colortype does not support alpha).
     *  @param dst The bitmap to be sized and allocated
     *  @param ct The desired colorType for dst
     *  @param allocator Allocator used to allocate the pixelref for the dst
     *                   bitmap. If this is null, the standard HeapAllocator
     *                   will be used.
     *  @return true if the copy was made.
     */
        #[link_name =
              "?copyTo@SkBitmap@@QEBA_NPEAV1@W4SkColorType@@PEAVAllocator@1@@Z"]
        pub fn SkBitmap_copyTo(this: *const root::SkBitmap,
                               dst: *mut root::SkBitmap,
                               ct: root::SkColorType,
                               arg1: *mut root::SkBitmap_Allocator) -> bool;
    }
    extern "C" {
        /**
     *  Copy the bitmap's pixels into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (SkImageInfo). The src pixels are read
     *  starting at the specified (srcX,srcY) offset, relative to the top-left corner.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the bitmap. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the bitmap bounds.
     *  - If the requested colortype/alphatype cannot be converted from the src's types.
     *  - If the src pixels are not available.
     */
        #[link_name =
              "?readPixels@SkBitmap@@QEBA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
        pub fn SkBitmap_readPixels(this: *const root::SkBitmap,
                                   dstInfo: *const root::SkImageInfo,
                                   dstPixels: *mut ::std::os::raw::c_void,
                                   dstRowBytes: usize,
                                   srcX: ::std::os::raw::c_int,
                                   srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Returns true if this bitmap's pixels can be converted into the requested
     *  colorType, such that copyTo() could succeed.
     */
        #[link_name = "?canCopyTo@SkBitmap@@QEBA_NW4SkColorType@@@Z"]
        pub fn SkBitmap_canCopyTo(this: *const root::SkBitmap,
                                  colorType: root::SkColorType) -> bool;
    }
    extern "C" {
        /** Makes a deep copy of this bitmap, keeping the copied pixels
     *  in the same domain as the source: If the src pixels are allocated for
     *  the cpu, then so will the dst. If the src pixels are allocated on the
     *  gpu (typically as a texture), the it will do the same for the dst.
     *  If the request cannot be fulfilled, returns false and dst is unmodified.
     */
        #[link_name = "?deepCopyTo@SkBitmap@@QEBA_NPEAV1@@Z"]
        pub fn SkBitmap_deepCopyTo(this: *const root::SkBitmap,
                                   dst: *mut root::SkBitmap) -> bool;
    }
    extern "C" {
        /** Set dst to contain alpha layer of this bitmap. If destination bitmap
        fails to be initialized, e.g. because allocator can't allocate pixels
        for it, dst will not be modified and false will be returned.

        @param dst The bitmap to be filled with alpha layer
        @param paint The paint to draw with
        @param allocator Allocator used to allocate the pixelref for the dst
                         bitmap. If this is null, the standard HeapAllocator
                         will be used.
        @param offset If not null, it is set to top-left coordinate to position
                      the returned bitmap so that it visually lines up with the
                      original
    */
        #[link_name =
              "?extractAlpha@SkBitmap@@QEBA_NPEAV1@PEBVSkPaint@@PEAVAllocator@1@PEAUSkIPoint@@@Z"]
        pub fn SkBitmap_extractAlpha(this: *const root::SkBitmap,
                                     dst: *mut root::SkBitmap,
                                     paint: *const root::SkPaint,
                                     allocator: *mut root::SkBitmap_Allocator,
                                     offset: *mut root::SkIPoint) -> bool;
    }
    extern "C" {
        /**
     *  If the pixels are available from this bitmap (w/o locking) return true, and fill out the
     *  specified pixmap (if not null). If the pixels are not available (either because there are
     *  none, or becuase accessing them would require locking or other machinary) return false and
     *  ignore the pixmap parameter.
     *
     *  Note: if this returns true, the results (in the pixmap) are only valid until the bitmap
     *  is changed in anyway, in which case the results are invalid.
     */
        #[link_name = "?peekPixels@SkBitmap@@QEBA_NPEAVSkPixmap@@@Z"]
        pub fn SkBitmap_peekPixels(this: *const root::SkBitmap,
                                   arg1: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        #[link_name = "?validate@SkBitmap@@QEBAXXZ"]
        pub fn SkBitmap_validate(this: *const root::SkBitmap);
    }
    extern "C" {
        #[link_name = "?toString@SkBitmap@@QEBAXPEAVSkString@@@Z"]
        pub fn SkBitmap_toString(this: *const root::SkBitmap,
                                 str: *mut root::SkString);
    }
    impl SkBitmap {
        #[inline]
        pub unsafe fn swap(&mut self, other: *mut root::SkBitmap) {
            SkBitmap_swap(&mut *self, other)
        }
        #[inline]
        pub unsafe fn setAlphaType(&mut self, arg1: root::SkAlphaType)
         -> bool {
            SkBitmap_setAlphaType(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn isImmutable(&self) -> bool {
            SkBitmap_isImmutable(&*self)
        }
        #[inline]
        pub unsafe fn setImmutable(&mut self) {
            SkBitmap_setImmutable(&mut *self)
        }
        #[inline]
        pub unsafe fn isVolatile(&self) -> bool {
            SkBitmap_isVolatile(&*self)
        }
        #[inline]
        pub unsafe fn setIsVolatile(&mut self, arg1: bool) {
            SkBitmap_setIsVolatile(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkBitmap_reset(&mut *self) }
        #[inline]
        pub unsafe fn getBounds(&self, bounds: *mut root::SkRect) {
            SkBitmap_getBounds(&*self, bounds)
        }
        #[inline]
        pub unsafe fn getBounds1(&self, bounds: *mut root::SkIRect) {
            SkBitmap_getBounds1(&*self, bounds)
        }
        #[inline]
        pub unsafe fn setInfo(&mut self, arg1: *const root::SkImageInfo,
                              rowBytes: usize) -> bool {
            SkBitmap_setInfo(&mut *self, arg1, rowBytes)
        }
        #[inline]
        pub unsafe fn tryAllocPixels(&mut self,
                                     arg1: *const root::SkImageInfo,
                                     arg2: *mut root::SkPixelRefFactory,
                                     arg3: *mut root::SkColorTable) -> bool {
            SkBitmap_tryAllocPixels(&mut *self, arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn tryAllocPixels1(&mut self,
                                      info: *const root::SkImageInfo,
                                      rowBytes: usize) -> bool {
            SkBitmap_tryAllocPixels1(&mut *self, info, rowBytes)
        }
        #[inline]
        pub unsafe fn installPixels(&mut self, arg1: *const root::SkImageInfo,
                                    pixels: *mut ::std::os::raw::c_void,
                                    rowBytes: usize,
                                    arg2: *mut root::SkColorTable,
                                    releaseProc:
                                        ::std::option::Option<unsafe extern "C" fn(addr:
                                                                                       *mut ::std::os::raw::c_void,
                                                                                   context:
                                                                                       *mut ::std::os::raw::c_void)>,
                                    context: *mut ::std::os::raw::c_void)
         -> bool {
            SkBitmap_installPixels(&mut *self, arg1, pixels, rowBytes, arg2,
                                   releaseProc, context)
        }
        #[inline]
        pub unsafe fn installPixels1(&mut self, arg1: *const root::SkPixmap)
         -> bool {
            SkBitmap_installPixels1(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn installMaskPixels(&mut self, arg1: *const root::SkMask)
         -> bool {
            SkBitmap_installMaskPixels(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setPixels(&mut self, p: *mut ::std::os::raw::c_void,
                                ctable: *mut root::SkColorTable) {
            SkBitmap_setPixels(&mut *self, p, ctable)
        }
        #[inline]
        pub unsafe fn copyPixelsTo(&self, dst: *const ::std::os::raw::c_void,
                                   dstSize: usize, dstRowBytes: usize,
                                   preserveDstPad: bool) -> bool {
            SkBitmap_copyPixelsTo(&*self, dst, dstSize, dstRowBytes,
                                  preserveDstPad)
        }
        #[inline]
        pub unsafe fn tryAllocPixels2(&mut self,
                                      allocator:
                                          *mut root::SkBitmap_Allocator,
                                      ctable: *mut root::SkColorTable)
         -> bool {
            SkBitmap_tryAllocPixels2(&mut *self, allocator, ctable)
        }
        #[inline]
        pub unsafe fn setPixelRef(&mut self, pr: *mut root::SkPixelRef,
                                  dx: ::std::os::raw::c_int,
                                  dy: ::std::os::raw::c_int)
         -> *mut root::SkPixelRef {
            SkBitmap_setPixelRef(&mut *self, pr, dx, dy)
        }
        #[inline]
        pub unsafe fn lockPixels(&self) { SkBitmap_lockPixels(&*self) }
        #[inline]
        pub unsafe fn unlockPixels(&self) { SkBitmap_unlockPixels(&*self) }
        #[inline]
        pub unsafe fn lockPixelsAreWritable(&self) -> bool {
            SkBitmap_lockPixelsAreWritable(&*self)
        }
        #[inline]
        pub unsafe fn requestLock(&self,
                                  result: *mut root::SkAutoPixmapUnlock)
         -> bool {
            SkBitmap_requestLock(&*self, result)
        }
        #[inline]
        pub unsafe fn getGenerationID(&self) -> u32 {
            SkBitmap_getGenerationID(&*self)
        }
        #[inline]
        pub unsafe fn notifyPixelsChanged(&self) {
            SkBitmap_notifyPixelsChanged(&*self)
        }
        #[inline]
        pub unsafe fn eraseColor(&self, c: root::SkColor) {
            SkBitmap_eraseColor(&*self, c)
        }
        #[inline]
        pub unsafe fn erase(&self, c: root::SkColor,
                            area: *const root::SkIRect) {
            SkBitmap_erase(&*self, c, area)
        }
        #[inline]
        pub unsafe fn getAddr(&self, x: ::std::os::raw::c_int,
                              y: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void {
            SkBitmap_getAddr(&*self, x, y)
        }
        #[inline]
        pub unsafe fn extractSubset(&self, dst: *mut root::SkBitmap,
                                    subset: *const root::SkIRect) -> bool {
            SkBitmap_extractSubset(&*self, dst, subset)
        }
        #[inline]
        pub unsafe fn copyTo(&self, dst: *mut root::SkBitmap,
                             ct: root::SkColorType,
                             arg1: *mut root::SkBitmap_Allocator) -> bool {
            SkBitmap_copyTo(&*self, dst, ct, arg1)
        }
        #[inline]
        pub unsafe fn readPixels(&self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int) -> bool {
            SkBitmap_readPixels(&*self, dstInfo, dstPixels, dstRowBytes, srcX,
                                srcY)
        }
        #[inline]
        pub unsafe fn canCopyTo(&self, colorType: root::SkColorType) -> bool {
            SkBitmap_canCopyTo(&*self, colorType)
        }
        #[inline]
        pub unsafe fn deepCopyTo(&self, dst: *mut root::SkBitmap) -> bool {
            SkBitmap_deepCopyTo(&*self, dst)
        }
        #[inline]
        pub unsafe fn extractAlpha(&self, dst: *mut root::SkBitmap,
                                   paint: *const root::SkPaint,
                                   allocator: *mut root::SkBitmap_Allocator,
                                   offset: *mut root::SkIPoint) -> bool {
            SkBitmap_extractAlpha(&*self, dst, paint, allocator, offset)
        }
        #[inline]
        pub unsafe fn peekPixels(&self, arg1: *mut root::SkPixmap) -> bool {
            SkBitmap_peekPixels(&*self, arg1)
        }
        #[inline]
        pub unsafe fn validate(&self) { SkBitmap_validate(&*self) }
        #[inline]
        pub unsafe fn toString(&self, str: *mut root::SkString) {
            SkBitmap_toString(&*self, str)
        }
    }
    #[repr(i32)]
    /**
 *  Enum describing format of encoded data.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkEncodedImageFormat {
        kBMP = 0,
        kGIF = 1,
        kICO = 2,
        kJPEG = 3,
        kPNG = 4,
        kWBMP = 5,
        kWEBP = 6,
        kPKM = 7,
        kKTX = 8,
        kASTC = 9,
        kDNG = 10,
    }
    #[repr(C)]
    pub struct SkStream__bindgen_vtable {
    }
    /**
 *  SkStream -- abstraction for a source of bytes. Subclasses can be backed by
 *  memory, or a file, or something else.
 *
 *  NOTE:
 *
 *  Classic "streams" APIs are sort of async, in that on a request for N
 *  bytes, they may return fewer than N bytes on a given call, in which case
 *  the caller can "try again" to get more bytes, eventually (modulo an error)
 *  receiving their total N bytes.
 *
 *  Skia streams behave differently. They are effectively synchronous, and will
 *  always return all N bytes of the request if possible. If they return fewer
 *  (the read() call returns the number of bytes read) then that means there is
 *  no more data (at EOF or hit an error). The caller should *not* call again
 *  in hopes of fulfilling more of the request.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkStream {
        pub vtable_: *const SkStream__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkStream() {
        assert_eq!(::std::mem::size_of::<SkStream>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkStream>() , 8usize);
    }
    extern "C" {
        /**
     *  Attempts to open the specified file as a stream, returns nullptr on failure.
     */
        #[link_name =
              "?MakeFromFile@SkStream@@SA?AV?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@QEBD@Z"]
        pub fn SkStream_MakeFromFile(path: *const ::std::os::raw::c_char)
         ->
             root::std::unique_ptr<root::SkStreamAsset,
                                   root::std::default_delete<root::SkStreamAsset>>;
    }
    extern "C" {
        #[link_name = "?readS8@SkStream@@QEAACXZ"]
        pub fn SkStream_readS8(this: *mut root::SkStream) -> i8;
    }
    extern "C" {
        #[link_name = "?readS16@SkStream@@QEAAFXZ"]
        pub fn SkStream_readS16(this: *mut root::SkStream) -> i16;
    }
    extern "C" {
        #[link_name = "?readS32@SkStream@@QEAAHXZ"]
        pub fn SkStream_readS32(this: *mut root::SkStream) -> i32;
    }
    extern "C" {
        #[link_name = "?readScalar@SkStream@@QEAAMXZ"]
        pub fn SkStream_readScalar(this: *mut root::SkStream)
         -> root::SkScalar;
    }
    extern "C" {
        #[link_name = "?readPackedUInt@SkStream@@QEAA_KXZ"]
        pub fn SkStream_readPackedUInt(this: *mut root::SkStream) -> usize;
    }
    impl SkStream {
        #[inline]
        pub unsafe fn MakeFromFile(path: *const ::std::os::raw::c_char)
         ->
             root::std::unique_ptr<root::SkStreamAsset,
                                   root::std::default_delete<root::SkStreamAsset>> {
            SkStream_MakeFromFile(path)
        }
        #[inline]
        pub unsafe fn readS8(&mut self) -> i8 { SkStream_readS8(&mut *self) }
        #[inline]
        pub unsafe fn readS16(&mut self) -> i16 {
            SkStream_readS16(&mut *self)
        }
        #[inline]
        pub unsafe fn readS32(&mut self) -> i32 {
            SkStream_readS32(&mut *self)
        }
        #[inline]
        pub unsafe fn readScalar(&mut self) -> root::SkScalar {
            SkStream_readScalar(&mut *self)
        }
        #[inline]
        pub unsafe fn readPackedUInt(&mut self) -> usize {
            SkStream_readPackedUInt(&mut *self)
        }
    }
    /** SkStreamRewindable is a SkStream for which rewind and duplicate are required. */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkStreamRewindable {
        pub _base: root::SkStream,
    }
    #[test]
    fn bindgen_test_layout_SkStreamRewindable() {
        assert_eq!(::std::mem::size_of::<SkStreamRewindable>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkStreamRewindable>() , 8usize);
    }
    /** SkStreamSeekable is a SkStreamRewindable for which position, seek, move, and fork are required. */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkStreamSeekable {
        pub _base: root::SkStreamRewindable,
    }
    #[test]
    fn bindgen_test_layout_SkStreamSeekable() {
        assert_eq!(::std::mem::size_of::<SkStreamSeekable>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkStreamSeekable>() , 8usize);
    }
    /** SkStreamAsset is a SkStreamSeekable for which getLength is required. */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkStreamAsset {
        pub _base: root::SkStreamSeekable,
    }
    #[test]
    fn bindgen_test_layout_SkStreamAsset() {
        assert_eq!(::std::mem::size_of::<SkStreamAsset>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkStreamAsset>() , 8usize);
    }
    pub const SkBlendMode_kLastCoeffMode: root::SkBlendMode =
        SkBlendMode::kScreen;
    pub const SkBlendMode_kLastSeparableMode: root::SkBlendMode =
        SkBlendMode::kMultiply;
    pub const SkBlendMode_kLastMode: root::SkBlendMode =
        SkBlendMode::kLuminosity;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkBlendMode {
        kClear = 0,
        kSrc = 1,
        kDst = 2,
        kSrcOver = 3,
        kDstOver = 4,
        kSrcIn = 5,
        kDstIn = 6,
        kSrcOut = 7,
        kDstOut = 8,
        kSrcATop = 9,
        kDstATop = 10,
        kXor = 11,
        kPlus = 12,
        kModulate = 13,
        kScreen = 14,
        kOverlay = 15,
        kDarken = 16,
        kLighten = 17,
        kColorDodge = 18,
        kColorBurn = 19,
        kHardLight = 20,
        kSoftLight = 21,
        kDifference = 22,
        kExclusion = 23,
        kMultiply = 24,
        kHue = 25,
        kSaturation = 26,
        kColor = 27,
        kLuminosity = 28,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkColorFilter {
        pub _address: u8,
    }
    impl Clone for SkColorFilter {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDrawLooper {
        pub _address: u8,
    }
    impl Clone for SkDrawLooper {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkGlyph {
        pub _address: u8,
    }
    impl Clone for SkGlyph {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkGlyphCache {
        pub _address: u8,
    }
    impl Clone for SkGlyphCache {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImageFilter {
        pub _address: u8,
    }
    impl Clone for SkImageFilter {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMaskFilter {
        pub _address: u8,
    }
    impl Clone for SkMaskFilter {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPath {
        pub _address: u8,
    }
    impl Clone for SkPath {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPathEffect {
        pub _address: u8,
    }
    impl Clone for SkPathEffect {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRasterizer {
        pub _address: u8,
    }
    impl Clone for SkRasterizer {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_13() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkPicture>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkPicture>>() ,
                   8usize);
    }
    /** \class SkShader
 *
 *  Shaders specify the source color(s) for what is being drawn. If a paint
 *  has no shader, then the paint's color is used. If the paint has a
 *  shader, then the shader's color(s) are use instead, but they are
 *  modulated by the paint's alpha. This makes it easy to create a shader
 *  once (e.g. bitmap tiling or gradient) and then change its transparency
 *  w/o having to modify the original shader... only the paint's alpha needs
 *  to be modified.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkShader {
        pub _base: root::SkFlattenable,
        pub fLocalMatrix: root::SkMatrix,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_TileMode {
        kClamp_TileMode = 0,
        kRepeat_TileMode = 1,
        kMirror_TileMode = 2,
    }
    pub const SkShader_kTileModeCount: root::SkShader__bindgen_ty_1 =
        SkShader__bindgen_ty_1::kTileModeCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader__bindgen_ty_1 { kTileModeCount = 3, }
    pub const SkShader_Flags_kOpaqueAlpha_Flag: root::SkShader_Flags =
        SkShader_Flags(1);
    pub const SkShader_Flags_kConstInY32_Flag: root::SkShader_Flags =
        SkShader_Flags(2);
    pub const SkShader_Flags_kPrefers4f_Flag: root::SkShader_Flags =
        SkShader_Flags(4);
    impl ::std::ops::BitOr<root::SkShader_Flags> for root::SkShader_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkShader_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkShader_Flags(pub i32);
    /**
     *  ContextRec acts as a parameter bundle for creating Contexts.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_ContextRec {
        pub fPaint: *const root::SkPaint,
        pub fMatrix: *const root::SkMatrix,
        pub fLocalMatrix: *const root::SkMatrix,
        pub fPreferredDstType: root::SkShader_ContextRec_DstType,
        pub fDstColorSpace: *mut root::SkColorSpace,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_ContextRec_DstType {
        kPMColor_DstType = 0,
        kPM4f_DstType = 1,
    }
    #[test]
    fn bindgen_test_layout_SkShader_ContextRec() {
        assert_eq!(::std::mem::size_of::<SkShader_ContextRec>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkShader_ContextRec>() , 8usize);
    }
    impl Clone for SkShader_ContextRec {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct SkShader_Context__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkShader_Context {
        pub vtable_: *const SkShader_Context__bindgen_vtable,
        pub fShader: *const root::SkShader,
        pub fCTM: root::SkMatrix,
        pub fTotalInverse: root::SkMatrix,
        pub fPaintAlpha: u8,
        pub fTotalInverseClass: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_Context_BlitState {
        pub fCtx: *mut root::SkShader_Context,
        pub fMode: root::SkBlendMode,
        pub fStorage: [*mut ::std::os::raw::c_void; 2usize],
        pub fBlitBW: root::SkShader_Context_BlitBW,
        pub fBlitAA: root::SkShader_Context_BlitAA,
    }
    pub const SkShader_Context_BlitState_N:
              root::SkShader_Context_BlitState__bindgen_ty_1 =
        SkShader_Context_BlitState__bindgen_ty_1::N;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_Context_BlitState__bindgen_ty_1 { N = 2, }
    #[test]
    fn bindgen_test_layout_SkShader_Context_BlitState() {
        assert_eq!(::std::mem::size_of::<SkShader_Context_BlitState>() ,
                   48usize);
        assert_eq!(::std::mem::align_of::<SkShader_Context_BlitState>() ,
                   8usize);
    }
    impl Clone for SkShader_Context_BlitState {
        fn clone(&self) -> Self { *self }
    }
    pub type SkShader_Context_BlitBW =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::SkShader_Context_BlitState,
                                                   x: ::std::os::raw::c_int,
                                                   y: ::std::os::raw::c_int,
                                                   arg2:
                                                       *const root::SkPixmap,
                                                   count:
                                                       ::std::os::raw::c_int)>;
    pub type SkShader_Context_BlitAA =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::SkShader_Context_BlitState,
                                                   x: ::std::os::raw::c_int,
                                                   y: ::std::os::raw::c_int,
                                                   arg2:
                                                       *const root::SkPixmap,
                                                   count:
                                                       ::std::os::raw::c_int,
                                                   arg3:
                                                       *const root::SkAlpha)>;
    /**
         * The const void* ctx is only const because all the implementations are const.
         * This can be changed to non-const if a new shade proc needs to change the ctx.
         */
    pub type SkShader_Context_ShadeProc =
        ::std::option::Option<unsafe extern "C" fn(ctx:
                                                       *const ::std::os::raw::c_void,
                                                   x: ::std::os::raw::c_int,
                                                   y: ::std::os::raw::c_int,
                                                   arg1: *mut root::SkPMColor,
                                                   count:
                                                       ::std::os::raw::c_int)>;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_Context_MatrixClass {
        kLinear_MatrixClass = 0,
        kFixedStepInX_MatrixClass = 1,
        kPerspective_MatrixClass = 2,
    }
    pub type SkShader_Context_INHERITED = root::SkNoncopyable;
    #[test]
    fn bindgen_test_layout_SkShader_Context() {
        assert_eq!(::std::mem::size_of::<SkShader_Context>() , 104usize);
        assert_eq!(::std::mem::align_of::<SkShader_Context>() , 8usize);
    }
    extern "C" {
        #[link_name =
              "?ComputeMatrixClass@Context@SkShader@@KA?AW4MatrixClass@12@AEBVSkMatrix@@@Z"]
        pub fn SkShader_Context_ComputeMatrixClass(arg1:
                                                       *const root::SkMatrix)
         -> root::SkShader_Context_MatrixClass;
    }
    impl SkShader_Context {
        #[inline]
        pub unsafe fn ComputeMatrixClass(arg1: *const root::SkMatrix)
         -> root::SkShader_Context_MatrixClass {
            SkShader_Context_ComputeMatrixClass(arg1)
        }
    }
    pub const SkShader_GradientType_kLast_GradientType:
              root::SkShader_GradientType =
        SkShader_GradientType::kConical_GradientType;
    #[repr(i32)]
    /**
     *  If the shader subclass can be represented as a gradient, asAGradient
     *  returns the matching GradientType enum (or kNone_GradientType if it
     *  cannot). Also, if info is not null, asAGradient populates info with
     *  the relevant (see below) parameters for the gradient.  fColorCount
     *  is both an input and output parameter.  On input, it indicates how
     *  many entries in fColors and fColorOffsets can be used, if they are
     *  non-NULL.  After asAGradient has run, fColorCount indicates how
     *  many color-offset pairs there are in the gradient.  If there is
     *  insufficient space to store all of the color-offset pairs, fColors
     *  and fColorOffsets will not be altered.  fColorOffsets specifies
     *  where on the range of 0 to 1 to transition to the given color.
     *  The meaning of fPoint and fRadius is dependant on the type of gradient.
     *
     *  None:
     *      info is ignored.
     *  Color:
     *      fColorOffsets[0] is meaningless.
     *  Linear:
     *      fPoint[0] and fPoint[1] are the end-points of the gradient
     *  Radial:
     *      fPoint[0] and fRadius[0] are the center and radius
     *  Conical:
     *      fPoint[0] and fRadius[0] are the center and radius of the 1st circle
     *      fPoint[1] and fRadius[1] are the center and radius of the 2nd circle
     *  Sweep:
     *      fPoint[0] is the center of the sweep.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_GradientType {
        kNone_GradientType = 0,
        kColor_GradientType = 1,
        kLinear_GradientType = 2,
        kRadial_GradientType = 3,
        kSweep_GradientType = 4,
        kConical_GradientType = 5,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_GradientInfo {
        //< In-out parameter, specifies passed size
        pub fColorCount: ::std::os::raw::c_int,
        //< The colors in the gradient.
        pub fColors: *mut root::SkColor,
        //< The unit offset for color transitions.
        pub fColorOffsets: *mut root::SkScalar,
        //< Type specific, see above.
        pub fPoint: [root::SkPoint; 2usize],
        //< Type specific, see above.
        pub fRadius: [root::SkScalar; 2usize],
        //< The tile mode used.
        pub fTileMode: root::SkShader_TileMode,
        //< see SkGradientShader::Flags
        pub fGradientFlags: u32,
    }
    #[test]
    fn bindgen_test_layout_SkShader_GradientInfo() {
        assert_eq!(::std::mem::size_of::<SkShader_GradientInfo>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkShader_GradientInfo>() , 8usize);
    }
    impl Clone for SkShader_GradientInfo {
        fn clone(&self) -> Self { *self }
    }
    /**
     *  If the shader subclass is composed of two shaders, return true, and if rec is not NULL,
     *  fill it out with info about the shader.
     *
     *  These are bare pointers; the ownership and reference count are unchanged.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_ComposeRec {
        pub fShaderA: *const root::SkShader,
        pub fShaderB: *const root::SkShader,
        pub fBlendMode: root::SkBlendMode,
    }
    #[test]
    fn bindgen_test_layout_SkShader_ComposeRec() {
        assert_eq!(::std::mem::size_of::<SkShader_ComposeRec>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkShader_ComposeRec>() , 8usize);
    }
    impl Clone for SkShader_ComposeRec {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_AsFPArgs {
        pub fContext: *mut root::GrContext,
        pub fViewMatrix: *const root::SkMatrix,
        pub fLocalMatrix: *const root::SkMatrix,
        pub fFilterQuality: root::SkFilterQuality,
        pub fDstColorSpace: *mut root::SkColorSpace,
        pub fColorMode: root::SkDestinationSurfaceColorMode,
    }
    #[test]
    fn bindgen_test_layout_SkShader_AsFPArgs() {
        assert_eq!(::std::mem::size_of::<SkShader_AsFPArgs>() , 48usize);
        assert_eq!(::std::mem::align_of::<SkShader_AsFPArgs>() , 8usize);
    }
    impl Clone for SkShader_AsFPArgs {
        fn clone(&self) -> Self { *self }
    }
    pub type SkShader_INHERITED = root::SkFlattenable;
    #[test]
    fn bindgen_test_layout_SkShader() {
        assert_eq!(::std::mem::size_of::<SkShader>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkShader>() , 8usize);
    }
    extern "C" {
        /**
     *  Create the actual object that does the shading.
     *  Size of storage must be >= contextSize.
     */
        #[link_name =
              "?createContext@SkShader@@QEBAPEAVContext@1@AEBUContextRec@1@PEAX@Z"]
        pub fn SkShader_createContext(this: *const root::SkShader,
                                      arg1: *const root::SkShader_ContextRec,
                                      storage: *mut ::std::os::raw::c_void)
         -> *mut root::SkShader_Context;
    }
    extern "C" {
        /**
     *  Return the size of a Context returned by createContext.
     */
        #[link_name = "?contextSize@SkShader@@QEBA_KAEBUContextRec@1@@Z"]
        pub fn SkShader_contextSize(this: *const root::SkShader,
                                    arg1: *const root::SkShader_ContextRec)
         -> usize;
    }
    extern "C" {
        /**
     *  If the shader can represent its "average" luminance in a single color, return true and
     *  if color is not NULL, return that color. If it cannot, return false and ignore the color
     *  parameter.
     *
     *  Note: if this returns true, the returned color will always be opaque, as only the RGB
     *  components are used to compute luminance.
     */
        #[link_name = "?asLuminanceColor@SkShader@@QEBA_NPEAI@Z"]
        pub fn SkShader_asLuminanceColor(this: *const root::SkShader,
                                         arg1: *mut root::SkColor) -> bool;
    }
    extern "C" {
        /**
     *  Return a shader that will apply the specified localMatrix to this shader.
     *  The specified matrix will be applied before any matrix associated with this shader.
     */
        #[link_name =
              "?makeWithLocalMatrix@SkShader@@QEBA?AV?$sk_sp@VSkShader@@@@AEBVSkMatrix@@@Z"]
        pub fn SkShader_makeWithLocalMatrix(this: *const root::SkShader,
                                            arg1: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  Create a new shader that produces the same colors as invoking this shader and then applying
     *  the colorfilter.
     */
        #[link_name =
              "?makeWithColorFilter@SkShader@@QEBA?AV?$sk_sp@VSkShader@@@@V?$sk_sp@VSkColorFilter@@@@@Z"]
        pub fn SkShader_makeWithColorFilter(this: *const root::SkShader,
                                            arg1:
                                                root::sk_sp<root::SkColorFilter>)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  Call this to create a new "empty" shader, that will not draw anything.
     */
        #[link_name =
              "?MakeEmptyShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@XZ"]
        pub fn SkShader_MakeEmptyShader() -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  Call this to create a new shader that just draws the specified color. This should always
     *  draw the same as a paint with this color (and no shader).
     */
        #[link_name =
              "?MakeColorShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@I@Z"]
        pub fn SkShader_MakeColorShader(arg1: root::SkColor)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  Create a shader that draws the specified color (in the specified colorspace).
     *
     *  This works around the limitation that SkPaint::setColor() only takes byte values, and does
     *  not support specific colorspaces.
     */
        #[link_name =
              "?MakeColorShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@AEBUSkColor4f@@V?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkShader_MakeColorShader1(arg1: *const root::SkColor4f,
                                         arg2:
                                             root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        #[link_name =
              "?MakeComposeShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@V2@0W4SkBlendMode@@@Z"]
        pub fn SkShader_MakeComposeShader(dst: root::sk_sp<root::SkShader>,
                                          src: root::sk_sp<root::SkShader>,
                                          arg1: root::SkBlendMode)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /** Call this to create a new shader that will draw with the specified bitmap.
     *
     *  If the bitmap cannot be used (e.g. has no pixels, or its dimensions
     *  exceed implementation limits (currently at 64K - 1)) then SkEmptyShader
     *  may be returned.
     *
     *  If the src is kA8_Config then that mask will be colorized using the color on
     *  the paint.
     *
     *  @param src  The bitmap to use inside the shader
     *  @param tmx  The tiling mode to use when sampling the bitmap in the x-direction.
     *  @param tmy  The tiling mode to use when sampling the bitmap in the y-direction.
     *  @return     Returns a new shader object. Note: this function never returns null.
    */
        #[link_name =
              "?MakeBitmapShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@AEBVSkBitmap@@W4TileMode@1@1PEBVSkMatrix@@@Z"]
        pub fn SkShader_MakeBitmapShader(src: *const root::SkBitmap,
                                         tmx: root::SkShader_TileMode,
                                         tmy: root::SkShader_TileMode,
                                         localMatrix: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /** Call this to create a new shader that will draw with the specified picture.
     *
     *  @param src  The picture to use inside the shader (if not NULL, its ref count
     *              is incremented). The SkPicture must not be changed after
     *              successfully creating a picture shader.
     *  @param tmx  The tiling mode to use when sampling the bitmap in the x-direction.
     *  @param tmy  The tiling mode to use when sampling the bitmap in the y-direction.
     *  @param tile The tile rectangle in picture coordinates: this represents the subset
     *              (or superset) of the picture used when building a tile. It is not
     *              affected by localMatrix and does not imply scaling (only translation
     *              and cropping). If null, the tile rect is considered equal to the picture
     *              bounds.
     *  @return     Returns a new shader object. Note: this function never returns null.
    */
        #[link_name =
              "?MakePictureShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@V?$sk_sp@VSkPicture@@@@W4TileMode@1@1PEBVSkMatrix@@PEBUSkRect@@@Z"]
        pub fn SkShader_MakePictureShader(src: root::sk_sp<root::SkPicture>,
                                          tmx: root::SkShader_TileMode,
                                          tmy: root::SkShader_TileMode,
                                          localMatrix: *const root::SkMatrix,
                                          tile: *const root::SkRect)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        #[link_name = "?InitializeFlattenables@SkShader@@SAXXZ"]
        pub fn SkShader_InitializeFlattenables();
    }
    extern "C" {
        #[link_name =
              "?appendStages@SkShader@@QEBA_NPEAVSkRasterPipeline@@PEAVSkColorSpace@@PEAVSkFallbackAlloc@@AEBVSkMatrix@@AEBVSkPaint@@@Z"]
        pub fn SkShader_appendStages(this: *const root::SkShader,
                                     arg1: *mut root::SkRasterPipeline,
                                     arg2: *mut root::SkColorSpace,
                                     arg3: *mut root::SkFallbackAlloc,
                                     ctm: *const root::SkMatrix,
                                     arg4: *const root::SkPaint) -> bool;
    }
    extern "C" {
        #[link_name =
              "?computeTotalInverse@SkShader@@IEBA_NAEBUContextRec@1@PEAVSkMatrix@@@Z"]
        pub fn SkShader_computeTotalInverse(this: *const root::SkShader,
                                            arg1:
                                                *const root::SkShader_ContextRec,
                                            totalInverse: *mut root::SkMatrix)
         -> bool;
    }
    impl SkShader {
        #[inline]
        pub unsafe fn createContext(&self,
                                    arg1: *const root::SkShader_ContextRec,
                                    storage: *mut ::std::os::raw::c_void)
         -> *mut root::SkShader_Context {
            SkShader_createContext(&*self, arg1, storage)
        }
        #[inline]
        pub unsafe fn contextSize(&self,
                                  arg1: *const root::SkShader_ContextRec)
         -> usize {
            SkShader_contextSize(&*self, arg1)
        }
        #[inline]
        pub unsafe fn asLuminanceColor(&self, arg1: *mut root::SkColor)
         -> bool {
            SkShader_asLuminanceColor(&*self, arg1)
        }
        #[inline]
        pub unsafe fn makeWithLocalMatrix(&self, arg1: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader> {
            SkShader_makeWithLocalMatrix(&*self, arg1)
        }
        #[inline]
        pub unsafe fn makeWithColorFilter(&self,
                                          arg1:
                                              root::sk_sp<root::SkColorFilter>)
         -> root::sk_sp<root::SkShader> {
            SkShader_makeWithColorFilter(&*self, arg1)
        }
        #[inline]
        pub unsafe fn MakeEmptyShader() -> root::sk_sp<root::SkShader> {
            SkShader_MakeEmptyShader()
        }
        #[inline]
        pub unsafe fn MakeColorShader(arg1: root::SkColor)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakeColorShader(arg1)
        }
        #[inline]
        pub unsafe fn MakeColorShader1(arg1: *const root::SkColor4f,
                                       arg2: root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakeColorShader1(arg1, arg2)
        }
        #[inline]
        pub unsafe fn MakeComposeShader(dst: root::sk_sp<root::SkShader>,
                                        src: root::sk_sp<root::SkShader>,
                                        arg1: root::SkBlendMode)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakeComposeShader(dst, src, arg1)
        }
        #[inline]
        pub unsafe fn MakeBitmapShader(src: *const root::SkBitmap,
                                       tmx: root::SkShader_TileMode,
                                       tmy: root::SkShader_TileMode,
                                       localMatrix: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakeBitmapShader(src, tmx, tmy, localMatrix)
        }
        #[inline]
        pub unsafe fn MakePictureShader(src: root::sk_sp<root::SkPicture>,
                                        tmx: root::SkShader_TileMode,
                                        tmy: root::SkShader_TileMode,
                                        localMatrix: *const root::SkMatrix,
                                        tile: *const root::SkRect)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakePictureShader(src, tmx, tmy, localMatrix, tile)
        }
        #[inline]
        pub unsafe fn InitializeFlattenables() {
            SkShader_InitializeFlattenables()
        }
        #[inline]
        pub unsafe fn appendStages(&self, arg1: *mut root::SkRasterPipeline,
                                   arg2: *mut root::SkColorSpace,
                                   arg3: *mut root::SkFallbackAlloc,
                                   ctm: *const root::SkMatrix,
                                   arg4: *const root::SkPaint) -> bool {
            SkShader_appendStages(&*self, arg1, arg2, arg3, ctm, arg4)
        }
        #[inline]
        pub unsafe fn computeTotalInverse(&self,
                                          arg1:
                                              *const root::SkShader_ContextRec,
                                          totalInverse: *mut root::SkMatrix)
         -> bool {
            SkShader_computeTotalInverse(&*self, arg1, totalInverse)
        }
    }
    /**
 *  Describes properties and constraints of a given SkSurface. The rendering engine can parse these
 *  during drawing, and can sometimes optimize its performance (e.g. disabling an expensive
 *  feature).
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkSurfaceProps {
        pub fFlags: u32,
        pub fPixelGeometry: root::SkPixelGeometry,
    }
    pub const SkSurfaceProps_Flags_kUseDeviceIndependentFonts_Flag:
              root::SkSurfaceProps_Flags =
        SkSurfaceProps_Flags(1);
    impl ::std::ops::BitOr<root::SkSurfaceProps_Flags> for
     root::SkSurfaceProps_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkSurfaceProps_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkSurfaceProps_Flags(pub i32);
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkSurfaceProps_InitType { kLegacyFontHost_InitType = 0, }
    extern "C" {
        #[link_name =
              "?kUseDistanceFieldFonts_Flag@SkSurfaceProps@@2W4Flags@1@B"]
        pub static SkSurfaceProps_kUseDistanceFieldFonts_Flag:
                   root::SkSurfaceProps_Flags;
    }
    #[test]
    fn bindgen_test_layout_SkSurfaceProps() {
        assert_eq!(::std::mem::size_of::<SkSurfaceProps>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkSurfaceProps>() , 4usize);
    }
    impl Clone for SkSurfaceProps {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkTextBlob {
        pub _address: u8,
    }
    impl Clone for SkTextBlob {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkTypeface {
        pub _address: u8,
    }
    impl Clone for SkTypeface {
        fn clone(&self) -> Self { *self }
    }
    pub const GrPixelConfig_kLast_GrPixelConfig: root::GrPixelConfig =
        GrPixelConfig::kRGBA_half_GrPixelConfig;
    #[repr(i32)]
    /**
 * Pixel configurations.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum GrPixelConfig {
        kUnknown_GrPixelConfig = 0,
        kAlpha_8_GrPixelConfig = 1,
        kIndex_8_GrPixelConfig = 2,
        kRGB_565_GrPixelConfig = 3,
        kRGBA_4444_GrPixelConfig = 4,
        kRGBA_8888_GrPixelConfig = 5,
        kBGRA_8888_GrPixelConfig = 6,
        kSRGBA_8888_GrPixelConfig = 7,
        kSBGRA_8888_GrPixelConfig = 8,
        kRGBA_8888_sint_GrPixelConfig = 9,
        kETC1_GrPixelConfig = 10,
        kLATC_GrPixelConfig = 11,
        kR11_EAC_GrPixelConfig = 12,
        kASTC_12x12_GrPixelConfig = 13,
        kRGBA_float_GrPixelConfig = 14,
        kAlpha_half_GrPixelConfig = 15,
        kRGBA_half_GrPixelConfig = 16,
    }
    pub type GrBackendObject = isize;
    #[repr(i32)]
    /**
 * Some textures will be stored such that the upper and left edges of the content meet at the
 * the origin (in texture coord space) and for other textures the lower and left edges meet at
 * the origin. kDefault_GrSurfaceOrigin sets textures to TopLeft, and render targets
 * to BottomLeft.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum GrSurfaceOrigin {
        kDefault_GrSurfaceOrigin = 0,
        kTopLeft_GrSurfaceOrigin = 1,
        kBottomLeft_GrSurfaceOrigin = 2,
    }
    pub const GrBackendTextureFlags_kNone_GrBackendTextureFlag:
              root::GrBackendTextureFlags =
        GrBackendTextureFlags(0);
    pub const GrBackendTextureFlags_kRenderTarget_GrBackendTextureFlag:
              root::GrBackendTextureFlags =
        GrBackendTextureFlags(1);
    impl ::std::ops::BitOr<root::GrBackendTextureFlags> for
     root::GrBackendTextureFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            GrBackendTextureFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    /**
 * Gr can wrap an existing texture created by the client with a GrTexture
 * object. The client is responsible for ensuring that the texture lives at
 * least as long as the GrTexture object wrapping it. We require the client to
 * explicitly provide information about the texture, such as width, height,
 * and pixel config, rather than querying the 3D APIfor these values. We expect
 * these to be immutable even if the 3D API doesn't require this (OpenGL).
 *
 * Textures that are also render targets are supported as well. Gr will manage
 * any ancillary 3D API (stencil buffer, FBO id, etc) objects necessary for
 * Gr to draw into the render target. To access the render target object
 * call GrTexture::asRenderTarget().
 *
 * If in addition to the render target flag, the caller also specifies a sample
 * count Gr will create an MSAA buffer that resolves into the texture. Gr auto-
 * resolves when it reads from the texture. The client can explictly resolve
 * using the GrRenderTarget interface.
 *
 * Note: These flags currently form a subset of GrTexture's flags.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct GrBackendTextureFlags(pub i32);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrBackendTextureDesc {
        pub fFlags: root::GrBackendTextureFlags,
        pub fOrigin: root::GrSurfaceOrigin,
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fConfig: root::GrPixelConfig,
        /**
     * If the render target flag is set and sample count is greater than 0
     * then Gr will create an MSAA buffer that resolves to the texture.
     */
        pub fSampleCnt: ::std::os::raw::c_int,
        /**
     * Handle to the 3D API object.
     * OpenGL: Texture ID.
     * Vulkan: GrVkImageInfo*
     */
        pub fTextureHandle: root::GrBackendObject,
    }
    #[test]
    fn bindgen_test_layout_GrBackendTextureDesc() {
        assert_eq!(::std::mem::size_of::<GrBackendTextureDesc>() , 32usize);
        assert_eq!(::std::mem::align_of::<GrBackendTextureDesc>() , 8usize);
    }
    impl Clone for GrBackendTextureDesc {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Gr can wrap an existing render target created by the client in the 3D API
 * with a GrRenderTarget object. The client is responsible for ensuring that the
 * underlying 3D API object lives at least as long as the GrRenderTarget object
 * wrapping it. We require the client to explicitly provide information about
 * the target, such as width, height, and pixel config rather than querying the
 * 3D API for these values. We expect these properties to be immutable even if
 * the 3D API doesn't require this (OpenGL).
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrBackendRenderTargetDesc {
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fConfig: root::GrPixelConfig,
        pub fOrigin: root::GrSurfaceOrigin,
        /**
     * The number of samples per pixel. Gr uses this to influence decisions
     * about applying other forms of anti-aliasing.
     */
        pub fSampleCnt: ::std::os::raw::c_int,
        /**
     * Number of bits of stencil per-pixel.
     */
        pub fStencilBits: ::std::os::raw::c_int,
        /**
     * Handle to the 3D API object.
     * OpenGL: FBO ID
     * Vulkan: GrVkImageInfo*
     */
        pub fRenderTargetHandle: root::GrBackendObject,
    }
    #[test]
    fn bindgen_test_layout_GrBackendRenderTargetDesc() {
        assert_eq!(::std::mem::size_of::<GrBackendRenderTargetDesc>() ,
                   32usize);
        assert_eq!(::std::mem::align_of::<GrBackendRenderTargetDesc>() ,
                   8usize);
    }
    impl Clone for GrBackendRenderTargetDesc {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkFallbackAlloc {
        pub _address: u8,
    }
    impl Clone for SkFallbackAlloc {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_14() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkImage>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkImage>>() ,
                   8usize);
    }
    /**
 *  SkImage is an abstraction for drawing a rectagle of pixels, though the
 *  particular type of image could be actually storing its data on the GPU, or
 *  as drawing commands (picture or PDF or otherwise), ready to be played back
 *  into another canvas.
 *
 *  The content of SkImage is always immutable, though the actual storage may
 *  change, if for example that image can be re-created via encoded data or
 *  other means.
 *
 *  SkImage always has a non-zero dimensions. If there is a request to create a new image, either
 *  directly or via SkSurface, and either of the requested dimensions are zero, then NULL will be
 *  returned.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkImage {
        pub _base: root::SkRefCnt,
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fUniqueID: u32,
    }
    pub type SkImage_Info = root::SkImageInfo;
    pub type SkImage_ReleaseContext = *mut ::std::os::raw::c_void;
    pub type SkImage_RasterReleaseProc =
        ::std::option::Option<unsafe extern "C" fn(pixels:
                                                       *const ::std::os::raw::c_void,
                                                   arg1:
                                                       root::SkImage_ReleaseContext)>;
    pub type SkImage_TextureReleaseProc =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       root::SkImage_ReleaseContext)>;
    #[repr(i32)]
    /**
     *  Hints to image calls where the system might cache computed intermediates (e.g. the results
     *  of decoding or a read-back from the GPU. Passing kAllow signals that the system's default
     *  behavior is fine. Passing kDisallow signals that caching should be avoided.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkImage_CachingHint {
        kAllow_CachingHint = 0,
        kDisallow_CachingHint = 1,
    }
    /** Drawing params for which a deferred texture image data should be optimized. */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImage_DeferredTextureImageUsageParams {
        pub fMatrix: root::SkMatrix,
        pub fQuality: root::SkFilterQuality,
        pub fPreScaleMipLevel: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_SkImage_DeferredTextureImageUsageParams() {
        assert_eq!(::std::mem::size_of::<SkImage_DeferredTextureImageUsageParams>()
                   , 48usize);
        assert_eq!(::std::mem::align_of::<SkImage_DeferredTextureImageUsageParams>()
                   , 4usize);
    }
    impl Clone for SkImage_DeferredTextureImageUsageParams {
        fn clone(&self) -> Self { *self }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkImage_LegacyBitmapMode {
        kRO_LegacyBitmapMode = 0,
        kRW_LegacyBitmapMode = 1,
    }
    pub type SkImage_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkImage() {
        assert_eq!(::std::mem::size_of::<SkImage>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkImage>() , 8usize);
    }
    extern "C" {
        #[link_name =
              "?MakeRasterCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkPixmap@@@Z"]
        pub fn SkImage_MakeRasterCopy(arg1: *const root::SkPixmap)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name =
              "?MakeRasterData@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBUSkImageInfo@@V?$sk_sp@VSkData@@@@_K@Z"]
        pub fn SkImage_MakeRasterData(arg1: *const root::SkImage_Info,
                                      pixels: root::sk_sp<root::SkData>,
                                      rowBytes: usize)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Return a new Image referencing the specified pixels. These must remain valid and unchanged
     *  until the specified release-proc is called, indicating that Skia no longer has a reference
     *  to the pixels.
     *
     *  Returns NULL if the requested pixmap info is unsupported.
     */
        #[link_name =
              "?MakeFromRaster@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkPixmap@@P6AXPEBXPEAX@Z2@Z"]
        pub fn SkImage_MakeFromRaster(arg1: *const root::SkPixmap,
                                      arg2: root::SkImage_RasterReleaseProc,
                                      arg3: root::SkImage_ReleaseContext)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Construct a new image from the specified bitmap. If the bitmap is marked immutable, and
     *  its pixel memory is shareable, it may be shared instead of copied.
     */
        #[link_name =
              "?MakeFromBitmap@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkBitmap@@@Z"]
        pub fn SkImage_MakeFromBitmap(arg1: *const root::SkBitmap)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Construct a new SkImage based on the given ImageGenerator. Returns NULL on error.
     *  This function will always take ownership of the passed generator.
     *
     *  If a subset is specified, it must be contained within the generator's bounds.
     */
        #[link_name =
              "?MakeFromGenerator@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVSkImageGenerator@@PEBUSkIRect@@@Z"]
        pub fn SkImage_MakeFromGenerator(arg1: *mut root::SkImageGenerator,
                                         subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Construct a new SkImage based on the specified encoded data. Returns NULL on failure,
     *  which can mean that the format of the encoded data was not recognized/supported.
     *
     *  If a subset is specified, it must be contained within the encoded data's bounds.
     */
        #[link_name =
              "?MakeFromEncoded@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkData@@@@PEBUSkIRect@@@Z"]
        pub fn SkImage_MakeFromEncoded(encoded: root::sk_sp<root::SkData>,
                                       subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
    *  Create a new image from the specified descriptor. The underlying platform texture must stay
    *  valid and unaltered until the specified release-proc is invoked, indicating that Skia
    *  no longer is holding a reference to it.
    *
    *  Will return NULL if the specified descriptor is unsupported.
    */
        #[link_name =
              "?MakeFromTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@P6AXPEAX@Z4@Z"]
        pub fn SkImage_MakeFromTexture(arg1: *mut root::GrContext,
                                       arg2:
                                           *const root::GrBackendTextureDesc,
                                       arg3: root::SkAlphaType,
                                       arg4: root::sk_sp<root::SkColorSpace>,
                                       arg5: root::SkImage_TextureReleaseProc,
                                       arg6: root::SkImage_ReleaseContext)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Create a new image from the specified descriptor. Note - Skia will delete or recycle the
     *  texture when the image is released.
     *
     *  Will return NULL if the specified descriptor is unsupported.
     */
        #[link_name =
              "?MakeFromAdoptedTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkImage_MakeFromAdoptedTexture(arg1: *mut root::GrContext,
                                              arg2:
                                                  *const root::GrBackendTextureDesc,
                                              arg3: root::SkAlphaType,
                                              arg4:
                                                  root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Create a new image by copying the pixels from the specified y, u, v textures. The data
     *  from the textures is immediately ingested into the image and the textures can be modified or
     *  deleted after the function returns. The image will have the dimensions of the y texture.
     */
        #[link_name =
              "?MakeFromYUVTexturesCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@W4SkYUVColorSpace@@QEB_JQEBU?$SkTSize@H@@W4GrSurfaceOrigin@@V?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkImage_MakeFromYUVTexturesCopy(arg1: *mut root::GrContext,
                                               arg2: root::SkYUVColorSpace,
                                               yuvTextureHandles:
                                                   *mut root::GrBackendObject,
                                               yuvSizes: *mut root::SkISize,
                                               arg3: root::GrSurfaceOrigin,
                                               arg4:
                                                   root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Create a new image by copying the pixels from the specified y and uv textures. The data
     *  from the textures is immediately ingested into the image and the textures can be modified or
     *  deleted after the function returns. The image will have the dimensions of the y texture.
     */
        #[link_name =
              "?MakeFromNV12TexturesCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@W4SkYUVColorSpace@@QEB_JQEBU?$SkTSize@H@@W4GrSurfaceOrigin@@V?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkImage_MakeFromNV12TexturesCopy(arg1: *mut root::GrContext,
                                                arg2: root::SkYUVColorSpace,
                                                nv12TextureHandles:
                                                    *mut root::GrBackendObject,
                                                nv12Sizes: *mut root::SkISize,
                                                arg3: root::GrSurfaceOrigin,
                                                arg4:
                                                    root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name =
              "?MakeFromPicture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkPicture@@@@AEBU?$SkTSize@H@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
        pub fn SkImage_MakeFromPicture(arg1: root::sk_sp<root::SkPicture>,
                                       dimensions: *const root::SkISize,
                                       arg2: *const root::SkMatrix,
                                       arg3: *const root::SkPaint)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name =
              "?MakeTextureFromPixmap@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@AEBVSkPixmap@@W4SkBudgeted@@@Z"]
        pub fn SkImage_MakeTextureFromPixmap(arg1: *mut root::GrContext,
                                             arg2: *const root::SkPixmap,
                                             budgeted: root::SkBudgeted)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name = "?alphaType@SkImage@@QEBA?AW4SkAlphaType@@XZ"]
        pub fn SkImage_alphaType(this: *const root::SkImage)
         -> root::SkAlphaType;
    }
    extern "C" {
        /**
     *  Returns true fi the image will be drawn as a mask, with no intrinsic color of its own.
     */
        #[link_name = "?isAlphaOnly@SkImage@@QEBA_NXZ"]
        pub fn SkImage_isAlphaOnly(this: *const root::SkImage) -> bool;
    }
    extern "C" {
        /**
     * Extracts YUV planes from the SkImage and stores them in client-provided memory. The sizes
     * planes and rowBytes arrays are ordered [y, u, v].
     */
        #[link_name =
              "?readYUV8Planes@SkImage@@QEBA_NQEBU?$SkTSize@H@@QEBQEAXQEB_KW4SkYUVColorSpace@@@Z"]
        pub fn SkImage_readYUV8Planes(this: *const root::SkImage,
                                      arg1: *mut root::SkISize,
                                      planes:
                                          *mut *const ::std::os::raw::c_void,
                                      rowBytes: *mut usize,
                                      arg2: root::SkYUVColorSpace) -> bool;
    }
    extern "C" {
        #[link_name =
              "?makeShader@SkImage@@QEBA?AV?$sk_sp@VSkShader@@@@W4TileMode@SkShader@@0PEBVSkMatrix@@@Z"]
        pub fn SkImage_makeShader(this: *const root::SkImage,
                                  arg1: root::SkShader_TileMode,
                                  arg2: root::SkShader_TileMode,
                                  localMatrix: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  If the image has direct access to its pixels (i.e. they are in local RAM)
     *  return true, and if not null, return in the pixmap parameter the info about the
     *  images pixels.
     *
     *  On failure, return false and ignore the pixmap parameter.
     */
        #[link_name = "?peekPixels@SkImage@@QEBA_NPEAVSkPixmap@@@Z"]
        pub fn SkImage_peekPixels(this: *const root::SkImage,
                                  pixmap: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Some images have to perform preliminary work in preparation for drawing. This can be
     *  decoding, uploading to a GPU, or other tasks. These happen automatically when an image
     *  is drawn, and often they are cached so that the cost is only paid the first time.
     *
     *  Preroll() can be called before drawing to try to perform this prepatory work ahead of time.
     *  For images that have no such work, this returns instantly. Others may do some thing to
     *  prepare their cache and then return.
     *
     *  If the image will drawn to a GPU-backed canvas or surface, pass the associated GrContext.
     *  If the image will be drawn to any other type of canvas or surface, pass null.
     */
        #[link_name = "?preroll@SkImage@@QEBAXPEAVGrContext@@@Z"]
        pub fn SkImage_preroll(this: *const root::SkImage,
                               arg1: *mut root::GrContext);
    }
    extern "C" {
        #[link_name = "?getTexture@SkImage@@QEBAPEAVGrTexture@@XZ"]
        pub fn SkImage_getTexture(this: *const root::SkImage)
         -> *mut root::GrTexture;
    }
    extern "C" {
        /**
     *  Returns true if the image is texture backed.
     */
        #[link_name = "?isTextureBacked@SkImage@@QEBA_NXZ"]
        pub fn SkImage_isTextureBacked(this: *const root::SkImage) -> bool;
    }
    extern "C" {
        /**
     *  Retrieves the backend API handle of the texture. If flushPendingGrContextIO then the
     *  GrContext will issue to the backend API any deferred IO operations on the texture before
     *  returning.
     */
        #[link_name = "?getTextureHandle@SkImage@@QEBA_J_N@Z"]
        pub fn SkImage_getTextureHandle(this: *const root::SkImage,
                                        flushPendingGrContextIO: bool)
         -> root::GrBackendObject;
    }
    extern "C" {
        /**
     *  Copy the pixels from the image into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (dstInfo). The image pixels are read
     *  starting at the specified (srcX,srcY) location.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the image. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the image bounds.
     *  - If the requested colortype/alphatype cannot be converted from the image's types.
     */
        #[link_name =
              "?readPixels@SkImage@@QEBA_NAEBUSkImageInfo@@PEAX_KHHW4CachingHint@1@@Z"]
        pub fn SkImage_readPixels(this: *const root::SkImage,
                                  dstInfo: *const root::SkImageInfo,
                                  dstPixels: *mut ::std::os::raw::c_void,
                                  dstRowBytes: usize,
                                  srcX: ::std::os::raw::c_int,
                                  srcY: ::std::os::raw::c_int,
                                  arg1: root::SkImage_CachingHint) -> bool;
    }
    extern "C" {
        #[link_name =
              "?readPixels@SkImage@@QEBA_NAEBVSkPixmap@@HHW4CachingHint@1@@Z"]
        pub fn SkImage_readPixels1(this: *const root::SkImage,
                                   dst: *const root::SkPixmap,
                                   srcX: ::std::os::raw::c_int,
                                   srcY: ::std::os::raw::c_int,
                                   arg1: root::SkImage_CachingHint) -> bool;
    }
    extern "C" {
        /**
     *  Copy the pixels from this image into the dst pixmap, converting as needed into dst's
     *  colortype/alphatype. If the conversion cannot be performed, false is returned.
     *
     *  If dst's dimensions differ from the src dimension, the image will be scaled, applying the
     *  specified filter-quality.
     */
        #[link_name =
              "?scalePixels@SkImage@@QEBA_NAEBVSkPixmap@@W4SkFilterQuality@@W4CachingHint@1@@Z"]
        pub fn SkImage_scalePixels(this: *const root::SkImage,
                                   dst: *const root::SkPixmap,
                                   arg1: root::SkFilterQuality,
                                   arg2: root::SkImage_CachingHint) -> bool;
    }
    extern "C" {
        /**
     *  Encode the image's pixels and return the result as a new SkData, which
     *  the caller must manage (i.e. call unref() when they are done).
     *
     *  If the image type cannot be encoded, or the requested encoder type is
     *  not supported, this will return NULL.
     *
     *  Note: this will attempt to encode the image's pixels in the specified format,
     *  even if the image returns a data from refEncoded(). That data will be ignored.
     */
        #[link_name =
              "?encode@SkImage@@QEBAPEAVSkData@@W4SkEncodedImageFormat@@H@Z"]
        pub fn SkImage_encode(this: *const root::SkImage,
                              arg1: root::SkEncodedImageFormat,
                              quality: ::std::os::raw::c_int)
         -> *mut root::SkData;
    }
    extern "C" {
        /**
     *  Encode the image and return the result as a caller-managed SkData.  This will
     *  attempt to reuse existing encoded data (as returned by refEncoded).
     *
     *  We defer to the SkPixelSerializer both for vetting existing encoded data
     *  (useEncodedData) and for encoding the image (encode) when no such data is
     *  present or is rejected by the serializer.
     *
     *  If not specified, we use a default serializer which 1) always accepts existing data
     *  (in any format) and 2) encodes to PNG.
     *
     *  If no compatible encoded data exists and encoding fails, this method will also
     *  fail (return NULL).
     */
        #[link_name =
              "?encode@SkImage@@QEBAPEAVSkData@@PEAVSkPixelSerializer@@@Z"]
        pub fn SkImage_encode1(this: *const root::SkImage,
                               arg1: *mut root::SkPixelSerializer)
         -> *mut root::SkData;
    }
    extern "C" {
        /**
     *  If the image already has its contents in encoded form (e.g. PNG or JPEG), return a ref
     *  to that data (which the caller must call unref() on). The caller is responsible for calling
     *  unref on the data when they are done.
     *
     *  If the image does not already has its contents in encoded form, return NULL.
     *
     *  Note: to force the image to return its contents as encoded data, try calling encode(...).
     */
        #[link_name = "?refEncoded@SkImage@@QEBAPEAVSkData@@XZ"]
        pub fn SkImage_refEncoded(this: *const root::SkImage)
         -> *mut root::SkData;
    }
    extern "C" {
        #[link_name = "?toString@SkImage@@QEBAPEBDPEAVSkString@@@Z"]
        pub fn SkImage_toString(this: *const root::SkImage,
                                arg1: *mut root::SkString)
         -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        /**
     *  Return a new image that is a subset of this image. The underlying implementation may
     *  share the pixels, or it may make a copy.
     *
     *  If subset does not intersect the bounds of this image, or the copy/share cannot be made,
     *  NULL will be returned.
     */
        #[link_name =
              "?makeSubset@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@AEBUSkIRect@@@Z"]
        pub fn SkImage_makeSubset(this: *const root::SkImage,
                                  subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Ensures that an image is backed by a texture (when GrContext is non-null). If no
     *  transformation is required, the returned image may be the same as this image. If the this
     *  image is from a different GrContext, this will fail.
     */
        #[link_name =
              "?makeTextureImage@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@@Z"]
        pub fn SkImage_makeTextureImage(this: *const root::SkImage,
                                        arg1: *mut root::GrContext)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     * If the image is texture-backed this will make a raster copy of it (or nullptr if reading back
     * the pixels fails). Otherwise, it returns the original image.
     */
        #[link_name =
              "?makeNonTextureImage@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@XZ"]
        pub fn SkImage_makeNonTextureImage(this: *const root::SkImage)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Apply a given image filter to this image, and return the filtered result.
     *
     *  The subset represents the active portion of this image. The return value is similarly an
     *  SkImage, with an active subset (outSubset). This is usually used with texture-backed
     *  images, where the texture may be approx-match and thus larger than the required size.
     *
     *  clipBounds constrains the device-space extent of the image which may be produced to the
     *  given rect.
     *
     *  offset is the amount to translate the resulting image relative to the src when it is drawn.
     *  This is an out-param.
     *
     *  If the result image cannot be created, or the result would be transparent black, null
     *  is returned, in which case the offset and outSubset parameters should be ignored by the
     *  caller.
     */
        #[link_name =
              "?makeWithFilter@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@PEBVSkImageFilter@@AEBUSkIRect@@1PEAU4@PEAUSkIPoint@@@Z"]
        pub fn SkImage_makeWithFilter(this: *const root::SkImage,
                                      filter: *const root::SkImageFilter,
                                      subset: *const root::SkIRect,
                                      clipBounds: *const root::SkIRect,
                                      outSubset: *mut root::SkIRect,
                                      offset: *mut root::SkIPoint)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     * This method allows clients to capture the data necessary to turn a SkImage into a texture-
     * backed image. If the original image is codec-backed this will decode into a format optimized
     * for the context represented by the proxy. This method is thread safe with respect to the
     * GrContext whence the proxy came. Clients allocate and manage the storage of the deferred
     * texture data and control its lifetime. No cleanup is required, thus it is safe to simply free
     * the memory out from under the data.
     *
     * The same method is used both for getting the size necessary for pre-uploaded texture data
     * and for retrieving the data. The params array represents the set of draws over which to
     * optimize the pre-upload data.
     *
     * When called with a null buffer this returns the size that the client must allocate in order
     * to create deferred texture data for this image (or zero if this is an inappropriate
     * candidate). The buffer allocated by the client should be 8 byte aligned.
     *
     * When buffer is not null this fills in the deferred texture data for this image in the
     * provided buffer (assuming this is an appropriate candidate image and the buffer is
     * appropriately aligned). Upon success the size written is returned, otherwise 0.
     *
     * dstColorSpace is the color space of the surface where this texture will ultimately be used.
     * If the method determines that mip-maps are needed, this helps determine the correct strategy
     * for building them (gamma-correct or not).
     */
        #[link_name =
              "?getDeferredTextureImageData@SkImage@@QEBA_KAEBVGrContextThreadSafeProxy@@QEBUDeferredTextureImageUsageParams@1@HPEAXPEAVSkColorSpace@@@Z"]
        pub fn SkImage_getDeferredTextureImageData(this: *const root::SkImage,
                                                   arg1:
                                                       *const root::GrContextThreadSafeProxy,
                                                   arg2:
                                                       *const root::SkImage_DeferredTextureImageUsageParams,
                                                   paramCnt:
                                                       ::std::os::raw::c_int,
                                                   buffer:
                                                       *mut ::std::os::raw::c_void,
                                                   dstColorSpace:
                                                       *mut root::SkColorSpace)
         -> usize;
    }
    extern "C" {
        /**
     * Returns a texture-backed image from data produced in SkImage::getDeferredTextureImageData.
     * The context must be the context that provided the proxy passed to
     * getDeferredTextureImageData.
     */
        #[link_name =
              "?MakeFromDeferredTextureImageData@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@PEBXW4SkBudgeted@@@Z"]
        pub fn SkImage_MakeFromDeferredTextureImageData(arg1:
                                                            *mut root::GrContext,
                                                        arg2:
                                                            *const ::std::os::raw::c_void,
                                                        arg3:
                                                            root::SkBudgeted)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Attempt to create a bitmap with the same pixels as the image. The result will always be
     *  a raster-backed bitmap (texture-backed bitmaps are DEPRECATED, and not supported here).
     *
     *  If the mode is kRO (read-only), the resulting bitmap will be marked as immutable.
     *
     *  On succcess, returns true. On failure, returns false and the bitmap parameter will be reset
     *  to empty.
     */
        #[link_name =
              "?asLegacyBitmap@SkImage@@QEBA_NPEAVSkBitmap@@W4LegacyBitmapMode@1@@Z"]
        pub fn SkImage_asLegacyBitmap(this: *const root::SkImage,
                                      arg1: *mut root::SkBitmap,
                                      arg2: root::SkImage_LegacyBitmapMode)
         -> bool;
    }
    extern "C" {
        /**
     *  Returns true if the image is backed by an image-generator or other src that creates
     *  (and caches) its pixels / texture on-demand.
     */
        #[link_name = "?isLazyGenerated@SkImage@@QEBA_NXZ"]
        pub fn SkImage_isLazyGenerated(this: *const root::SkImage) -> bool;
    }
    impl SkImage {
        #[inline]
        pub unsafe fn MakeRasterCopy(arg1: *const root::SkPixmap)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeRasterCopy(arg1)
        }
        #[inline]
        pub unsafe fn MakeRasterData(arg1: *const root::SkImage_Info,
                                     pixels: root::sk_sp<root::SkData>,
                                     rowBytes: usize)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeRasterData(arg1, pixels, rowBytes)
        }
        #[inline]
        pub unsafe fn MakeFromRaster(arg1: *const root::SkPixmap,
                                     arg2: root::SkImage_RasterReleaseProc,
                                     arg3: root::SkImage_ReleaseContext)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromRaster(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn MakeFromBitmap(arg1: *const root::SkBitmap)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromBitmap(arg1)
        }
        #[inline]
        pub unsafe fn MakeFromGenerator(arg1: *mut root::SkImageGenerator,
                                        subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromGenerator(arg1, subset)
        }
        #[inline]
        pub unsafe fn MakeFromEncoded(encoded: root::sk_sp<root::SkData>,
                                      subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromEncoded(encoded, subset)
        }
        #[inline]
        pub unsafe fn MakeFromTexture(arg1: *mut root::GrContext,
                                      arg2: *const root::GrBackendTextureDesc,
                                      arg3: root::SkAlphaType,
                                      arg4: root::sk_sp<root::SkColorSpace>,
                                      arg5: root::SkImage_TextureReleaseProc,
                                      arg6: root::SkImage_ReleaseContext)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromTexture(arg1, arg2, arg3, arg4, arg5, arg6)
        }
        #[inline]
        pub unsafe fn MakeFromAdoptedTexture(arg1: *mut root::GrContext,
                                             arg2:
                                                 *const root::GrBackendTextureDesc,
                                             arg3: root::SkAlphaType,
                                             arg4:
                                                 root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromAdoptedTexture(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromYUVTexturesCopy(arg1: *mut root::GrContext,
                                              arg2: root::SkYUVColorSpace,
                                              yuvTextureHandles:
                                                  *mut root::GrBackendObject,
                                              yuvSizes: *mut root::SkISize,
                                              arg3: root::GrSurfaceOrigin,
                                              arg4:
                                                  root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromYUVTexturesCopy(arg1, arg2, yuvTextureHandles,
                                            yuvSizes, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromNV12TexturesCopy(arg1: *mut root::GrContext,
                                               arg2: root::SkYUVColorSpace,
                                               nv12TextureHandles:
                                                   *mut root::GrBackendObject,
                                               nv12Sizes: *mut root::SkISize,
                                               arg3: root::GrSurfaceOrigin,
                                               arg4:
                                                   root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromNV12TexturesCopy(arg1, arg2, nv12TextureHandles,
                                             nv12Sizes, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromPicture(arg1: root::sk_sp<root::SkPicture>,
                                      dimensions: *const root::SkISize,
                                      arg2: *const root::SkMatrix,
                                      arg3: *const root::SkPaint)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromPicture(arg1, dimensions, arg2, arg3)
        }
        #[inline]
        pub unsafe fn MakeTextureFromPixmap(arg1: *mut root::GrContext,
                                            arg2: *const root::SkPixmap,
                                            budgeted: root::SkBudgeted)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeTextureFromPixmap(arg1, arg2, budgeted)
        }
        #[inline]
        pub unsafe fn alphaType(&self) -> root::SkAlphaType {
            SkImage_alphaType(&*self)
        }
        #[inline]
        pub unsafe fn isAlphaOnly(&self) -> bool {
            SkImage_isAlphaOnly(&*self)
        }
        #[inline]
        pub unsafe fn readYUV8Planes(&self, arg1: *mut root::SkISize,
                                     planes:
                                         *mut *const ::std::os::raw::c_void,
                                     rowBytes: *mut usize,
                                     arg2: root::SkYUVColorSpace) -> bool {
            SkImage_readYUV8Planes(&*self, arg1, planes, rowBytes, arg2)
        }
        #[inline]
        pub unsafe fn makeShader(&self, arg1: root::SkShader_TileMode,
                                 arg2: root::SkShader_TileMode,
                                 localMatrix: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader> {
            SkImage_makeShader(&*self, arg1, arg2, localMatrix)
        }
        #[inline]
        pub unsafe fn peekPixels(&self, pixmap: *mut root::SkPixmap) -> bool {
            SkImage_peekPixels(&*self, pixmap)
        }
        #[inline]
        pub unsafe fn preroll(&self, arg1: *mut root::GrContext) {
            SkImage_preroll(&*self, arg1)
        }
        #[inline]
        pub unsafe fn getTexture(&self) -> *mut root::GrTexture {
            SkImage_getTexture(&*self)
        }
        #[inline]
        pub unsafe fn isTextureBacked(&self) -> bool {
            SkImage_isTextureBacked(&*self)
        }
        #[inline]
        pub unsafe fn getTextureHandle(&self, flushPendingGrContextIO: bool)
         -> root::GrBackendObject {
            SkImage_getTextureHandle(&*self, flushPendingGrContextIO)
        }
        #[inline]
        pub unsafe fn readPixels(&self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int,
                                 arg1: root::SkImage_CachingHint) -> bool {
            SkImage_readPixels(&*self, dstInfo, dstPixels, dstRowBytes, srcX,
                               srcY, arg1)
        }
        #[inline]
        pub unsafe fn readPixels1(&self, dst: *const root::SkPixmap,
                                  srcX: ::std::os::raw::c_int,
                                  srcY: ::std::os::raw::c_int,
                                  arg1: root::SkImage_CachingHint) -> bool {
            SkImage_readPixels1(&*self, dst, srcX, srcY, arg1)
        }
        #[inline]
        pub unsafe fn scalePixels(&self, dst: *const root::SkPixmap,
                                  arg1: root::SkFilterQuality,
                                  arg2: root::SkImage_CachingHint) -> bool {
            SkImage_scalePixels(&*self, dst, arg1, arg2)
        }
        #[inline]
        pub unsafe fn encode(&self, arg1: root::SkEncodedImageFormat,
                             quality: ::std::os::raw::c_int)
         -> *mut root::SkData {
            SkImage_encode(&*self, arg1, quality)
        }
        #[inline]
        pub unsafe fn encode1(&self, arg1: *mut root::SkPixelSerializer)
         -> *mut root::SkData {
            SkImage_encode1(&*self, arg1)
        }
        #[inline]
        pub unsafe fn refEncoded(&self) -> *mut root::SkData {
            SkImage_refEncoded(&*self)
        }
        #[inline]
        pub unsafe fn toString(&self, arg1: *mut root::SkString)
         -> *const ::std::os::raw::c_char {
            SkImage_toString(&*self, arg1)
        }
        #[inline]
        pub unsafe fn makeSubset(&self, subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage> {
            SkImage_makeSubset(&*self, subset)
        }
        #[inline]
        pub unsafe fn makeTextureImage(&self, arg1: *mut root::GrContext)
         -> root::sk_sp<root::SkImage> {
            SkImage_makeTextureImage(&*self, arg1)
        }
        #[inline]
        pub unsafe fn makeNonTextureImage(&self)
         -> root::sk_sp<root::SkImage> {
            SkImage_makeNonTextureImage(&*self)
        }
        #[inline]
        pub unsafe fn makeWithFilter(&self,
                                     filter: *const root::SkImageFilter,
                                     subset: *const root::SkIRect,
                                     clipBounds: *const root::SkIRect,
                                     outSubset: *mut root::SkIRect,
                                     offset: *mut root::SkIPoint)
         -> root::sk_sp<root::SkImage> {
            SkImage_makeWithFilter(&*self, filter, subset, clipBounds,
                                   outSubset, offset)
        }
        #[inline]
        pub unsafe fn getDeferredTextureImageData(&self,
                                                  arg1:
                                                      *const root::GrContextThreadSafeProxy,
                                                  arg2:
                                                      *const root::SkImage_DeferredTextureImageUsageParams,
                                                  paramCnt:
                                                      ::std::os::raw::c_int,
                                                  buffer:
                                                      *mut ::std::os::raw::c_void,
                                                  dstColorSpace:
                                                      *mut root::SkColorSpace)
         -> usize {
            SkImage_getDeferredTextureImageData(&*self, arg1, arg2, paramCnt,
                                                buffer, dstColorSpace)
        }
        #[inline]
        pub unsafe fn MakeFromDeferredTextureImageData(arg1:
                                                           *mut root::GrContext,
                                                       arg2:
                                                           *const ::std::os::raw::c_void,
                                                       arg3: root::SkBudgeted)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromDeferredTextureImageData(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn asLegacyBitmap(&self, arg1: *mut root::SkBitmap,
                                     arg2: root::SkImage_LegacyBitmapMode)
         -> bool {
            SkImage_asLegacyBitmap(&*self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn isLazyGenerated(&self) -> bool {
            SkImage_isLazyGenerated(&*self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPicture {
        pub _address: u8,
    }
    impl Clone for SkPicture {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRasterPipeline {
        pub _address: u8,
    }
    impl Clone for SkRasterPipeline {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrContext {
        pub _address: u8,
    }
    impl Clone for GrContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrFragmentProcessor {
        pub _address: u8,
    }
    impl Clone for GrFragmentProcessor {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_15() {
        assert_eq!(::std::mem::size_of::<root::std::unique_ptr<root::SkCanvas,
                                            root::std::default_delete<root::SkCanvas>>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::std::unique_ptr<root::SkCanvas,
                                             root::std::default_delete<root::SkCanvas>>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_16() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkSurface>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkSurface>>() ,
                   8usize);
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkClipOp {
        kDifference_SkClipOp = 0,
        kIntersect_SkClipOp = 1,
        kUnion_SkClipOp = 2,
        kXOR_SkClipOp = 3,
        kReverseDifference_SkClipOp = 4,
        kReplace_SkClipOp = 5,
    }
    #[repr(C)]
    pub struct SkCanvas__bindgen_vtable {
    }
    /** \class SkCanvas

    A Canvas encapsulates all of the state about drawing into a device (bitmap).
    This includes a reference to the device itself, and a stack of matrix/clip
    values. For any given draw call (e.g. drawRect), the geometry of the object
    being drawn is transformed by the concatenation of all the matrices in the
    stack. The transformed geometry is clipped by the intersection of all of
    the clips in the stack.

    While the Canvas holds the state of the drawing device, the state (style)
    of the object being drawn is held by the Paint, which is provided as a
    parameter to each of the draw() methods. The Paint holds attributes such as
    color, typeface, textSize, strokeWidth, shader (e.g. gradients, patterns),
    etc.
*/
    #[repr(C)]
    pub struct SkCanvas {
        pub vtable_: *const SkCanvas__bindgen_vtable,
        pub fClipStack: root::sk_sp<root::SkClipStack>,
        pub fMCStack: root::SkDeque,
        pub fMCRec: *mut root::SkCanvas_MCRec,
        pub fMCRecStorage: [isize; 512usize],
        pub fDeviceCMStorage: [isize; 22usize],
        pub fProps: root::SkSurfaceProps,
        pub fSaveCount: ::std::os::raw::c_int,
        pub fMetaData: *mut root::SkMetaData,
        pub fSurfaceBase: *mut root::SkSurface_Base,
        pub fDeviceCMDirty: bool,
        /**
     *  Keep track of the device clip bounds and if the matrix is scale-translate.  This allows
     *  us to do a fast quick reject in the common case.
     */
        pub fIsScaleTranslate: bool,
        pub fDeviceClipBounds: root::SkRect,
        pub fAllowSoftClip: bool,
        pub fAllowSimplifyClip: bool,
        pub fConservativeRasterClip: bool,
    }
    pub const SkCanvas_PrivateSaveLayerFlags_kDontClipToLayer_PrivateSaveLayerFlag:
              root::SkCanvas_PrivateSaveLayerFlags =
        SkCanvas_PrivateSaveLayerFlags(-2147483648);
    impl ::std::ops::BitOr<root::SkCanvas_PrivateSaveLayerFlags> for
     root::SkCanvas_PrivateSaveLayerFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkCanvas_PrivateSaveLayerFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkCanvas_PrivateSaveLayerFlags(pub i32);
    pub const SkCanvas_kIsOpaque_SaveLayerFlag: root::SkCanvas__bindgen_ty_1 =
        SkCanvas__bindgen_ty_1::kIsOpaque_SaveLayerFlag;
    pub const SkCanvas_kPreserveLCDText_SaveLayerFlag:
              root::SkCanvas__bindgen_ty_1 =
        SkCanvas__bindgen_ty_1::kPreserveLCDText_SaveLayerFlag;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas__bindgen_ty_1 {
        kIsOpaque_SaveLayerFlag = 1,
        kPreserveLCDText_SaveLayerFlag = 2,
    }
    pub type SkCanvas_SaveLayerFlags = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkCanvas_SaveLayerRec {
        pub fBounds: *const root::SkRect,
        pub fPaint: *const root::SkPaint,
        pub fBackdrop: *const root::SkImageFilter,
        pub fSaveLayerFlags: root::SkCanvas_SaveLayerFlags,
    }
    #[test]
    fn bindgen_test_layout_SkCanvas_SaveLayerRec() {
        assert_eq!(::std::mem::size_of::<SkCanvas_SaveLayerRec>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkCanvas_SaveLayerRec>() , 8usize);
    }
    impl Clone for SkCanvas_SaveLayerRec {
        fn clone(&self) -> Self { *self }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_PointMode {
        kPoints_PointMode = 0,
        kLines_PointMode = 1,
        kPolygon_PointMode = 2,
    }
    #[repr(i32)]
    /**
     *  Controls the behavior at the edge of the src-rect, when specified in drawImageRect,
     *  trading off speed for exactness.
     *
     *  When filtering is enabled (in the Paint), skia may need to sample in a neighborhood around
     *  the pixels in the image. If there is a src-rect specified, it is intended to restrict the
     *  pixels that will be read. However, for performance reasons, some implementations may slow
     *  down if they cannot read 1-pixel past the src-rect boundary at times.
     *
     *  This enum allows the caller to specify if such a 1-pixel "slop" will be visually acceptable.
     *  If it is, the caller should pass kFast, and it may result in a faster draw. If the src-rect
     *  must be strictly respected, the caller should pass kStrict.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_SrcRectConstraint {
        kStrict_SrcRectConstraint = 0,
        kFast_SrcRectConstraint = 1,
    }
    /**
     *  Specifies coordinates to divide a bitmap into (xCount*yCount) rects.
     *
     *  If the lattice divs or bounds are invalid, the entire lattice
     *  struct will be ignored on the draw call.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkCanvas_Lattice {
        pub fXDivs: *const ::std::os::raw::c_int,
        pub fYDivs: *const ::std::os::raw::c_int,
        pub fFlags: *const root::SkCanvas_Lattice_Flags,
        pub fXCount: ::std::os::raw::c_int,
        pub fYCount: ::std::os::raw::c_int,
        pub fBounds: *const root::SkIRect,
    }
    pub const SkCanvas_Lattice_Flags_kTransparent_Flags:
              root::SkCanvas_Lattice_Flags =
        SkCanvas_Lattice_Flags(1);
    impl ::std::ops::BitOr<root::SkCanvas_Lattice_Flags> for
     root::SkCanvas_Lattice_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkCanvas_Lattice_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkCanvas_Lattice_Flags(pub u8);
    #[test]
    fn bindgen_test_layout_SkCanvas_Lattice() {
        assert_eq!(::std::mem::size_of::<SkCanvas_Lattice>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkCanvas_Lattice>() , 8usize);
    }
    impl Clone for SkCanvas_Lattice {
        fn clone(&self) -> Self { *self }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_VertexMode {
        kTriangles_VertexMode = 0,
        kTriangleStrip_VertexMode = 1,
        kTriangleFan_VertexMode = 2,
    }
    pub type SkCanvas_ClipVisitor = root::SkCanvasClipVisitor;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_SaveLayerStrategy {
        kFullLayer_SaveLayerStrategy = 0,
        kNoLayer_SaveLayerStrategy = 1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_ClipEdgeStyle {
        kHard_ClipEdgeStyle = 0,
        kSoft_ClipEdgeStyle = 1,
    }
    /** After calling saveLayer(), there can be any number of devices that make
     up the top-most drawing area. LayerIter can be used to iterate through
     those devices. Note that the iterator is only valid until the next API
     call made on the canvas. Ownership of all pointers in the iterator stays
     with the canvas, so none of them should be modified or deleted.
     */
    #[repr(C)]
    pub struct SkCanvas_LayerIter {
        pub fStorage: [isize; 32usize],
        pub fImpl: *mut root::SkCanvas_LayerIter_SkDrawIter,
        pub fDefaultPaint: root::SkPaint,
        pub fDone: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkCanvas_LayerIter_SkDrawIter {
        pub _address: u8,
    }
    impl Clone for SkCanvas_LayerIter_SkDrawIter {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_SkCanvas_LayerIter() {
        assert_eq!(::std::mem::size_of::<SkCanvas_LayerIter>() , 368usize);
        assert_eq!(::std::mem::align_of::<SkCanvas_LayerIter>() , 8usize);
    }
    extern "C" {
        /** Cycle to the next device */
        #[link_name = "?next@LayerIter@SkCanvas@@QEAAXXZ"]
        pub fn SkCanvas_LayerIter_next(this: *mut root::SkCanvas_LayerIter);
    }
    extern "C" {
        #[link_name = "?device@LayerIter@SkCanvas@@QEBAPEAVSkBaseDevice@@XZ"]
        pub fn SkCanvas_LayerIter_device(this:
                                             *const root::SkCanvas_LayerIter)
         -> *mut root::SkBaseDevice;
    }
    extern "C" {
        #[link_name = "?matrix@LayerIter@SkCanvas@@QEBAAEBVSkMatrix@@XZ"]
        pub fn SkCanvas_LayerIter_matrix(this:
                                             *const root::SkCanvas_LayerIter)
         -> *const root::SkMatrix;
    }
    extern "C" {
        #[link_name = "?clip@LayerIter@SkCanvas@@QEBAAEBVSkRasterClip@@XZ"]
        pub fn SkCanvas_LayerIter_clip(this: *const root::SkCanvas_LayerIter)
         -> *const root::SkRasterClip;
    }
    extern "C" {
        #[link_name = "?paint@LayerIter@SkCanvas@@QEBAAEBVSkPaint@@XZ"]
        pub fn SkCanvas_LayerIter_paint(this: *const root::SkCanvas_LayerIter)
         -> *const root::SkPaint;
    }
    extern "C" {
        #[link_name = "?x@LayerIter@SkCanvas@@QEBAHXZ"]
        pub fn SkCanvas_LayerIter_x(this: *const root::SkCanvas_LayerIter)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "?y@LayerIter@SkCanvas@@QEBAHXZ"]
        pub fn SkCanvas_LayerIter_y(this: *const root::SkCanvas_LayerIter)
         -> ::std::os::raw::c_int;
    }
    impl SkCanvas_LayerIter {
        #[inline]
        pub unsafe fn next(&mut self) { SkCanvas_LayerIter_next(&mut *self) }
        #[inline]
        pub unsafe fn device(&self) -> *mut root::SkBaseDevice {
            SkCanvas_LayerIter_device(&*self)
        }
        #[inline]
        pub unsafe fn matrix(&self) -> *const root::SkMatrix {
            SkCanvas_LayerIter_matrix(&*self)
        }
        #[inline]
        pub unsafe fn clip(&self) -> *const root::SkRasterClip {
            SkCanvas_LayerIter_clip(&*self)
        }
        #[inline]
        pub unsafe fn paint(&self) -> *const root::SkPaint {
            SkCanvas_LayerIter_paint(&*self)
        }
        #[inline]
        pub unsafe fn x(&self) -> ::std::os::raw::c_int {
            SkCanvas_LayerIter_x(&*self)
        }
        #[inline]
        pub unsafe fn y(&self) -> ::std::os::raw::c_int {
            SkCanvas_LayerIter_y(&*self)
        }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_ShaderOverrideOpacity {
        kNone_ShaderOverrideOpacity = 0,
        kOpaque_ShaderOverrideOpacity = 1,
        kNotOpaque_ShaderOverrideOpacity = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkCanvas_MCRec {
        pub _address: u8,
    }
    impl Clone for SkCanvas_MCRec {
        fn clone(&self) -> Self { *self }
    }
    pub const SkCanvas_kMCRecSize: root::SkCanvas__bindgen_ty_2 =
        SkCanvas__bindgen_ty_2::kMCRecSize;
    pub const SkCanvas_kMCRecCount: root::SkCanvas__bindgen_ty_2 =
        SkCanvas__bindgen_ty_2::kMCRecCount;
    pub const SkCanvas_kDeviceCMSize: root::SkCanvas__bindgen_ty_2 =
        SkCanvas__bindgen_ty_2::kDeviceCMSize;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas__bindgen_ty_2 {
        kMCRecSize = 128,
        kMCRecCount = 32,
        kDeviceCMSize = 176,
    }
    pub const SkCanvas_InitFlags_kDefault_InitFlags: root::SkCanvas_InitFlags
              =
        SkCanvas_InitFlags(0);
    pub const SkCanvas_InitFlags_kConservativeRasterClip_InitFlag:
              root::SkCanvas_InitFlags =
        SkCanvas_InitFlags(1);
    impl ::std::ops::BitOr<root::SkCanvas_InitFlags> for
     root::SkCanvas_InitFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkCanvas_InitFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkCanvas_InitFlags(pub i32);
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkCanvas_AutoValidateClip {
        pub fCanvas: *const root::SkCanvas,
    }
    #[test]
    fn bindgen_test_layout_SkCanvas_AutoValidateClip() {
        assert_eq!(::std::mem::size_of::<SkCanvas_AutoValidateClip>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<SkCanvas_AutoValidateClip>() ,
                   8usize);
    }
    pub type SkCanvas_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkCanvas() {
        assert_eq!(::std::mem::size_of::<SkCanvas>() , 4408usize);
        assert_eq!(::std::mem::align_of::<SkCanvas>() , 8usize);
    }
    extern "C" {
        /**
     *  Attempt to allocate raster canvas, matching the ImageInfo, that will draw directly into the
     *  specified pixels. To access the pixels after drawing to them, the caller should call
     *  flush() or call peekPixels(...).
     *
     *  On failure, return NULL. This can fail for several reasons:
     *  1. invalid ImageInfo (e.g. negative dimensions)
     *  2. unsupported ImageInfo for a canvas
     *      - kUnknown_SkColorType, kIndex_8_SkColorType
     *      - kUnknown_SkAlphaType
     *      - this list is not complete, so others may also be unsupported
     *
     *  Note: it is valid to request a supported ImageInfo, but with zero
     *  dimensions.
     */
        #[link_name =
              "?MakeRasterDirect@SkCanvas@@SA?AV?$unique_ptr@VSkCanvas@@U?$default_delete@VSkCanvas@@@std@@@std@@AEBUSkImageInfo@@PEAX_K@Z"]
        pub fn SkCanvas_MakeRasterDirect(arg1: *const root::SkImageInfo,
                                         arg2: *mut ::std::os::raw::c_void,
                                         arg3: usize)
         ->
             root::std::unique_ptr<root::SkCanvas,
                                   root::std::default_delete<root::SkCanvas>>;
    }
    extern "C" {
        #[link_name = "?getMetaData@SkCanvas@@QEAAAEAVSkMetaData@@XZ"]
        pub fn SkCanvas_getMetaData(this: *mut root::SkCanvas)
         -> *mut root::SkMetaData;
    }
    extern "C" {
        /**
     *  Return ImageInfo for this canvas. If the canvas is not backed by pixels
     *  (cpu or gpu), then the info's ColorType will be kUnknown_SkColorType.
     */
        #[link_name = "?imageInfo@SkCanvas@@QEBA?AUSkImageInfo@@XZ"]
        pub fn SkCanvas_imageInfo(this: *const root::SkCanvas)
         -> root::SkImageInfo;
    }
    extern "C" {
        /**
     *  If the canvas is backed by pixels (cpu or gpu), this writes a copy of the SurfaceProps
     *  for the canvas to the location supplied by the caller, and returns true. Otherwise,
     *  return false and leave the supplied props unchanged.
     */
        #[link_name = "?getProps@SkCanvas@@QEBA_NPEAVSkSurfaceProps@@@Z"]
        pub fn SkCanvas_getProps(this: *const root::SkCanvas,
                                 arg1: *mut root::SkSurfaceProps) -> bool;
    }
    extern "C" {
        /**
     *  Trigger the immediate execution of all pending draw operations. For the GPU
     *  backend this will resolve all rendering to the GPU surface backing the
     *  SkSurface that owns this canvas.
     */
        #[link_name = "?flush@SkCanvas@@QEAAXXZ"]
        pub fn SkCanvas_flush(this: *mut root::SkCanvas);
    }
    extern "C" {
        #[link_name = "?getDevice@SkCanvas@@IEBAPEAVSkBaseDevice@@XZ"]
        pub fn SkCanvas_getDevice(this: *const root::SkCanvas)
         -> *mut root::SkBaseDevice;
    }
    extern "C" {
        /**
     *  Create a new surface matching the specified info, one that attempts to
     *  be maximally compatible when used with this canvas. If there is no matching Surface type,
     *  NULL is returned.
     *
     *  If surfaceprops is specified, those are passed to the new surface, otherwise the new surface
     *  inherits the properties of the surface that owns this canvas. If this canvas has no parent
     *  surface, then the new surface is created with default properties.
     */
        #[link_name =
              "?makeSurface@SkCanvas@@QEAA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkCanvas_makeSurface(this: *mut root::SkCanvas,
                                    arg1: *const root::SkImageInfo,
                                    arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     * Return the GPU context of the device that is associated with the canvas.
     * For a canvas with non-GPU device, NULL is returned.
     */
        #[link_name = "?getGrContext@SkCanvas@@QEAAPEAVGrContext@@XZ"]
        pub fn SkCanvas_getGrContext(this: *mut root::SkCanvas)
         -> *mut root::GrContext;
    }
    extern "C" {
        /**
     *  If the canvas has writable pixels in its top layer (and is not recording to a picture
     *  or other non-raster target) and has direct access to its pixels (i.e. they are in
     *  local RAM) return the address of those pixels, and if not null,
     *  return the ImageInfo, rowBytes and origin. The returned address is only valid
     *  while the canvas object is in scope and unchanged. Any API calls made on
     *  canvas (or its parent surface if any) will invalidate the
     *  returned address (and associated information).
     *
     *  On failure, returns NULL and the info, rowBytes, and origin parameters are ignored.
     */
        #[link_name =
              "?accessTopLayerPixels@SkCanvas@@QEAAPEAXPEAUSkImageInfo@@PEA_KPEAUSkIPoint@@@Z"]
        pub fn SkCanvas_accessTopLayerPixels(this: *mut root::SkCanvas,
                                             info: *mut root::SkImageInfo,
                                             rowBytes: *mut usize,
                                             origin: *mut root::SkIPoint)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        /**
     *  If the canvas has readable pixels in its base layer (and is not recording to a picture
     *  or other non-raster target) and has direct access to its pixels (i.e. they are in
     *  local RAM) return true, and if not null, return in the pixmap parameter information about
     *  the pixels. The pixmap's pixel address is only valid
     *  while the canvas object is in scope and unchanged. Any API calls made on
     *  canvas (or its parent surface if any) will invalidate the pixel address
     *  (and associated information).
     *
     *  On failure, returns false and the pixmap parameter will be ignored.
     */
        #[link_name = "?peekPixels@SkCanvas@@QEAA_NPEAVSkPixmap@@@Z"]
        pub fn SkCanvas_peekPixels(this: *mut root::SkCanvas,
                                   arg1: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Copy the pixels from the base-layer into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (SkImageInfo). The base-layer pixels are read
     *  starting at the specified (srcX,srcY) location in the coordinate system of the base-layer.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the base-layer. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the base-layer bounds.
     *  - If the requested colortype/alphatype cannot be converted from the base-layer's types.
     *  - If this canvas is not backed by pixels (e.g. picture or PDF)
     */
        #[link_name =
              "?readPixels@SkCanvas@@QEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
        pub fn SkCanvas_readPixels(this: *mut root::SkCanvas,
                                   dstInfo: *const root::SkImageInfo,
                                   dstPixels: *mut ::std::os::raw::c_void,
                                   dstRowBytes: usize,
                                   srcX: ::std::os::raw::c_int,
                                   srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Helper for calling readPixels(info). This call will check if bitmap has been allocated.
     *  If not, it will attempt to call allocPixels(). If this fails, it will return false. If not,
     *  it calls through to readPixels(info) and returns its result.
     */
        #[link_name = "?readPixels@SkCanvas@@QEAA_NPEAVSkBitmap@@HH@Z"]
        pub fn SkCanvas_readPixels1(this: *mut root::SkCanvas,
                                    bitmap: *mut root::SkBitmap,
                                    srcX: ::std::os::raw::c_int,
                                    srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Helper for allocating pixels and then calling readPixels(info). The bitmap is resized
     *  to the intersection of srcRect and the base-layer bounds. On success, pixels will be
     *  allocated in bitmap and true returned. On failure, false is returned and bitmap will be
     *  set to empty.
     */
        #[link_name =
              "?readPixels@SkCanvas@@QEAA_NAEBUSkIRect@@PEAVSkBitmap@@@Z"]
        pub fn SkCanvas_readPixels2(this: *mut root::SkCanvas,
                                    srcRect: *const root::SkIRect,
                                    bitmap: *mut root::SkBitmap) -> bool;
    }
    extern "C" {
        /**
     *  This method affects the pixels in the base-layer, and operates in pixel coordinates,
     *  ignoring the matrix and clip.
     *
     *  The specified ImageInfo and (x,y) offset specifies a rectangle: target.
     *
     *      target.setXYWH(x, y, info.width(), info.height());
     *
     *  Target is intersected with the bounds of the base-layer. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size), the "src" specified by info+pixels+rowBytes
     *  and the "dst" by the canvas' backend. Replace the dst pixels with the corresponding src
     *  pixels, performing any colortype/alphatype transformations needed (in the case where the
     *  src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If the src colortype/alphatype cannot be converted to the canvas' types
     *  - If this canvas is not backed by pixels (e.g. picture or PDF)
     */
        #[link_name =
              "?writePixels@SkCanvas@@QEAA_NAEBUSkImageInfo@@PEBX_KHH@Z"]
        pub fn SkCanvas_writePixels(this: *mut root::SkCanvas,
                                    arg1: *const root::SkImageInfo,
                                    pixels: *const ::std::os::raw::c_void,
                                    rowBytes: usize, x: ::std::os::raw::c_int,
                                    y: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Helper for calling writePixels(info) by passing its pixels and rowbytes. If the bitmap
     *  is just wrapping a texture, returns false and does nothing.
     */
        #[link_name = "?writePixels@SkCanvas@@QEAA_NAEBVSkBitmap@@HH@Z"]
        pub fn SkCanvas_writePixels1(this: *mut root::SkCanvas,
                                     bitmap: *const root::SkBitmap,
                                     x: ::std::os::raw::c_int,
                                     y: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** This call saves the current matrix, clip, and drawFilter, and pushes a
        copy onto a private stack. Subsequent calls to translate, scale,
        rotate, skew, concat or clipRect, clipPath, and setDrawFilter all
        operate on this copy.
        When the balancing call to restore() is made, the previous matrix, clip,
        and drawFilter are restored.

        @return The value to pass to restoreToCount() to balance this save()
    */
        #[link_name = "?save@SkCanvas@@QEAAHXZ"]
        pub fn SkCanvas_save(this: *mut root::SkCanvas)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** This behaves the same as save(), but in addition it allocates an
        offscreen bitmap. All drawing calls are directed there, and only when
        the balancing call to restore() is made is that offscreen transfered to
        the canvas (or the previous layer).
        @param bounds (may be null) This rect, if non-null, is used as a hint to
                      limit the size of the offscreen, and thus drawing may be
                      clipped to it, though that clipping is not guaranteed to
                      happen. If exact clipping is desired, use clipRect().
        @param paint (may be null) This is copied, and is applied to the
                     offscreen when restore() is called
        @return The value to pass to restoreToCount() to balance this save()
    */
        #[link_name = "?saveLayer@SkCanvas@@QEAAHPEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_saveLayer(this: *mut root::SkCanvas,
                                  bounds: *const root::SkRect,
                                  paint: *const root::SkPaint)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /**
     *  Temporary name.
     *  Will allow any requests for LCD text to be respected, so the caller must be careful to
     *  only draw on top of opaque sections of the layer to get good results.
     */
        #[link_name =
              "?saveLayerPreserveLCDTextRequests@SkCanvas@@QEAAHPEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_saveLayerPreserveLCDTextRequests(this:
                                                             *mut root::SkCanvas,
                                                         bounds:
                                                             *const root::SkRect,
                                                         paint:
                                                             *const root::SkPaint)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** This behaves the same as save(), but in addition it allocates an
        offscreen bitmap. All drawing calls are directed there, and only when
        the balancing call to restore() is made is that offscreen transfered to
        the canvas (or the previous layer).
        @param bounds (may be null) This rect, if non-null, is used as a hint to
                      limit the size of the offscreen, and thus drawing may be
                      clipped to it, though that clipping is not guaranteed to
                      happen. If exact clipping is desired, use clipRect().
        @param alpha  This is applied to the offscreen when restore() is called.
        @return The value to pass to restoreToCount() to balance this save()
    */
        #[link_name = "?saveLayerAlpha@SkCanvas@@QEAAHPEBUSkRect@@I@Z"]
        pub fn SkCanvas_saveLayerAlpha(this: *mut root::SkCanvas,
                                       bounds: *const root::SkRect,
                                       alpha: root::U8CPU)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "?saveLayer@SkCanvas@@QEAAHAEBUSaveLayerRec@1@@Z"]
        pub fn SkCanvas_saveLayer1(this: *mut root::SkCanvas,
                                   arg1: *const root::SkCanvas_SaveLayerRec)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** This call balances a previous call to save(), and is used to remove all
        modifications to the matrix/clip/drawFilter state since the last save
        call.
        It is an error to call restore() more times than save() was called.
    */
        #[link_name = "?restore@SkCanvas@@QEAAXXZ"]
        pub fn SkCanvas_restore(this: *mut root::SkCanvas);
    }
    extern "C" {
        /** Returns the number of matrix/clip states on the SkCanvas' private stack.
        This will equal # save() calls - # restore() calls + 1. The save count on
        a new canvas is 1.
    */
        #[link_name = "?getSaveCount@SkCanvas@@QEBAHXZ"]
        pub fn SkCanvas_getSaveCount(this: *const root::SkCanvas)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Efficient way to pop any calls to save() that happened after the save
        count reached saveCount. It is an error for saveCount to be greater than
        getSaveCount(). To pop all the way back to the initial matrix/clip context
        pass saveCount == 1.
        @param saveCount    The number of save() levels to restore from
    */
        #[link_name = "?restoreToCount@SkCanvas@@QEAAXH@Z"]
        pub fn SkCanvas_restoreToCount(this: *mut root::SkCanvas,
                                       saveCount: ::std::os::raw::c_int);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified translation
        @param dx   The distance to translate in X
        @param dy   The distance to translate in Y
    */
        #[link_name = "?translate@SkCanvas@@QEAAXMM@Z"]
        pub fn SkCanvas_translate(this: *mut root::SkCanvas,
                                  dx: root::SkScalar, dy: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified scale.
        @param sx   The amount to scale in X
        @param sy   The amount to scale in Y
    */
        #[link_name = "?scale@SkCanvas@@QEAAXMM@Z"]
        pub fn SkCanvas_scale(this: *mut root::SkCanvas, sx: root::SkScalar,
                              sy: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified rotation about the origin.
        @param degrees  The amount to rotate, in degrees
    */
        #[link_name = "?rotate@SkCanvas@@QEAAXM@Z"]
        pub fn SkCanvas_rotate(this: *mut root::SkCanvas,
                               degrees: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified rotation about a given point.
        @param degrees  The amount to rotate, in degrees
        @param px  The x coordinate of the point to rotate about.
        @param py  The y coordinate of the point to rotate about.
    */
        #[link_name = "?rotate@SkCanvas@@QEAAXMMM@Z"]
        pub fn SkCanvas_rotate1(this: *mut root::SkCanvas,
                                degrees: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified skew.
        @param sx   The amount to skew in X
        @param sy   The amount to skew in Y
    */
        #[link_name = "?skew@SkCanvas@@QEAAXMM@Z"]
        pub fn SkCanvas_skew(this: *mut root::SkCanvas, sx: root::SkScalar,
                             sy: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified matrix.
        @param matrix   The matrix to preconcatenate with the current matrix
    */
        #[link_name = "?concat@SkCanvas@@QEAAXAEBVSkMatrix@@@Z"]
        pub fn SkCanvas_concat(this: *mut root::SkCanvas,
                               matrix: *const root::SkMatrix);
    }
    extern "C" {
        /** Replace the current matrix with a copy of the specified matrix.
        @param matrix The matrix that will be copied into the current matrix.
    */
        #[link_name = "?setMatrix@SkCanvas@@QEAAXAEBVSkMatrix@@@Z"]
        pub fn SkCanvas_setMatrix(this: *mut root::SkCanvas,
                                  matrix: *const root::SkMatrix);
    }
    extern "C" {
        /** Helper for setMatrix(identity). Sets the current matrix to identity.
    */
        #[link_name = "?resetMatrix@SkCanvas@@QEAAXXZ"]
        pub fn SkCanvas_resetMatrix(this: *mut root::SkCanvas);
    }
    extern "C" {
        /**
     *  Modify the current clip with the specified rectangle.
     *  @param rect The rect to combine with the current clip
     *  @param op The region op to apply to the current clip
     *  @param doAntiAlias true if the clip should be antialiased
     */
        #[link_name = "?clipRect@SkCanvas@@QEAAXAEBUSkRect@@W4SkClipOp@@_N@Z"]
        pub fn SkCanvas_clipRect(this: *mut root::SkCanvas,
                                 rect: *const root::SkRect,
                                 arg1: root::SkClipOp, doAntiAlias: bool);
    }
    extern "C" {
        /**
     *  Modify the current clip with the specified SkRRect.
     *  @param rrect The rrect to combine with the current clip
     *  @param op The region op to apply to the current clip
     *  @param doAntiAlias true if the clip should be antialiased
     */
        #[link_name =
              "?clipRRect@SkCanvas@@QEAAXAEBVSkRRect@@W4SkClipOp@@_N@Z"]
        pub fn SkCanvas_clipRRect(this: *mut root::SkCanvas,
                                  rrect: *const root::SkRRect,
                                  op: root::SkClipOp, doAntiAlias: bool);
    }
    extern "C" {
        /**
     *  Modify the current clip with the specified path.
     *  @param path The path to combine with the current clip
     *  @param op The region op to apply to the current clip
     *  @param doAntiAlias true if the clip should be antialiased
     */
        #[link_name = "?clipPath@SkCanvas@@QEAAXAEBVSkPath@@W4SkClipOp@@_N@Z"]
        pub fn SkCanvas_clipPath(this: *mut root::SkCanvas,
                                 path: *const root::SkPath,
                                 op: root::SkClipOp, doAntiAlias: bool);
    }
    extern "C" {
        /** Modify the current clip with the specified region. Note that unlike
        clipRect() and clipPath() which transform their arguments by the current
        matrix, clipRegion() assumes its argument is already in device
        coordinates, and so no transformation is performed.
        @param deviceRgn    The region to apply to the current clip
        @param op The region op to apply to the current clip
    */
        #[link_name =
              "?clipRegion@SkCanvas@@QEAAXAEBVSkRegion@@W4SkClipOp@@@Z"]
        pub fn SkCanvas_clipRegion(this: *mut root::SkCanvas,
                                   deviceRgn: *const root::SkRegion,
                                   op: root::SkClipOp);
    }
    extern "C" {
        /** Return true if the specified rectangle, after being transformed by the
        current matrix, would lie completely outside of the current clip. Call
        this to check if an area you intend to draw into is clipped out (and
        therefore you can skip making the draw calls).
        @param rect the rect to compare with the current clip
        @return true if the rect (transformed by the canvas' matrix) does not
                     intersect with the canvas' clip
    */
        #[link_name = "?quickReject@SkCanvas@@QEBA_NAEBUSkRect@@@Z"]
        pub fn SkCanvas_quickReject(this: *const root::SkCanvas,
                                    rect: *const root::SkRect) -> bool;
    }
    extern "C" {
        /** Return true if the specified path, after being transformed by the
        current matrix, would lie completely outside of the current clip. Call
        this to check if an area you intend to draw into is clipped out (and
        therefore you can skip making the draw calls). Note, for speed it may
        return false even if the path itself might not intersect the clip
        (i.e. the bounds of the path intersects, but the path does not).
        @param path The path to compare with the current clip
        @return true if the path (transformed by the canvas' matrix) does not
                     intersect with the canvas' clip
    */
        #[link_name = "?quickReject@SkCanvas@@QEBA_NAEBVSkPath@@@Z"]
        pub fn SkCanvas_quickReject1(this: *const root::SkCanvas,
                                     path: *const root::SkPath) -> bool;
    }
    extern "C" {
        /** Fill the entire canvas' bitmap (restricted to the current clip) with the
        specified ARGB color, using the specified mode.
        @param a    the alpha component (0..255) of the color to fill the canvas
        @param r    the red component (0..255) of the color to fill the canvas
        @param g    the green component (0..255) of the color to fill the canvas
        @param b    the blue component (0..255) of the color to fill the canvas
        @param mode the mode to apply the color in (defaults to SrcOver)
    */
        #[link_name = "?drawARGB@SkCanvas@@QEAAXIIIIW4SkBlendMode@@@Z"]
        pub fn SkCanvas_drawARGB(this: *mut root::SkCanvas, a: root::U8CPU,
                                 r: root::U8CPU, g: root::U8CPU,
                                 b: root::U8CPU, mode: root::SkBlendMode);
    }
    extern "C" {
        /** Fill the entire canvas' bitmap (restricted to the current clip) with the
        specified color and mode.
        @param color    the color to draw with
        @param mode the mode to apply the color in (defaults to SrcOver)
    */
        #[link_name = "?drawColor@SkCanvas@@QEAAXIW4SkBlendMode@@@Z"]
        pub fn SkCanvas_drawColor(this: *mut root::SkCanvas,
                                  color: root::SkColor,
                                  mode: root::SkBlendMode);
    }
    extern "C" {
        /**
     *  Fill the entire canvas (restricted to the current clip) with the
     *  specified paint.
     *  @param paint    The paint used to fill the canvas
     */
        #[link_name = "?drawPaint@SkCanvas@@QEAAXAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPaint(this: *mut root::SkCanvas,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw a series of points, interpreted based on the PointMode mode. For
        all modes, the count parameter is interpreted as the total number of
        points. For kLine mode, count/2 line segments are drawn.
        For kPoint mode, each point is drawn centered at its coordinate, and its
        size is specified by the paint's stroke-width. It draws as a square,
        unless the paint's cap-type is round, in which the points are drawn as
        circles.
        For kLine mode, each pair of points is drawn as a line segment,
        respecting the paint's settings for cap/join/width.
        For kPolygon mode, the entire array is drawn as a series of connected
        line segments.
        Note that, while similar, kLine and kPolygon modes draw slightly
        differently than the equivalent path built with a series of moveto,
        lineto calls, in that the path will draw all of its contours at once,
        with no interactions if contours intersect each other (think XOR
        xfermode). drawPoints always draws each element one at a time.
        @param mode     PointMode specifying how to draw the array of points.
        @param count    The number of points in the array
        @param pts      Array of points to draw
        @param paint    The paint used to draw the points
    */
        #[link_name =
              "?drawPoints@SkCanvas@@QEAAXW4PointMode@1@_KQEBUSkPoint@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPoints(this: *mut root::SkCanvas,
                                   mode: root::SkCanvas_PointMode,
                                   count: usize, pts: *const root::SkPoint,
                                   paint: *const root::SkPaint);
    }
    extern "C" {
        /** Helper method for drawing a single point. See drawPoints() for a more
        details.
    */
        #[link_name = "?drawPoint@SkCanvas@@QEAAXMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPoint(this: *mut root::SkCanvas,
                                  x: root::SkScalar, y: root::SkScalar,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draws a single pixel in the specified color.
        @param x        The X coordinate of which pixel to draw
        @param y        The Y coordiante of which pixel to draw
        @param color    The color to draw
    */
        #[link_name = "?drawPoint@SkCanvas@@QEAAXMMI@Z"]
        pub fn SkCanvas_drawPoint1(this: *mut root::SkCanvas,
                                   x: root::SkScalar, y: root::SkScalar,
                                   color: root::SkColor);
    }
    extern "C" {
        /** Draw a line segment with the specified start and stop x,y coordinates,
        using the specified paint. NOTE: since a line is always "framed", the
        paint's Style is ignored.
        @param x0    The x-coordinate of the start point of the line
        @param y0    The y-coordinate of the start point of the line
        @param x1    The x-coordinate of the end point of the line
        @param y1    The y-coordinate of the end point of the line
        @param paint The paint used to draw the line
    */
        #[link_name = "?drawLine@SkCanvas@@QEAAXMMMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawLine(this: *mut root::SkCanvas,
                                 x0: root::SkScalar, y0: root::SkScalar,
                                 x1: root::SkScalar, y1: root::SkScalar,
                                 paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified rectangle using the specified paint. The rectangle
        will be filled or stroked based on the Style in the paint.
        @param rect     The rect to be drawn
        @param paint    The paint used to draw the rect
    */
        #[link_name = "?drawRect@SkCanvas@@QEAAXAEBUSkRect@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRect(this: *mut root::SkCanvas,
                                 rect: *const root::SkRect,
                                 paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified rectangle using the specified paint. The rectangle
        will be filled or framed based on the Style in the paint.
        @param left     The left side of the rectangle to be drawn
        @param top      The top side of the rectangle to be drawn
        @param right    The right side of the rectangle to be drawn
        @param bottom   The bottom side of the rectangle to be drawn
        @param paint    The paint used to draw the rect
    */
        #[link_name = "?drawRectCoords@SkCanvas@@QEAAXMMMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRectCoords(this: *mut root::SkCanvas,
                                       left: root::SkScalar,
                                       top: root::SkScalar,
                                       right: root::SkScalar,
                                       bottom: root::SkScalar,
                                       paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the outline of the specified region using the specified paint.
        @param region   The region to be drawn
        @param paint    The paint used to draw the region
    */
        #[link_name =
              "?drawRegion@SkCanvas@@QEAAXAEBVSkRegion@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRegion(this: *mut root::SkCanvas,
                                   region: *const root::SkRegion,
                                   paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified oval using the specified paint. The oval will be
        filled or framed based on the Style in the paint.
        @param oval     The rectangle bounds of the oval to be drawn
        @param paint    The paint used to draw the oval
    */
        #[link_name = "?drawOval@SkCanvas@@QEAAXAEBUSkRect@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawOval(this: *mut root::SkCanvas,
                                 oval: *const root::SkRect,
                                 arg1: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the specified RRect using the specified paint The rrect will be filled or stroked
     *  based on the Style in the paint.
     *
     *  @param rrect    The round-rect to draw
     *  @param paint    The paint used to draw the round-rect
     */
        #[link_name =
              "?drawRRect@SkCanvas@@QEAAXAEBVSkRRect@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRRect(this: *mut root::SkCanvas,
                                  rrect: *const root::SkRRect,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the annulus formed by the outer and inner rrects. The results
     *  are undefined if the outer does not contain the inner.
     */
        #[link_name =
              "?drawDRRect@SkCanvas@@QEAAXAEBVSkRRect@@0AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawDRRect(this: *mut root::SkCanvas,
                                   outer: *const root::SkRRect,
                                   inner: *const root::SkRRect,
                                   arg1: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified circle using the specified paint. If radius is <= 0,
        then nothing will be drawn. The circle will be filled
        or framed based on the Style in the paint.
        @param cx       The x-coordinate of the center of the cirle to be drawn
        @param cy       The y-coordinate of the center of the cirle to be drawn
        @param radius   The radius of the cirle to be drawn
        @param paint    The paint used to draw the circle
    */
        #[link_name = "?drawCircle@SkCanvas@@QEAAXMMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawCircle(this: *mut root::SkCanvas,
                                   cx: root::SkScalar, cy: root::SkScalar,
                                   radius: root::SkScalar,
                                   paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified arc, which will be scaled to fit inside the
        specified oval. Sweep angles are not treated as modulo 360 and thus can
        exceed a full sweep of the oval. Note that this differs slightly from
        SkPath::arcTo, which treats the sweep angle mod 360. If the oval is empty
        or the sweep angle is zero nothing is drawn. If useCenter is true the oval
        center is inserted into the implied path before the arc and the path is
        closed back to the, center forming a wedge. Otherwise, the implied path
        contains just the arc and is not closed.
        @param oval The bounds of oval used to define the shape of the arc.
        @param startAngle Starting angle (in degrees) where the arc begins
        @param sweepAngle Sweep angle (in degrees) measured clockwise.
        @param useCenter true means include the center of the oval.
        @param paint    The paint used to draw the arc
    */
        #[link_name =
              "?drawArc@SkCanvas@@QEAAXAEBUSkRect@@MM_NAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawArc(this: *mut root::SkCanvas,
                                oval: *const root::SkRect,
                                startAngle: root::SkScalar,
                                sweepAngle: root::SkScalar, useCenter: bool,
                                paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified round-rect using the specified paint. The round-rect
        will be filled or framed based on the Style in the paint.
        @param rect     The rectangular bounds of the roundRect to be drawn
        @param rx       The x-radius of the oval used to round the corners
        @param ry       The y-radius of the oval used to round the corners
        @param paint    The paint used to draw the roundRect
    */
        #[link_name =
              "?drawRoundRect@SkCanvas@@QEAAXAEBUSkRect@@MMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRoundRect(this: *mut root::SkCanvas,
                                      rect: *const root::SkRect,
                                      rx: root::SkScalar, ry: root::SkScalar,
                                      paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified path using the specified paint. The path will be
        filled or framed based on the Style in the paint.
        @param path     The path to be drawn
        @param paint    The paint used to draw the path
    */
        #[link_name = "?drawPath@SkCanvas@@QEAAXAEBVSkPath@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPath(this: *mut root::SkCanvas,
                                 path: *const root::SkPath,
                                 paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified image, with its top/left corner at (x,y), using the
        specified paint, transformed by the current matrix.

        @param image    The image to be drawn
        @param left     The position of the left side of the image being drawn
        @param top      The position of the top side of the image being drawn
        @param paint    The paint used to draw the image, or NULL
     */
        #[link_name =
              "?drawImage@SkCanvas@@QEAAXPEBVSkImage@@MMPEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawImage(this: *mut root::SkCanvas,
                                  image: *const root::SkImage,
                                  left: root::SkScalar, top: root::SkScalar,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified image, scaling and translating so that it fills the specified
     *  dst rect. If the src rect is non-null, only that subset of the image is transformed
     *  and drawn.
     *
     *  @param image      The image to be drawn
     *  @param src        Optional: specify the subset of the image to be drawn
     *  @param dst        The destination rectangle where the scaled/translated
     *                    image will be drawn
     *  @param paint      The paint used to draw the image, or NULL
     *  @param constraint Control the tradeoff between speed and exactness w.r.t. the src-rect.
     */
        #[link_name =
              "?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkRect@@1PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawImageRect(this: *mut root::SkCanvas,
                                      image: *const root::SkImage,
                                      src: *const root::SkRect,
                                      dst: *const root::SkRect,
                                      paint: *const root::SkPaint,
                                      constraint:
                                          root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawImageRect1(this: *mut root::SkCanvas,
                                       image: *const root::SkImage,
                                       isrc: *const root::SkIRect,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint,
                                       arg1:
                                           root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawImageRect2(this: *mut root::SkCanvas,
                                       image: *const root::SkImage,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint,
                                       arg1:
                                           root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        /**
     *  Draw the image stretched differentially to fit into dst.
     *  center is a rect within the image, and logically divides the image
     *  into 9 sections (3x3). For example, if the middle pixel of a [5x5]
     *  image is the "center", then the center-rect should be [2, 2, 3, 3].
     *
     *  If the dst is >= the image size, then...
     *  - The 4 corners are not stretched at all.
     *  - The sides are stretched in only one axis.
     *  - The center is stretched in both axes.
     * Else, for each axis where dst < image,
     *  - The corners shrink proportionally
     *  - The sides (along the shrink axis) and center are not drawn
     */
        #[link_name =
              "?drawImageNine@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawImageNine(this: *mut root::SkCanvas,
                                      arg1: *const root::SkImage,
                                      center: *const root::SkIRect,
                                      dst: *const root::SkRect,
                                      paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified bitmap, with its top/left corner at (x,y), using the
        specified paint, transformed by the current matrix. Note: if the paint
        contains a maskfilter that generates a mask which extends beyond the
        bitmap's original width/height, then the bitmap will be drawn as if it
        were in a Shader with CLAMP mode. Thus the color outside of the original
        width/height will be the edge color replicated.

        If a shader is present on the paint it will be ignored, except in the
        case where the bitmap is kAlpha_8_SkColorType. In that case, the color is
        generated by the shader.

        @param bitmap   The bitmap to be drawn
        @param left     The position of the left side of the bitmap being drawn
        @param top      The position of the top side of the bitmap being drawn
        @param paint    The paint used to draw the bitmap, or NULL
    */
        #[link_name =
              "?drawBitmap@SkCanvas@@QEAAXAEBVSkBitmap@@MMPEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawBitmap(this: *mut root::SkCanvas,
                                   bitmap: *const root::SkBitmap,
                                   left: root::SkScalar, top: root::SkScalar,
                                   paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified bitmap, scaling and translating so that it fills the specified
     *  dst rect. If the src rect is non-null, only that subset of the bitmap is transformed
     *  and drawn.
     *
     *  @param bitmap     The bitmap to be drawn
     *  @param src        Optional: specify the subset of the bitmap to be drawn
     *  @param dst        The destination rectangle where the scaled/translated
     *                    bitmap will be drawn
     *  @param paint      The paint used to draw the bitmap, or NULL
     *  @param constraint Control the tradeoff between speed and exactness w.r.t. the src-rect.
     */
        #[link_name =
              "?drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkRect@@1PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawBitmapRect(this: *mut root::SkCanvas,
                                       bitmap: *const root::SkBitmap,
                                       src: *const root::SkRect,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint,
                                       arg1:
                                           root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawBitmapRect1(this: *mut root::SkCanvas,
                                        bitmap: *const root::SkBitmap,
                                        isrc: *const root::SkIRect,
                                        dst: *const root::SkRect,
                                        paint: *const root::SkPaint,
                                        arg1:
                                            root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawBitmapRect2(this: *mut root::SkCanvas,
                                        bitmap: *const root::SkBitmap,
                                        dst: *const root::SkRect,
                                        paint: *const root::SkPaint,
                                        arg1:
                                            root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        /**
     *  Draw the bitmap stretched or shrunk differentially to fit into dst.
     *  center is a rect within the bitmap, and logically divides the bitmap
     *  into 9 sections (3x3). For example, if the middle pixel of a [5x5]
     *  bitmap is the "center", then the center-rect should be [2, 2, 3, 3].
     *
     *  If the dst is >= the bitmap size, then...
     *  - The 4 corners are not stretched at all.
     *  - The sides are stretched in only one axis.
     *  - The center is stretched in both axes.
     * Else, for each axis where dst < bitmap,
     *  - The corners shrink proportionally
     *  - The sides (along the shrink axis) and center are not drawn
     */
        #[link_name =
              "?drawBitmapNine@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawBitmapNine(this: *mut root::SkCanvas,
                                       bitmap: *const root::SkBitmap,
                                       center: *const root::SkIRect,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the bitmap stretched or shrunk differentially to fit into dst.
     *
     *  Moving horizontally across the bitmap, alternating rects will be "scalable"
     *  (in the x-dimension) to fit into dst or must be left "fixed".  The first rect
     *  is treated as "fixed", but it's possible to specify an empty first rect by
     *  making lattice.fXDivs[0] = 0.
     *
     *  The scale factor for all "scalable" rects will be the same, and may be greater
     *  than or less than 1 (meaning we can stretch or shrink).  If the number of
     *  "fixed" pixels is greater than the width of the dst, we will collapse all of
     *  the "scalable" regions and appropriately downscale the "fixed" regions.
     *
     *  The same interpretation also applies to the y-dimension.
     */
        #[link_name =
              "?drawBitmapLattice@SkCanvas@@QEAAXAEBVSkBitmap@@AEBULattice@1@AEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawBitmapLattice(this: *mut root::SkCanvas,
                                          bitmap: *const root::SkBitmap,
                                          lattice:
                                              *const root::SkCanvas_Lattice,
                                          dst: *const root::SkRect,
                                          paint: *const root::SkPaint);
    }
    extern "C" {
        #[link_name =
              "?drawImageLattice@SkCanvas@@QEAAXPEBVSkImage@@AEBULattice@1@AEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawImageLattice(this: *mut root::SkCanvas,
                                         image: *const root::SkImage,
                                         lattice:
                                             *const root::SkCanvas_Lattice,
                                         dst: *const root::SkRect,
                                         paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with origin at (x,y), using the specified paint.
        The origin is interpreted based on the Align setting in the paint.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param x        The x-coordinate of the origin of the text being drawn
        @param y        The y-coordinate of the origin of the text being drawn
        @param paint    The paint used for the text (e.g. color, size, style)
    */
        #[link_name = "?drawText@SkCanvas@@QEAAXPEBX_KMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawText(this: *mut root::SkCanvas,
                                 text: *const ::std::os::raw::c_void,
                                 byteLength: usize, x: root::SkScalar,
                                 y: root::SkScalar,
                                 paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with each character/glyph origin specified by the pos[]
        array. The origin is interpreted by the Align setting in the paint.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param pos      Array of positions, used to position each character
        @param paint    The paint used for the text (e.g. color, size, style)
        */
        #[link_name =
              "?drawPosText@SkCanvas@@QEAAXPEBX_KQEBUSkPoint@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPosText(this: *mut root::SkCanvas,
                                    text: *const ::std::os::raw::c_void,
                                    byteLength: usize,
                                    pos: *const root::SkPoint,
                                    paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with each character/glyph origin specified by the x
        coordinate taken from the xpos[] array, and the y from the constY param.
        The origin is interpreted by the Align setting in the paint.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param xpos     Array of x-positions, used to position each character
        @param constY   The shared Y coordinate for all of the positions
        @param paint    The paint used for the text (e.g. color, size, style)
        */
        #[link_name =
              "?drawPosTextH@SkCanvas@@QEAAXPEBX_KQEBMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPosTextH(this: *mut root::SkCanvas,
                                     text: *const ::std::os::raw::c_void,
                                     byteLength: usize,
                                     xpos: *const root::SkScalar,
                                     constY: root::SkScalar,
                                     paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with origin at (x,y), using the specified paint, along
        the specified path. The paint's Align setting determins where along the
        path to start the text.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param path         The path the text should follow for its baseline
        @param hOffset      The distance along the path to add to the text's
                            starting position
        @param vOffset      The distance above(-) or below(+) the path to
                            position the text
        @param paint        The paint used for the text
    */
        #[link_name =
              "?drawTextOnPathHV@SkCanvas@@QEAAXPEBX_KAEBVSkPath@@MMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawTextOnPathHV(this: *mut root::SkCanvas,
                                         text: *const ::std::os::raw::c_void,
                                         byteLength: usize,
                                         path: *const root::SkPath,
                                         hOffset: root::SkScalar,
                                         vOffset: root::SkScalar,
                                         paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with origin at (x,y), using the specified paint, along
        the specified path. The paint's Align setting determins where along the
        path to start the text.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param path         The path the text should follow for its baseline
        @param matrix       (may be null) Applied to the text before it is
                            mapped onto the path
        @param paint        The paint used for the text
        */
        #[link_name =
              "?drawTextOnPath@SkCanvas@@QEAAXPEBX_KAEBVSkPath@@PEBVSkMatrix@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawTextOnPath(this: *mut root::SkCanvas,
                                       text: *const ::std::os::raw::c_void,
                                       byteLength: usize,
                                       path: *const root::SkPath,
                                       matrix: *const root::SkMatrix,
                                       paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the text with each character/glyph individually transformed by its xform.
     *  If cullRect is not null, it is a conservative bounds of what will be drawn
     *  taking into account the xforms and the paint, and will be used to accelerate culling.
     */
        #[link_name =
              "?drawTextRSXform@SkCanvas@@QEAAXPEBX_KQEBUSkRSXform@@PEBUSkRect@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawTextRSXform(this: *mut root::SkCanvas,
                                        text: *const ::std::os::raw::c_void,
                                        byteLength: usize,
                                        arg1: *const root::SkRSXform,
                                        cullRect: *const root::SkRect,
                                        paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text blob, offset by (x,y), using the specified paint.
        @param blob     The text blob to be drawn
        @param x        The x-offset of the text being drawn
        @param y        The y-offset of the text being drawn
        @param paint    The paint used for the text (e.g. color, size, style)
    */
        #[link_name =
              "?drawTextBlob@SkCanvas@@QEAAXPEBVSkTextBlob@@MMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawTextBlob(this: *mut root::SkCanvas,
                                     blob: *const root::SkTextBlob,
                                     x: root::SkScalar, y: root::SkScalar,
                                     paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the picture into this canvas.
     *
     *  If matrix is non-null, apply that matrix to the CTM when drawing this picture. This is
     *  logically equivalent to
     *      save/concat/drawPicture/restore
     *
     *  If paint is non-null, draw the picture into a temporary buffer, and then apply the paint's
     *  alpha/colorfilter/imagefilter/xfermode to that buffer as it is drawn to the canvas.
     *  This is logically equivalent to
     *      saveLayer(paint)/drawPicture/restore
     */
        #[link_name =
              "?drawPicture@SkCanvas@@QEAAXPEBVSkPicture@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPicture(this: *mut root::SkCanvas,
                                    arg1: *const root::SkPicture,
                                    matrix: *const root::SkMatrix,
                                    paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the array of vertices, interpreted as triangles (based on mode).

        If both textures and vertex-colors are NULL, it strokes hairlines with
        the paint's color. This behavior is a useful debugging mode to visualize
        the mesh.

        @param vmode How to interpret the array of vertices
        @param vertexCount The number of points in the vertices array (and
                    corresponding texs and colors arrays if non-null)
        @param vertices Array of vertices for the mesh
        @param texs May be null. If not null, specifies the coordinate
                    in _texture_ space (not uv space) for each vertex.
        @param colors May be null. If not null, specifies a color for each
                      vertex, to be interpolated across the triangle.
        @param mode Used if both texs and colors are present. In this
                    case the colors are combined with the texture using mode,
                    before being drawn using the paint. 
        @param indices If not null, array of indices to reference into the
                    vertex (texs, colors) array.
        @param indexCount number of entries in the indices array (if not null)
        @param paint Specifies the shader/texture if present.
    */
        #[link_name =
              "?drawVertices@SkCanvas@@QEAAXW4VertexMode@1@HQEBUSkPoint@@1QEBIW4SkBlendMode@@QEBGHAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawVertices(this: *mut root::SkCanvas,
                                     vmode: root::SkCanvas_VertexMode,
                                     vertexCount: ::std::os::raw::c_int,
                                     vertices: *const root::SkPoint,
                                     texs: *const root::SkPoint,
                                     colors: *const root::SkColor,
                                     mode: root::SkBlendMode,
                                     indices: *const u16,
                                     indexCount: ::std::os::raw::c_int,
                                     paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     Draw a cubic coons patch

     @param cubic specifies the 4 bounding cubic bezier curves of a patch with clockwise order
                    starting at the top left corner.
     @param colors specifies the colors for the corners which will be bilerp across the patch,
                    their order is clockwise starting at the top left corner.
     @param texCoords specifies the texture coordinates that will be bilerp across the patch,
                    their order is the same as the colors.
     @param mode specifies how are the colors and the textures combined if both of them are
                    present.
     @param paint Specifies the shader/texture if present.
     */
        #[link_name =
              "?drawPatch@SkCanvas@@QEAAXQEBUSkPoint@@QEBI0W4SkBlendMode@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPatch(this: *mut root::SkCanvas,
                                  cubics: *mut root::SkPoint,
                                  colors: *mut root::SkColor,
                                  texCoords: *mut root::SkPoint,
                                  mode: root::SkBlendMode,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw a set of sprites from the atlas. Each is specified by a tex rectangle in the
     *  coordinate space of the atlas, and a corresponding xform which transforms the tex rectangle
     *  into a quad.
     *
     *      xform maps [0, 0, tex.width, tex.height] -> quad
     *
     *  The color array is optional. When specified, each color modulates the pixels in its
     *  corresponding quad (via the specified SkBlendMode).
     *
     *  The cullRect is optional. When specified, it must be a conservative bounds of all of the
     *  resulting transformed quads, allowing the canvas to skip drawing if the cullRect does not
     *  intersect the current clip.
     *
     *  The paint is optional. If specified, its antialiasing, alpha, color-filter, image-filter
     *  and blendmode are used to affect each of the quads.
     */
        #[link_name =
              "?drawAtlas@SkCanvas@@QEAAXPEBVSkImage@@QEBUSkRSXform@@QEBUSkRect@@QEBIHW4SkBlendMode@@PEBU4@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawAtlas(this: *mut root::SkCanvas,
                                  atlas: *const root::SkImage,
                                  xform: *const root::SkRSXform,
                                  tex: *const root::SkRect,
                                  colors: *const root::SkColor,
                                  count: ::std::os::raw::c_int,
                                  arg1: root::SkBlendMode,
                                  cullRect: *const root::SkRect,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the contents of this drawable into the canvas. If the canvas is async
     *  (e.g. it is recording into a picture) then the drawable will be referenced instead,
     *  to have its draw() method called when the picture is finalized.
     *
     *  If the intent is to force the contents of the drawable into this canvas immediately,
     *  then drawable->draw(canvas) may be called.
     */
        #[link_name =
              "?drawDrawable@SkCanvas@@QEAAXPEAVSkDrawable@@PEBVSkMatrix@@@Z"]
        pub fn SkCanvas_drawDrawable(this: *mut root::SkCanvas,
                                     drawable: *mut root::SkDrawable,
                                     arg1: *const root::SkMatrix);
    }
    extern "C" {
        #[link_name = "?drawDrawable@SkCanvas@@QEAAXPEAVSkDrawable@@MM@Z"]
        pub fn SkCanvas_drawDrawable1(this: *mut root::SkCanvas,
                                      arg1: *mut root::SkDrawable,
                                      x: root::SkScalar, y: root::SkScalar);
    }
    extern "C" {
        /**
     *  Send an "annotation" to the canvas. The annotation is a key/value pair, where the key is
     *  a null-terminated utf8 string, and the value is a blob of data stored in an SkData
     *  (which may be null). The annotation is associated with the specified rectangle.
     *
     *  The caller still retains its ownership of the data (if any).
     *
     *  Note: on may canvas types, this information is ignored, but some canvases (e.g. recording
     *  a picture or drawing to a PDF document) will pass on this information.
     */
        #[link_name =
              "?drawAnnotation@SkCanvas@@QEAAXAEBUSkRect@@QEBDPEAVSkData@@@Z"]
        pub fn SkCanvas_drawAnnotation(this: *mut root::SkCanvas,
                                       arg1: *const root::SkRect,
                                       key: *const ::std::os::raw::c_char,
                                       value: *mut root::SkData);
    }
    extern "C" {
        /** Return the current matrix on the canvas.
        This does not account for the translate in any of the devices.
        @return The current matrix on the canvas.
    */
        #[link_name = "?getTotalMatrix@SkCanvas@@QEBAAEBVSkMatrix@@XZ"]
        pub fn SkCanvas_getTotalMatrix(this: *const root::SkCanvas)
         -> *const root::SkMatrix;
    }
    extern "C" {
        /**
     *  Replays the clip operations, back to front, that have been applied to
     *  the canvas, calling the appropriate method on the visitor for each
     *  clip. All clips have already been transformed into device space.
     */
        #[link_name =
              "?replayClips@SkCanvas@@QEBAXPEAVSkCanvasClipVisitor@@@Z"]
        pub fn SkCanvas_replayClips(this: *const root::SkCanvas,
                                    arg1: *mut root::SkCanvas_ClipVisitor);
    }
    extern "C" {
        ///////////////////////////////////////////////////////////////////////////
        #[link_name =
              "?internal_private_accessTopLayerRenderTargetContext@SkCanvas@@QEAAPEAVGrRenderTargetContext@@XZ"]
        pub fn SkCanvas_internal_private_accessTopLayerRenderTargetContext(this:
                                                                               *mut root::SkCanvas)
         -> *mut root::GrRenderTargetContext;
    }
    extern "C" {
        #[link_name =
              "?Internal_Private_SetIgnoreSaveLayerBounds@SkCanvas@@SAX_N@Z"]
        pub fn SkCanvas_Internal_Private_SetIgnoreSaveLayerBounds(arg1: bool);
    }
    extern "C" {
        #[link_name =
              "?Internal_Private_GetIgnoreSaveLayerBounds@SkCanvas@@SA_NXZ"]
        pub fn SkCanvas_Internal_Private_GetIgnoreSaveLayerBounds() -> bool;
    }
    extern "C" {
        #[link_name =
              "?Internal_Private_SetTreatSpriteAsBitmap@SkCanvas@@SAX_N@Z"]
        pub fn SkCanvas_Internal_Private_SetTreatSpriteAsBitmap(arg1: bool);
    }
    extern "C" {
        #[link_name =
              "?Internal_Private_GetTreatSpriteAsBitmap@SkCanvas@@SA_NXZ"]
        pub fn SkCanvas_Internal_Private_GetTreatSpriteAsBitmap() -> bool;
    }
    extern "C" {
        #[link_name =
              "?legacy_drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@PEBUSkRect@@AEBU3@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_legacy_drawImageRect(this: *mut root::SkCanvas,
                                             image: *const root::SkImage,
                                             src: *const root::SkRect,
                                             dst: *const root::SkRect,
                                             paint: *const root::SkPaint,
                                             constraint:
                                                 root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?legacy_drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@PEBUSkRect@@AEBU3@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_legacy_drawBitmapRect(this: *mut root::SkCanvas,
                                              bitmap: *const root::SkBitmap,
                                              src: *const root::SkRect,
                                              dst: *const root::SkRect,
                                              paint: *const root::SkPaint,
                                              constraint:
                                                  root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        /**
     * Returns CTM and clip bounds, translated from canvas coordinates to top layer coordinates.
     */
        #[link_name =
              "?temporary_internal_describeTopLayer@SkCanvas@@QEAAXPEAVSkMatrix@@PEAUSkIRect@@@Z"]
        pub fn SkCanvas_temporary_internal_describeTopLayer(this:
                                                                *mut root::SkCanvas,
                                                            matrix:
                                                                *mut root::SkMatrix,
                                                            clip_bounds:
                                                                *mut root::SkIRect);
    }
    extern "C" {
        #[link_name =
              "?clipRectBounds@SkCanvas@@IEAA_NPEBUSkRect@@IPEAUSkIRect@@PEBVSkImageFilter@@@Z"]
        pub fn SkCanvas_clipRectBounds(this: *mut root::SkCanvas,
                                       bounds: *const root::SkRect,
                                       arg1: root::SkCanvas_SaveLayerFlags,
                                       intersection: *mut root::SkIRect,
                                       imageFilter:
                                           *const root::SkImageFilter)
         -> bool;
    }
    impl SkCanvas {
        #[inline]
        pub unsafe fn MakeRasterDirect(arg1: *const root::SkImageInfo,
                                       arg2: *mut ::std::os::raw::c_void,
                                       arg3: usize)
         ->
             root::std::unique_ptr<root::SkCanvas,
                                   root::std::default_delete<root::SkCanvas>> {
            SkCanvas_MakeRasterDirect(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn getMetaData(&mut self) -> *mut root::SkMetaData {
            SkCanvas_getMetaData(&mut *self)
        }
        #[inline]
        pub unsafe fn imageInfo(&self) -> root::SkImageInfo {
            SkCanvas_imageInfo(&*self)
        }
        #[inline]
        pub unsafe fn getProps(&self, arg1: *mut root::SkSurfaceProps)
         -> bool {
            SkCanvas_getProps(&*self, arg1)
        }
        #[inline]
        pub unsafe fn flush(&mut self) { SkCanvas_flush(&mut *self) }
        #[inline]
        pub unsafe fn getDevice(&self) -> *mut root::SkBaseDevice {
            SkCanvas_getDevice(&*self)
        }
        #[inline]
        pub unsafe fn makeSurface(&mut self, arg1: *const root::SkImageInfo,
                                  arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkCanvas_makeSurface(&mut *self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn getGrContext(&mut self) -> *mut root::GrContext {
            SkCanvas_getGrContext(&mut *self)
        }
        #[inline]
        pub unsafe fn accessTopLayerPixels(&mut self,
                                           info: *mut root::SkImageInfo,
                                           rowBytes: *mut usize,
                                           origin: *mut root::SkIPoint)
         -> *mut ::std::os::raw::c_void {
            SkCanvas_accessTopLayerPixels(&mut *self, info, rowBytes, origin)
        }
        #[inline]
        pub unsafe fn peekPixels(&mut self, arg1: *mut root::SkPixmap)
         -> bool {
            SkCanvas_peekPixels(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn readPixels(&mut self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int) -> bool {
            SkCanvas_readPixels(&mut *self, dstInfo, dstPixels, dstRowBytes,
                                srcX, srcY)
        }
        #[inline]
        pub unsafe fn readPixels1(&mut self, bitmap: *mut root::SkBitmap,
                                  srcX: ::std::os::raw::c_int,
                                  srcY: ::std::os::raw::c_int) -> bool {
            SkCanvas_readPixels1(&mut *self, bitmap, srcX, srcY)
        }
        #[inline]
        pub unsafe fn readPixels2(&mut self, srcRect: *const root::SkIRect,
                                  bitmap: *mut root::SkBitmap) -> bool {
            SkCanvas_readPixels2(&mut *self, srcRect, bitmap)
        }
        #[inline]
        pub unsafe fn writePixels(&mut self, arg1: *const root::SkImageInfo,
                                  pixels: *const ::std::os::raw::c_void,
                                  rowBytes: usize, x: ::std::os::raw::c_int,
                                  y: ::std::os::raw::c_int) -> bool {
            SkCanvas_writePixels(&mut *self, arg1, pixels, rowBytes, x, y)
        }
        #[inline]
        pub unsafe fn writePixels1(&mut self, bitmap: *const root::SkBitmap,
                                   x: ::std::os::raw::c_int,
                                   y: ::std::os::raw::c_int) -> bool {
            SkCanvas_writePixels1(&mut *self, bitmap, x, y)
        }
        #[inline]
        pub unsafe fn save(&mut self) -> ::std::os::raw::c_int {
            SkCanvas_save(&mut *self)
        }
        #[inline]
        pub unsafe fn saveLayer(&mut self, bounds: *const root::SkRect,
                                paint: *const root::SkPaint)
         -> ::std::os::raw::c_int {
            SkCanvas_saveLayer(&mut *self, bounds, paint)
        }
        #[inline]
        pub unsafe fn saveLayerPreserveLCDTextRequests(&mut self,
                                                       bounds:
                                                           *const root::SkRect,
                                                       paint:
                                                           *const root::SkPaint)
         -> ::std::os::raw::c_int {
            SkCanvas_saveLayerPreserveLCDTextRequests(&mut *self, bounds,
                                                      paint)
        }
        #[inline]
        pub unsafe fn saveLayerAlpha(&mut self, bounds: *const root::SkRect,
                                     alpha: root::U8CPU)
         -> ::std::os::raw::c_int {
            SkCanvas_saveLayerAlpha(&mut *self, bounds, alpha)
        }
        #[inline]
        pub unsafe fn saveLayer1(&mut self,
                                 arg1: *const root::SkCanvas_SaveLayerRec)
         -> ::std::os::raw::c_int {
            SkCanvas_saveLayer1(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn restore(&mut self) { SkCanvas_restore(&mut *self) }
        #[inline]
        pub unsafe fn getSaveCount(&self) -> ::std::os::raw::c_int {
            SkCanvas_getSaveCount(&*self)
        }
        #[inline]
        pub unsafe fn restoreToCount(&mut self,
                                     saveCount: ::std::os::raw::c_int) {
            SkCanvas_restoreToCount(&mut *self, saveCount)
        }
        #[inline]
        pub unsafe fn translate(&mut self, dx: root::SkScalar,
                                dy: root::SkScalar) {
            SkCanvas_translate(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn scale(&mut self, sx: root::SkScalar,
                            sy: root::SkScalar) {
            SkCanvas_scale(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn rotate(&mut self, degrees: root::SkScalar) {
            SkCanvas_rotate(&mut *self, degrees)
        }
        #[inline]
        pub unsafe fn rotate1(&mut self, degrees: root::SkScalar,
                              px: root::SkScalar, py: root::SkScalar) {
            SkCanvas_rotate1(&mut *self, degrees, px, py)
        }
        #[inline]
        pub unsafe fn skew(&mut self, sx: root::SkScalar,
                           sy: root::SkScalar) {
            SkCanvas_skew(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn concat(&mut self, matrix: *const root::SkMatrix) {
            SkCanvas_concat(&mut *self, matrix)
        }
        #[inline]
        pub unsafe fn setMatrix(&mut self, matrix: *const root::SkMatrix) {
            SkCanvas_setMatrix(&mut *self, matrix)
        }
        #[inline]
        pub unsafe fn resetMatrix(&mut self) {
            SkCanvas_resetMatrix(&mut *self)
        }
        #[inline]
        pub unsafe fn clipRect(&mut self, rect: *const root::SkRect,
                               arg1: root::SkClipOp, doAntiAlias: bool) {
            SkCanvas_clipRect(&mut *self, rect, arg1, doAntiAlias)
        }
        #[inline]
        pub unsafe fn clipRRect(&mut self, rrect: *const root::SkRRect,
                                op: root::SkClipOp, doAntiAlias: bool) {
            SkCanvas_clipRRect(&mut *self, rrect, op, doAntiAlias)
        }
        #[inline]
        pub unsafe fn clipPath(&mut self, path: *const root::SkPath,
                               op: root::SkClipOp, doAntiAlias: bool) {
            SkCanvas_clipPath(&mut *self, path, op, doAntiAlias)
        }
        #[inline]
        pub unsafe fn clipRegion(&mut self, deviceRgn: *const root::SkRegion,
                                 op: root::SkClipOp) {
            SkCanvas_clipRegion(&mut *self, deviceRgn, op)
        }
        #[inline]
        pub unsafe fn quickReject(&self, rect: *const root::SkRect) -> bool {
            SkCanvas_quickReject(&*self, rect)
        }
        #[inline]
        pub unsafe fn quickReject1(&self, path: *const root::SkPath) -> bool {
            SkCanvas_quickReject1(&*self, path)
        }
        #[inline]
        pub unsafe fn drawARGB(&mut self, a: root::U8CPU, r: root::U8CPU,
                               g: root::U8CPU, b: root::U8CPU,
                               mode: root::SkBlendMode) {
            SkCanvas_drawARGB(&mut *self, a, r, g, b, mode)
        }
        #[inline]
        pub unsafe fn drawColor(&mut self, color: root::SkColor,
                                mode: root::SkBlendMode) {
            SkCanvas_drawColor(&mut *self, color, mode)
        }
        #[inline]
        pub unsafe fn drawPaint(&mut self, paint: *const root::SkPaint) {
            SkCanvas_drawPaint(&mut *self, paint)
        }
        #[inline]
        pub unsafe fn drawPoints(&mut self, mode: root::SkCanvas_PointMode,
                                 count: usize, pts: *const root::SkPoint,
                                 paint: *const root::SkPaint) {
            SkCanvas_drawPoints(&mut *self, mode, count, pts, paint)
        }
        #[inline]
        pub unsafe fn drawPoint(&mut self, x: root::SkScalar,
                                y: root::SkScalar,
                                paint: *const root::SkPaint) {
            SkCanvas_drawPoint(&mut *self, x, y, paint)
        }
        #[inline]
        pub unsafe fn drawPoint1(&mut self, x: root::SkScalar,
                                 y: root::SkScalar, color: root::SkColor) {
            SkCanvas_drawPoint1(&mut *self, x, y, color)
        }
        #[inline]
        pub unsafe fn drawLine(&mut self, x0: root::SkScalar,
                               y0: root::SkScalar, x1: root::SkScalar,
                               y1: root::SkScalar,
                               paint: *const root::SkPaint) {
            SkCanvas_drawLine(&mut *self, x0, y0, x1, y1, paint)
        }
        #[inline]
        pub unsafe fn drawRect(&mut self, rect: *const root::SkRect,
                               paint: *const root::SkPaint) {
            SkCanvas_drawRect(&mut *self, rect, paint)
        }
        #[inline]
        pub unsafe fn drawRectCoords(&mut self, left: root::SkScalar,
                                     top: root::SkScalar,
                                     right: root::SkScalar,
                                     bottom: root::SkScalar,
                                     paint: *const root::SkPaint) {
            SkCanvas_drawRectCoords(&mut *self, left, top, right, bottom,
                                    paint)
        }
        #[inline]
        pub unsafe fn drawRegion(&mut self, region: *const root::SkRegion,
                                 paint: *const root::SkPaint) {
            SkCanvas_drawRegion(&mut *self, region, paint)
        }
        #[inline]
        pub unsafe fn drawOval(&mut self, oval: *const root::SkRect,
                               arg1: *const root::SkPaint) {
            SkCanvas_drawOval(&mut *self, oval, arg1)
        }
        #[inline]
        pub unsafe fn drawRRect(&mut self, rrect: *const root::SkRRect,
                                paint: *const root::SkPaint) {
            SkCanvas_drawRRect(&mut *self, rrect, paint)
        }
        #[inline]
        pub unsafe fn drawDRRect(&mut self, outer: *const root::SkRRect,
                                 inner: *const root::SkRRect,
                                 arg1: *const root::SkPaint) {
            SkCanvas_drawDRRect(&mut *self, outer, inner, arg1)
        }
        #[inline]
        pub unsafe fn drawCircle(&mut self, cx: root::SkScalar,
                                 cy: root::SkScalar, radius: root::SkScalar,
                                 paint: *const root::SkPaint) {
            SkCanvas_drawCircle(&mut *self, cx, cy, radius, paint)
        }
        #[inline]
        pub unsafe fn drawArc(&mut self, oval: *const root::SkRect,
                              startAngle: root::SkScalar,
                              sweepAngle: root::SkScalar, useCenter: bool,
                              paint: *const root::SkPaint) {
            SkCanvas_drawArc(&mut *self, oval, startAngle, sweepAngle,
                             useCenter, paint)
        }
        #[inline]
        pub unsafe fn drawRoundRect(&mut self, rect: *const root::SkRect,
                                    rx: root::SkScalar, ry: root::SkScalar,
                                    paint: *const root::SkPaint) {
            SkCanvas_drawRoundRect(&mut *self, rect, rx, ry, paint)
        }
        #[inline]
        pub unsafe fn drawPath(&mut self, path: *const root::SkPath,
                               paint: *const root::SkPaint) {
            SkCanvas_drawPath(&mut *self, path, paint)
        }
        #[inline]
        pub unsafe fn drawImage(&mut self, image: *const root::SkImage,
                                left: root::SkScalar, top: root::SkScalar,
                                paint: *const root::SkPaint) {
            SkCanvas_drawImage(&mut *self, image, left, top, paint)
        }
        #[inline]
        pub unsafe fn drawImageRect(&mut self, image: *const root::SkImage,
                                    src: *const root::SkRect,
                                    dst: *const root::SkRect,
                                    paint: *const root::SkPaint,
                                    constraint:
                                        root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawImageRect(&mut *self, image, src, dst, paint,
                                   constraint)
        }
        #[inline]
        pub unsafe fn drawImageRect1(&mut self, image: *const root::SkImage,
                                     isrc: *const root::SkIRect,
                                     dst: *const root::SkRect,
                                     paint: *const root::SkPaint,
                                     arg1: root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawImageRect1(&mut *self, image, isrc, dst, paint, arg1)
        }
        #[inline]
        pub unsafe fn drawImageRect2(&mut self, image: *const root::SkImage,
                                     dst: *const root::SkRect,
                                     paint: *const root::SkPaint,
                                     arg1: root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawImageRect2(&mut *self, image, dst, paint, arg1)
        }
        #[inline]
        pub unsafe fn drawImageNine(&mut self, arg1: *const root::SkImage,
                                    center: *const root::SkIRect,
                                    dst: *const root::SkRect,
                                    paint: *const root::SkPaint) {
            SkCanvas_drawImageNine(&mut *self, arg1, center, dst, paint)
        }
        #[inline]
        pub unsafe fn drawBitmap(&mut self, bitmap: *const root::SkBitmap,
                                 left: root::SkScalar, top: root::SkScalar,
                                 paint: *const root::SkPaint) {
            SkCanvas_drawBitmap(&mut *self, bitmap, left, top, paint)
        }
        #[inline]
        pub unsafe fn drawBitmapRect(&mut self, bitmap: *const root::SkBitmap,
                                     src: *const root::SkRect,
                                     dst: *const root::SkRect,
                                     paint: *const root::SkPaint,
                                     arg1: root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawBitmapRect(&mut *self, bitmap, src, dst, paint, arg1)
        }
        #[inline]
        pub unsafe fn drawBitmapRect1(&mut self,
                                      bitmap: *const root::SkBitmap,
                                      isrc: *const root::SkIRect,
                                      dst: *const root::SkRect,
                                      paint: *const root::SkPaint,
                                      arg1:
                                          root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawBitmapRect1(&mut *self, bitmap, isrc, dst, paint,
                                     arg1)
        }
        #[inline]
        pub unsafe fn drawBitmapRect2(&mut self,
                                      bitmap: *const root::SkBitmap,
                                      dst: *const root::SkRect,
                                      paint: *const root::SkPaint,
                                      arg1:
                                          root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawBitmapRect2(&mut *self, bitmap, dst, paint, arg1)
        }
        #[inline]
        pub unsafe fn drawBitmapNine(&mut self, bitmap: *const root::SkBitmap,
                                     center: *const root::SkIRect,
                                     dst: *const root::SkRect,
                                     paint: *const root::SkPaint) {
            SkCanvas_drawBitmapNine(&mut *self, bitmap, center, dst, paint)
        }
        #[inline]
        pub unsafe fn drawBitmapLattice(&mut self,
                                        bitmap: *const root::SkBitmap,
                                        lattice:
                                            *const root::SkCanvas_Lattice,
                                        dst: *const root::SkRect,
                                        paint: *const root::SkPaint) {
            SkCanvas_drawBitmapLattice(&mut *self, bitmap, lattice, dst,
                                       paint)
        }
        #[inline]
        pub unsafe fn drawImageLattice(&mut self, image: *const root::SkImage,
                                       lattice: *const root::SkCanvas_Lattice,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint) {
            SkCanvas_drawImageLattice(&mut *self, image, lattice, dst, paint)
        }
        #[inline]
        pub unsafe fn drawText(&mut self, text: *const ::std::os::raw::c_void,
                               byteLength: usize, x: root::SkScalar,
                               y: root::SkScalar,
                               paint: *const root::SkPaint) {
            SkCanvas_drawText(&mut *self, text, byteLength, x, y, paint)
        }
        #[inline]
        pub unsafe fn drawPosText(&mut self,
                                  text: *const ::std::os::raw::c_void,
                                  byteLength: usize,
                                  pos: *const root::SkPoint,
                                  paint: *const root::SkPaint) {
            SkCanvas_drawPosText(&mut *self, text, byteLength, pos, paint)
        }
        #[inline]
        pub unsafe fn drawPosTextH(&mut self,
                                   text: *const ::std::os::raw::c_void,
                                   byteLength: usize,
                                   xpos: *const root::SkScalar,
                                   constY: root::SkScalar,
                                   paint: *const root::SkPaint) {
            SkCanvas_drawPosTextH(&mut *self, text, byteLength, xpos, constY,
                                  paint)
        }
        #[inline]
        pub unsafe fn drawTextOnPathHV(&mut self,
                                       text: *const ::std::os::raw::c_void,
                                       byteLength: usize,
                                       path: *const root::SkPath,
                                       hOffset: root::SkScalar,
                                       vOffset: root::SkScalar,
                                       paint: *const root::SkPaint) {
            SkCanvas_drawTextOnPathHV(&mut *self, text, byteLength, path,
                                      hOffset, vOffset, paint)
        }
        #[inline]
        pub unsafe fn drawTextOnPath(&mut self,
                                     text: *const ::std::os::raw::c_void,
                                     byteLength: usize,
                                     path: *const root::SkPath,
                                     matrix: *const root::SkMatrix,
                                     paint: *const root::SkPaint) {
            SkCanvas_drawTextOnPath(&mut *self, text, byteLength, path,
                                    matrix, paint)
        }
        #[inline]
        pub unsafe fn drawTextRSXform(&mut self,
                                      text: *const ::std::os::raw::c_void,
                                      byteLength: usize,
                                      arg1: *const root::SkRSXform,
                                      cullRect: *const root::SkRect,
                                      paint: *const root::SkPaint) {
            SkCanvas_drawTextRSXform(&mut *self, text, byteLength, arg1,
                                     cullRect, paint)
        }
        #[inline]
        pub unsafe fn drawTextBlob(&mut self, blob: *const root::SkTextBlob,
                                   x: root::SkScalar, y: root::SkScalar,
                                   paint: *const root::SkPaint) {
            SkCanvas_drawTextBlob(&mut *self, blob, x, y, paint)
        }
        #[inline]
        pub unsafe fn drawPicture(&mut self, arg1: *const root::SkPicture,
                                  matrix: *const root::SkMatrix,
                                  paint: *const root::SkPaint) {
            SkCanvas_drawPicture(&mut *self, arg1, matrix, paint)
        }
        #[inline]
        pub unsafe fn drawVertices(&mut self,
                                   vmode: root::SkCanvas_VertexMode,
                                   vertexCount: ::std::os::raw::c_int,
                                   vertices: *const root::SkPoint,
                                   texs: *const root::SkPoint,
                                   colors: *const root::SkColor,
                                   mode: root::SkBlendMode,
                                   indices: *const u16,
                                   indexCount: ::std::os::raw::c_int,
                                   paint: *const root::SkPaint) {
            SkCanvas_drawVertices(&mut *self, vmode, vertexCount, vertices,
                                  texs, colors, mode, indices, indexCount,
                                  paint)
        }
        #[inline]
        pub unsafe fn drawPatch(&mut self, cubics: *mut root::SkPoint,
                                colors: *mut root::SkColor,
                                texCoords: *mut root::SkPoint,
                                mode: root::SkBlendMode,
                                paint: *const root::SkPaint) {
            SkCanvas_drawPatch(&mut *self, cubics, colors, texCoords, mode,
                               paint)
        }
        #[inline]
        pub unsafe fn drawAtlas(&mut self, atlas: *const root::SkImage,
                                xform: *const root::SkRSXform,
                                tex: *const root::SkRect,
                                colors: *const root::SkColor,
                                count: ::std::os::raw::c_int,
                                arg1: root::SkBlendMode,
                                cullRect: *const root::SkRect,
                                paint: *const root::SkPaint) {
            SkCanvas_drawAtlas(&mut *self, atlas, xform, tex, colors, count,
                               arg1, cullRect, paint)
        }
        #[inline]
        pub unsafe fn drawDrawable(&mut self, drawable: *mut root::SkDrawable,
                                   arg1: *const root::SkMatrix) {
            SkCanvas_drawDrawable(&mut *self, drawable, arg1)
        }
        #[inline]
        pub unsafe fn drawDrawable1(&mut self, arg1: *mut root::SkDrawable,
                                    x: root::SkScalar, y: root::SkScalar) {
            SkCanvas_drawDrawable1(&mut *self, arg1, x, y)
        }
        #[inline]
        pub unsafe fn drawAnnotation(&mut self, arg1: *const root::SkRect,
                                     key: *const ::std::os::raw::c_char,
                                     value: *mut root::SkData) {
            SkCanvas_drawAnnotation(&mut *self, arg1, key, value)
        }
        #[inline]
        pub unsafe fn getTotalMatrix(&self) -> *const root::SkMatrix {
            SkCanvas_getTotalMatrix(&*self)
        }
        #[inline]
        pub unsafe fn replayClips(&self,
                                  arg1: *mut root::SkCanvas_ClipVisitor) {
            SkCanvas_replayClips(&*self, arg1)
        }
        #[inline]
        pub unsafe fn internal_private_accessTopLayerRenderTargetContext(&mut self)
         -> *mut root::GrRenderTargetContext {
            SkCanvas_internal_private_accessTopLayerRenderTargetContext(&mut *self)
        }
        #[inline]
        pub unsafe fn Internal_Private_SetIgnoreSaveLayerBounds(arg1: bool) {
            SkCanvas_Internal_Private_SetIgnoreSaveLayerBounds(arg1)
        }
        #[inline]
        pub unsafe fn Internal_Private_GetIgnoreSaveLayerBounds() -> bool {
            SkCanvas_Internal_Private_GetIgnoreSaveLayerBounds()
        }
        #[inline]
        pub unsafe fn Internal_Private_SetTreatSpriteAsBitmap(arg1: bool) {
            SkCanvas_Internal_Private_SetTreatSpriteAsBitmap(arg1)
        }
        #[inline]
        pub unsafe fn Internal_Private_GetTreatSpriteAsBitmap() -> bool {
            SkCanvas_Internal_Private_GetTreatSpriteAsBitmap()
        }
        #[inline]
        pub unsafe fn legacy_drawImageRect(&mut self,
                                           image: *const root::SkImage,
                                           src: *const root::SkRect,
                                           dst: *const root::SkRect,
                                           paint: *const root::SkPaint,
                                           constraint:
                                               root::SkCanvas_SrcRectConstraint) {
            SkCanvas_legacy_drawImageRect(&mut *self, image, src, dst, paint,
                                          constraint)
        }
        #[inline]
        pub unsafe fn legacy_drawBitmapRect(&mut self,
                                            bitmap: *const root::SkBitmap,
                                            src: *const root::SkRect,
                                            dst: *const root::SkRect,
                                            paint: *const root::SkPaint,
                                            constraint:
                                                root::SkCanvas_SrcRectConstraint) {
            SkCanvas_legacy_drawBitmapRect(&mut *self, bitmap, src, dst,
                                           paint, constraint)
        }
        #[inline]
        pub unsafe fn temporary_internal_describeTopLayer(&mut self,
                                                          matrix:
                                                              *mut root::SkMatrix,
                                                          clip_bounds:
                                                              *mut root::SkIRect) {
            SkCanvas_temporary_internal_describeTopLayer(&mut *self, matrix,
                                                         clip_bounds)
        }
        #[inline]
        pub unsafe fn clipRectBounds(&mut self, bounds: *const root::SkRect,
                                     arg1: root::SkCanvas_SaveLayerFlags,
                                     intersection: *mut root::SkIRect,
                                     imageFilter: *const root::SkImageFilter)
         -> bool {
            SkCanvas_clipRectBounds(&mut *self, bounds, arg1, intersection,
                                    imageFilter)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImageGenerator {
        pub _address: u8,
    }
    impl Clone for SkImageGenerator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPixelSerializer {
        pub _address: u8,
    }
    impl Clone for SkPixelSerializer {
        fn clone(&self) -> Self { *self }
    }
    /**
 *  SkSurface represents the backend/results of drawing to a canvas. For raster
 *  drawing, the surface will be pixels, but (for example) when drawing into
 *  a PDF or Picture canvas, the surface stores the recorded commands.
 *
 *  To draw into a canvas, first create the appropriate type of Surface, and
 *  then request the canvas from the surface.
 *
 *  SkSurface always has non-zero dimensions. If there is a request for a new surface, and either
 *  of the requested dimensions are zero, then NULL will be returned.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkSurface {
        pub _base: root::SkRefCnt,
        pub fProps: root::SkSurfaceProps,
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fGenerationID: u32,
    }
    #[repr(i32)]
    /**
     *  Modes that can be passed to notifyContentWillChange
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkSurface_ContentChangeMode {
        kDiscard_ContentChangeMode = 0,
        kRetain_ContentChangeMode = 1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkSurface_BackendHandleAccess {
        kFlushRead_BackendHandleAccess = 0,
        kFlushWrite_BackendHandleAccess = 1,
        kDiscardWrite_BackendHandleAccess = 2,
    }
    #[repr(i32)]
    /**
     * In rare instances a client may want a unique copy of the SkSurface's contents in an image
     * snapshot. This enum can be used to enforce that the image snapshot's backing store is not
     * shared with another image snapshot or the surface's backing store. This is generally more
     * expensive. This was added for Chromium bug 585250.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkSurface_ForceUnique {
        kNo_ForceUnique = 0,
        kYes_ForceUnique = 1,
    }
    pub type SkSurface_INHERITED = root::SkRefCnt;
    extern "C" {
        #[link_name =
              "?kFlushRead_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"]
        pub static SkSurface_kFlushRead_TextureHandleAccess:
                   root::SkSurface_BackendHandleAccess;
    }
    extern "C" {
        #[link_name =
              "?kFlushWrite_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"]
        pub static SkSurface_kFlushWrite_TextureHandleAccess:
                   root::SkSurface_BackendHandleAccess;
    }
    extern "C" {
        #[link_name =
              "?kDiscardWrite_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"]
        pub static SkSurface_kDiscardWrite_TextureHandleAccess:
                   root::SkSurface_BackendHandleAccess;
    }
    #[test]
    fn bindgen_test_layout_SkSurface() {
        assert_eq!(::std::mem::size_of::<SkSurface>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkSurface>() , 8usize);
    }
    extern "C" {
        /**
     *  Create a new surface, using the specified pixels/rowbytes as its
     *  backend.
     *
     *  If the requested surface cannot be created, or the request is not a
     *  supported configuration, NULL will be returned.
     *
     *  Callers are responsible for initialiazing the surface pixels.
     */
        #[link_name =
              "?MakeRasterDirect@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEAX_KPEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeRasterDirect(arg1: *const root::SkImageInfo,
                                          pixels: *mut ::std::os::raw::c_void,
                                          rowBytes: usize,
                                          arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  The same as NewRasterDirect, but also accepts a call-back routine, which is invoked
     *  when the surface is deleted, and is passed the pixel memory and the specified context.
     */
        #[link_name =
              "?MakeRasterDirectReleaseProc@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEAX_KP6AX11@Z1PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeRasterDirectReleaseProc(arg1:
                                                         *const root::SkImageInfo,
                                                     pixels:
                                                         *mut ::std::os::raw::c_void,
                                                     rowBytes: usize,
                                                     releaseProc:
                                                         ::std::option::Option<unsafe extern "C" fn(pixels:
                                                                                                        *mut ::std::os::raw::c_void,
                                                                                                    context:
                                                                                                        *mut ::std::os::raw::c_void)>,
                                                     context:
                                                         *mut ::std::os::raw::c_void,
                                                     arg2:
                                                         *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Return a new surface, with the memory for the pixels automatically allocated and
     *  zero-initialized, but respecting the specified rowBytes. If rowBytes==0, then a default
     *  value will be chosen. If a non-zero rowBytes is specified, then any images snapped off of
     *  this surface (via makeImageSnapshot()) are guaranteed to have the same rowBytes.
     *
     *  If the requested surface cannot be created, or the request is not a
     *  supported configuration, NULL will be returned.
     */
        #[link_name =
              "?MakeRaster@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@_KPEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeRaster(arg1: *const root::SkImageInfo,
                                    rowBytes: usize,
                                    arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Used to wrap a pre-existing backend 3D API texture as a SkSurface. The kRenderTarget flag
     *  must be set on GrBackendTextureDesc for this to succeed. Skia will not assume ownership
     *  of the texture and the client must ensure the texture is valid for the lifetime of the
     *  SkSurface.
     */
        #[link_name =
              "?MakeFromBackendTexture@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeFromBackendTexture(arg1: *mut root::GrContext,
                                                arg2:
                                                    *const root::GrBackendTextureDesc,
                                                arg3:
                                                    root::sk_sp<root::SkColorSpace>,
                                                arg4:
                                                    *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Used to wrap a pre-existing 3D API rendering target as a SkSurface. Skia will not assume
     *  ownership of the render target and the client must ensure the render target is valid for the
     *  lifetime of the SkSurface.
     */
        #[link_name =
              "?MakeFromBackendRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@AEBUGrBackendRenderTargetDesc@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeFromBackendRenderTarget(arg1:
                                                         *mut root::GrContext,
                                                     arg2:
                                                         *const root::GrBackendRenderTargetDesc,
                                                     arg3:
                                                         root::sk_sp<root::SkColorSpace>,
                                                     arg4:
                                                         *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Used to wrap a pre-existing 3D API texture as a SkSurface. Skia will treat the texture as
     *  a rendering target only, but unlike NewFromBackendRenderTarget, Skia will manage and own
     *  the associated render target objects (but not the provided texture). The kRenderTarget flag
     *  must be set on GrBackendTextureDesc for this to succeed. Skia will not assume ownership
     *  of the texture and the client must ensure the texture is valid for the lifetime of the
     *  SkSurface.
     */
        #[link_name =
              "?MakeFromBackendTextureAsRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeFromBackendTextureAsRenderTarget(arg1:
                                                                  *mut root::GrContext,
                                                              arg2:
                                                                  *const root::GrBackendTextureDesc,
                                                              arg3:
                                                                  root::sk_sp<root::SkColorSpace>,
                                                              arg4:
                                                                  *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Return a new surface whose contents will be drawn to an offscreen
     *  render target, allocated by the surface.
     */
        #[link_name =
              "?MakeRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@W4SkBudgeted@@AEBUSkImageInfo@@HW4GrSurfaceOrigin@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeRenderTarget(arg1: *mut root::GrContext,
                                          arg2: root::SkBudgeted,
                                          arg3: *const root::SkImageInfo,
                                          sampleCount: ::std::os::raw::c_int,
                                          arg4: root::GrSurfaceOrigin,
                                          arg5: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Returns a unique non-zero, unique value identifying the content of this
     *  surface. Each time the content is changed changed, either by drawing
     *  into this surface, or explicitly calling notifyContentChanged()) this
     *  method will return a new value.
     *
     *  If this surface is empty (i.e. has a zero-dimention), this will return
     *  0.
     */
        #[link_name = "?generationID@SkSurface@@QEAAIXZ"]
        pub fn SkSurface_generationID(this: *mut root::SkSurface) -> u32;
    }
    extern "C" {
        /**
     *  Call this if the contents are about to change. This will (lazily) force a new
     *  value to be returned from generationID() when it is called next.
     *
     *  CAN WE DEPRECATE THIS?
     */
        #[link_name =
              "?notifyContentWillChange@SkSurface@@QEAAXW4ContentChangeMode@1@@Z"]
        pub fn SkSurface_notifyContentWillChange(this: *mut root::SkSurface,
                                                 mode:
                                                     root::SkSurface_ContentChangeMode);
    }
    extern "C" {
        /**
     *  Retrieves the backend API handle of the texture used by this surface, or 0 if the surface
     *  is not backed by a GPU texture.
     *
     *  The returned texture-handle is only valid until the next draw-call into the surface,
     *  or the surface is deleted.
     */
        #[link_name =
              "?getTextureHandle@SkSurface@@QEAA_JW4BackendHandleAccess@1@@Z"]
        pub fn SkSurface_getTextureHandle(this: *mut root::SkSurface,
                                          arg1:
                                              root::SkSurface_BackendHandleAccess)
         -> root::GrBackendObject;
    }
    extern "C" {
        /**
     *  Retrieves the backend API handle of the RenderTarget backing this surface.  Callers must
     *  ensure this function returns 'true' or else the GrBackendObject will be invalid
     *
     *  In OpenGL this will return the FramebufferObject ID.
     */
        #[link_name =
              "?getRenderTargetHandle@SkSurface@@QEAA_NPEA_JW4BackendHandleAccess@1@@Z"]
        pub fn SkSurface_getRenderTargetHandle(this: *mut root::SkSurface,
                                               arg1:
                                                   *mut root::GrBackendObject,
                                               arg2:
                                                   root::SkSurface_BackendHandleAccess)
         -> bool;
    }
    extern "C" {
        /**
     *  Return a canvas that will draw into this surface. This will always
     *  return the same canvas for a given surface, and is manged/owned by the
     *  surface. It should not be used when its parent surface has gone out of
     *  scope.
     */
        #[link_name = "?getCanvas@SkSurface@@QEAAPEAVSkCanvas@@XZ"]
        pub fn SkSurface_getCanvas(this: *mut root::SkSurface)
         -> *mut root::SkCanvas;
    }
    extern "C" {
        /**
     *  Return a new surface that is "compatible" with this one, in that it will
     *  efficiently be able to be drawn into this surface. Typical calling
     *  pattern:
     *
     *  SkSurface* A = SkSurface::New...();
     *  SkCanvas* canvasA = surfaceA->newCanvas();
     *  ...
     *  SkSurface* surfaceB = surfaceA->newSurface(...);
     *  SkCanvas* canvasB = surfaceB->newCanvas();
     *  ... // draw using canvasB
     *  canvasA->drawSurface(surfaceB); // <--- this will always be optimal!
     */
        #[link_name =
              "?makeSurface@SkSurface@@QEAA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@@Z"]
        pub fn SkSurface_makeSurface(this: *mut root::SkSurface,
                                     arg1: *const root::SkImageInfo)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Returns an image of the current state of the surface pixels up to this
     *  point. Subsequent changes to the surface (by drawing into its canvas)
     *  will not be reflected in this image. If a copy must be made the Budgeted
     *  parameter controls whether it counts against the resource budget
     *  (currently for the gpu backend only).
     */
        #[link_name =
              "?makeImageSnapshot@SkSurface@@QEAA?AV?$sk_sp@VSkImage@@@@W4SkBudgeted@@@Z"]
        pub fn SkSurface_makeImageSnapshot(this: *mut root::SkSurface,
                                           arg1: root::SkBudgeted)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name =
              "?makeImageSnapshot@SkSurface@@QEAA?AV?$sk_sp@VSkImage@@@@W4SkBudgeted@@W4ForceUnique@1@@Z"]
        pub fn SkSurface_makeImageSnapshot1(this: *mut root::SkSurface,
                                            arg1: root::SkBudgeted,
                                            arg2: root::SkSurface_ForceUnique)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Though the caller could get a snapshot image explicitly, and draw that,
     *  it seems that directly drawing a surface into another canvas might be
     *  a common pattern, and that we could possibly be more efficient, since
     *  we'd know that the "snapshot" need only live until we've handed it off
     *  to the canvas.
     */
        #[link_name = "?draw@SkSurface@@QEAAXPEAVSkCanvas@@MMPEBVSkPaint@@@Z"]
        pub fn SkSurface_draw(this: *mut root::SkSurface,
                              arg1: *mut root::SkCanvas, x: root::SkScalar,
                              y: root::SkScalar, arg2: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  If the surface has direct access to its pixels (i.e. they are in local
     *  RAM) return true, and if not null, set the pixmap parameter to point to the information
     *  about the surface's pixels. The pixel address in the pixmap is only valid while
     *  the surface object is in scope, and no API call is made on the surface
     *  or its canvas.
     *
     *  On failure, returns false and the pixmap parameter is ignored.
     */
        #[link_name = "?peekPixels@SkSurface@@QEAA_NPEAVSkPixmap@@@Z"]
        pub fn SkSurface_peekPixels(this: *mut root::SkSurface,
                                    arg1: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Copy the pixels from the surface into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (dstInfo). The surface pixels are read
     *  starting at the specified (srcX,srcY) location.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the base-layer. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the surface bounds.
     *  - If the requested colortype/alphatype cannot be converted from the surface's types.
     */
        #[link_name =
              "?readPixels@SkSurface@@QEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
        pub fn SkSurface_readPixels(this: *mut root::SkSurface,
                                    dstInfo: *const root::SkImageInfo,
                                    dstPixels: *mut ::std::os::raw::c_void,
                                    dstRowBytes: usize,
                                    srcX: ::std::os::raw::c_int,
                                    srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     * Issue any pending surface IO to the current backend 3D API and resolve any surface MSAA.
     */
        #[link_name = "?prepareForExternalIO@SkSurface@@QEAAXXZ"]
        pub fn SkSurface_prepareForExternalIO(this: *mut root::SkSurface);
    }
    impl SkSurface {
        #[inline]
        pub unsafe fn MakeRasterDirect(arg1: *const root::SkImageInfo,
                                       pixels: *mut ::std::os::raw::c_void,
                                       rowBytes: usize,
                                       arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeRasterDirect(arg1, pixels, rowBytes, arg2)
        }
        #[inline]
        pub unsafe fn MakeRasterDirectReleaseProc(arg1:
                                                      *const root::SkImageInfo,
                                                  pixels:
                                                      *mut ::std::os::raw::c_void,
                                                  rowBytes: usize,
                                                  releaseProc:
                                                      ::std::option::Option<unsafe extern "C" fn(pixels:
                                                                                                     *mut ::std::os::raw::c_void,
                                                                                                 context:
                                                                                                     *mut ::std::os::raw::c_void)>,
                                                  context:
                                                      *mut ::std::os::raw::c_void,
                                                  arg2:
                                                      *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeRasterDirectReleaseProc(arg1, pixels, rowBytes,
                                                  releaseProc, context, arg2)
        }
        #[inline]
        pub unsafe fn MakeRaster(arg1: *const root::SkImageInfo,
                                 rowBytes: usize,
                                 arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeRaster(arg1, rowBytes, arg2)
        }
        #[inline]
        pub unsafe fn MakeFromBackendTexture(arg1: *mut root::GrContext,
                                             arg2:
                                                 *const root::GrBackendTextureDesc,
                                             arg3:
                                                 root::sk_sp<root::SkColorSpace>,
                                             arg4:
                                                 *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeFromBackendTexture(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromBackendRenderTarget(arg1: *mut root::GrContext,
                                                  arg2:
                                                      *const root::GrBackendRenderTargetDesc,
                                                  arg3:
                                                      root::sk_sp<root::SkColorSpace>,
                                                  arg4:
                                                      *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeFromBackendRenderTarget(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromBackendTextureAsRenderTarget(arg1:
                                                               *mut root::GrContext,
                                                           arg2:
                                                               *const root::GrBackendTextureDesc,
                                                           arg3:
                                                               root::sk_sp<root::SkColorSpace>,
                                                           arg4:
                                                               *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeFromBackendTextureAsRenderTarget(arg1, arg2, arg3,
                                                           arg4)
        }
        #[inline]
        pub unsafe fn MakeRenderTarget(arg1: *mut root::GrContext,
                                       arg2: root::SkBudgeted,
                                       arg3: *const root::SkImageInfo,
                                       sampleCount: ::std::os::raw::c_int,
                                       arg4: root::GrSurfaceOrigin,
                                       arg5: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeRenderTarget(arg1, arg2, arg3, sampleCount, arg4,
                                       arg5)
        }
        #[inline]
        pub unsafe fn generationID(&mut self) -> u32 {
            SkSurface_generationID(&mut *self)
        }
        #[inline]
        pub unsafe fn notifyContentWillChange(&mut self,
                                              mode:
                                                  root::SkSurface_ContentChangeMode) {
            SkSurface_notifyContentWillChange(&mut *self, mode)
        }
        #[inline]
        pub unsafe fn getTextureHandle(&mut self,
                                       arg1:
                                           root::SkSurface_BackendHandleAccess)
         -> root::GrBackendObject {
            SkSurface_getTextureHandle(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn getRenderTargetHandle(&mut self,
                                            arg1: *mut root::GrBackendObject,
                                            arg2:
                                                root::SkSurface_BackendHandleAccess)
         -> bool {
            SkSurface_getRenderTargetHandle(&mut *self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn getCanvas(&mut self) -> *mut root::SkCanvas {
            SkSurface_getCanvas(&mut *self)
        }
        #[inline]
        pub unsafe fn makeSurface(&mut self, arg1: *const root::SkImageInfo)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_makeSurface(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn makeImageSnapshot(&mut self, arg1: root::SkBudgeted)
         -> root::sk_sp<root::SkImage> {
            SkSurface_makeImageSnapshot(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn makeImageSnapshot1(&mut self, arg1: root::SkBudgeted,
                                         arg2: root::SkSurface_ForceUnique)
         -> root::sk_sp<root::SkImage> {
            SkSurface_makeImageSnapshot1(&mut *self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn draw(&mut self, arg1: *mut root::SkCanvas,
                           x: root::SkScalar, y: root::SkScalar,
                           arg2: *const root::SkPaint) {
            SkSurface_draw(&mut *self, arg1, x, y, arg2)
        }
        #[inline]
        pub unsafe fn peekPixels(&mut self, arg1: *mut root::SkPixmap)
         -> bool {
            SkSurface_peekPixels(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn readPixels(&mut self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int) -> bool {
            SkSurface_readPixels(&mut *self, dstInfo, dstPixels, dstRowBytes,
                                 srcX, srcY)
        }
        #[inline]
        pub unsafe fn prepareForExternalIO(&mut self) {
            SkSurface_prepareForExternalIO(&mut *self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrContextThreadSafeProxy {
        pub _address: u8,
    }
    impl Clone for GrContextThreadSafeProxy {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrTexture {
        pub _address: u8,
    }
    impl Clone for GrTexture {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkDeque {
        pub fFront: *mut ::std::os::raw::c_void,
        pub fBack: *mut ::std::os::raw::c_void,
        pub fFrontBlock: *mut root::SkDeque_Block,
        pub fBackBlock: *mut root::SkDeque_Block,
        pub fElemSize: usize,
        pub fInitialStorage: *mut ::std::os::raw::c_void,
        pub fCount: ::std::os::raw::c_int,
        pub fAllocCount: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDeque_Block {
        pub _address: u8,
    }
    impl Clone for SkDeque_Block {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDeque_Iter {
        pub fCurBlock: *mut root::SkDeque_Block,
        pub fPos: *mut ::std::os::raw::c_char,
        pub fElemSize: usize,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkDeque_Iter_IterStart {
        kFront_IterStart = 0,
        kBack_IterStart = 1,
    }
    #[test]
    fn bindgen_test_layout_SkDeque_Iter() {
        assert_eq!(::std::mem::size_of::<SkDeque_Iter>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkDeque_Iter>() , 8usize);
    }
    extern "C" {
        #[link_name = "?next@Iter@SkDeque@@QEAAPEAXXZ"]
        pub fn SkDeque_Iter_next(this: *mut root::SkDeque_Iter)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?prev@Iter@SkDeque@@QEAAPEAXXZ"]
        pub fn SkDeque_Iter_prev(this: *mut root::SkDeque_Iter)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?reset@Iter@SkDeque@@QEAAXAEBV2@W4IterStart@12@@Z"]
        pub fn SkDeque_Iter_reset(this: *mut root::SkDeque_Iter,
                                  d: *const root::SkDeque,
                                  startLoc: root::SkDeque_Iter_IterStart);
    }
    impl Clone for SkDeque_Iter {
        fn clone(&self) -> Self { *self }
    }
    impl SkDeque_Iter {
        #[inline]
        pub unsafe fn next(&mut self) -> *mut ::std::os::raw::c_void {
            SkDeque_Iter_next(&mut *self)
        }
        #[inline]
        pub unsafe fn prev(&mut self) -> *mut ::std::os::raw::c_void {
            SkDeque_Iter_prev(&mut *self)
        }
        #[inline]
        pub unsafe fn reset(&mut self, d: *const root::SkDeque,
                            startLoc: root::SkDeque_Iter_IterStart) {
            SkDeque_Iter_reset(&mut *self, d, startLoc)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDeque_F2BIter {
        pub _base: root::SkDeque_Iter,
    }
    pub type SkDeque_F2BIter_INHERITED = root::SkDeque_Iter;
    #[test]
    fn bindgen_test_layout_SkDeque_F2BIter() {
        assert_eq!(::std::mem::size_of::<SkDeque_F2BIter>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkDeque_F2BIter>() , 8usize);
    }
    impl Clone for SkDeque_F2BIter {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_SkDeque() {
        assert_eq!(::std::mem::size_of::<SkDeque>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkDeque>() , 8usize);
    }
    extern "C" {
        /**
     * push_front and push_back return a pointer to the memory space
     * for the new element
     */
        #[link_name = "?push_front@SkDeque@@QEAAPEAXXZ"]
        pub fn SkDeque_push_front(this: *mut root::SkDeque)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?push_back@SkDeque@@QEAAPEAXXZ"]
        pub fn SkDeque_push_back(this: *mut root::SkDeque)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?pop_front@SkDeque@@QEAAXXZ"]
        pub fn SkDeque_pop_front(this: *mut root::SkDeque);
    }
    extern "C" {
        #[link_name = "?pop_back@SkDeque@@QEAAXXZ"]
        pub fn SkDeque_pop_back(this: *mut root::SkDeque);
    }
    impl SkDeque {
        #[inline]
        pub unsafe fn push_front(&mut self) -> *mut ::std::os::raw::c_void {
            SkDeque_push_front(&mut *self)
        }
        #[inline]
        pub unsafe fn push_back(&mut self) -> *mut ::std::os::raw::c_void {
            SkDeque_push_back(&mut *self)
        }
        #[inline]
        pub unsafe fn pop_front(&mut self) { SkDeque_pop_front(&mut *self) }
        #[inline]
        pub unsafe fn pop_back(&mut self) { SkDeque_pop_back(&mut *self) }
    }
    #[repr(i32)]
    /**
 *  Description of how the LCD strips are arranged for each pixel. If this is unknown, or the
 *  pixels are meant to be "portable" and/or transformed before showing (e.g. rotated, scaled)
 *  then use kUnknown_SkPixelGeometry.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPixelGeometry {
        kUnknown_SkPixelGeometry = 0,
        kRGB_H_SkPixelGeometry = 1,
        kBGR_H_SkPixelGeometry = 2,
        kRGB_V_SkPixelGeometry = 3,
        kBGR_V_SkPixelGeometry = 4,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrRenderTargetContext {
        pub _address: u8,
    }
    impl Clone for GrRenderTargetContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkBaseDevice {
        pub _address: u8,
    }
    impl Clone for SkBaseDevice {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct SkCanvasClipVisitor__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkCanvasClipVisitor {
        pub vtable_: *const SkCanvasClipVisitor__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkCanvasClipVisitor() {
        assert_eq!(::std::mem::size_of::<SkCanvasClipVisitor>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkCanvasClipVisitor>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkClipStack {
        pub _address: u8,
    }
    impl Clone for SkClipStack {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDrawable {
        pub _address: u8,
    }
    impl Clone for SkDrawable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMetaData {
        pub _address: u8,
    }
    impl Clone for SkMetaData {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRasterClip {
        pub _address: u8,
    }
    impl Clone for SkRasterClip {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRRect {
        pub _address: u8,
    }
    impl Clone for SkRRect {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkSurface_Base {
        pub _address: u8,
    }
    impl Clone for SkSurface_Base {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_17() {
        assert_eq!(::std::mem::size_of::<root::SkTSize<::std::os::raw::c_int>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::SkTSize<::std::os::raw::c_int>>()
                   , 4usize);
    }
    #[test]
    fn __bindgen_test_layout_template_18() {
        assert_eq!(::std::mem::size_of::<root::std::default_delete<root::SkCanvas>>()
                   , 1usize);
        assert_eq!(::std::mem::align_of::<root::std::default_delete<root::SkCanvas>>()
                   , 1usize);
    }
}
