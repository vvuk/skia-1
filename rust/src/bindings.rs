/* automatically generated by rust-bindgen */

pub use self::root::*;

pub mod root { use binding_helpers::{SkRefCntBase, sk_sp};
    #[allow(unused_imports)]
    use self::super::root;
    /// <div rustbindgen replaces="SkOnce"></div>
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkOnce {
        pub v: ::std::os::raw::c_uchar,
    }
    #[test]
    fn bindgen_test_layout_SkOnce() {
        assert_eq!(::std::mem::size_of::<SkOnce>() , 1usize);
        assert_eq!(::std::mem::align_of::<SkOnce>() , 1usize);
    }
    impl Clone for SkOnce {
        fn clone(&self) -> Self { *self }
    }
    /// <div rustbindgen replaces="sk_sp"></div>
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_sp_ignore_this_one<T> {
        pub ptr: *mut T,
        pub dummy: *mut ::std::os::raw::c_void,
    }
    pub type va_list = *mut ::std::os::raw::c_char;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod tr1 {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_delete<_Ty> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<_Ty>,
        }
        /// <div rustbindgen replaces="std::unique_ptr"></div>
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unique_ptr<T, D> {
            pub ptr: *mut T,
            pub _phantom_1: ::std::marker::PhantomData<D>,
        }
    }
    /** 32 bit integer to hold a unicode value
*/
    pub type SkUnichar = i32;
    pub type SkScalar = f32;
    /** \class SkString

    Light weight class for managing strings. Uses reference
    counting to make string assignments and copies very fast
    with no extra RAM cost. Assumes UTF8 encoding.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkString {
        pub fRec: *mut root::SkString_Rec,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkString_Rec {
        pub fLength: u32,
        pub fRefCnt: i32,
        pub fBeginningOfData: ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_SkString_Rec() {
        assert_eq!(::std::mem::size_of::<SkString_Rec>() , 12usize);
        assert_eq!(::std::mem::align_of::<SkString_Rec>() , 4usize);
    }
    impl Clone for SkString_Rec {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "?gEmptyRec@SkString@@0URec@1@B"]
        pub static SkString_gEmptyRec: root::SkString_Rec;
    }
    #[test]
    fn bindgen_test_layout_SkString() {
        assert_eq!(::std::mem::size_of::<SkString>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkString>() , 8usize);
    }
    extern "C" {
        #[link_name = "?equals@SkString@@QEBA_NAEBV1@@Z"]
        pub fn SkString_equals(this: *const root::SkString,
                               arg1: *const root::SkString) -> bool;
    }
    extern "C" {
        #[link_name = "?equals@SkString@@QEBA_NQEBD@Z"]
        pub fn SkString_equals1(this: *const root::SkString,
                                text: *const ::std::os::raw::c_char) -> bool;
    }
    extern "C" {
        #[link_name = "?equals@SkString@@QEBA_NQEBD_K@Z"]
        pub fn SkString_equals2(this: *const root::SkString,
                                text: *const ::std::os::raw::c_char,
                                len: usize) -> bool;
    }
    extern "C" {
        #[link_name = "?writable_str@SkString@@QEAAPEADXZ"]
        pub fn SkString_writable_str(this: *mut root::SkString)
         -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "?reset@SkString@@QEAAXXZ"]
        pub fn SkString_reset(this: *mut root::SkString);
    }
    extern "C" {
        #[link_name = "?set@SkString@@QEAAXQEBD@Z"]
        pub fn SkString_set(this: *mut root::SkString,
                            text: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?set@SkString@@QEAAXQEBD_K@Z"]
        pub fn SkString_set1(this: *mut root::SkString,
                             text: *const ::std::os::raw::c_char, len: usize);
    }
    extern "C" {
        #[link_name = "?setUTF16@SkString@@QEAAXQEBG@Z"]
        pub fn SkString_setUTF16(this: *mut root::SkString, arg1: *const u16);
    }
    extern "C" {
        #[link_name = "?setUTF16@SkString@@QEAAXQEBG_K@Z"]
        pub fn SkString_setUTF161(this: *mut root::SkString, arg1: *const u16,
                                  len: usize);
    }
    extern "C" {
        #[link_name = "?insert@SkString@@QEAAX_KQEBD@Z"]
        pub fn SkString_insert(this: *mut root::SkString, offset: usize,
                               text: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?insert@SkString@@QEAAX_KQEBD0@Z"]
        pub fn SkString_insert1(this: *mut root::SkString, offset: usize,
                                text: *const ::std::os::raw::c_char,
                                len: usize);
    }
    extern "C" {
        #[link_name = "?insertUnichar@SkString@@QEAAX_KH@Z"]
        pub fn SkString_insertUnichar(this: *mut root::SkString,
                                      offset: usize, arg1: root::SkUnichar);
    }
    extern "C" {
        #[link_name = "?insertS32@SkString@@QEAAX_KH@Z"]
        pub fn SkString_insertS32(this: *mut root::SkString, offset: usize,
                                  value: i32);
    }
    extern "C" {
        #[link_name = "?insertS64@SkString@@QEAAX_K_JH@Z"]
        pub fn SkString_insertS64(this: *mut root::SkString, offset: usize,
                                  value: i64,
                                  minDigits: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "?insertU32@SkString@@QEAAX_KI@Z"]
        pub fn SkString_insertU32(this: *mut root::SkString, offset: usize,
                                  value: u32);
    }
    extern "C" {
        #[link_name = "?insertU64@SkString@@QEAAX_K0H@Z"]
        pub fn SkString_insertU64(this: *mut root::SkString, offset: usize,
                                  value: u64,
                                  minDigits: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "?insertHex@SkString@@QEAAX_KIH@Z"]
        pub fn SkString_insertHex(this: *mut root::SkString, offset: usize,
                                  value: u32,
                                  minDigits: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "?insertScalar@SkString@@QEAAX_KM@Z"]
        pub fn SkString_insertScalar(this: *mut root::SkString, offset: usize,
                                     arg1: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?printf@SkString@@QEAAXQEBDZZ"]
        pub fn SkString_printf(this: *mut root::SkString,
                               format: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?appendf@SkString@@QEAAXQEBDZZ"]
        pub fn SkString_appendf(this: *mut root::SkString,
                                format: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?appendVAList@SkString@@QEAAXQEBDPEAD@Z"]
        pub fn SkString_appendVAList(this: *mut root::SkString,
                                     format: *const ::std::os::raw::c_char,
                                     arg1: root::va_list);
    }
    extern "C" {
        #[link_name = "?prependf@SkString@@QEAAXQEBDZZ"]
        pub fn SkString_prependf(this: *mut root::SkString,
                                 format: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?prependVAList@SkString@@QEAAXQEBDPEAD@Z"]
        pub fn SkString_prependVAList(this: *mut root::SkString,
                                      format: *const ::std::os::raw::c_char,
                                      arg1: root::va_list);
    }
    extern "C" {
        #[link_name = "?remove@SkString@@QEAAX_K0@Z"]
        pub fn SkString_remove(this: *mut root::SkString, offset: usize,
                               length: usize);
    }
    extern "C" {
        /**
     *  Swap contents between this and other. This function is guaranteed
     *  to never fail or throw.
     */
        #[link_name = "?swap@SkString@@QEAAXAEAV1@@Z"]
        pub fn SkString_swap(this: *mut root::SkString,
                             other: *mut root::SkString);
    }
    extern "C" {
        #[link_name = "??0SkString@@QEAA@XZ"]
        pub fn SkString_SkString(this: *mut root::SkString);
    }
    extern "C" {
        #[link_name = "??0SkString@@QEAA@_K@Z"]
        pub fn SkString_SkString1(this: *mut root::SkString, len: usize);
    }
    extern "C" {
        #[link_name = "??0SkString@@QEAA@QEBD@Z"]
        pub fn SkString_SkString2(this: *mut root::SkString,
                                  text: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "??0SkString@@QEAA@QEBD_K@Z"]
        pub fn SkString_SkString3(this: *mut root::SkString,
                                  text: *const ::std::os::raw::c_char,
                                  len: usize);
    }
    extern "C" {
        #[link_name = "??0SkString@@QEAA@AEBV0@@Z"]
        pub fn SkString_SkString4(this: *mut root::SkString,
                                  arg1: *const root::SkString);
    }
    extern "C" {
        #[link_name = "??0SkString@@QEAA@$$QEAV0@@Z"]
        pub fn SkString_SkString5(this: *mut root::SkString,
                                  arg1: *mut root::SkString);
    }
    impl SkString {
        #[inline]
        pub unsafe fn equals(&self, arg1: *const root::SkString) -> bool {
            SkString_equals(&*self, arg1)
        }
        #[inline]
        pub unsafe fn equals1(&self, text: *const ::std::os::raw::c_char)
         -> bool {
            SkString_equals1(&*self, text)
        }
        #[inline]
        pub unsafe fn equals2(&self, text: *const ::std::os::raw::c_char,
                              len: usize) -> bool {
            SkString_equals2(&*self, text, len)
        }
        #[inline]
        pub unsafe fn writable_str(&mut self) -> *mut ::std::os::raw::c_char {
            SkString_writable_str(&mut *self)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkString_reset(&mut *self) }
        #[inline]
        pub unsafe fn set(&mut self, text: *const ::std::os::raw::c_char) {
            SkString_set(&mut *self, text)
        }
        #[inline]
        pub unsafe fn set1(&mut self, text: *const ::std::os::raw::c_char,
                           len: usize) {
            SkString_set1(&mut *self, text, len)
        }
        #[inline]
        pub unsafe fn setUTF16(&mut self, arg1: *const u16) {
            SkString_setUTF16(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setUTF161(&mut self, arg1: *const u16, len: usize) {
            SkString_setUTF161(&mut *self, arg1, len)
        }
        #[inline]
        pub unsafe fn insert(&mut self, offset: usize,
                             text: *const ::std::os::raw::c_char) {
            SkString_insert(&mut *self, offset, text)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, offset: usize,
                              text: *const ::std::os::raw::c_char,
                              len: usize) {
            SkString_insert1(&mut *self, offset, text, len)
        }
        #[inline]
        pub unsafe fn insertUnichar(&mut self, offset: usize,
                                    arg1: root::SkUnichar) {
            SkString_insertUnichar(&mut *self, offset, arg1)
        }
        #[inline]
        pub unsafe fn insertS32(&mut self, offset: usize, value: i32) {
            SkString_insertS32(&mut *self, offset, value)
        }
        #[inline]
        pub unsafe fn insertS64(&mut self, offset: usize, value: i64,
                                minDigits: ::std::os::raw::c_int) {
            SkString_insertS64(&mut *self, offset, value, minDigits)
        }
        #[inline]
        pub unsafe fn insertU32(&mut self, offset: usize, value: u32) {
            SkString_insertU32(&mut *self, offset, value)
        }
        #[inline]
        pub unsafe fn insertU64(&mut self, offset: usize, value: u64,
                                minDigits: ::std::os::raw::c_int) {
            SkString_insertU64(&mut *self, offset, value, minDigits)
        }
        #[inline]
        pub unsafe fn insertHex(&mut self, offset: usize, value: u32,
                                minDigits: ::std::os::raw::c_int) {
            SkString_insertHex(&mut *self, offset, value, minDigits)
        }
        #[inline]
        pub unsafe fn insertScalar(&mut self, offset: usize,
                                   arg1: root::SkScalar) {
            SkString_insertScalar(&mut *self, offset, arg1)
        }
        #[inline]
        pub unsafe fn printf(&mut self,
                             format: *const ::std::os::raw::c_char) {
            SkString_printf(&mut *self, format)
        }
        #[inline]
        pub unsafe fn appendf(&mut self,
                              format: *const ::std::os::raw::c_char) {
            SkString_appendf(&mut *self, format)
        }
        #[inline]
        pub unsafe fn appendVAList(&mut self,
                                   format: *const ::std::os::raw::c_char,
                                   arg1: root::va_list) {
            SkString_appendVAList(&mut *self, format, arg1)
        }
        #[inline]
        pub unsafe fn prependf(&mut self,
                               format: *const ::std::os::raw::c_char) {
            SkString_prependf(&mut *self, format)
        }
        #[inline]
        pub unsafe fn prependVAList(&mut self,
                                    format: *const ::std::os::raw::c_char,
                                    arg1: root::va_list) {
            SkString_prependVAList(&mut *self, format, arg1)
        }
        #[inline]
        pub unsafe fn remove(&mut self, offset: usize, length: usize) {
            SkString_remove(&mut *self, offset, length)
        }
        #[inline]
        pub unsafe fn swap(&mut self, other: *mut root::SkString) {
            SkString_swap(&mut *self, other)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkString_SkString(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(len: usize) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkString_SkString1(&mut __bindgen_tmp, len);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(text: *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkString_SkString2(&mut __bindgen_tmp, text);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(text: *const ::std::os::raw::c_char, len: usize)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkString_SkString3(&mut __bindgen_tmp, text, len);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(arg1: *const root::SkString) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkString_SkString4(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(arg1: *mut root::SkString) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkString_SkString5(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    /**
 *  Fast type for unsigned 8 bits. Use for parameter passing and local
 *  variables, not for storage
 */
    pub type U8CPU = ::std::os::raw::c_uint;
    /**
 *  Fast type for unsigned 16 bits. Use for parameter passing and local
 *  variables, not for storage
 */
    pub type U16CPU = ::std::os::raw::c_uint;
    /**
 *  Meant to be a small version of bool, for storage purposes. Will be 0 or 1
 */
    pub type SkBool8 = u8;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct _iobuf {
        pub _Placeholder: *mut ::std::os::raw::c_void,
    }
    impl Clone for _iobuf {
        fn clone(&self) -> Self { *self }
    }
    pub type FILE = root::_iobuf;
    pub mod sktfitsin {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    /** 16 bit unsigned integer to hold a glyph index
*/
    pub type SkGlyphID = u16;
    #[repr(u8)]
    /**
 *  Indicates whether an allocation should count against a cache budget.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkBudgeted { kNo = 0, kYes = 1, }
    /** \class SkNoncopyable

SkNoncopyable is the base class for objects that do not want to
be copied. It hides its copy-constructor and its assignment-operator.
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkNoncopyable {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_SkNoncopyable() {
        assert_eq!(::std::mem::size_of::<SkNoncopyable>() , 1usize);
        assert_eq!(::std::mem::align_of::<SkNoncopyable>() , 1usize);
    }
    impl Clone for SkNoncopyable {
        fn clone(&self) -> Self { *self }
    }
    pub const SkFilterQuality_kLast_SkFilterQuality: root::SkFilterQuality =
        SkFilterQuality::kHigh_SkFilterQuality;
    #[repr(i32)]
    /**
 *  Controls how much filtering to be done when scaling/transforming complex colors
 *  e.g. images
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkFilterQuality {
        kNone_SkFilterQuality = 0,
        kLow_SkFilterQuality = 1,
        kMedium_SkFilterQuality = 2,
        kHigh_SkFilterQuality = 3,
    }
    /** \struct SkIPoint16

    SkIPoint holds two 16 bit integer coordinates
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkIPoint16 {
        pub fX: i16,
        pub fY: i16,
    }
    #[test]
    fn bindgen_test_layout_SkIPoint16() {
        assert_eq!(::std::mem::size_of::<SkIPoint16>() , 4usize);
        assert_eq!(::std::mem::align_of::<SkIPoint16>() , 2usize);
    }
    impl Clone for SkIPoint16 {
        fn clone(&self) -> Self { *self }
    }
    /** \struct SkIPoint

    SkIPoint holds two 32 bit integer coordinates
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkIPoint {
        pub fX: i32,
        pub fY: i32,
    }
    #[test]
    fn bindgen_test_layout_SkIPoint() {
        assert_eq!(::std::mem::size_of::<SkIPoint>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkIPoint>() , 4usize);
    }
    extern "C" {
        /** Rotate the point clockwise, writing the new point into dst
        It is legal for dst == this
    */
        #[link_name = "?rotateCW@SkIPoint@@QEBAXPEAU1@@Z"]
        pub fn SkIPoint_rotateCW(this: *const root::SkIPoint,
                                 dst: *mut root::SkIPoint);
    }
    extern "C" {
        /** Rotate the point counter-clockwise, writing the new point into dst.
        It is legal for dst == this
    */
        #[link_name = "?rotateCCW@SkIPoint@@QEBAXPEAU1@@Z"]
        pub fn SkIPoint_rotateCCW(this: *const root::SkIPoint,
                                  dst: *mut root::SkIPoint);
    }
    impl Clone for SkIPoint {
        fn clone(&self) -> Self { *self }
    }
    impl SkIPoint {
        #[inline]
        pub unsafe fn rotateCW(&self, dst: *mut root::SkIPoint) {
            SkIPoint_rotateCW(&*self, dst)
        }
        #[inline]
        pub unsafe fn rotateCCW(&self, dst: *mut root::SkIPoint) {
            SkIPoint_rotateCCW(&*self, dst)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPoint {
        pub fX: root::SkScalar,
        pub fY: root::SkScalar,
    }
    #[repr(i32)]
    /**
     * The side of a point relative to a line. If the line is from a to b then
     * the values are consistent with the sign of (b-a) cross (pt-a)
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPoint_Side { kLeft_Side = -1, kOn_Side = 0, kRight_Side = 1, }
    #[test]
    fn bindgen_test_layout_SkPoint() {
        assert_eq!(::std::mem::size_of::<SkPoint>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkPoint>() , 4usize);
    }
    extern "C" {
        #[link_name = "?setIRectFan@SkPoint@@QEAAXHHHH_K@Z"]
        pub fn SkPoint_setIRectFan(this: *mut root::SkPoint,
                                   l: ::std::os::raw::c_int,
                                   t: ::std::os::raw::c_int,
                                   r: ::std::os::raw::c_int,
                                   b: ::std::os::raw::c_int, stride: usize);
    }
    extern "C" {
        /** Set the point (vector) to be unit-length in the same direction as it
        already points.  If the point has a degenerate length (i.e. nearly 0)
        then set it to (0,0) and return false; otherwise return true.
    */
        #[link_name = "?normalize@SkPoint@@QEAA_NXZ"]
        pub fn SkPoint_normalize(this: *mut root::SkPoint) -> bool;
    }
    extern "C" {
        /** Set the point (vector) to be unit-length in the same direction as the
        x,y params. If the vector (x,y) has a degenerate length (i.e. nearly 0)
        then set it to (0,0) and return false, otherwise return true.
    */
        #[link_name = "?setNormalize@SkPoint@@QEAA_NMM@Z"]
        pub fn SkPoint_setNormalize(this: *mut root::SkPoint,
                                    x: root::SkScalar, y: root::SkScalar)
         -> bool;
    }
    extern "C" {
        /** Scale the point (vector) to have the specified length, and return that
        length. If the original length is degenerately small (nearly zero),
        set it to (0,0) and return false, otherwise return true.
    */
        #[link_name = "?setLength@SkPoint@@QEAA_NM@Z"]
        pub fn SkPoint_setLength(this: *mut root::SkPoint,
                                 length: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Set the point (vector) to have the specified length in the same
     direction as (x,y). If the vector (x,y) has a degenerate length
     (i.e. nearly 0) then set it to (0,0) and return false, otherwise return true.
    */
        #[link_name = "?setLength@SkPoint@@QEAA_NMMM@Z"]
        pub fn SkPoint_setLength1(this: *mut root::SkPoint, x: root::SkScalar,
                                  y: root::SkScalar, length: root::SkScalar)
         -> bool;
    }
    extern "C" {
        /** Same as setLength, but favoring speed over accuracy.
    */
        #[link_name = "?setLengthFast@SkPoint@@QEAA_NM@Z"]
        pub fn SkPoint_setLengthFast(this: *mut root::SkPoint,
                                     length: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Same as setLength, but favoring speed over accuracy.
    */
        #[link_name = "?setLengthFast@SkPoint@@QEAA_NMMM@Z"]
        pub fn SkPoint_setLengthFast1(this: *mut root::SkPoint,
                                      x: root::SkScalar, y: root::SkScalar,
                                      length: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Scale the point's coordinates by scale, writing the answer into dst.
        It is legal for dst == this.
    */
        #[link_name = "?scale@SkPoint@@QEBAXMPEAU1@@Z"]
        pub fn SkPoint_scale(this: *const root::SkPoint,
                             scale: root::SkScalar, dst: *mut root::SkPoint);
    }
    extern "C" {
        /** Rotate the point clockwise by 90 degrees, writing the answer into dst.
        It is legal for dst == this.
    */
        #[link_name = "?rotateCW@SkPoint@@QEBAXPEAU1@@Z"]
        pub fn SkPoint_rotateCW(this: *const root::SkPoint,
                                dst: *mut root::SkPoint);
    }
    extern "C" {
        /** Rotate the point counter-clockwise by 90 degrees, writing the answer
        into dst. It is legal for dst == this.
    */
        #[link_name = "?rotateCCW@SkPoint@@QEBAXPEAU1@@Z"]
        pub fn SkPoint_rotateCCW(this: *const root::SkPoint,
                                 dst: *mut root::SkPoint);
    }
    extern "C" {
        /** Returns the euclidian distance from (0,0) to (x,y)
    */
        #[link_name = "?Length@SkPoint@@SAMMM@Z"]
        pub fn SkPoint_Length(x: root::SkScalar, y: root::SkScalar)
         -> root::SkScalar;
    }
    extern "C" {
        /** Normalize pt, returning its previous length. If the prev length is too
        small (degenerate), set pt to (0,0) and return 0. This uses the same
        tolerance as CanNormalize.

        Note that this method may be significantly more expensive than
        the non-static normalize(), because it has to return the previous length
        of the point.  If you don't need the previous length, call the
        non-static normalize() method instead.
     */
        #[link_name = "?Normalize@SkPoint@@SAMPEAU1@@Z"]
        pub fn SkPoint_Normalize(pt: *mut root::SkPoint) -> root::SkScalar;
    }
    extern "C" {
        /**
     * Returns the squared distance to the infinite line between two pts. Also
     * optionally returns the side of the line that the pt falls on (looking
     * along line from a to b)
     */
        #[link_name =
              "?distanceToLineBetweenSqd@SkPoint@@QEBAMAEBU1@0PEAW4Side@1@@Z"]
        pub fn SkPoint_distanceToLineBetweenSqd(this: *const root::SkPoint,
                                                a: *const root::SkPoint,
                                                b: *const root::SkPoint,
                                                side: *mut root::SkPoint_Side)
         -> root::SkScalar;
    }
    extern "C" {
        /**
     * Returns the squared distance to the line segment between pts a and b
     */
        #[link_name =
              "?distanceToLineSegmentBetweenSqd@SkPoint@@QEBAMAEBU1@0@Z"]
        pub fn SkPoint_distanceToLineSegmentBetweenSqd(this:
                                                           *const root::SkPoint,
                                                       a:
                                                           *const root::SkPoint,
                                                       b:
                                                           *const root::SkPoint)
         -> root::SkScalar;
    }
    impl Clone for SkPoint {
        fn clone(&self) -> Self { *self }
    }
    impl SkPoint {
        #[inline]
        pub unsafe fn setIRectFan(&mut self, l: ::std::os::raw::c_int,
                                  t: ::std::os::raw::c_int,
                                  r: ::std::os::raw::c_int,
                                  b: ::std::os::raw::c_int, stride: usize) {
            SkPoint_setIRectFan(&mut *self, l, t, r, b, stride)
        }
        #[inline]
        pub unsafe fn normalize(&mut self) -> bool {
            SkPoint_normalize(&mut *self)
        }
        #[inline]
        pub unsafe fn setNormalize(&mut self, x: root::SkScalar,
                                   y: root::SkScalar) -> bool {
            SkPoint_setNormalize(&mut *self, x, y)
        }
        #[inline]
        pub unsafe fn setLength(&mut self, length: root::SkScalar) -> bool {
            SkPoint_setLength(&mut *self, length)
        }
        #[inline]
        pub unsafe fn setLength1(&mut self, x: root::SkScalar,
                                 y: root::SkScalar, length: root::SkScalar)
         -> bool {
            SkPoint_setLength1(&mut *self, x, y, length)
        }
        #[inline]
        pub unsafe fn setLengthFast(&mut self, length: root::SkScalar)
         -> bool {
            SkPoint_setLengthFast(&mut *self, length)
        }
        #[inline]
        pub unsafe fn setLengthFast1(&mut self, x: root::SkScalar,
                                     y: root::SkScalar,
                                     length: root::SkScalar) -> bool {
            SkPoint_setLengthFast1(&mut *self, x, y, length)
        }
        #[inline]
        pub unsafe fn scale(&self, scale: root::SkScalar,
                            dst: *mut root::SkPoint) {
            SkPoint_scale(&*self, scale, dst)
        }
        #[inline]
        pub unsafe fn rotateCW(&self, dst: *mut root::SkPoint) {
            SkPoint_rotateCW(&*self, dst)
        }
        #[inline]
        pub unsafe fn rotateCCW(&self, dst: *mut root::SkPoint) {
            SkPoint_rotateCCW(&*self, dst)
        }
        #[inline]
        pub unsafe fn Length(x: root::SkScalar, y: root::SkScalar)
         -> root::SkScalar {
            SkPoint_Length(x, y)
        }
        #[inline]
        pub unsafe fn Normalize(pt: *mut root::SkPoint) -> root::SkScalar {
            SkPoint_Normalize(pt)
        }
        #[inline]
        pub unsafe fn distanceToLineBetweenSqd(&self, a: *const root::SkPoint,
                                               b: *const root::SkPoint,
                                               side: *mut root::SkPoint_Side)
         -> root::SkScalar {
            SkPoint_distanceToLineBetweenSqd(&*self, a, b, side)
        }
        #[inline]
        pub unsafe fn distanceToLineSegmentBetweenSqd(&self,
                                                      a: *const root::SkPoint,
                                                      b: *const root::SkPoint)
         -> root::SkScalar {
            SkPoint_distanceToLineSegmentBetweenSqd(&*self, a, b)
        }
    }
    pub type SkVector = root::SkPoint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct SkTSize<T> {
        pub fWidth: T,
        pub fHeight: T,
    }
    ///////////////////////////////////////////////////////////////////////////////
    pub type SkISize = root::SkTSize<::std::os::raw::c_int>;
    #[test]
    fn __bindgen_test_layout_template_1() {
        assert_eq!(::std::mem::size_of::<root::SkTSize<f32>>() , 8usize);
        assert_eq!(::std::mem::align_of::<root::SkTSize<f32>>() , 4usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkSize {
        pub _base: root::SkTSize<f32>,
    }
    #[test]
    fn bindgen_test_layout_SkSize() {
        assert_eq!(::std::mem::size_of::<SkSize>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkSize>() , 4usize);
    }
    impl Clone for SkSize {
        fn clone(&self) -> Self { *self }
    }
    /** \struct SkRect
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRect {
        pub fLeft: root::SkScalar,
        pub fTop: root::SkScalar,
        pub fRight: root::SkScalar,
        pub fBottom: root::SkScalar,
    }
    #[test]
    fn bindgen_test_layout_SkRect() {
        assert_eq!(::std::mem::size_of::<SkRect>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkRect>() , 4usize);
    }
    extern "C" {
        /** return the 4 points that enclose the rectangle (top-left, top-right, bottom-right,
        bottom-left). TODO: Consider adding param to control whether quad is CW or CCW.
     */
        #[link_name = "?toQuad@SkRect@@QEBAXQEAUSkPoint@@@Z"]
        pub fn SkRect_toQuad(this: *const root::SkRect,
                             quad: *mut root::SkPoint);
    }
    extern "C" {
        /**
     *  Compute the bounds of the array of points, and set this rect to that
     *  bounds and return true... unless a non-finite value is encountered,
     *  in which case this rect is set to empty and false is returned.
     */
        #[link_name = "?setBoundsCheck@SkRect@@QEAA_NQEBUSkPoint@@H@Z"]
        pub fn SkRect_setBoundsCheck(this: *mut root::SkRect,
                                     pts: *const root::SkPoint,
                                     count: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** If this rectangle intersects r, return true and set this rectangle to that
        intersection, otherwise return false and do not change this rectangle.
        If either rectangle is empty, do nothing and return false.
    */
        #[link_name = "?intersect@SkRect@@QEAA_NAEBU1@@Z"]
        pub fn SkRect_intersect(this: *mut root::SkRect,
                                r: *const root::SkRect) -> bool;
    }
    extern "C" {
        /** If this rectangle intersects the rectangle specified by left, top, right, bottom,
        return true and set this rectangle to that intersection, otherwise return false
        and do not change this rectangle.
        If either rectangle is empty, do nothing and return false.
    */
        #[link_name = "?intersect@SkRect@@QEAA_NMMMM@Z"]
        pub fn SkRect_intersect1(this: *mut root::SkRect,
                                 left: root::SkScalar, top: root::SkScalar,
                                 right: root::SkScalar,
                                 bottom: root::SkScalar) -> bool;
    }
    extern "C" {
        /**
     *  If rectangles a and b intersect, return true and set this rectangle to
     *  that intersection, otherwise return false and do not change this
     *  rectangle. If either rectangle is empty, do nothing and return false.
     */
        #[link_name = "?intersect@SkRect@@QEAA_NAEBU1@0@Z"]
        pub fn SkRect_intersect2(this: *mut root::SkRect,
                                 a: *const root::SkRect,
                                 b: *const root::SkRect) -> bool;
    }
    extern "C" {
        /**
     *  Update this rectangle to enclose itself and the specified rectangle.
     *  If this rectangle is empty, just set it to the specified rectangle.
     *  If the specified rectangle is empty, do nothing.
     */
        #[link_name = "?join@SkRect@@QEAAXMMMM@Z"]
        pub fn SkRect_join(this: *mut root::SkRect, left: root::SkScalar,
                           top: root::SkScalar, right: root::SkScalar,
                           bottom: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?dump@SkRect@@QEBAX_N@Z"]
        pub fn SkRect_dump(this: *const root::SkRect, asHex: bool);
    }
    impl Clone for SkRect {
        fn clone(&self) -> Self { *self }
    }
    impl SkRect {
        #[inline]
        pub unsafe fn toQuad(&self, quad: *mut root::SkPoint) {
            SkRect_toQuad(&*self, quad)
        }
        #[inline]
        pub unsafe fn setBoundsCheck(&mut self, pts: *const root::SkPoint,
                                     count: ::std::os::raw::c_int) -> bool {
            SkRect_setBoundsCheck(&mut *self, pts, count)
        }
        #[inline]
        pub unsafe fn intersect(&mut self, r: *const root::SkRect) -> bool {
            SkRect_intersect(&mut *self, r)
        }
        #[inline]
        pub unsafe fn intersect1(&mut self, left: root::SkScalar,
                                 top: root::SkScalar, right: root::SkScalar,
                                 bottom: root::SkScalar) -> bool {
            SkRect_intersect1(&mut *self, left, top, right, bottom)
        }
        #[inline]
        pub unsafe fn intersect2(&mut self, a: *const root::SkRect,
                                 b: *const root::SkRect) -> bool {
            SkRect_intersect2(&mut *self, a, b)
        }
        #[inline]
        pub unsafe fn join(&mut self, left: root::SkScalar,
                           top: root::SkScalar, right: root::SkScalar,
                           bottom: root::SkScalar) {
            SkRect_join(&mut *self, left, top, right, bottom)
        }
        #[inline]
        pub unsafe fn dump(&self, asHex: bool) { SkRect_dump(&*self, asHex) }
    }
    /** \struct SkIRect

    SkIRect holds four 32 bit integer coordinates for a rectangle
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkIRect {
        pub fLeft: i32,
        pub fTop: i32,
        pub fRight: i32,
        pub fBottom: i32,
    }
    #[test]
    fn bindgen_test_layout_SkIRect() {
        assert_eq!(::std::mem::size_of::<SkIRect>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkIRect>() , 4usize);
    }
    extern "C" {
        /** Returns true if the specified rectangle r is inside or equal to this rectangle.
    */
        #[link_name = "?contains@SkIRect@@QEBA_NAEBUSkRect@@@Z"]
        pub fn SkIRect_contains(this: *const root::SkIRect,
                                r: *const root::SkRect) -> bool;
    }
    extern "C" {
        /** Update this rectangle to enclose itself and the specified rectangle.
        If this rectangle is empty, just set it to the specified rectangle. If the specified
        rectangle is empty, do nothing.
    */
        #[link_name = "?join@SkIRect@@QEAAXHHHH@Z"]
        pub fn SkIRect_join(this: *mut root::SkIRect, left: i32, top: i32,
                            right: i32, bottom: i32);
    }
    extern "C" {
        /** Swap top/bottom or left/right if there are flipped.
        This can be called if the edges are computed separately,
        and may have crossed over each other.
        When this returns, left <= right && top <= bottom
    */
        #[link_name = "?sort@SkIRect@@QEAAXXZ"]
        pub fn SkIRect_sort(this: *mut root::SkIRect);
    }
    impl Clone for SkIRect {
        fn clone(&self) -> Self { *self }
    }
    impl SkIRect {
        #[inline]
        pub unsafe fn contains(&self, r: *const root::SkRect) -> bool {
            SkIRect_contains(&*self, r)
        }
        #[inline]
        pub unsafe fn join(&mut self, left: i32, top: i32, right: i32,
                           bottom: i32) {
            SkIRect_join(&mut *self, left, top, right, bottom)
        }
        #[inline]
        pub unsafe fn sort(&mut self) { SkIRect_sort(&mut *self) }
    }
    /**
 *  A compressed form of a rotation+scale matrix.
 *
 *  [ fSCos     -fSSin    fTx ]
 *  [ fSSin      fSCos    fTy ]
 *  [     0          0      1 ]
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRSXform {
        pub fSCos: root::SkScalar,
        pub fSSin: root::SkScalar,
        pub fTx: root::SkScalar,
        pub fTy: root::SkScalar,
    }
    #[test]
    fn bindgen_test_layout_SkRSXform() {
        assert_eq!(::std::mem::size_of::<SkRSXform>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkRSXform>() , 4usize);
    }
    extern "C" {
        #[link_name = "?toQuad@SkRSXform@@QEBAXMMQEAUSkPoint@@@Z"]
        pub fn SkRSXform_toQuad(this: *const root::SkRSXform,
                                width: root::SkScalar, height: root::SkScalar,
                                quad: *mut root::SkPoint);
    }
    impl Clone for SkRSXform {
        fn clone(&self) -> Self { *self }
    }
    impl SkRSXform {
        #[inline]
        pub unsafe fn toQuad(&self, width: root::SkScalar,
                             height: root::SkScalar,
                             quad: *mut root::SkPoint) {
            SkRSXform_toQuad(&*self, width, height, quad)
        }
    }
    /** \class SkMatrix

    The SkMatrix class holds a 3x3 matrix for transforming coordinates.
    SkMatrix does not have a constructor, so it must be explicitly initialized
    using either reset() - to construct an identity matrix, or one of the set
    functions (e.g. setTranslate, setRotate, etc.).
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMatrix {
        pub fMat: [root::SkScalar; 9usize],
        pub fTypeMask: u32,
    }
    #[repr(i32)]
    /** Enum of bit fields for the mask return by getType().
        Use this to identify the complexity of the matrix.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix_TypeMask {
        kIdentity_Mask = 0,
        kTranslate_Mask = 1,
        kScale_Mask = 2,
        kAffine_Mask = 4,
        kPerspective_Mask = 8,
    }
    pub const SkMatrix_kMScaleX: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMScaleX;
    pub const SkMatrix_kMSkewX: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMSkewX;
    pub const SkMatrix_kMTransX: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMTransX;
    pub const SkMatrix_kMSkewY: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMSkewY;
    pub const SkMatrix_kMScaleY: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMScaleY;
    pub const SkMatrix_kMTransY: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMTransY;
    pub const SkMatrix_kMPersp0: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMPersp0;
    pub const SkMatrix_kMPersp1: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMPersp1;
    pub const SkMatrix_kMPersp2: root::SkMatrix__bindgen_ty_1 =
        SkMatrix__bindgen_ty_1::kMPersp2;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix__bindgen_ty_1 {
        kMScaleX = 0,
        kMSkewX = 1,
        kMTransX = 2,
        kMSkewY = 3,
        kMScaleY = 4,
        kMTransY = 5,
        kMPersp0 = 6,
        kMPersp1 = 7,
        kMPersp2 = 8,
    }
    pub const SkMatrix_kAScaleX: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kAScaleX;
    pub const SkMatrix_kASkewY: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kASkewY;
    pub const SkMatrix_kASkewX: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kASkewX;
    pub const SkMatrix_kAScaleY: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kAScaleY;
    pub const SkMatrix_kATransX: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kATransX;
    pub const SkMatrix_kATransY: root::SkMatrix__bindgen_ty_2 =
        SkMatrix__bindgen_ty_2::kATransY;
    #[repr(i32)]
    /** Affine arrays are in column major order
        because that's how PDF and XPS like it.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix__bindgen_ty_2 {
        kAScaleX = 0,
        kASkewY = 1,
        kASkewX = 2,
        kAScaleY = 3,
        kATransX = 4,
        kATransY = 5,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix_ScaleToFit {
        kFill_ScaleToFit = 0,
        kStart_ScaleToFit = 1,
        kCenter_ScaleToFit = 2,
        kEnd_ScaleToFit = 3,
    }
    pub type SkMatrix_MapXYProc =
        ::std::option::Option<unsafe extern "C" fn(mat: *const root::SkMatrix,
                                                   x: root::SkScalar,
                                                   y: root::SkScalar,
                                                   result:
                                                       *mut root::SkPoint)>;
    pub type SkMatrix_MapPtsProc =
        ::std::option::Option<unsafe extern "C" fn(mat: *const root::SkMatrix,
                                                   dst: *mut root::SkPoint,
                                                   src: *const root::SkPoint,
                                                   count:
                                                       ::std::os::raw::c_int)>;
    pub const SkMatrix_kMaxFlattenSize: root::SkMatrix__bindgen_ty_3 =
        SkMatrix__bindgen_ty_3::kMaxFlattenSize;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix__bindgen_ty_3 { kMaxFlattenSize = 40, }
    pub const SkMatrix_kRectStaysRect_Mask: root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kRectStaysRect_Mask;
    pub const SkMatrix_kOnlyPerspectiveValid_Mask:
              root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kOnlyPerspectiveValid_Mask;
    pub const SkMatrix_kUnknown_Mask: root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kUnknown_Mask;
    pub const SkMatrix_kORableMasks: root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kORableMasks;
    pub const SkMatrix_kAllMasks: root::SkMatrix__bindgen_ty_4 =
        SkMatrix__bindgen_ty_4::kAllMasks;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix__bindgen_ty_4 {
        kRectStaysRect_Mask = 16,
        kOnlyPerspectiveValid_Mask = 64,
        kUnknown_Mask = 128,
        kORableMasks = 15,
        kAllMasks = 31,
    }
    extern "C" {
        #[link_name =
              "?gMapXYProcs@SkMatrix@@0QBQ6AXAEBV1@MMPEAUSkPoint@@@ZB"]
        pub static mut SkMatrix_gMapXYProcs: *const root::SkMatrix_MapXYProc;
    }
    extern "C" {
        #[link_name =
              "?gMapPtsProcs@SkMatrix@@0QBQ6AXAEBV1@QEAUSkPoint@@QEBU2@H@ZB"]
        pub static mut SkMatrix_gMapPtsProcs:
                   *const root::SkMatrix_MapPtsProc;
    }
    #[test]
    fn bindgen_test_layout_SkMatrix() {
        assert_eq!(::std::mem::size_of::<SkMatrix>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkMatrix>() , 4usize);
    }
    extern "C" {
        /** Returns true if the matrix contains only translation, rotation/reflection or uniform scale
        Returns false if other transformation types are included or is degenerate
     */
        #[link_name = "?isSimilarity@SkMatrix@@QEBA_NM@Z"]
        pub fn SkMatrix_isSimilarity(this: *const root::SkMatrix,
                                     tol: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Returns true if the matrix contains only translation, rotation/reflection or scale
        (non-uniform scale is allowed).
        Returns false if other transformation types are included or is degenerate
     */
        #[link_name = "?preservesRightAngles@SkMatrix@@QEBA_NM@Z"]
        pub fn SkMatrix_preservesRightAngles(this: *const root::SkMatrix,
                                             tol: root::SkScalar) -> bool;
    }
    extern "C" {
        /**
     *  Set this matrix to the 9 scalars from the buffer, in the same order as the kMScaleX
     *  enum... scalex, skewx, transx, skewy, scaley, transy, persp0, persp1, persp2
     *
     *  Note: calling set9 followed by get9 may not return the exact same values. Since the matrix
     *  is used to map non-homogeneous coordinates, it is free to rescale the 9 values as needed.
     */
        #[link_name = "?set9@SkMatrix@@QEAAXQEBM@Z"]
        pub fn SkMatrix_set9(this: *mut root::SkMatrix,
                             buffer: *mut root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to identity
    */
        #[link_name = "?reset@SkMatrix@@QEAAXXZ"]
        pub fn SkMatrix_reset(this: *mut root::SkMatrix);
    }
    extern "C" {
        /** Set the matrix to translate by (dx, dy).
    */
        #[link_name = "?setTranslate@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_setTranslate(this: *mut root::SkMatrix,
                                     dx: root::SkScalar, dy: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to scale by sx and sy, with a pivot point at (px, py).
        The pivot point is the coordinate that should remain unchanged by the
        specified transformation.
    */
        #[link_name = "?setScale@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_setScale(this: *mut root::SkMatrix,
                                 sx: root::SkScalar, sy: root::SkScalar,
                                 px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to scale by sx and sy.
    */
        #[link_name = "?setScale@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_setScale1(this: *mut root::SkMatrix,
                                  sx: root::SkScalar, sy: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to scale by 1/divx and 1/divy. Returns false and doesn't
        touch the matrix if either divx or divy is zero.
    */
        #[link_name = "?setIDiv@SkMatrix@@QEAA_NHH@Z"]
        pub fn SkMatrix_setIDiv(this: *mut root::SkMatrix,
                                divx: ::std::os::raw::c_int,
                                divy: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** Set the matrix to rotate by the specified number of degrees, with a
        pivot point at (px, py). The pivot point is the coordinate that should
        remain unchanged by the specified transformation.
    */
        #[link_name = "?setRotate@SkMatrix@@QEAAXMMM@Z"]
        pub fn SkMatrix_setRotate(this: *mut root::SkMatrix,
                                  degrees: root::SkScalar, px: root::SkScalar,
                                  py: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to rotate about (0,0) by the specified number of degrees.
    */
        #[link_name = "?setRotate@SkMatrix@@QEAAXM@Z"]
        pub fn SkMatrix_setRotate1(this: *mut root::SkMatrix,
                                   degrees: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to rotate by the specified sine and cosine values, with
        a pivot point at (px, py). The pivot point is the coordinate that
        should remain unchanged by the specified transformation.
    */
        #[link_name = "?setSinCos@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_setSinCos(this: *mut root::SkMatrix,
                                  sinValue: root::SkScalar,
                                  cosValue: root::SkScalar,
                                  px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to rotate by the specified sine and cosine values.
    */
        #[link_name = "?setSinCos@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_setSinCos1(this: *mut root::SkMatrix,
                                   sinValue: root::SkScalar,
                                   cosValue: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?setRSXform@SkMatrix@@QEAAAEAV1@AEBUSkRSXform@@@Z"]
        pub fn SkMatrix_setRSXform(this: *mut root::SkMatrix,
                                   arg1: *const root::SkRSXform)
         -> *mut root::SkMatrix;
    }
    extern "C" {
        /** Set the matrix to skew by sx and sy, with a pivot point at (px, py).
        The pivot point is the coordinate that should remain unchanged by the
        specified transformation.
    */
        #[link_name = "?setSkew@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_setSkew(this: *mut root::SkMatrix, kx: root::SkScalar,
                                ky: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to skew by sx and sy.
    */
        #[link_name = "?setSkew@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_setSkew1(this: *mut root::SkMatrix,
                                 kx: root::SkScalar, ky: root::SkScalar);
    }
    extern "C" {
        /** Set the matrix to the concatenation of the two specified matrices.
        Either of the two matrices may also be the target matrix.
        *this = a * b;
    */
        #[link_name = "?setConcat@SkMatrix@@QEAAXAEBV1@0@Z"]
        pub fn SkMatrix_setConcat(this: *mut root::SkMatrix,
                                  a: *const root::SkMatrix,
                                  b: *const root::SkMatrix);
    }
    extern "C" {
        /** Preconcats the matrix with the specified translation.
        M' = M * T(dx, dy)
    */
        #[link_name = "?preTranslate@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_preTranslate(this: *mut root::SkMatrix,
                                     dx: root::SkScalar, dy: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified scale.
        M' = M * S(sx, sy, px, py)
    */
        #[link_name = "?preScale@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_preScale(this: *mut root::SkMatrix,
                                 sx: root::SkScalar, sy: root::SkScalar,
                                 px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified scale.
        M' = M * S(sx, sy)
    */
        #[link_name = "?preScale@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_preScale1(this: *mut root::SkMatrix,
                                  sx: root::SkScalar, sy: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified rotation.
        M' = M * R(degrees, px, py)
    */
        #[link_name = "?preRotate@SkMatrix@@QEAAXMMM@Z"]
        pub fn SkMatrix_preRotate(this: *mut root::SkMatrix,
                                  degrees: root::SkScalar, px: root::SkScalar,
                                  py: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified rotation.
        M' = M * R(degrees)
    */
        #[link_name = "?preRotate@SkMatrix@@QEAAXM@Z"]
        pub fn SkMatrix_preRotate1(this: *mut root::SkMatrix,
                                   degrees: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified skew.
        M' = M * K(kx, ky, px, py)
    */
        #[link_name = "?preSkew@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_preSkew(this: *mut root::SkMatrix, kx: root::SkScalar,
                                ky: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified skew.
        M' = M * K(kx, ky)
    */
        #[link_name = "?preSkew@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_preSkew1(this: *mut root::SkMatrix,
                                 kx: root::SkScalar, ky: root::SkScalar);
    }
    extern "C" {
        /** Preconcats the matrix with the specified matrix.
        M' = M * other
    */
        #[link_name = "?preConcat@SkMatrix@@QEAAXAEBV1@@Z"]
        pub fn SkMatrix_preConcat(this: *mut root::SkMatrix,
                                  other: *const root::SkMatrix);
    }
    extern "C" {
        /** Postconcats the matrix with the specified translation.
        M' = T(dx, dy) * M
    */
        #[link_name = "?postTranslate@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_postTranslate(this: *mut root::SkMatrix,
                                      dx: root::SkScalar, dy: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified scale.
        M' = S(sx, sy, px, py) * M
    */
        #[link_name = "?postScale@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_postScale(this: *mut root::SkMatrix,
                                  sx: root::SkScalar, sy: root::SkScalar,
                                  px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified scale.
        M' = S(sx, sy) * M
    */
        #[link_name = "?postScale@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_postScale1(this: *mut root::SkMatrix,
                                   sx: root::SkScalar, sy: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix by dividing it by the specified integers.
        M' = S(1/divx, 1/divy, 0, 0) * M
    */
        #[link_name = "?postIDiv@SkMatrix@@QEAA_NHH@Z"]
        pub fn SkMatrix_postIDiv(this: *mut root::SkMatrix,
                                 divx: ::std::os::raw::c_int,
                                 divy: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** Postconcats the matrix with the specified rotation.
        M' = R(degrees, px, py) * M
    */
        #[link_name = "?postRotate@SkMatrix@@QEAAXMMM@Z"]
        pub fn SkMatrix_postRotate(this: *mut root::SkMatrix,
                                   degrees: root::SkScalar,
                                   px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified rotation.
        M' = R(degrees) * M
    */
        #[link_name = "?postRotate@SkMatrix@@QEAAXM@Z"]
        pub fn SkMatrix_postRotate1(this: *mut root::SkMatrix,
                                    degrees: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified skew.
        M' = K(kx, ky, px, py) * M
    */
        #[link_name = "?postSkew@SkMatrix@@QEAAXMMMM@Z"]
        pub fn SkMatrix_postSkew(this: *mut root::SkMatrix,
                                 kx: root::SkScalar, ky: root::SkScalar,
                                 px: root::SkScalar, py: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified skew.
        M' = K(kx, ky) * M
    */
        #[link_name = "?postSkew@SkMatrix@@QEAAXMM@Z"]
        pub fn SkMatrix_postSkew1(this: *mut root::SkMatrix,
                                  kx: root::SkScalar, ky: root::SkScalar);
    }
    extern "C" {
        /** Postconcats the matrix with the specified matrix.
        M' = other * M
    */
        #[link_name = "?postConcat@SkMatrix@@QEAAXAEBV1@@Z"]
        pub fn SkMatrix_postConcat(this: *mut root::SkMatrix,
                                   other: *const root::SkMatrix);
    }
    extern "C" {
        /** Set the matrix to the scale and translate values that map the source
        rectangle to the destination rectangle, returning true if the the result
        can be represented.
        @param src the source rectangle to map from.
        @param dst the destination rectangle to map to.
        @param stf the ScaleToFit option
        @return true if the matrix can be represented by the rectangle mapping.
    */
        #[link_name =
              "?setRectToRect@SkMatrix@@QEAA_NAEBUSkRect@@0W4ScaleToFit@1@@Z"]
        pub fn SkMatrix_setRectToRect(this: *mut root::SkMatrix,
                                      src: *const root::SkRect,
                                      dst: *const root::SkRect,
                                      stf: root::SkMatrix_ScaleToFit) -> bool;
    }
    extern "C" {
        /** Set the matrix such that the specified src points would map to the
        specified dst points. count must be within [0..4].
        @param src  The array of src points
        @param dst  The array of dst points
        @param count The number of points to use for the transformation
        @return true if the matrix was set to the specified transformation
    */
        #[link_name = "?setPolyToPoly@SkMatrix@@QEAA_NQEBUSkPoint@@0H@Z"]
        pub fn SkMatrix_setPolyToPoly(this: *mut root::SkMatrix,
                                      src: *const root::SkPoint,
                                      dst: *const root::SkPoint,
                                      count: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** Fills the passed array with affine identity values
        in column major order.
        @param affine  The array to fill with affine identity values.
        Must not be NULL.
    */
        #[link_name = "?SetAffineIdentity@SkMatrix@@SAXQEAM@Z"]
        pub fn SkMatrix_SetAffineIdentity(affine: *mut root::SkScalar);
    }
    extern "C" {
        /** Fills the passed array with the affine values in column major order.
        If the matrix is a perspective transform, returns false
        and does not change the passed array.
        @param affine  The array to fill with affine values. Ignored if NULL.
    */
        #[link_name = "?asAffine@SkMatrix@@QEBA_NQEAM@Z"]
        pub fn SkMatrix_asAffine(this: *const root::SkMatrix,
                                 affine: *mut root::SkScalar) -> bool;
    }
    extern "C" {
        /** Set the matrix to the specified affine values.
     *  Note: these are passed in column major order.
     */
        #[link_name = "?setAffine@SkMatrix@@QEAAXQEBM@Z"]
        pub fn SkMatrix_setAffine(this: *mut root::SkMatrix,
                                  affine: *mut root::SkScalar);
    }
    extern "C" {
        /** Apply this matrix to the array of homogeneous points, specified by src,
        where a homogeneous point is defined by 3 contiguous scalar values,
        and write the transformed points into the array of scalars specified by dst.
        dst[] = M * src[]
        @param dst  Where the transformed coordinates are written. It must
                    contain at least 3 * count entries
        @param src  The original coordinates that are to be transformed. It
                    must contain at least 3 * count entries
        @param count The number of triples (homogeneous points) in src to read,
                     and then transform into dst.
    */
        #[link_name = "?mapHomogeneousPoints@SkMatrix@@QEBAXQEAMQEBMH@Z"]
        pub fn SkMatrix_mapHomogeneousPoints(this: *const root::SkMatrix,
                                             dst: *mut root::SkScalar,
                                             src: *const root::SkScalar,
                                             count: ::std::os::raw::c_int);
    }
    extern "C" {
        /** Apply this matrix to the array of vectors specified by src, and write
        the transformed vectors into the array of vectors specified by dst.
        This is similar to mapPoints, but ignores any translation in the matrix.
        @param dst  Where the transformed coordinates are written. It must
                    contain at least count entries
        @param src  The original coordinates that are to be transformed. It
                    must contain at least count entries
        @param count The number of vectors in src to read, and then transform
                     into dst.
    */
        #[link_name = "?mapVectors@SkMatrix@@QEBAXQEAUSkPoint@@QEBU2@H@Z"]
        pub fn SkMatrix_mapVectors(this: *const root::SkMatrix,
                                   dst: *mut root::SkVector,
                                   src: *const root::SkVector,
                                   count: ::std::os::raw::c_int);
    }
    extern "C" {
        /** Apply this matrix to the src rectangle, and write the transformed
        rectangle into dst. This is accomplished by transforming the 4 corners
        of src, and then setting dst to the bounds of those points.
        @param dst  Where the transformed rectangle is written.
        @param src  The original rectangle to be transformed.
        @return the result of calling rectStaysRect()
    */
        #[link_name = "?mapRect@SkMatrix@@QEBA_NPEAUSkRect@@AEBU2@@Z"]
        pub fn SkMatrix_mapRect(this: *const root::SkMatrix,
                                dst: *mut root::SkRect,
                                src: *const root::SkRect) -> bool;
    }
    extern "C" {
        /**
     *  Maps a rect to another rect, asserting (in debug mode) that the matrix only contains
     *  scale and translate elements. If it contains other elements, the results are undefined.
     */
        #[link_name =
              "?mapRectScaleTranslate@SkMatrix@@QEBAXPEAUSkRect@@AEBU2@@Z"]
        pub fn SkMatrix_mapRectScaleTranslate(this: *const root::SkMatrix,
                                              dst: *mut root::SkRect,
                                              src: *const root::SkRect);
    }
    extern "C" {
        /** Return the mean radius of a circle after it has been mapped by
        this matrix. NOTE: in perspective this value assumes the circle
        has its center at the origin.
    */
        #[link_name = "?mapRadius@SkMatrix@@QEBAMM@Z"]
        pub fn SkMatrix_mapRadius(this: *const root::SkMatrix,
                                  radius: root::SkScalar) -> root::SkScalar;
    }
    extern "C" {
        /** Returns true if the matrix can be stepped in X (not complex
        perspective).
    */
        #[link_name = "?isFixedStepInX@SkMatrix@@QEBA_NXZ"]
        pub fn SkMatrix_isFixedStepInX(this: *const root::SkMatrix) -> bool;
    }
    extern "C" {
        /** If the matrix can be stepped in X (not complex perspective)
        then return the step value.
        If it cannot, behavior is undefined.
    */
        #[link_name = "?fixedStepInX@SkMatrix@@QEBA?AUSkPoint@@M@Z"]
        pub fn SkMatrix_fixedStepInX(this: *const root::SkMatrix,
                                     y: root::SkScalar) -> root::SkVector;
    }
    extern "C" {
        #[link_name = "?writeToMemory@SkMatrix@@QEBA_KPEAX@Z"]
        pub fn SkMatrix_writeToMemory(this: *const root::SkMatrix,
                                      buffer: *mut ::std::os::raw::c_void)
         -> usize;
    }
    extern "C" {
        /**
     * Reads data from the buffer parameter
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
        #[link_name = "?readFromMemory@SkMatrix@@QEAA_KPEBX_K@Z"]
        pub fn SkMatrix_readFromMemory(this: *mut root::SkMatrix,
                                       buffer: *const ::std::os::raw::c_void,
                                       length: usize) -> usize;
    }
    extern "C" {
        #[link_name = "?dump@SkMatrix@@QEBAXXZ"]
        pub fn SkMatrix_dump(this: *const root::SkMatrix);
    }
    extern "C" {
        #[link_name = "?toString@SkMatrix@@QEBAXPEAVSkString@@@Z"]
        pub fn SkMatrix_toString(this: *const root::SkMatrix,
                                 arg1: *mut root::SkString);
    }
    extern "C" {
        /**
     * Calculates the minimum scaling factor of the matrix as computed from the SVD of the upper
     * left 2x2. If the max scale factor cannot be computed (for example overflow or perspective)
     * -1 is returned.
     *
     * @return minimum scale factor
     */
        #[link_name = "?getMinScale@SkMatrix@@QEBAMXZ"]
        pub fn SkMatrix_getMinScale(this: *const root::SkMatrix)
         -> root::SkScalar;
    }
    extern "C" {
        /**
     * Calculates the maximum scaling factor of the matrix as computed from the SVD of the upper
     * left 2x2. If the max scale factor cannot be computed (for example overflow or perspective)
     * -1 is returned.
     *
     * @return maximum scale factor
     */
        #[link_name = "?getMaxScale@SkMatrix@@QEBAMXZ"]
        pub fn SkMatrix_getMaxScale(this: *const root::SkMatrix)
         -> root::SkScalar;
    }
    extern "C" {
        /**
     * Gets both the min and max scale factors. The min scale factor is scaleFactors[0] and the max
     * is scaleFactors[1]. If the min/max scale factors cannot be computed false is returned and the
     * values of scaleFactors[] are undefined.
     */
        #[link_name = "?getMinMaxScales@SkMatrix@@QEBA_NQEAM@Z"]
        pub fn SkMatrix_getMinMaxScales(this: *const root::SkMatrix,
                                        scaleFactors: *mut root::SkScalar)
         -> bool;
    }
    extern "C" {
        /**
     *  Attempt to decompose this matrix into a scale-only component and whatever remains, where
     *  the scale component is to be applied first.
     *
     *  M -> Remaining * Scale
     *
     *  On success, return true and assign the scale and remaining components (assuming their
     *  respective parameters are not null). On failure return false and ignore the parameters.
     *
     *  Possible reasons to fail: perspective, one or more scale factors are zero.
     */
        #[link_name = "?decomposeScale@SkMatrix@@QEBA_NPEAUSkSize@@PEAV1@@Z"]
        pub fn SkMatrix_decomposeScale(this: *const root::SkMatrix,
                                       scale: *mut root::SkSize,
                                       remaining: *mut root::SkMatrix)
         -> bool;
    }
    extern "C" {
        /**
     *  Return a reference to a const identity matrix
     */
        #[link_name = "?I@SkMatrix@@SAAEBV1@XZ"]
        pub fn SkMatrix_I() -> *const root::SkMatrix;
    }
    extern "C" {
        /**
     *  Return a reference to a const matrix that is "invalid", one that could
     *  never be used.
     */
        #[link_name = "?InvalidMatrix@SkMatrix@@SAAEBV1@XZ"]
        pub fn SkMatrix_InvalidMatrix() -> *const root::SkMatrix;
    }
    impl Clone for SkMatrix {
        fn clone(&self) -> Self { *self }
    }
    impl SkMatrix {
        #[inline]
        pub unsafe fn isSimilarity(&self, tol: root::SkScalar) -> bool {
            SkMatrix_isSimilarity(&*self, tol)
        }
        #[inline]
        pub unsafe fn preservesRightAngles(&self, tol: root::SkScalar)
         -> bool {
            SkMatrix_preservesRightAngles(&*self, tol)
        }
        #[inline]
        pub unsafe fn set9(&mut self, buffer: *mut root::SkScalar) {
            SkMatrix_set9(&mut *self, buffer)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkMatrix_reset(&mut *self) }
        #[inline]
        pub unsafe fn setTranslate(&mut self, dx: root::SkScalar,
                                   dy: root::SkScalar) {
            SkMatrix_setTranslate(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn setScale(&mut self, sx: root::SkScalar,
                               sy: root::SkScalar, px: root::SkScalar,
                               py: root::SkScalar) {
            SkMatrix_setScale(&mut *self, sx, sy, px, py)
        }
        #[inline]
        pub unsafe fn setScale1(&mut self, sx: root::SkScalar,
                                sy: root::SkScalar) {
            SkMatrix_setScale1(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn setIDiv(&mut self, divx: ::std::os::raw::c_int,
                              divy: ::std::os::raw::c_int) -> bool {
            SkMatrix_setIDiv(&mut *self, divx, divy)
        }
        #[inline]
        pub unsafe fn setRotate(&mut self, degrees: root::SkScalar,
                                px: root::SkScalar, py: root::SkScalar) {
            SkMatrix_setRotate(&mut *self, degrees, px, py)
        }
        #[inline]
        pub unsafe fn setRotate1(&mut self, degrees: root::SkScalar) {
            SkMatrix_setRotate1(&mut *self, degrees)
        }
        #[inline]
        pub unsafe fn setSinCos(&mut self, sinValue: root::SkScalar,
                                cosValue: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar) {
            SkMatrix_setSinCos(&mut *self, sinValue, cosValue, px, py)
        }
        #[inline]
        pub unsafe fn setSinCos1(&mut self, sinValue: root::SkScalar,
                                 cosValue: root::SkScalar) {
            SkMatrix_setSinCos1(&mut *self, sinValue, cosValue)
        }
        #[inline]
        pub unsafe fn setRSXform(&mut self, arg1: *const root::SkRSXform)
         -> *mut root::SkMatrix {
            SkMatrix_setRSXform(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setSkew(&mut self, kx: root::SkScalar,
                              ky: root::SkScalar, px: root::SkScalar,
                              py: root::SkScalar) {
            SkMatrix_setSkew(&mut *self, kx, ky, px, py)
        }
        #[inline]
        pub unsafe fn setSkew1(&mut self, kx: root::SkScalar,
                               ky: root::SkScalar) {
            SkMatrix_setSkew1(&mut *self, kx, ky)
        }
        #[inline]
        pub unsafe fn setConcat(&mut self, a: *const root::SkMatrix,
                                b: *const root::SkMatrix) {
            SkMatrix_setConcat(&mut *self, a, b)
        }
        #[inline]
        pub unsafe fn preTranslate(&mut self, dx: root::SkScalar,
                                   dy: root::SkScalar) {
            SkMatrix_preTranslate(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn preScale(&mut self, sx: root::SkScalar,
                               sy: root::SkScalar, px: root::SkScalar,
                               py: root::SkScalar) {
            SkMatrix_preScale(&mut *self, sx, sy, px, py)
        }
        #[inline]
        pub unsafe fn preScale1(&mut self, sx: root::SkScalar,
                                sy: root::SkScalar) {
            SkMatrix_preScale1(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn preRotate(&mut self, degrees: root::SkScalar,
                                px: root::SkScalar, py: root::SkScalar) {
            SkMatrix_preRotate(&mut *self, degrees, px, py)
        }
        #[inline]
        pub unsafe fn preRotate1(&mut self, degrees: root::SkScalar) {
            SkMatrix_preRotate1(&mut *self, degrees)
        }
        #[inline]
        pub unsafe fn preSkew(&mut self, kx: root::SkScalar,
                              ky: root::SkScalar, px: root::SkScalar,
                              py: root::SkScalar) {
            SkMatrix_preSkew(&mut *self, kx, ky, px, py)
        }
        #[inline]
        pub unsafe fn preSkew1(&mut self, kx: root::SkScalar,
                               ky: root::SkScalar) {
            SkMatrix_preSkew1(&mut *self, kx, ky)
        }
        #[inline]
        pub unsafe fn preConcat(&mut self, other: *const root::SkMatrix) {
            SkMatrix_preConcat(&mut *self, other)
        }
        #[inline]
        pub unsafe fn postTranslate(&mut self, dx: root::SkScalar,
                                    dy: root::SkScalar) {
            SkMatrix_postTranslate(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn postScale(&mut self, sx: root::SkScalar,
                                sy: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar) {
            SkMatrix_postScale(&mut *self, sx, sy, px, py)
        }
        #[inline]
        pub unsafe fn postScale1(&mut self, sx: root::SkScalar,
                                 sy: root::SkScalar) {
            SkMatrix_postScale1(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn postIDiv(&mut self, divx: ::std::os::raw::c_int,
                               divy: ::std::os::raw::c_int) -> bool {
            SkMatrix_postIDiv(&mut *self, divx, divy)
        }
        #[inline]
        pub unsafe fn postRotate(&mut self, degrees: root::SkScalar,
                                 px: root::SkScalar, py: root::SkScalar) {
            SkMatrix_postRotate(&mut *self, degrees, px, py)
        }
        #[inline]
        pub unsafe fn postRotate1(&mut self, degrees: root::SkScalar) {
            SkMatrix_postRotate1(&mut *self, degrees)
        }
        #[inline]
        pub unsafe fn postSkew(&mut self, kx: root::SkScalar,
                               ky: root::SkScalar, px: root::SkScalar,
                               py: root::SkScalar) {
            SkMatrix_postSkew(&mut *self, kx, ky, px, py)
        }
        #[inline]
        pub unsafe fn postSkew1(&mut self, kx: root::SkScalar,
                                ky: root::SkScalar) {
            SkMatrix_postSkew1(&mut *self, kx, ky)
        }
        #[inline]
        pub unsafe fn postConcat(&mut self, other: *const root::SkMatrix) {
            SkMatrix_postConcat(&mut *self, other)
        }
        #[inline]
        pub unsafe fn setRectToRect(&mut self, src: *const root::SkRect,
                                    dst: *const root::SkRect,
                                    stf: root::SkMatrix_ScaleToFit) -> bool {
            SkMatrix_setRectToRect(&mut *self, src, dst, stf)
        }
        #[inline]
        pub unsafe fn setPolyToPoly(&mut self, src: *const root::SkPoint,
                                    dst: *const root::SkPoint,
                                    count: ::std::os::raw::c_int) -> bool {
            SkMatrix_setPolyToPoly(&mut *self, src, dst, count)
        }
        #[inline]
        pub unsafe fn SetAffineIdentity(affine: *mut root::SkScalar) {
            SkMatrix_SetAffineIdentity(affine)
        }
        #[inline]
        pub unsafe fn asAffine(&self, affine: *mut root::SkScalar) -> bool {
            SkMatrix_asAffine(&*self, affine)
        }
        #[inline]
        pub unsafe fn setAffine(&mut self, affine: *mut root::SkScalar) {
            SkMatrix_setAffine(&mut *self, affine)
        }
        #[inline]
        pub unsafe fn mapHomogeneousPoints(&self, dst: *mut root::SkScalar,
                                           src: *const root::SkScalar,
                                           count: ::std::os::raw::c_int) {
            SkMatrix_mapHomogeneousPoints(&*self, dst, src, count)
        }
        #[inline]
        pub unsafe fn mapVectors(&self, dst: *mut root::SkVector,
                                 src: *const root::SkVector,
                                 count: ::std::os::raw::c_int) {
            SkMatrix_mapVectors(&*self, dst, src, count)
        }
        #[inline]
        pub unsafe fn mapRect(&self, dst: *mut root::SkRect,
                              src: *const root::SkRect) -> bool {
            SkMatrix_mapRect(&*self, dst, src)
        }
        #[inline]
        pub unsafe fn mapRectScaleTranslate(&self, dst: *mut root::SkRect,
                                            src: *const root::SkRect) {
            SkMatrix_mapRectScaleTranslate(&*self, dst, src)
        }
        #[inline]
        pub unsafe fn mapRadius(&self, radius: root::SkScalar)
         -> root::SkScalar {
            SkMatrix_mapRadius(&*self, radius)
        }
        #[inline]
        pub unsafe fn isFixedStepInX(&self) -> bool {
            SkMatrix_isFixedStepInX(&*self)
        }
        #[inline]
        pub unsafe fn fixedStepInX(&self, y: root::SkScalar)
         -> root::SkVector {
            SkMatrix_fixedStepInX(&*self, y)
        }
        #[inline]
        pub unsafe fn writeToMemory(&self,
                                    buffer: *mut ::std::os::raw::c_void)
         -> usize {
            SkMatrix_writeToMemory(&*self, buffer)
        }
        #[inline]
        pub unsafe fn readFromMemory(&mut self,
                                     buffer: *const ::std::os::raw::c_void,
                                     length: usize) -> usize {
            SkMatrix_readFromMemory(&mut *self, buffer, length)
        }
        #[inline]
        pub unsafe fn dump(&self) { SkMatrix_dump(&*self) }
        #[inline]
        pub unsafe fn toString(&self, arg1: *mut root::SkString) {
            SkMatrix_toString(&*self, arg1)
        }
        #[inline]
        pub unsafe fn getMinScale(&self) -> root::SkScalar {
            SkMatrix_getMinScale(&*self)
        }
        #[inline]
        pub unsafe fn getMaxScale(&self) -> root::SkScalar {
            SkMatrix_getMaxScale(&*self)
        }
        #[inline]
        pub unsafe fn getMinMaxScales(&self,
                                      scaleFactors: *mut root::SkScalar)
         -> bool {
            SkMatrix_getMinMaxScales(&*self, scaleFactors)
        }
        #[inline]
        pub unsafe fn decomposeScale(&self, scale: *mut root::SkSize,
                                     remaining: *mut root::SkMatrix) -> bool {
            SkMatrix_decomposeScale(&*self, scale, remaining)
        }
        #[inline]
        pub unsafe fn I() -> *const root::SkMatrix { SkMatrix_I() }
        #[inline]
        pub unsafe fn InvalidMatrix() -> *const root::SkMatrix {
            SkMatrix_InvalidMatrix()
        }
    }
    pub type SkMScalar = f32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMatrix44 {
        pub fMat: [[root::SkMScalar; 4usize]; 4usize],
        pub fTypeMask: ::std::os::raw::c_uint,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix44_Uninitialized_Constructor {
        kUninitialized_Constructor = 0,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix44_Identity_Constructor { kIdentity_Constructor = 0, }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix44_TypeMask {
        kIdentity_Mask = 0,
        kTranslate_Mask = 1,
        kScale_Mask = 2,
        kAffine_Mask = 4,
        kPerspective_Mask = 8,
    }
    pub const SkMatrix44_kUnknown_Mask: root::SkMatrix44__bindgen_ty_1 =
        SkMatrix44__bindgen_ty_1::kUnknown_Mask;
    pub const SkMatrix44_kAllPublic_Masks: root::SkMatrix44__bindgen_ty_1 =
        SkMatrix44__bindgen_ty_1::kAllPublic_Masks;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMatrix44__bindgen_ty_1 {
        kUnknown_Mask = 128,
        kAllPublic_Masks = 15,
    }
    #[test]
    fn bindgen_test_layout_SkMatrix44() {
        assert_eq!(::std::mem::size_of::<SkMatrix44>() , 68usize);
        assert_eq!(::std::mem::align_of::<SkMatrix44>() , 4usize);
    }
    extern "C" {
        /**
     *  Return a reference to a const identity matrix
     */
        #[link_name = "?I@SkMatrix44@@SAAEBV1@XZ"]
        pub fn SkMatrix44_I() -> *const root::SkMatrix44;
    }
    extern "C" {
        #[link_name = "?setIdentity@SkMatrix44@@QEAAXXZ"]
        pub fn SkMatrix44_setIdentity(this: *mut root::SkMatrix44);
    }
    extern "C" {
        /** These methods allow one to efficiently read matrix entries into an
     *  array. The given array must have room for exactly 16 entries. Whenever
     *  possible, they will try to use memcpy rather than an entry-by-entry
     *  copy.
     *
     *  Col major indicates that consecutive elements of columns will be stored
     *  contiguously in memory.  Row major indicates that consecutive elements
     *  of rows will be stored contiguously in memory.
     */
        #[link_name = "?asColMajorf@SkMatrix44@@QEBAXQEAM@Z"]
        pub fn SkMatrix44_asColMajorf(this: *const root::SkMatrix44,
                                      arg1: *mut f32);
    }
    extern "C" {
        #[link_name = "?asColMajord@SkMatrix44@@QEBAXQEAN@Z"]
        pub fn SkMatrix44_asColMajord(this: *const root::SkMatrix44,
                                      arg1: *mut f64);
    }
    extern "C" {
        #[link_name = "?asRowMajorf@SkMatrix44@@QEBAXQEAM@Z"]
        pub fn SkMatrix44_asRowMajorf(this: *const root::SkMatrix44,
                                      arg1: *mut f32);
    }
    extern "C" {
        #[link_name = "?asRowMajord@SkMatrix44@@QEBAXQEAN@Z"]
        pub fn SkMatrix44_asRowMajord(this: *const root::SkMatrix44,
                                      arg1: *mut f64);
    }
    extern "C" {
        /** These methods allow one to efficiently set all matrix entries from an
     *  array. The given array must have room for exactly 16 entries. Whenever
     *  possible, they will try to use memcpy rather than an entry-by-entry
     *  copy.
     *
     *  Col major indicates that input memory will be treated as if consecutive
     *  elements of columns are stored contiguously in memory.  Row major
     *  indicates that input memory will be treated as if consecutive elements
     *  of rows are stored contiguously in memory.
     */
        #[link_name = "?setColMajorf@SkMatrix44@@QEAAXQEBM@Z"]
        pub fn SkMatrix44_setColMajorf(this: *mut root::SkMatrix44,
                                       arg1: *const f32);
    }
    extern "C" {
        #[link_name = "?setColMajord@SkMatrix44@@QEAAXQEBN@Z"]
        pub fn SkMatrix44_setColMajord(this: *mut root::SkMatrix44,
                                       arg1: *const f64);
    }
    extern "C" {
        #[link_name = "?setRowMajorf@SkMatrix44@@QEAAXQEBM@Z"]
        pub fn SkMatrix44_setRowMajorf(this: *mut root::SkMatrix44,
                                       arg1: *const f32);
    }
    extern "C" {
        #[link_name = "?setRowMajord@SkMatrix44@@QEAAXQEBN@Z"]
        pub fn SkMatrix44_setRowMajord(this: *mut root::SkMatrix44,
                                       arg1: *const f64);
    }
    extern "C" {
        #[link_name = "?set3x3@SkMatrix44@@QEAAXMMMMMMMMM@Z"]
        pub fn SkMatrix44_set3x3(this: *mut root::SkMatrix44,
                                 m00: root::SkMScalar, m01: root::SkMScalar,
                                 m02: root::SkMScalar, m10: root::SkMScalar,
                                 m11: root::SkMScalar, m12: root::SkMScalar,
                                 m20: root::SkMScalar, m21: root::SkMScalar,
                                 m22: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?set3x3RowMajorf@SkMatrix44@@QEAAXQEBM@Z"]
        pub fn SkMatrix44_set3x3RowMajorf(this: *mut root::SkMatrix44,
                                          arg1: *const f32);
    }
    extern "C" {
        #[link_name = "?setTranslate@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_setTranslate(this: *mut root::SkMatrix44,
                                       dx: root::SkMScalar,
                                       dy: root::SkMScalar,
                                       dz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?preTranslate@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_preTranslate(this: *mut root::SkMatrix44,
                                       dx: root::SkMScalar,
                                       dy: root::SkMScalar,
                                       dz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?postTranslate@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_postTranslate(this: *mut root::SkMatrix44,
                                        dx: root::SkMScalar,
                                        dy: root::SkMScalar,
                                        dz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?setScale@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_setScale(this: *mut root::SkMatrix44,
                                   sx: root::SkMScalar, sy: root::SkMScalar,
                                   sz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?preScale@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_preScale(this: *mut root::SkMatrix44,
                                   sx: root::SkMScalar, sy: root::SkMScalar,
                                   sz: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?postScale@SkMatrix44@@QEAAXMMM@Z"]
        pub fn SkMatrix44_postScale(this: *mut root::SkMatrix44,
                                    sx: root::SkMScalar, sy: root::SkMScalar,
                                    sz: root::SkMScalar);
    }
    extern "C" {
        /** Rotate about the vector [x,y,z]. If that vector is not unit-length,
        it will be automatically resized.
     */
        #[link_name = "?setRotateAbout@SkMatrix44@@QEAAXMMMM@Z"]
        pub fn SkMatrix44_setRotateAbout(this: *mut root::SkMatrix44,
                                         x: root::SkMScalar,
                                         y: root::SkMScalar,
                                         z: root::SkMScalar,
                                         radians: root::SkMScalar);
    }
    extern "C" {
        /** Rotate about the vector [x,y,z]. Does not check the length of the
        vector, assuming it is unit-length.
     */
        #[link_name = "?setRotateAboutUnit@SkMatrix44@@QEAAXMMMM@Z"]
        pub fn SkMatrix44_setRotateAboutUnit(this: *mut root::SkMatrix44,
                                             x: root::SkMScalar,
                                             y: root::SkMScalar,
                                             z: root::SkMScalar,
                                             radians: root::SkMScalar);
    }
    extern "C" {
        #[link_name = "?setConcat@SkMatrix44@@QEAAXAEBV1@0@Z"]
        pub fn SkMatrix44_setConcat(this: *mut root::SkMatrix44,
                                    a: *const root::SkMatrix44,
                                    b: *const root::SkMatrix44);
    }
    extern "C" {
        /** If this is invertible, return that in inverse and return true. If it is
        not invertible, return false and leave the inverse parameter in an
        unspecified state.
     */
        #[link_name = "?invert@SkMatrix44@@QEBA_NPEAV1@@Z"]
        pub fn SkMatrix44_invert(this: *const root::SkMatrix44,
                                 inverse: *mut root::SkMatrix44) -> bool;
    }
    extern "C" {
        /** Transpose this matrix in place. */
        #[link_name = "?transpose@SkMatrix44@@QEAAXXZ"]
        pub fn SkMatrix44_transpose(this: *mut root::SkMatrix44);
    }
    extern "C" {
        /** Apply the matrix to the src vector, returning the new vector in dst.
        It is legal for src and dst to point to the same memory.
     */
        #[link_name = "?mapScalars@SkMatrix44@@QEBAXQEBMQEAM@Z"]
        pub fn SkMatrix44_mapScalars(this: *const root::SkMatrix44,
                                     src: *mut root::SkScalar,
                                     dst: *mut root::SkScalar);
    }
    extern "C" {
        /**
     *  map an array of [x, y, 0, 1] through the matrix, returning an array
     *  of [x', y', z', w'].
     *
     *  @param src2     array of [x, y] pairs, with implied z=0 and w=1
     *  @param count    number of [x, y] pairs in src2
     *  @param dst4     array of [x', y', z', w'] quads as the output.
     */
        #[link_name = "?map2@SkMatrix44@@QEBAXQEBMHQEAM@Z"]
        pub fn SkMatrix44_map2(this: *const root::SkMatrix44,
                               src2: *const f32, count: ::std::os::raw::c_int,
                               dst4: *mut f32);
    }
    extern "C" {
        #[link_name = "?map2@SkMatrix44@@QEBAXQEBNHQEAN@Z"]
        pub fn SkMatrix44_map21(this: *const root::SkMatrix44,
                                src2: *const f64,
                                count: ::std::os::raw::c_int, dst4: *mut f64);
    }
    extern "C" {
        /** Returns true if transformating an axis-aligned square in 2d by this matrix
        will produce another 2d axis-aligned square; typically means the matrix
        is a scale with perhaps a 90-degree rotation. A 3d rotation through 90
        degrees into a perpendicular plane collapses a square to a line, but
        is still considered to be axis-aligned.

        By default, tolerates very slight error due to float imprecisions;
        a 90-degree rotation can still end up with 10^-17 of
        "non-axis-aligned" result.
     */
        #[link_name = "?preserves2dAxisAlignment@SkMatrix44@@QEBA_NM@Z"]
        pub fn SkMatrix44_preserves2dAxisAlignment(this:
                                                       *const root::SkMatrix44,
                                                   epsilon: root::SkMScalar)
         -> bool;
    }
    extern "C" {
        #[link_name = "?dump@SkMatrix44@@QEBAXXZ"]
        pub fn SkMatrix44_dump(this: *const root::SkMatrix44);
    }
    extern "C" {
        #[link_name = "?determinant@SkMatrix44@@QEBANXZ"]
        pub fn SkMatrix44_determinant(this: *const root::SkMatrix44) -> f64;
    }
    extern "C" {
        #[link_name = "??0SkMatrix44@@QEAA@AEBVSkMatrix@@@Z"]
        pub fn SkMatrix44_SkMatrix44(this: *mut root::SkMatrix44,
                                     arg1: *const root::SkMatrix);
    }
    impl Clone for SkMatrix44 {
        fn clone(&self) -> Self { *self }
    }
    impl SkMatrix44 {
        #[inline]
        pub unsafe fn I() -> *const root::SkMatrix44 { SkMatrix44_I() }
        #[inline]
        pub unsafe fn setIdentity(&mut self) {
            SkMatrix44_setIdentity(&mut *self)
        }
        #[inline]
        pub unsafe fn asColMajorf(&self, arg1: *mut f32) {
            SkMatrix44_asColMajorf(&*self, arg1)
        }
        #[inline]
        pub unsafe fn asColMajord(&self, arg1: *mut f64) {
            SkMatrix44_asColMajord(&*self, arg1)
        }
        #[inline]
        pub unsafe fn asRowMajorf(&self, arg1: *mut f32) {
            SkMatrix44_asRowMajorf(&*self, arg1)
        }
        #[inline]
        pub unsafe fn asRowMajord(&self, arg1: *mut f64) {
            SkMatrix44_asRowMajord(&*self, arg1)
        }
        #[inline]
        pub unsafe fn setColMajorf(&mut self, arg1: *const f32) {
            SkMatrix44_setColMajorf(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setColMajord(&mut self, arg1: *const f64) {
            SkMatrix44_setColMajord(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setRowMajorf(&mut self, arg1: *const f32) {
            SkMatrix44_setRowMajorf(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setRowMajord(&mut self, arg1: *const f64) {
            SkMatrix44_setRowMajord(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn set3x3(&mut self, m00: root::SkMScalar,
                             m01: root::SkMScalar, m02: root::SkMScalar,
                             m10: root::SkMScalar, m11: root::SkMScalar,
                             m12: root::SkMScalar, m20: root::SkMScalar,
                             m21: root::SkMScalar, m22: root::SkMScalar) {
            SkMatrix44_set3x3(&mut *self, m00, m01, m02, m10, m11, m12, m20,
                              m21, m22)
        }
        #[inline]
        pub unsafe fn set3x3RowMajorf(&mut self, arg1: *const f32) {
            SkMatrix44_set3x3RowMajorf(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setTranslate(&mut self, dx: root::SkMScalar,
                                   dy: root::SkMScalar, dz: root::SkMScalar) {
            SkMatrix44_setTranslate(&mut *self, dx, dy, dz)
        }
        #[inline]
        pub unsafe fn preTranslate(&mut self, dx: root::SkMScalar,
                                   dy: root::SkMScalar, dz: root::SkMScalar) {
            SkMatrix44_preTranslate(&mut *self, dx, dy, dz)
        }
        #[inline]
        pub unsafe fn postTranslate(&mut self, dx: root::SkMScalar,
                                    dy: root::SkMScalar,
                                    dz: root::SkMScalar) {
            SkMatrix44_postTranslate(&mut *self, dx, dy, dz)
        }
        #[inline]
        pub unsafe fn setScale(&mut self, sx: root::SkMScalar,
                               sy: root::SkMScalar, sz: root::SkMScalar) {
            SkMatrix44_setScale(&mut *self, sx, sy, sz)
        }
        #[inline]
        pub unsafe fn preScale(&mut self, sx: root::SkMScalar,
                               sy: root::SkMScalar, sz: root::SkMScalar) {
            SkMatrix44_preScale(&mut *self, sx, sy, sz)
        }
        #[inline]
        pub unsafe fn postScale(&mut self, sx: root::SkMScalar,
                                sy: root::SkMScalar, sz: root::SkMScalar) {
            SkMatrix44_postScale(&mut *self, sx, sy, sz)
        }
        #[inline]
        pub unsafe fn setRotateAbout(&mut self, x: root::SkMScalar,
                                     y: root::SkMScalar, z: root::SkMScalar,
                                     radians: root::SkMScalar) {
            SkMatrix44_setRotateAbout(&mut *self, x, y, z, radians)
        }
        #[inline]
        pub unsafe fn setRotateAboutUnit(&mut self, x: root::SkMScalar,
                                         y: root::SkMScalar,
                                         z: root::SkMScalar,
                                         radians: root::SkMScalar) {
            SkMatrix44_setRotateAboutUnit(&mut *self, x, y, z, radians)
        }
        #[inline]
        pub unsafe fn setConcat(&mut self, a: *const root::SkMatrix44,
                                b: *const root::SkMatrix44) {
            SkMatrix44_setConcat(&mut *self, a, b)
        }
        #[inline]
        pub unsafe fn invert(&self, inverse: *mut root::SkMatrix44) -> bool {
            SkMatrix44_invert(&*self, inverse)
        }
        #[inline]
        pub unsafe fn transpose(&mut self) {
            SkMatrix44_transpose(&mut *self)
        }
        #[inline]
        pub unsafe fn mapScalars(&self, src: *mut root::SkScalar,
                                 dst: *mut root::SkScalar) {
            SkMatrix44_mapScalars(&*self, src, dst)
        }
        #[inline]
        pub unsafe fn map2(&self, src2: *const f32,
                           count: ::std::os::raw::c_int, dst4: *mut f32) {
            SkMatrix44_map2(&*self, src2, count, dst4)
        }
        #[inline]
        pub unsafe fn map21(&self, src2: *const f64,
                            count: ::std::os::raw::c_int, dst4: *mut f64) {
            SkMatrix44_map21(&*self, src2, count, dst4)
        }
        #[inline]
        pub unsafe fn preserves2dAxisAlignment(&self,
                                               epsilon: root::SkMScalar)
         -> bool {
            SkMatrix44_preserves2dAxisAlignment(&*self, epsilon)
        }
        #[inline]
        pub unsafe fn dump(&self) { SkMatrix44_dump(&*self) }
        #[inline]
        pub unsafe fn determinant(&self) -> f64 {
            SkMatrix44_determinant(&*self)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::SkMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkMatrix44_SkMatrix44(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkRefCnt {
        pub _base: root::SkRefCntBase,
    }
    #[test]
    fn bindgen_test_layout_SkRefCnt() {
        assert_eq!(::std::mem::size_of::<SkRefCnt>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkRefCnt>() , 8usize);
    }
    ///////////////////////////////////////////////////////////////////////////////
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkNVRefCnt<Derived> {
        pub fRefCnt: u32,
        pub _phantom_0: ::std::marker::PhantomData<Derived>,
    }
    #[test]
    fn __bindgen_test_layout_template_2() {
        assert_eq!(::std::mem::size_of::<root::SkNVRefCnt<root::SkData>>() ,
                   4usize);
        assert_eq!(::std::mem::align_of::<root::SkNVRefCnt<root::SkData>>() ,
                   4usize);
    }
    #[test]
    fn __bindgen_test_layout_template_3() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkData>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkData>>() ,
                   8usize);
    }
    /**
 *  SkData holds an immutable data buffer. Not only is the data immutable,
 *  but the actual ptr that is returned (by data() or bytes()) is guaranteed
 *  to always be the same for the life of this instance.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkData {
        pub _base: root::SkNVRefCnt<root::SkData>,
        pub fReleaseProc: root::SkData_ReleaseProc,
        pub fReleaseProcContext: *mut ::std::os::raw::c_void,
        pub fPtr: *mut ::std::os::raw::c_void,
        pub fSize: usize,
    }
    /**
     *  Function that, if provided, will be called when the SkData goes out
     *  of scope, allowing for custom allocation/freeing of the data's contents.
     */
    pub type SkData_ReleaseProc =
        ::std::option::Option<unsafe extern "C" fn(ptr:
                                                       *const ::std::os::raw::c_void,
                                                   context:
                                                       *mut ::std::os::raw::c_void)>;
    pub type SkData_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkData() {
        assert_eq!(::std::mem::size_of::<SkData>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkData>() , 8usize);
    }
    extern "C" {
        /**
     *  Helper to copy a range of the data into a caller-provided buffer.
     *  Returns the actual number of bytes copied, after clamping offset and
     *  length to the size of the data. If buffer is NULL, it is ignored, and
     *  only the computed number of bytes is returned.
     */
        #[link_name = "?copyRange@SkData@@QEBA_K_K0PEAX@Z"]
        pub fn SkData_copyRange(this: *const root::SkData, offset: usize,
                                length: usize,
                                buffer: *mut ::std::os::raw::c_void) -> usize;
    }
    extern "C" {
        /**
     *  Returns true if these two objects have the same length and contents,
     *  effectively returning 0 == memcmp(...)
     */
        #[link_name = "?equals@SkData@@QEBA_NPEBV1@@Z"]
        pub fn SkData_equals(this: *const root::SkData,
                             other: *const root::SkData) -> bool;
    }
    extern "C" {
        /**
     *  Create a new dataref by copying the specified data
     */
        #[link_name =
              "?MakeWithCopy@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_K@Z"]
        pub fn SkData_MakeWithCopy(data: *const ::std::os::raw::c_void,
                                   length: usize)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new data with uninitialized contents. The caller should call writable_data()
     *  to write into the buffer, but this must be done before another ref() is made.
     */
        #[link_name =
              "?MakeUninitialized@SkData@@SA?AV?$sk_sp@VSkData@@@@_K@Z"]
        pub fn SkData_MakeUninitialized(length: usize)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref by copying the specified c-string
     *  (a null-terminated array of bytes). The returned SkData will have size()
     *  equal to strlen(cstr) + 1. If cstr is NULL, it will be treated the same
     *  as "".
     */
        #[link_name =
              "?MakeWithCString@SkData@@SA?AV?$sk_sp@VSkData@@@@QEBD@Z"]
        pub fn SkData_MakeWithCString(cstr: *const ::std::os::raw::c_char)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref, taking the ptr as is, and using the
     *  releaseproc to free it. The proc may be NULL.
     */
        #[link_name =
              "?MakeWithProc@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_KP6AX0PEAX@Z2@Z"]
        pub fn SkData_MakeWithProc(ptr: *const ::std::os::raw::c_void,
                                   length: usize,
                                   proc_: root::SkData_ReleaseProc,
                                   ctx: *mut ::std::os::raw::c_void)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref from a pointer allocated by malloc. The Data object
     *  takes ownership of that allocation, and will handling calling sk_free.
     */
        #[link_name =
              "?MakeFromMalloc@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_K@Z"]
        pub fn SkData_MakeFromMalloc(data: *const ::std::os::raw::c_void,
                                     length: usize)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref the file with the specified path.
     *  If the file cannot be opened, this returns NULL.
     */
        #[link_name =
              "?MakeFromFileName@SkData@@SA?AV?$sk_sp@VSkData@@@@QEBD@Z"]
        pub fn SkData_MakeFromFileName(path: *const ::std::os::raw::c_char)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref from a stdio FILE.
     *  This does not take ownership of the FILE, nor close it.
     *  The caller is free to close the FILE at its convenience.
     *  The FILE must be open for reading only.
     *  Returns NULL on failure.
     */
        #[link_name =
              "?MakeFromFILE@SkData@@SA?AV?$sk_sp@VSkData@@@@PEAU_iobuf@@@Z"]
        pub fn SkData_MakeFromFILE(f: *mut root::FILE)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref from a file descriptor.
     *  This does not take ownership of the file descriptor, nor close it.
     *  The caller is free to close the file descriptor at its convenience.
     *  The file descriptor must be open for reading only.
     *  Returns NULL on failure.
     */
        #[link_name = "?MakeFromFD@SkData@@SA?AV?$sk_sp@VSkData@@@@H@Z"]
        pub fn SkData_MakeFromFD(fd: ::std::os::raw::c_int)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Attempt to read size bytes into a SkData. If the read succeeds, return the data,
     *  else return NULL. Either way the stream's cursor may have been changed as a result
     *  of calling read().
     */
        #[link_name =
              "?MakeFromStream@SkData@@SA?AV?$sk_sp@VSkData@@@@PEAVSkStream@@_K@Z"]
        pub fn SkData_MakeFromStream(arg1: *mut root::SkStream, size: usize)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Create a new dataref using a subset of the data in the specified
     *  src dataref.
     */
        #[link_name =
              "?MakeSubset@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBV1@_K1@Z"]
        pub fn SkData_MakeSubset(src: *const root::SkData, offset: usize,
                                 length: usize) -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Returns a new empty dataref (or a reference to a shared empty dataref).
     *  New or shared, the caller must see that unref() is eventually called.
     */
        #[link_name = "?MakeEmpty@SkData@@SA?AV?$sk_sp@VSkData@@@@XZ"]
        pub fn SkData_MakeEmpty() -> root::sk_sp<root::SkData>;
    }
    impl SkData {
        #[inline]
        pub unsafe fn copyRange(&self, offset: usize, length: usize,
                                buffer: *mut ::std::os::raw::c_void)
         -> usize {
            SkData_copyRange(&*self, offset, length, buffer)
        }
        #[inline]
        pub unsafe fn equals(&self, other: *const root::SkData) -> bool {
            SkData_equals(&*self, other)
        }
        #[inline]
        pub unsafe fn MakeWithCopy(data: *const ::std::os::raw::c_void,
                                   length: usize)
         -> root::sk_sp<root::SkData> {
            SkData_MakeWithCopy(data, length)
        }
        #[inline]
        pub unsafe fn MakeUninitialized(length: usize)
         -> root::sk_sp<root::SkData> {
            SkData_MakeUninitialized(length)
        }
        #[inline]
        pub unsafe fn MakeWithCString(cstr: *const ::std::os::raw::c_char)
         -> root::sk_sp<root::SkData> {
            SkData_MakeWithCString(cstr)
        }
        #[inline]
        pub unsafe fn MakeWithProc(ptr: *const ::std::os::raw::c_void,
                                   length: usize,
                                   proc_: root::SkData_ReleaseProc,
                                   ctx: *mut ::std::os::raw::c_void)
         -> root::sk_sp<root::SkData> {
            SkData_MakeWithProc(ptr, length, proc_, ctx)
        }
        #[inline]
        pub unsafe fn MakeFromMalloc(data: *const ::std::os::raw::c_void,
                                     length: usize)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromMalloc(data, length)
        }
        #[inline]
        pub unsafe fn MakeFromFileName(path: *const ::std::os::raw::c_char)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromFileName(path)
        }
        #[inline]
        pub unsafe fn MakeFromFILE(f: *mut root::FILE)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromFILE(f)
        }
        #[inline]
        pub unsafe fn MakeFromFD(fd: ::std::os::raw::c_int)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromFD(fd)
        }
        #[inline]
        pub unsafe fn MakeFromStream(arg1: *mut root::SkStream, size: usize)
         -> root::sk_sp<root::SkData> {
            SkData_MakeFromStream(arg1, size)
        }
        #[inline]
        pub unsafe fn MakeSubset(src: *const root::SkData, offset: usize,
                                 length: usize) -> root::sk_sp<root::SkData> {
            SkData_MakeSubset(src, offset, length)
        }
        #[inline]
        pub unsafe fn MakeEmpty() -> root::sk_sp<root::SkData> {
            SkData_MakeEmpty()
        }
    }
    /**
 *  Contains the coefficients for a common transfer function equation, specified as
 *  a transformation from a curved space to linear.
 *
 *  LinearVal = E*InputVal + F        , for 0.0f <= InputVal <  D
 *  LinearVal = (A*InputVal + B)^G + C, for D    <= InputVal <= 1.0f
 *
 *  Function is undefined if InputVal is not in [ 0.0f, 1.0f ].
 *  Resulting LinearVals must be in [ 0.0f, 1.0f ].
 *  Function must be positive and increasing.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkColorSpaceTransferFn {
        pub fG: f32,
        pub fA: f32,
        pub fB: f32,
        pub fC: f32,
        pub fD: f32,
        pub fE: f32,
        pub fF: f32,
    }
    #[test]
    fn bindgen_test_layout_SkColorSpaceTransferFn() {
        assert_eq!(::std::mem::size_of::<SkColorSpaceTransferFn>() , 28usize);
        assert_eq!(::std::mem::align_of::<SkColorSpaceTransferFn>() , 4usize);
    }
    impl Clone for SkColorSpaceTransferFn {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_4() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkColorSpace>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkColorSpace>>() ,
                   8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkColorSpace {
        pub _base: root::SkRefCnt,
    }
    #[repr(u8)]
    /**
     *  Common, named profiles that we can recognize.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkColorSpace_Named {
        kSRGB_Named = 0,
        kAdobeRGB_Named = 1,
        kSRGBLinear_Named = 2,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkColorSpace_RenderTargetGamma {
        kLinear_RenderTargetGamma = 0,
        kSRGB_RenderTargetGamma = 1,
    }
    #[test]
    fn bindgen_test_layout_SkColorSpace() {
        assert_eq!(::std::mem::size_of::<SkColorSpace>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkColorSpace>() , 8usize);
    }
    extern "C" {
        /**
     *  Create an SkColorSpace from a transfer function and a color gamut.
     *
     *  Transfer function can be specified as a render target, as the coefficients to an equation,
     *  or as three exponents (R, G, B).
     *  Gamut is specified using the matrix transformation to XYZ D50.
     */
        #[link_name =
              "?MakeRGB@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@W4RenderTargetGamma@1@AEBVSkMatrix44@@@Z"]
        pub fn SkColorSpace_MakeRGB(gamma:
                                        root::SkColorSpace_RenderTargetGamma,
                                    toXYZD50: *const root::SkMatrix44)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        #[link_name =
              "?MakeRGB@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@AEBUSkColorSpaceTransferFn@@AEBVSkMatrix44@@@Z"]
        pub fn SkColorSpace_MakeRGB1(coeffs:
                                         *const root::SkColorSpaceTransferFn,
                                     toXYZD50: *const root::SkMatrix44)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        /**
     *  Create a common, named SkColorSpace.
     */
        #[link_name =
              "?MakeNamed@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@W4Named@1@@Z"]
        pub fn SkColorSpace_MakeNamed(arg1: root::SkColorSpace_Named)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        /**
     *  Create an SkColorSpace from an ICC profile.
     */
        #[link_name =
              "?MakeICC@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@PEBX_K@Z"]
        pub fn SkColorSpace_MakeICC(arg1: *const ::std::os::raw::c_void,
                                    arg2: usize)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        /**
     *  Returns true if the color space gamma is near enough to be approximated as sRGB.
     */
        #[link_name = "?gammaCloseToSRGB@SkColorSpace@@QEBA_NXZ"]
        pub fn SkColorSpace_gammaCloseToSRGB(this: *const root::SkColorSpace)
         -> bool;
    }
    extern "C" {
        /**
     *  Returns true if the color space gamma is linear.
     */
        #[link_name = "?gammaIsLinear@SkColorSpace@@QEBA_NXZ"]
        pub fn SkColorSpace_gammaIsLinear(this: *const root::SkColorSpace)
         -> bool;
    }
    extern "C" {
        /**
     *  Returns nullptr on failure.  Fails when we fallback to serializing ICC data and
     *  the data is too large to serialize.
     */
        #[link_name = "?serialize@SkColorSpace@@QEBA?AV?$sk_sp@VSkData@@@@XZ"]
        pub fn SkColorSpace_serialize(this: *const root::SkColorSpace)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  If |memory| is nullptr, returns the size required to serialize.
     *  Otherwise, serializes into |memory| and returns the size.
     */
        #[link_name = "?writeToMemory@SkColorSpace@@QEBA_KPEAX@Z"]
        pub fn SkColorSpace_writeToMemory(this: *const root::SkColorSpace,
                                          memory: *mut ::std::os::raw::c_void)
         -> usize;
    }
    extern "C" {
        #[link_name =
              "?Deserialize@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@PEBX_K@Z"]
        pub fn SkColorSpace_Deserialize(data: *const ::std::os::raw::c_void,
                                        length: usize)
         -> root::sk_sp<root::SkColorSpace>;
    }
    extern "C" {
        /**
     *  If both are null, we return true.  If one is null and the other is not, we return false.
     *  If both are non-null, we do a deeper compare.
     */
        #[link_name = "?Equals@SkColorSpace@@SA_NPEBV1@0@Z"]
        pub fn SkColorSpace_Equals(src: *const root::SkColorSpace,
                                   dst: *const root::SkColorSpace) -> bool;
    }
    impl SkColorSpace {
        #[inline]
        pub unsafe fn MakeRGB(gamma: root::SkColorSpace_RenderTargetGamma,
                              toXYZD50: *const root::SkMatrix44)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_MakeRGB(gamma, toXYZD50)
        }
        #[inline]
        pub unsafe fn MakeRGB1(coeffs: *const root::SkColorSpaceTransferFn,
                               toXYZD50: *const root::SkMatrix44)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_MakeRGB1(coeffs, toXYZD50)
        }
        #[inline]
        pub unsafe fn MakeNamed(arg1: root::SkColorSpace_Named)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_MakeNamed(arg1)
        }
        #[inline]
        pub unsafe fn MakeICC(arg1: *const ::std::os::raw::c_void,
                              arg2: usize)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_MakeICC(arg1, arg2)
        }
        #[inline]
        pub unsafe fn gammaCloseToSRGB(&self) -> bool {
            SkColorSpace_gammaCloseToSRGB(&*self)
        }
        #[inline]
        pub unsafe fn gammaIsLinear(&self) -> bool {
            SkColorSpace_gammaIsLinear(&*self)
        }
        #[inline]
        pub unsafe fn serialize(&self) -> root::sk_sp<root::SkData> {
            SkColorSpace_serialize(&*self)
        }
        #[inline]
        pub unsafe fn writeToMemory(&self,
                                    memory: *mut ::std::os::raw::c_void)
         -> usize {
            SkColorSpace_writeToMemory(&*self, memory)
        }
        #[inline]
        pub unsafe fn Deserialize(data: *const ::std::os::raw::c_void,
                                  length: usize)
         -> root::sk_sp<root::SkColorSpace> {
            SkColorSpace_Deserialize(data, length)
        }
        #[inline]
        pub unsafe fn Equals(src: *const root::SkColorSpace,
                             dst: *const root::SkColorSpace) -> bool {
            SkColorSpace_Equals(src, dst)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkReadBuffer {
        pub _address: u8,
    }
    impl Clone for SkReadBuffer {
        fn clone(&self) -> Self { *self }
    }
    /** 32 bit ARGB color value, not premultiplied. The color components are always in
    a known order. This is different from SkPMColor, which has its bytes in a configuration
    dependent order, to match the format of kARGB32 bitmaps. SkColor is the type used to
    specify colors in SkPaint and in gradients.
*/
    pub type SkColor = u32;
    #[repr(C)]
    pub struct SkWriteBuffer__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkWriteBuffer {
        pub vtable_: *const SkWriteBuffer__bindgen_vtable,
        pub fDeduper: *mut root::SkDeduper,
    }
    #[test]
    fn bindgen_test_layout_SkWriteBuffer() {
        assert_eq!(::std::mem::size_of::<SkWriteBuffer>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkWriteBuffer>() , 8usize);
    }
    pub const SkAlphaType_kLastEnum_SkAlphaType: root::SkAlphaType =
        SkAlphaType::kUnpremul_SkAlphaType;
    #[repr(i32)]
    /**
 *  Describes how to interpret the alpha component of a pixel.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkAlphaType {
        kUnknown_SkAlphaType = 0,
        kOpaque_SkAlphaType = 1,
        kPremul_SkAlphaType = 2,
        kUnpremul_SkAlphaType = 3,
    }
    pub const SkColorType_kLastEnum_SkColorType: root::SkColorType =
        SkColorType::kRGBA_F16_SkColorType;
    pub const SkColorType_kN32_SkColorType: root::SkColorType =
        SkColorType::kBGRA_8888_SkColorType;
    #[repr(i32)]
    /**
 *  Describes how to interpret the components of a pixel.
 *
 *  kN32_SkColorType is an alias for whichever 32bit ARGB format is the "native"
 *  form for skia's blitters. Use this if you don't have a swizzle preference
 *  for 32bit pixels.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkColorType {
        kUnknown_SkColorType = 0,
        kAlpha_8_SkColorType = 1,
        kRGB_565_SkColorType = 2,
        kARGB_4444_SkColorType = 3,
        kRGBA_8888_SkColorType = 4,
        kBGRA_8888_SkColorType = 5,
        kIndex_8_SkColorType = 6,
        kGray_8_SkColorType = 7,
        kRGBA_F16_SkColorType = 8,
    }
    pub const SkYUVColorSpace_kLastEnum_SkYUVColorSpace: root::SkYUVColorSpace
              =
        SkYUVColorSpace::kRec709_SkYUVColorSpace;
    #[repr(i32)]
    /**
 *  Describes the color space a YUV pixel.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkYUVColorSpace {
        kJPEG_SkYUVColorSpace = 0,
        kRec601_SkYUVColorSpace = 1,
        kRec709_SkYUVColorSpace = 2,
    }
    #[repr(i32)]
    ///////////////////////////////////////////////////////////////////////////////
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkDestinationSurfaceColorMode {
        kLegacy = 0,
        kGammaAndColorSpaceAware = 1,
    }
    /**
 *  Describe an image's dimensions and pixel type.
 *  Used for both src images and render-targets (surfaces).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkImageInfo {
        pub fColorSpace: root::sk_sp<root::SkColorSpace>,
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fColorType: root::SkColorType,
        pub fAlphaType: root::SkAlphaType,
    }
    #[test]
    fn bindgen_test_layout_SkImageInfo() {
        assert_eq!(::std::mem::size_of::<SkImageInfo>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkImageInfo>() , 8usize);
    }
    extern "C" {
        /**
     *  Create an ImageInfo marked as SRGB with N32 swizzle.
     */
        #[link_name = "?MakeS32@SkImageInfo@@SA?AU1@HHW4SkAlphaType@@@Z"]
        pub fn SkImageInfo_MakeS32(width: ::std::os::raw::c_int,
                                   height: ::std::os::raw::c_int,
                                   at: root::SkAlphaType)
         -> root::SkImageInfo;
    }
    extern "C" {
        #[link_name = "?unflatten@SkImageInfo@@QEAAXAEAVSkReadBuffer@@@Z"]
        pub fn SkImageInfo_unflatten(this: *mut root::SkImageInfo,
                                     arg1: *mut root::SkReadBuffer);
    }
    extern "C" {
        #[link_name = "?flatten@SkImageInfo@@QEBAXAEAVSkWriteBuffer@@@Z"]
        pub fn SkImageInfo_flatten(this: *const root::SkImageInfo,
                                   arg1: *mut root::SkWriteBuffer);
    }
    extern "C" {
        #[link_name = "?validate@SkImageInfo@@QEBAXXZ"]
        pub fn SkImageInfo_validate(this: *const root::SkImageInfo);
    }
    impl SkImageInfo {
        #[inline]
        pub unsafe fn MakeS32(width: ::std::os::raw::c_int,
                              height: ::std::os::raw::c_int,
                              at: root::SkAlphaType) -> root::SkImageInfo {
            SkImageInfo_MakeS32(width, height, at)
        }
        #[inline]
        pub unsafe fn unflatten(&mut self, arg1: *mut root::SkReadBuffer) {
            SkImageInfo_unflatten(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn flatten(&self, arg1: *mut root::SkWriteBuffer) {
            SkImageInfo_flatten(&*self, arg1)
        }
        #[inline]
        pub unsafe fn validate(&self) { SkImageInfo_validate(&*self) }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPoint3 {
        pub fX: root::SkScalar,
        pub fY: root::SkScalar,
        pub fZ: root::SkScalar,
    }
    #[test]
    fn bindgen_test_layout_SkPoint3() {
        assert_eq!(::std::mem::size_of::<SkPoint3>() , 12usize);
        assert_eq!(::std::mem::align_of::<SkPoint3>() , 4usize);
    }
    extern "C" {
        /** Returns the Euclidian distance from (0,0,0) to (x,y,z)
    */
        #[link_name = "?Length@SkPoint3@@SAMMMM@Z"]
        pub fn SkPoint3_Length(x: root::SkScalar, y: root::SkScalar,
                               z: root::SkScalar) -> root::SkScalar;
    }
    extern "C" {
        /** Set the point (vector) to be unit-length in the same direction as it
        already points.  If the point has a degenerate length (i.e., nearly 0)
        then set it to (0,0,0) and return false; otherwise return true.
    */
        #[link_name = "?normalize@SkPoint3@@QEAA_NXZ"]
        pub fn SkPoint3_normalize(this: *mut root::SkPoint3) -> bool;
    }
    impl Clone for SkPoint3 {
        fn clone(&self) -> Self { *self }
    }
    impl SkPoint3 {
        #[inline]
        pub unsafe fn Length(x: root::SkScalar, y: root::SkScalar,
                             z: root::SkScalar) -> root::SkScalar {
            SkPoint3_Length(x, y, z)
        }
        #[inline]
        pub unsafe fn normalize(&mut self) -> bool {
            SkPoint3_normalize(&mut *self)
        }
    }
    pub type SkColor3f = root::SkPoint3;
    /** 8-bit type for an alpha value. 0xFF is 100% opaque, 0x00 is 100% transparent.
*/
    pub type SkAlpha = u8;
    /** 32 bit ARGB color value, premultiplied. The byte order for this value is
    configuration dependent, matching the format of kARGB32 bitmaps. This is different
    from SkColor, which is nonpremultiplied, and is always in the same byte order.
*/
    pub type SkPMColor = u32;
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPM4f {
        pub _address: u8,
    }
    impl Clone for SkPM4f {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkColor4f {
        pub fR: f32,
        pub fG: f32,
        pub fB: f32,
        pub fA: f32,
    }
    #[test]
    fn bindgen_test_layout_SkColor4f() {
        assert_eq!(::std::mem::size_of::<SkColor4f>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkColor4f>() , 4usize);
    }
    extern "C" {
        #[link_name = "?Pin@SkColor4f@@SA?AU1@MMMM@Z"]
        pub fn SkColor4f_Pin(r: f32, g: f32, b: f32, a: f32)
         -> root::SkColor4f;
    }
    extern "C" {
        /** Convert to SkColor4f, assuming SkColor is sRGB */
        #[link_name = "?FromColor@SkColor4f@@SA?AU1@I@Z"]
        pub fn SkColor4f_FromColor(arg1: root::SkColor) -> root::SkColor4f;
    }
    extern "C" {
        #[link_name = "?FromColor3f@SkColor4f@@SA?AU1@USkPoint3@@M@Z"]
        pub fn SkColor4f_FromColor3f(arg1: root::SkColor3f, a: f32)
         -> root::SkColor4f;
    }
    extern "C" {
        #[link_name = "?toSkColor@SkColor4f@@QEBAIXZ"]
        pub fn SkColor4f_toSkColor(this: *const root::SkColor4f)
         -> root::SkColor;
    }
    extern "C" {
        #[link_name = "?premul@SkColor4f@@QEBA?AUSkPM4f@@XZ"]
        pub fn SkColor4f_premul(this: *const root::SkColor4f) -> root::SkPM4f;
    }
    impl Clone for SkColor4f {
        fn clone(&self) -> Self { *self }
    }
    impl SkColor4f {
        #[inline]
        pub unsafe fn Pin(r: f32, g: f32, b: f32, a: f32) -> root::SkColor4f {
            SkColor4f_Pin(r, g, b, a)
        }
        #[inline]
        pub unsafe fn FromColor(arg1: root::SkColor) -> root::SkColor4f {
            SkColor4f_FromColor(arg1)
        }
        #[inline]
        pub unsafe fn FromColor3f(arg1: root::SkColor3f, a: f32)
         -> root::SkColor4f {
            SkColor4f_FromColor3f(arg1, a)
        }
        #[inline]
        pub unsafe fn toSkColor(&self) -> root::SkColor {
            SkColor4f_toSkColor(&*self)
        }
        #[inline]
        pub unsafe fn premul(&self) -> root::SkPM4f {
            SkColor4f_premul(&*self)
        }
    }
    /** \class SkFlattenable

 SkFlattenable is the base class for objects that need to be flattened
 into a data stream for either transport or as part of the key to the
 font cache.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkFlattenable {
        pub _base: root::SkRefCnt,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkFlattenable_Type {
        kSkColorFilter_Type = 0,
        kSkDrawable_Type = 1,
        kSkDrawLooper_Type = 2,
        kSkImageFilter_Type = 3,
        kSkMaskFilter_Type = 4,
        kSkPathEffect_Type = 5,
        kSkPixelRef_Type = 6,
        kSkRasterizer_Type = 7,
        kSkShader_Type = 8,
        kSkUnused_Type = 9,
        kSkXfermode_Type = 10,
        kSkNormalSource_Type = 11,
    }
    pub type SkFlattenable_Factory =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::SkReadBuffer)
                                  -> root::sk_sp<root::SkFlattenable>>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkFlattenable_PrivateInitializer {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_SkFlattenable_PrivateInitializer() {
        assert_eq!(::std::mem::size_of::<SkFlattenable_PrivateInitializer>() ,
                   1usize);
        assert_eq!(::std::mem::align_of::<SkFlattenable_PrivateInitializer>()
                   , 1usize);
    }
    extern "C" {
        #[link_name = "?InitCore@PrivateInitializer@SkFlattenable@@SAXXZ"]
        pub fn SkFlattenable_PrivateInitializer_InitCore();
    }
    extern "C" {
        #[link_name = "?InitEffects@PrivateInitializer@SkFlattenable@@SAXXZ"]
        pub fn SkFlattenable_PrivateInitializer_InitEffects();
    }
    impl Clone for SkFlattenable_PrivateInitializer {
        fn clone(&self) -> Self { *self }
    }
    impl SkFlattenable_PrivateInitializer {
        #[inline]
        pub unsafe fn InitCore() {
            SkFlattenable_PrivateInitializer_InitCore()
        }
        #[inline]
        pub unsafe fn InitEffects() {
            SkFlattenable_PrivateInitializer_InitEffects()
        }
    }
    pub type SkFlattenable_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkFlattenable() {
        assert_eq!(::std::mem::size_of::<SkFlattenable>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkFlattenable>() , 8usize);
    }
    extern "C" {
        #[link_name =
              "?NameToFactory@SkFlattenable@@SAP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@ZQEBD@Z"]
        pub fn SkFlattenable_NameToFactory(name:
                                               *const ::std::os::raw::c_char)
         -> root::SkFlattenable_Factory;
    }
    extern "C" {
        #[link_name =
              "?FactoryToName@SkFlattenable@@SAPEBDP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@Z@Z"]
        pub fn SkFlattenable_FactoryToName(arg1: root::SkFlattenable_Factory)
         -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "?NameToType@SkFlattenable@@SA_NQEBDPEAW4Type@1@@Z"]
        pub fn SkFlattenable_NameToType(name: *const ::std::os::raw::c_char,
                                        type_: *mut root::SkFlattenable_Type)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?Register@SkFlattenable@@SAXQEBDP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@ZW4Type@1@@Z"]
        pub fn SkFlattenable_Register(name: *const ::std::os::raw::c_char,
                                      arg1: root::SkFlattenable_Factory,
                                      arg2: root::SkFlattenable_Type);
    }
    impl SkFlattenable {
        #[inline]
        pub unsafe fn NameToFactory(name: *const ::std::os::raw::c_char)
         -> root::SkFlattenable_Factory {
            SkFlattenable_NameToFactory(name)
        }
        #[inline]
        pub unsafe fn FactoryToName(arg1: root::SkFlattenable_Factory)
         -> *const ::std::os::raw::c_char {
            SkFlattenable_FactoryToName(arg1)
        }
        #[inline]
        pub unsafe fn NameToType(name: *const ::std::os::raw::c_char,
                                 type_: *mut root::SkFlattenable_Type)
         -> bool {
            SkFlattenable_NameToType(name, type_)
        }
        #[inline]
        pub unsafe fn Register(name: *const ::std::os::raw::c_char,
                               arg1: root::SkFlattenable_Factory,
                               arg2: root::SkFlattenable_Type) {
            SkFlattenable_Register(name, arg1, arg2)
        }
    }
    /** \class SkColorTable

    SkColorTable holds an array SkPMColors (premultiplied 32-bit colors) used by
    8-bit bitmaps, where the bitmap bytes are interpreted as indices into the colortable.

    SkColorTable is thread-safe.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkColorTable {
        pub _base: root::SkRefCnt,
        pub fColors: *mut root::SkPMColor,
        pub f16BitCache: *mut u16,
        pub f16BitCacheOnce: root::SkOnce,
        pub fCount: ::std::os::raw::c_int,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkColorTable_AllocatedWithMalloc { kAllocatedWithMalloc = 0, }
    pub type SkColorTable_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkColorTable() {
        assert_eq!(::std::mem::size_of::<SkColorTable>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkColorTable>() , 8usize);
    }
    extern "C" {
        /** read16BitCache() returns the array of RGB16 colors that mirror the 32bit colors.
     */
        #[link_name = "?read16BitCache@SkColorTable@@QEBAPEBGXZ"]
        pub fn SkColorTable_read16BitCache(this: *const root::SkColorTable)
         -> *const u16;
    }
    extern "C" {
        #[link_name =
              "?writeToBuffer@SkColorTable@@QEBAXAEAVSkWriteBuffer@@@Z"]
        pub fn SkColorTable_writeToBuffer(this: *const root::SkColorTable,
                                          arg1: *mut root::SkWriteBuffer);
    }
    extern "C" {
        #[link_name = "?Create@SkColorTable@@SAPEAV1@AEAVSkReadBuffer@@@Z"]
        pub fn SkColorTable_Create(arg1: *mut root::SkReadBuffer)
         -> *mut root::SkColorTable;
    }
    extern "C" {
        /** Copy up to 256 colors into a new SkColorTable.
     */
        #[link_name = "??0SkColorTable@@QEAA@QEBIH@Z"]
        pub fn SkColorTable_SkColorTable(this: *mut root::SkColorTable,
                                         colors: *const root::SkPMColor,
                                         count: ::std::os::raw::c_int);
    }
    impl SkColorTable {
        #[inline]
        pub unsafe fn read16BitCache(&self) -> *const u16 {
            SkColorTable_read16BitCache(&*self)
        }
        #[inline]
        pub unsafe fn writeToBuffer(&self, arg1: *mut root::SkWriteBuffer) {
            SkColorTable_writeToBuffer(&*self, arg1)
        }
        #[inline]
        pub unsafe fn Create(arg1: *mut root::SkReadBuffer)
         -> *mut root::SkColorTable {
            SkColorTable_Create(arg1)
        }
        #[inline]
        pub unsafe fn new(colors: *const root::SkPMColor,
                          count: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkColorTable_SkColorTable(&mut __bindgen_tmp, colors, count);
            __bindgen_tmp
        }
    }
    /** \class SkMask
    SkMask is used to describe alpha bitmaps, either 1bit, 8bit, or
    the 3-channel 3D format. These are passed to SkMaskFilter objects.
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMask {
        pub fImage: *mut u8,
        pub fBounds: root::SkIRect,
        pub fRowBytes: u32,
        pub fFormat: root::SkMask_Format,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMask_Format {
        kBW_Format = 0,
        kA8_Format = 1,
        k3D_Format = 2,
        kARGB32_Format = 3,
        kLCD16_Format = 4,
    }
    pub const SkMask_kCountMaskFormats: root::SkMask__bindgen_ty_1 =
        SkMask__bindgen_ty_1::kCountMaskFormats;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMask__bindgen_ty_1 { kCountMaskFormats = 5, }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMask_CreateMode {
        kJustComputeBounds_CreateMode = 0,
        kJustRenderImage_CreateMode = 1,
        kComputeBoundsAndRenderImage_CreateMode = 2,
    }
    #[test]
    fn bindgen_test_layout_SkMask() {
        assert_eq!(::std::mem::size_of::<SkMask>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkMask>() , 8usize);
    }
    extern "C" {
        /** Return the byte size of the mask, assuming only 1 plane.
        Does not account for k3D_Format. For that, use computeTotalImageSize().
        If there is an overflow of 32bits, then returns 0.
    */
        #[link_name = "?computeImageSize@SkMask@@QEBA_KXZ"]
        pub fn SkMask_computeImageSize(this: *const root::SkMask) -> usize;
    }
    extern "C" {
        /** Return the byte size of the mask, taking into account
        any extra planes (e.g. k3D_Format).
        If there is an overflow of 32bits, then returns 0.
    */
        #[link_name = "?computeTotalImageSize@SkMask@@QEBA_KXZ"]
        pub fn SkMask_computeTotalImageSize(this: *const root::SkMask)
         -> usize;
    }
    extern "C" {
        /**
     *  Returns the address of the specified pixel, computing the pixel-size
     *  at runtime based on the mask format. This will be slightly slower than
     *  using one of the routines where the format is implied by the name
     *  e.g. getAddr8 or getAddr32.
     *
     *  x,y must be contained by the mask's bounds (this is asserted in the
     *  debug build, but not checked in the release build.)
     *
     *  This should not be called with kBW_Format, as it will give unspecified
     *  results (and assert in the debug build).
     */
        #[link_name = "?getAddr@SkMask@@QEBAPEAXHH@Z"]
        pub fn SkMask_getAddr(this: *const root::SkMask,
                              x: ::std::os::raw::c_int,
                              y: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?AllocImage@SkMask@@SAPEAE_K@Z"]
        pub fn SkMask_AllocImage(bytes: usize) -> *mut u8;
    }
    extern "C" {
        #[link_name = "?FreeImage@SkMask@@SAXPEAX@Z"]
        pub fn SkMask_FreeImage(image: *mut ::std::os::raw::c_void);
    }
    impl Clone for SkMask {
        fn clone(&self) -> Self { *self }
    }
    impl SkMask {
        #[inline]
        pub unsafe fn computeImageSize(&self) -> usize {
            SkMask_computeImageSize(&*self)
        }
        #[inline]
        pub unsafe fn computeTotalImageSize(&self) -> usize {
            SkMask_computeTotalImageSize(&*self)
        }
        #[inline]
        pub unsafe fn getAddr(&self, x: ::std::os::raw::c_int,
                              y: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void {
            SkMask_getAddr(&*self, x, y)
        }
        #[inline]
        pub unsafe fn AllocImage(bytes: usize) -> *mut u8 {
            SkMask_AllocImage(bytes)
        }
        #[inline]
        pub unsafe fn FreeImage(image: *mut ::std::os::raw::c_void) {
            SkMask_FreeImage(image)
        }
    }
    /**
 *  Pairs SkImageInfo with actual pixels and rowbytes. This class does not try to manage the
 *  lifetime of the pixel memory (nor the colortable if provided).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPixmap {
        pub fPixels: *const ::std::os::raw::c_void,
        pub fCTable: *mut root::SkColorTable,
        pub fRowBytes: usize,
        pub fInfo: root::SkImageInfo,
    }
    #[test]
    fn bindgen_test_layout_SkPixmap() {
        assert_eq!(::std::mem::size_of::<SkPixmap>() , 48usize);
        assert_eq!(::std::mem::align_of::<SkPixmap>() , 8usize);
    }
    extern "C" {
        #[link_name = "?reset@SkPixmap@@QEAAXXZ"]
        pub fn SkPixmap_reset(this: *mut root::SkPixmap);
    }
    extern "C" {
        #[link_name =
              "?reset@SkPixmap@@QEAAXAEBUSkImageInfo@@PEBX_KPEAVSkColorTable@@@Z"]
        pub fn SkPixmap_reset1(this: *mut root::SkPixmap,
                               info: *const root::SkImageInfo,
                               addr: *const ::std::os::raw::c_void,
                               rowBytes: usize,
                               ctable: *mut root::SkColorTable);
    }
    extern "C" {
        #[link_name =
              "?setColorSpace@SkPixmap@@QEAAXV?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkPixmap_setColorSpace(this: *mut root::SkPixmap,
                                      arg1: root::sk_sp<root::SkColorSpace>);
    }
    extern "C" {
        /**
     *  If supported, set this pixmap to point to the pixels in the specified mask and return true.
     *  On failure, return false and set this pixmap to empty.
     */
        #[link_name = "?reset@SkPixmap@@QEAA_NAEBUSkMask@@@Z"]
        pub fn SkPixmap_reset2(this: *mut root::SkPixmap,
                               arg1: *const root::SkMask) -> bool;
    }
    extern "C" {
        /**
     *  Computes the intersection of area and this pixmap. If that intersection is non-empty,
     *  set subset to that intersection and return true.
     *
     *  On failure, return false and ignore the subset parameter.
     */
        #[link_name = "?extractSubset@SkPixmap@@QEBA_NPEAV1@AEBUSkIRect@@@Z"]
        pub fn SkPixmap_extractSubset(this: *const root::SkPixmap,
                                      subset: *mut root::SkPixmap,
                                      area: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /**
     *  This will brute-force return true if all of the pixels in the pixmap
     *  are opaque. If there are no pixels, or encounters an error, returns false.
     */
        #[link_name = "?computeIsOpaque@SkPixmap@@QEBA_NXZ"]
        pub fn SkPixmap_computeIsOpaque(this: *const root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Converts the pixel at the specified coordinate to an unpremultiplied
     *  SkColor. Note: this ignores any SkColorSpace information, and may return
     *  lower precision data than is actually in the pixel. Alpha only
     *  colortypes (e.g. kAlpha_8_SkColorType) return black with the appropriate
     *  alpha set.  The value is undefined for kUnknown_SkColorType or if x or y
     *  are out of bounds, or if the pixtap does not have any pixels.
     */
        #[link_name = "?getColor@SkPixmap@@QEBAIHH@Z"]
        pub fn SkPixmap_getColor(this: *const root::SkPixmap,
                                 x: ::std::os::raw::c_int,
                                 y: ::std::os::raw::c_int) -> root::SkColor;
    }
    extern "C" {
        #[link_name =
              "?readPixels@SkPixmap@@QEBA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
        pub fn SkPixmap_readPixels(this: *const root::SkPixmap,
                                   dstInfo: *const root::SkImageInfo,
                                   dstPixels: *mut ::std::os::raw::c_void,
                                   dstRowBytes: usize,
                                   srcX: ::std::os::raw::c_int,
                                   srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Copy the pixels from this pixmap into the dst pixmap, converting as needed into dst's
     *  colortype/alphatype. If the conversion cannot be performed, false is returned.
     *
     *  If dst's dimensions differ from the src dimension, the image will be scaled, applying the
     *  specified filter-quality.
     */
        #[link_name =
              "?scalePixels@SkPixmap@@QEBA_NAEBV1@W4SkFilterQuality@@@Z"]
        pub fn SkPixmap_scalePixels(this: *const root::SkPixmap,
                                    dst: *const root::SkPixmap,
                                    arg1: root::SkFilterQuality) -> bool;
    }
    extern "C" {
        /**
     *  Returns true if pixels were written to (e.g. if colorType is kUnknown_SkColorType, this
     *  will return false). If subset does not intersect the bounds of this pixmap, returns false.
     */
        #[link_name = "?erase@SkPixmap@@QEBA_NIAEBUSkIRect@@@Z"]
        pub fn SkPixmap_erase(this: *const root::SkPixmap,
                              arg1: root::SkColor,
                              subset: *const root::SkIRect) -> bool;
    }
    extern "C" {
        #[link_name = "?erase@SkPixmap@@QEBA_NAEBUSkColor4f@@PEBUSkIRect@@@Z"]
        pub fn SkPixmap_erase1(this: *const root::SkPixmap,
                               arg1: *const root::SkColor4f,
                               subset: *const root::SkIRect) -> bool;
    }
    impl SkPixmap {
        #[inline]
        pub unsafe fn reset(&mut self) { SkPixmap_reset(&mut *self) }
        #[inline]
        pub unsafe fn reset1(&mut self, info: *const root::SkImageInfo,
                             addr: *const ::std::os::raw::c_void,
                             rowBytes: usize,
                             ctable: *mut root::SkColorTable) {
            SkPixmap_reset1(&mut *self, info, addr, rowBytes, ctable)
        }
        #[inline]
        pub unsafe fn setColorSpace(&mut self,
                                    arg1: root::sk_sp<root::SkColorSpace>) {
            SkPixmap_setColorSpace(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn reset2(&mut self, arg1: *const root::SkMask) -> bool {
            SkPixmap_reset2(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn extractSubset(&self, subset: *mut root::SkPixmap,
                                    area: *const root::SkIRect) -> bool {
            SkPixmap_extractSubset(&*self, subset, area)
        }
        #[inline]
        pub unsafe fn computeIsOpaque(&self) -> bool {
            SkPixmap_computeIsOpaque(&*self)
        }
        #[inline]
        pub unsafe fn getColor(&self, x: ::std::os::raw::c_int,
                               y: ::std::os::raw::c_int) -> root::SkColor {
            SkPixmap_getColor(&*self, x, y)
        }
        #[inline]
        pub unsafe fn readPixels(&self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int) -> bool {
            SkPixmap_readPixels(&*self, dstInfo, dstPixels, dstRowBytes, srcX,
                                srcY)
        }
        #[inline]
        pub unsafe fn scalePixels(&self, dst: *const root::SkPixmap,
                                  arg1: root::SkFilterQuality) -> bool {
            SkPixmap_scalePixels(&*self, dst, arg1)
        }
        #[inline]
        pub unsafe fn erase(&self, arg1: root::SkColor,
                            subset: *const root::SkIRect) -> bool {
            SkPixmap_erase(&*self, arg1, subset)
        }
        #[inline]
        pub unsafe fn erase1(&self, arg1: *const root::SkColor4f,
                             subset: *const root::SkIRect) -> bool {
            SkPixmap_erase1(&*self, arg1, subset)
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkAutoPixmapUnlock {
        pub fUnlockProc: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::std::os::raw::c_void)>,
        pub fUnlockContext: *mut ::std::os::raw::c_void,
        pub fPixmap: root::SkPixmap,
        pub fIsLocked: bool,
    }
    #[test]
    fn bindgen_test_layout_SkAutoPixmapUnlock() {
        assert_eq!(::std::mem::size_of::<SkAutoPixmapUnlock>() , 72usize);
        assert_eq!(::std::mem::align_of::<SkAutoPixmapUnlock>() , 8usize);
    }
    extern "C" {
        /**
     *  If there is a currently locked pixmap, unlock it, then copy the specified pixmap
     *  and (optional) unlock proc/context.
     */
        #[link_name =
              "?reset@SkAutoPixmapUnlock@@QEAAXAEBVSkPixmap@@P6AXPEAX@Z1@Z"]
        pub fn SkAutoPixmapUnlock_reset(this: *mut root::SkAutoPixmapUnlock,
                                        pm: *const root::SkPixmap,
                                        unlock:
                                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                           *mut ::std::os::raw::c_void)>,
                                        ctx: *mut ::std::os::raw::c_void);
    }
    impl SkAutoPixmapUnlock {
        #[inline]
        pub unsafe fn reset(&mut self, pm: *const root::SkPixmap,
                            unlock:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut ::std::os::raw::c_void)>,
                            ctx: *mut ::std::os::raw::c_void) {
            SkAutoPixmapUnlock_reset(&mut *self, pm, unlock, ctx)
        }
    }
    #[test]
    fn __bindgen_test_layout_template_5() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkShader>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkShader>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_6() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkColorFilter>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkColorFilter>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_7() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkPathEffect>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkPathEffect>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_8() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkMaskFilter>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkMaskFilter>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_9() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkTypeface>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkTypeface>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_10() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkRasterizer>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkRasterizer>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_11() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkImageFilter>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkImageFilter>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_12() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkDrawLooper>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkDrawLooper>>() ,
                   8usize);
    }
    /** \class SkPaint

    The SkPaint class holds the style and color information about how to draw
    geometries, text and bitmaps.
*/
    #[repr(C)]
    pub struct SkPaint {
        pub fTypeface: root::sk_sp<root::SkTypeface>,
        pub fPathEffect: root::sk_sp<root::SkPathEffect>,
        pub fShader: root::sk_sp<root::SkShader>,
        pub fMaskFilter: root::sk_sp<root::SkMaskFilter>,
        pub fColorFilter: root::sk_sp<root::SkColorFilter>,
        pub fRasterizer: root::sk_sp<root::SkRasterizer>,
        pub fDrawLooper: root::sk_sp<root::SkDrawLooper>,
        pub fImageFilter: root::sk_sp<root::SkImageFilter>,
        pub fTextSize: root::SkScalar,
        pub fTextScaleX: root::SkScalar,
        pub fTextSkewX: root::SkScalar,
        pub fColor: root::SkColor,
        pub fWidth: root::SkScalar,
        pub fMiterLimit: root::SkScalar,
        pub fBlendMode: u32,
        pub __bindgen_anon_1: root::SkPaint__bindgen_ty_1,
    }
    #[repr(i32)]
    /** Specifies the level of hinting to be performed. These names are taken
        from the Gnome/Cairo names for the same. They are translated into
        Freetype concepts the same as in cairo-ft-font.c:
           kNo_Hinting     -> FT_LOAD_NO_HINTING
           kSlight_Hinting -> FT_LOAD_TARGET_LIGHT
           kNormal_Hinting -> <default, no option>
           kFull_Hinting   -> <same as kNormalHinting, unless we are rendering
                              subpixel glyphs, in which case TARGET_LCD or
                              TARGET_LCD_V is used>
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Hinting {
        kNo_Hinting = 0,
        kSlight_Hinting = 1,
        kNormal_Hinting = 2,
        kFull_Hinting = 3,
    }
    pub const SkPaint_Flags_kAntiAlias_Flag: root::SkPaint_Flags =
        SkPaint_Flags(1);
    pub const SkPaint_Flags_kDither_Flag: root::SkPaint_Flags =
        SkPaint_Flags(4);
    pub const SkPaint_Flags_kUnderlineText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(8);
    pub const SkPaint_Flags_kStrikeThruText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(16);
    pub const SkPaint_Flags_kFakeBoldText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(32);
    pub const SkPaint_Flags_kLinearText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(64);
    pub const SkPaint_Flags_kSubpixelText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(128);
    pub const SkPaint_Flags_kDevKernText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(256);
    pub const SkPaint_Flags_kLCDRenderText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(512);
    pub const SkPaint_Flags_kEmbeddedBitmapText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(1024);
    pub const SkPaint_Flags_kAutoHinting_Flag: root::SkPaint_Flags =
        SkPaint_Flags(2048);
    pub const SkPaint_Flags_kVerticalText_Flag: root::SkPaint_Flags =
        SkPaint_Flags(4096);
    pub const SkPaint_Flags_kGenA8FromLCD_Flag: root::SkPaint_Flags =
        SkPaint_Flags(8192);
    pub const SkPaint_Flags_kAllFlags: root::SkPaint_Flags =
        SkPaint_Flags(65535);
    impl ::std::ops::BitOr<root::SkPaint_Flags> for root::SkPaint_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkPaint_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    /** Specifies the bit values that are stored in the paint's flags.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkPaint_Flags(pub i32);
    #[repr(i32)]
    /** Styles apply to rect, oval, path, and text.
        Bitmaps are always drawn in "fill", and lines are always drawn in
        "stroke".

        Note: strokeandfill implicitly draws the result with
        SkPath::kWinding_FillType, so if the original path is even-odd, the
        results may not appear the same as if it was drawn twice, filled and
        then stroked.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Style {
        kFill_Style = 0,
        kStroke_Style = 1,
        kStrokeAndFill_Style = 2,
    }
    pub const SkPaint_kStyleCount: root::SkPaint__bindgen_ty_2 =
        SkPaint__bindgen_ty_2::kStyleCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint__bindgen_ty_2 { kStyleCount = 3, }
    pub const SkPaint_Cap_kLast_Cap: root::SkPaint_Cap =
        SkPaint_Cap::kSquare_Cap;
    pub const SkPaint_Cap_kDefault_Cap: root::SkPaint_Cap =
        SkPaint_Cap::kButt_Cap;
    #[repr(i32)]
    /** Cap enum specifies the settings for the paint's strokecap. This is the
        treatment that is applied to the beginning and end of each non-closed
        contour (e.g. lines).

        If the cap is round or square, the caps are drawn when the contour has
        a zero length. Zero length contours can be created by following moveTo
        with a lineTo at the same point, or a moveTo followed by a close.

        A dash with an on interval of zero also creates a zero length contour.

        The zero length contour draws the square cap without rotation, since
        the no direction can be inferred.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Cap { kButt_Cap = 0, kRound_Cap = 1, kSquare_Cap = 2, }
    pub const SkPaint_Join_kLast_Join: root::SkPaint_Join =
        SkPaint_Join::kBevel_Join;
    pub const SkPaint_Join_kDefault_Join: root::SkPaint_Join =
        SkPaint_Join::kMiter_Join;
    #[repr(i32)]
    /** Join enum specifies the settings for the paint's strokejoin. This is
        the treatment that is applied to corners in paths and rectangles.
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Join {
        kMiter_Join = 0,
        kRound_Join = 1,
        kBevel_Join = 2,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_Align {
        kLeft_Align = 0,
        kCenter_Align = 1,
        kRight_Align = 2,
    }
    pub const SkPaint_kAlignCount: root::SkPaint__bindgen_ty_3 =
        SkPaint__bindgen_ty_3::kAlignCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint__bindgen_ty_3 { kAlignCount = 3, }
    #[repr(i32)]
    /** Describes how to interpret the text parameters that are passed to paint
        methods like measureText() and getTextWidths().
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint_TextEncoding {
        kUTF8_TextEncoding = 0,
        kUTF16_TextEncoding = 1,
        kUTF32_TextEncoding = 2,
        kGlyphID_TextEncoding = 3,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPaint_FontMetrics {
        //< Bit field to identify which values are unknown
        pub fFlags: u32,
        //< The greatest distance above the baseline for any glyph (will be <= 0)
        pub fTop: root::SkScalar,
        //< The recommended distance above the baseline (will be <= 0)
        pub fAscent: root::SkScalar,
        //< The recommended distance below the baseline (will be >= 0)
        pub fDescent: root::SkScalar,
        //< The greatest distance below the baseline for any glyph (will be >= 0)
        pub fBottom: root::SkScalar,
        //< The recommended distance to add between lines of text (will be >= 0)
        pub fLeading: root::SkScalar,
        //< the average character width (>= 0)
        pub fAvgCharWidth: root::SkScalar,
        //< the max character width (>= 0)
        pub fMaxCharWidth: root::SkScalar,
        //< The minimum bounding box x value for all glyphs
        pub fXMin: root::SkScalar,
        //< The maximum bounding box x value for all glyphs
        pub fXMax: root::SkScalar,
        //< The height of an 'x' in px, or 0 if no 'x' in face
        pub fXHeight: root::SkScalar,
        //< The cap height (> 0), or 0 if cannot be determined.
        pub fCapHeight: root::SkScalar,
        //< underline thickness, or 0 if cannot be determined
        pub fUnderlineThickness: root::SkScalar,
        //< underline position, or 0 if cannot be determined
        pub fUnderlinePosition: root::SkScalar,
    }
    pub const SkPaint_FontMetrics_FontMetricsFlags_kUnderlineThinknessIsValid_Flag:
              root::SkPaint_FontMetrics_FontMetricsFlags =
        SkPaint_FontMetrics_FontMetricsFlags(1);
    pub const SkPaint_FontMetrics_FontMetricsFlags_kUnderlinePositionIsValid_Flag:
              root::SkPaint_FontMetrics_FontMetricsFlags =
        SkPaint_FontMetrics_FontMetricsFlags(2);
    impl ::std::ops::BitOr<root::SkPaint_FontMetrics_FontMetricsFlags> for
     root::SkPaint_FontMetrics_FontMetricsFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkPaint_FontMetrics_FontMetricsFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    /** Flags which indicate the confidence level of various metrics.
            A set flag indicates that the metric may be trusted.
        */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkPaint_FontMetrics_FontMetricsFlags(pub i32);
    #[test]
    fn bindgen_test_layout_SkPaint_FontMetrics() {
        assert_eq!(::std::mem::size_of::<SkPaint_FontMetrics>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkPaint_FontMetrics>() , 4usize);
    }
    impl Clone for SkPaint_FontMetrics {
        fn clone(&self) -> Self { *self }
    }
    pub type SkPaint_GlyphCacheProc =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::SkGlyphCache,
                                                   arg2:
                                                       *mut *const ::std::os::raw::c_char)
                                  -> *const root::SkGlyph>;
    #[repr(C)]
    #[derive(Copy)]
    pub union SkPaint__bindgen_ty_1 {
        pub fBitfields: root::SkPaint__bindgen_ty_1__bindgen_ty_1,
        pub fBitfieldsUInt: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPaint__bindgen_ty_1__bindgen_ty_1 {
        pub _bitfield_1: u32,
    }
    #[test]
    fn bindgen_test_layout_SkPaint__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>()
                   , 4usize);
        assert_eq!(::std::mem::align_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>()
                   , 4usize);
    }
    impl Clone for SkPaint__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    impl SkPaint__bindgen_ty_1__bindgen_ty_1 {
        #[inline]
        pub fn fFlags(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (65535usize as u32)) >> 0u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_fFlags(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(65535usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 0u32) & (65535usize as u32);
        }
        #[inline]
        pub fn fTextAlign(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (196608usize as u32)) >> 16u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_fTextAlign(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(196608usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 16u32) & (196608usize as u32);
        }
        #[inline]
        pub fn fCapType(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (786432usize as u32)) >> 18u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_fCapType(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(786432usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 18u32) & (786432usize as u32);
        }
        #[inline]
        pub fn fJoinType(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (3145728usize as u32)) >> 20u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fJoinType(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(3145728usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 20u32) & (3145728usize as u32);
        }
        #[inline]
        pub fn fStyle(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (12582912usize as u32)) >> 22u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fStyle(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(12582912usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 22u32) & (12582912usize as u32);
        }
        #[inline]
        pub fn fTextEncoding(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (50331648usize as u32)) >> 24u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fTextEncoding(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(50331648usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 24u32) & (50331648usize as u32);
        }
        #[inline]
        pub fn fHinting(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (201326592usize as u32)) >> 26u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fHinting(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(201326592usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 26u32) & (201326592usize as u32);
        }
        #[inline]
        pub fn fFilterQuality(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (805306368usize as u32)) >> 28u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_fFilterQuality(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(805306368usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 28u32) & (805306368usize as u32);
        }
    }
    #[test]
    fn bindgen_test_layout_SkPaint__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<SkPaint__bindgen_ty_1>() , 4usize);
        assert_eq!(::std::mem::align_of::<SkPaint__bindgen_ty_1>() , 4usize);
    }
    impl Clone for SkPaint__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    pub const SkPaint_ScalerContextFlags_kNone_ScalerContextFlags:
              root::SkPaint_ScalerContextFlags =
        SkPaint_ScalerContextFlags(0);
    pub const SkPaint_ScalerContextFlags_kFakeGamma_ScalerContextFlag:
              root::SkPaint_ScalerContextFlags =
        SkPaint_ScalerContextFlags(1);
    pub const SkPaint_ScalerContextFlags_kBoostContrast_ScalerContextFlag:
              root::SkPaint_ScalerContextFlags =
        SkPaint_ScalerContextFlags(2);
    pub const SkPaint_ScalerContextFlags_kFakeGammaAndBoostContrast_ScalerContextFlags:
              root::SkPaint_ScalerContextFlags =
        SkPaint_ScalerContextFlags(3);
    impl ::std::ops::BitOr<root::SkPaint_ScalerContextFlags> for
     root::SkPaint_ScalerContextFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkPaint_ScalerContextFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkPaint_ScalerContextFlags(pub u32);
    pub const SkPaint_kCanonicalTextSizeForPaths: root::SkPaint__bindgen_ty_4
              =
        SkPaint__bindgen_ty_4::kCanonicalTextSizeForPaths;
    pub const SkPaint_kMaxSizeForGlyphCache: root::SkPaint__bindgen_ty_4 =
        SkPaint__bindgen_ty_4::kMaxSizeForGlyphCache;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPaint__bindgen_ty_4 {
        kCanonicalTextSizeForPaths = 64,
        kMaxSizeForGlyphCache = 256,
    }
    pub const SkPaint_kCapCount: ::std::os::raw::c_int = 3;
    pub const SkPaint_kJoinCount: ::std::os::raw::c_int = 3;
    #[test]
    fn bindgen_test_layout_SkPaint() {
        assert_eq!(::std::mem::size_of::<SkPaint>() , 96usize);
        assert_eq!(::std::mem::align_of::<SkPaint>() , 8usize);
    }
    extern "C" {
        /** getHash() is a shallow hash, with the same limitations as operator==.
     *  If operator== returns true for two paints, getHash() returns the same value for each.
     */
        #[link_name = "?getHash@SkPaint@@QEBAIXZ"]
        pub fn SkPaint_getHash(this: *const root::SkPaint) -> u32;
    }
    extern "C" {
        #[link_name = "?flatten@SkPaint@@QEBAXAEAVSkWriteBuffer@@@Z"]
        pub fn SkPaint_flatten(this: *const root::SkPaint,
                               arg1: *mut root::SkWriteBuffer);
    }
    extern "C" {
        #[link_name = "?unflatten@SkPaint@@QEAAXAEAVSkReadBuffer@@@Z"]
        pub fn SkPaint_unflatten(this: *mut root::SkPaint,
                                 arg1: *mut root::SkReadBuffer);
    }
    extern "C" {
        /** Restores the paint to its initial settings.
    */
        #[link_name = "?reset@SkPaint@@QEAAXXZ"]
        pub fn SkPaint_reset(this: *mut root::SkPaint);
    }
    extern "C" {
        #[link_name = "?setHinting@SkPaint@@QEAAXW4Hinting@1@@Z"]
        pub fn SkPaint_setHinting(this: *mut root::SkPaint,
                                  hintingLevel: root::SkPaint_Hinting);
    }
    extern "C" {
        /** Set the paint's flags. Use the Flag enum to specific flag values.
        @param flags    The new flag bits for the paint (see Flags enum)
    */
        #[link_name = "?setFlags@SkPaint@@QEAAXI@Z"]
        pub fn SkPaint_setFlags(this: *mut root::SkPaint, flags: u32);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kAntiAlias_Flag bit
        @param aa   true to enable antialiasing, false to disable it
        */
        #[link_name = "?setAntiAlias@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setAntiAlias(this: *mut root::SkPaint, aa: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kDither_Flag bit
        @param dither   true to enable dithering, false to disable it
        */
        #[link_name = "?setDither@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setDither(this: *mut root::SkPaint, dither: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kLinearText_Flag bit
        @param linearText true to set the linearText bit in the paint's flags,
                          false to clear it.
    */
        #[link_name = "?setLinearText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setLinearText(this: *mut root::SkPaint,
                                     linearText: bool);
    }
    extern "C" {
        /**
     *  Helper for setFlags(), setting or clearing the kSubpixelText_Flag.
     *  @param subpixelText true to set the subpixelText bit in the paint's
     *                      flags, false to clear it.
     */
        #[link_name = "?setSubpixelText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setSubpixelText(this: *mut root::SkPaint,
                                       subpixelText: bool);
    }
    extern "C" {
        /**
     *  Helper for setFlags(), setting or clearing the kLCDRenderText_Flag.
     *  Note: antialiasing must also be on for lcd rendering
     *  @param lcdText true to set the LCDRenderText bit in the paint's flags,
     *                 false to clear it.
     */
        #[link_name = "?setLCDRenderText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setLCDRenderText(this: *mut root::SkPaint,
                                        lcdText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kEmbeddedBitmapText_Flag bit
        @param useEmbeddedBitmapText true to set the kEmbeddedBitmapText bit in the paint's flags,
                                     false to clear it.
    */
        #[link_name = "?setEmbeddedBitmapText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setEmbeddedBitmapText(this: *mut root::SkPaint,
                                             useEmbeddedBitmapText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kAutoHinting_Flag bit
        @param useAutohinter true to set the kEmbeddedBitmapText bit in the
                                  paint's flags,
                             false to clear it.
    */
        #[link_name = "?setAutohinted@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setAutohinted(this: *mut root::SkPaint,
                                     useAutohinter: bool);
    }
    extern "C" {
        /**
     *  Helper for setting or clearing the kVerticalText_Flag bit in
     *  setFlags(...).
     *
     *  If this bit is set, then advances are treated as Y values rather than
     *  X values, and drawText will places its glyphs vertically rather than
     *  horizontally.
     */
        #[link_name = "?setVerticalText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setVerticalText(this: *mut root::SkPaint, arg1: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kUnderlineText_Flag bit
        @param underlineText true to set the underlineText bit in the paint's
                             flags, false to clear it.
    */
        #[link_name = "?setUnderlineText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setUnderlineText(this: *mut root::SkPaint,
                                        underlineText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kStrikeThruText_Flag bit
        @param strikeThruText   true to set the strikeThruText bit in the
                                paint's flags, false to clear it.
    */
        #[link_name = "?setStrikeThruText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setStrikeThruText(this: *mut root::SkPaint,
                                         strikeThruText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kFakeBoldText_Flag bit
        @param fakeBoldText true to set the kFakeBoldText_Flag bit in the paint's
                            flags, false to clear it.
    */
        #[link_name = "?setFakeBoldText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setFakeBoldText(this: *mut root::SkPaint,
                                       fakeBoldText: bool);
    }
    extern "C" {
        /** Helper for setFlags(), setting or clearing the kKernText_Flag bit
        @param kernText true to set the kKernText_Flag bit in the paint's
                            flags, false to clear it.
    */
        #[link_name = "?setDevKernText@SkPaint@@QEAAX_N@Z"]
        pub fn SkPaint_setDevKernText(this: *mut root::SkPaint,
                                      devKernText: bool);
    }
    extern "C" {
        /**
     *  Set the filter quality. This affects the quality (and performance) of
     *  drawing scaled images.
     */
        #[link_name = "?setFilterQuality@SkPaint@@QEAAXW4SkFilterQuality@@@Z"]
        pub fn SkPaint_setFilterQuality(this: *mut root::SkPaint,
                                        quality: root::SkFilterQuality);
    }
    extern "C" {
        /** Set the paint's style, used for controlling how primitives'
        geometries are interpreted (except for drawBitmap, which always assumes
        Fill).
        @param style    The new style to set in the paint
    */
        #[link_name = "?setStyle@SkPaint@@QEAAXW4Style@1@@Z"]
        pub fn SkPaint_setStyle(this: *mut root::SkPaint,
                                style: root::SkPaint_Style);
    }
    extern "C" {
        /** Set the paint's color. Note that the color is a 32bit value containing
        alpha as well as r,g,b. This 32bit value is not premultiplied, meaning
        that its alpha can be any value, regardless of the values of r,g,b.
        @param color    The new color (including alpha) to set in the paint.
    */
        #[link_name = "?setColor@SkPaint@@QEAAXI@Z"]
        pub fn SkPaint_setColor(this: *mut root::SkPaint,
                                color: root::SkColor);
    }
    extern "C" {
        /** Helper to setColor(), that only assigns the color's alpha value,
        leaving its r,g,b values unchanged.
        @param a    set the alpha component (0..255) of the paint's color.
    */
        #[link_name = "?setAlpha@SkPaint@@QEAAXI@Z"]
        pub fn SkPaint_setAlpha(this: *mut root::SkPaint, a: root::U8CPU);
    }
    extern "C" {
        /** Helper to setColor(), that takes a,r,g,b and constructs the color value
        using SkColorSetARGB()
        @param a    The new alpha component (0..255) of the paint's color.
        @param r    The new red component (0..255) of the paint's color.
        @param g    The new green component (0..255) of the paint's color.
        @param b    The new blue component (0..255) of the paint's color.
    */
        #[link_name = "?setARGB@SkPaint@@QEAAXIIII@Z"]
        pub fn SkPaint_setARGB(this: *mut root::SkPaint, a: root::U8CPU,
                               r: root::U8CPU, g: root::U8CPU,
                               b: root::U8CPU);
    }
    extern "C" {
        /** Set the width for stroking.
        Pass 0 to stroke in hairline mode.
        Hairlines always draw 1-pixel wide, regardless of the matrix.
        @param width set the paint's stroke width, used whenever the paint's
                     style is Stroke or StrokeAndFill.
    */
        #[link_name = "?setStrokeWidth@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setStrokeWidth(this: *mut root::SkPaint,
                                      width: root::SkScalar);
    }
    extern "C" {
        /** Set the paint's stroke miter value. This is used to control the
        behavior of miter joins when the joins angle is sharp. This value must
        be >= 0.
        @param miter    set the miter limit on the paint, used whenever the
                        paint's style is Stroke or StrokeAndFill.
    */
        #[link_name = "?setStrokeMiter@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setStrokeMiter(this: *mut root::SkPaint,
                                      miter: root::SkScalar);
    }
    extern "C" {
        /** Set the paint's stroke cap type.
        @param cap  set the paint's line cap style, used whenever the paint's
                    style is Stroke or StrokeAndFill.
    */
        #[link_name = "?setStrokeCap@SkPaint@@QEAAXW4Cap@1@@Z"]
        pub fn SkPaint_setStrokeCap(this: *mut root::SkPaint,
                                    cap: root::SkPaint_Cap);
    }
    extern "C" {
        /** Set the paint's stroke join type.
        @param join set the paint's line join style, used whenever the paint's
                    style is Stroke or StrokeAndFill.
    */
        #[link_name = "?setStrokeJoin@SkPaint@@QEAAXW4Join@1@@Z"]
        pub fn SkPaint_setStrokeJoin(this: *mut root::SkPaint,
                                     join: root::SkPaint_Join);
    }
    extern "C" {
        /**
     *  Applies any/all effects (patheffect, stroking) to src, returning the
     *  result in dst. The result is that drawing src with this paint will be
     *  the same as drawing dst with a default paint (at least from the
     *  geometric perspective).
     *
     *  @param src  input path
     *  @param dst  output path (may be the same as src)
     *  @param cullRect If not null, the dst path may be culled to this rect.
     *  @param resScale If > 1, increase precision, else if (0 < res < 1) reduce precision
     *              in favor of speed/size.
     *  @return     true if the path should be filled, or false if it should be
     *              drawn with a hairline (width == 0)
     */
        #[link_name =
              "?getFillPath@SkPaint@@QEBA_NAEBVSkPath@@PEAV2@PEBUSkRect@@M@Z"]
        pub fn SkPaint_getFillPath(this: *const root::SkPaint,
                                   src: *const root::SkPath,
                                   dst: *mut root::SkPath,
                                   cullRect: *const root::SkRect,
                                   resScale: root::SkScalar) -> bool;
    }
    extern "C" {
        /** Set or clear the shader object.
     *  Shaders specify the source color(s) for what is being drawn. If a paint
     *  has no shader, then the paint's color is used. If the paint has a
     *  shader, then the shader's color(s) are use instead, but they are
     *  modulated by the paint's alpha. This makes it easy to create a shader
     *  once (e.g. bitmap tiling or gradient) and then change its transparency
     *  w/o having to modify the original shader... only the paint's alpha needs
     *  to be modified.
     *
     *  There is an exception to this only-respect-paint's-alpha rule: If the shader only generates
     *  alpha (e.g. SkShader::CreateBitmapShader(bitmap) where bitmap's colortype is kAlpha_8)
     *  then the shader will use the paint's entire color to "colorize" its output (modulating the
     *  bitmap's alpha with the paint's color+alpha).
     *
     *  Pass NULL to clear any previous shader.
     *  As a convenience, the parameter passed is also returned.
     *  If a previous shader exists, its reference count is decremented.
     *  If shader is not NULL, its reference count is incremented.
     *  @param shader   May be NULL. The shader to be installed in the paint
     */
        #[link_name = "?setShader@SkPaint@@QEAAXV?$sk_sp@VSkShader@@@@@Z"]
        pub fn SkPaint_setShader(this: *mut root::SkPaint,
                                 arg1: root::sk_sp<root::SkShader>);
    }
    extern "C" {
        /** Set or clear the paint's colorfilter.
        <p />
        If the paint already has a filter, its reference count is decremented.
        If filter is not NULL, its reference count is incremented.
        @param filter   May be NULL. The filter to be installed in the paint
    */
        #[link_name =
              "?setColorFilter@SkPaint@@QEAAXV?$sk_sp@VSkColorFilter@@@@@Z"]
        pub fn SkPaint_setColorFilter(this: *mut root::SkPaint,
                                      arg1: root::sk_sp<root::SkColorFilter>);
    }
    extern "C" {
        /** Set or clear the patheffect object.
        <p />
        Pass NULL to clear any previous patheffect.
        As a convenience, the parameter passed is also returned.
        If a previous patheffect exists, its reference count is decremented.
        If patheffect is not NULL, its reference count is incremented.
        @param effect   May be NULL. The new patheffect to be installed in the
                        paint
        @return         effect
    */
        #[link_name =
              "?setPathEffect@SkPaint@@QEAAXV?$sk_sp@VSkPathEffect@@@@@Z"]
        pub fn SkPaint_setPathEffect(this: *mut root::SkPaint,
                                     arg1: root::sk_sp<root::SkPathEffect>);
    }
    extern "C" {
        /** Set or clear the maskfilter object.
        <p />
        Pass NULL to clear any previous maskfilter.
        As a convenience, the parameter passed is also returned.
        If a previous maskfilter exists, its reference count is decremented.
        If maskfilter is not NULL, its reference count is incremented.
        @param maskfilter   May be NULL. The new maskfilter to be installed in
                            the paint
        @return             maskfilter
    */
        #[link_name =
              "?setMaskFilter@SkPaint@@QEAAXV?$sk_sp@VSkMaskFilter@@@@@Z"]
        pub fn SkPaint_setMaskFilter(this: *mut root::SkPaint,
                                     arg1: root::sk_sp<root::SkMaskFilter>);
    }
    extern "C" {
        /** Set or clear the typeface object.
        <p />
        Pass NULL to clear any previous typeface.
        As a convenience, the parameter passed is also returned.
        If a previous typeface exists, its reference count is decremented.
        If typeface is not NULL, its reference count is incremented.
        @param typeface May be NULL. The new typeface to be installed in the
                        paint
        @return         typeface
    */
        #[link_name = "?setTypeface@SkPaint@@QEAAXV?$sk_sp@VSkTypeface@@@@@Z"]
        pub fn SkPaint_setTypeface(this: *mut root::SkPaint,
                                   arg1: root::sk_sp<root::SkTypeface>);
    }
    extern "C" {
        /** Set or clear the rasterizer object.
        <p />
        Pass NULL to clear any previous rasterizer.
        As a convenience, the parameter passed is also returned.
        If a previous rasterizer exists in the paint, its reference count is
        decremented. If rasterizer is not NULL, its reference count is
        incremented.
        @param rasterizer May be NULL. The new rasterizer to be installed in
                          the paint.
        @return           rasterizer
    */
        #[link_name =
              "?setRasterizer@SkPaint@@QEAAXV?$sk_sp@VSkRasterizer@@@@@Z"]
        pub fn SkPaint_setRasterizer(this: *mut root::SkPaint,
                                     arg1: root::sk_sp<root::SkRasterizer>);
    }
    extern "C" {
        #[link_name =
              "?setImageFilter@SkPaint@@QEAAXV?$sk_sp@VSkImageFilter@@@@@Z"]
        pub fn SkPaint_setImageFilter(this: *mut root::SkPaint,
                                      arg1: root::sk_sp<root::SkImageFilter>);
    }
    extern "C" {
        /**
     *  Set or clear the looper object.
     *  <p />
     *  Pass NULL to clear any previous looper.
     *  If a previous looper exists in the paint, its reference count is
     *  decremented. If looper is not NULL, its reference count is
     *  incremented.
     *  @param looper May be NULL. The new looper to be installed in the paint.
     */
        #[link_name =
              "?setDrawLooper@SkPaint@@QEAAXV?$sk_sp@VSkDrawLooper@@@@@Z"]
        pub fn SkPaint_setDrawLooper(this: *mut root::SkPaint,
                                     arg1: root::sk_sp<root::SkDrawLooper>);
    }
    extern "C" {
        #[link_name = "?setLooper@SkPaint@@QEAAXV?$sk_sp@VSkDrawLooper@@@@@Z"]
        pub fn SkPaint_setLooper(this: *mut root::SkPaint,
                                 arg1: root::sk_sp<root::SkDrawLooper>);
    }
    extern "C" {
        /** Set the paint's text alignment.
        @param align set the paint's Align value for drawing text.
    */
        #[link_name = "?setTextAlign@SkPaint@@QEAAXW4Align@1@@Z"]
        pub fn SkPaint_setTextAlign(this: *mut root::SkPaint,
                                    align: root::SkPaint_Align);
    }
    extern "C" {
        /** Set the paint's text size. This value must be > 0
        @param textSize set the paint's text size.
    */
        #[link_name = "?setTextSize@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setTextSize(this: *mut root::SkPaint,
                                   textSize: root::SkScalar);
    }
    extern "C" {
        /** Set the paint's horizontal scale factor for text. The default value
        is 1.0. Values > 1.0 will stretch the text wider. Values < 1.0 will
        stretch the text narrower.
        @param scaleX   set the paint's scale factor in X for drawing/measuring
                        text.
    */
        #[link_name = "?setTextScaleX@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setTextScaleX(this: *mut root::SkPaint,
                                     scaleX: root::SkScalar);
    }
    extern "C" {
        /** Set the paint's horizontal skew factor for text. The default value
        is 0. For approximating oblique text, use values around -0.25.
        @param skewX set the paint's skew factor in X for drawing text.
    */
        #[link_name = "?setTextSkewX@SkPaint@@QEAAXM@Z"]
        pub fn SkPaint_setTextSkewX(this: *mut root::SkPaint,
                                    skewX: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?setTextEncoding@SkPaint@@QEAAXW4TextEncoding@1@@Z"]
        pub fn SkPaint_setTextEncoding(this: *mut root::SkPaint,
                                       encoding: root::SkPaint_TextEncoding);
    }
    extern "C" {
        /** Return the recommend spacing between lines (which will be
        fDescent - fAscent + fLeading).
        If metrics is not null, return in it the font metrics for the
        typeface/pointsize/etc. currently set in the paint.
        @param metrics      If not null, returns the font metrics for the
                            current typeface/pointsize/etc setting in this
                            paint.
        @param scale        If not 0, return width as if the canvas were scaled
                            by this value
        @param return the recommended spacing between lines
    */
        #[link_name = "?getFontMetrics@SkPaint@@QEBAMPEAUFontMetrics@1@M@Z"]
        pub fn SkPaint_getFontMetrics(this: *const root::SkPaint,
                                      metrics: *mut root::SkPaint_FontMetrics,
                                      scale: root::SkScalar)
         -> root::SkScalar;
    }
    extern "C" {
        /** Convert the specified text into glyph IDs, returning the number of
        glyphs ID written. If glyphs is NULL, it is ignore and only the count
        is returned.
    */
        #[link_name = "?textToGlyphs@SkPaint@@QEBAHPEBX_KQEAG@Z"]
        pub fn SkPaint_textToGlyphs(this: *const root::SkPaint,
                                    text: *const ::std::os::raw::c_void,
                                    byteLength: usize,
                                    glyphs: *mut root::SkGlyphID)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return true if all of the specified text has a corresponding non-zero
        glyph ID. If any of the code-points in the text are not supported in
        the typeface (i.e. the glyph ID would be zero), then return false.

        If the text encoding for the paint is kGlyph_TextEncoding, then this
        returns true if all of the specified glyph IDs are non-zero.
     */
        #[link_name = "?containsText@SkPaint@@QEBA_NPEBX_K@Z"]
        pub fn SkPaint_containsText(this: *const root::SkPaint,
                                    text: *const ::std::os::raw::c_void,
                                    byteLength: usize) -> bool;
    }
    extern "C" {
        /** Convert the glyph array into Unichars. Unconvertable glyphs are mapped
        to zero. Note: this does not look at the text-encoding setting in the
        paint, only at the typeface.
    */
        #[link_name = "?glyphsToUnichars@SkPaint@@QEBAXQEBGHQEAH@Z"]
        pub fn SkPaint_glyphsToUnichars(this: *const root::SkPaint,
                                        glyphs: *const root::SkGlyphID,
                                        count: ::std::os::raw::c_int,
                                        text: *mut root::SkUnichar);
    }
    extern "C" {
        /** Return the width of the text. This will return the vertical measure
     *  if isVerticalText() is true, in which case the returned value should
     *  be treated has a height instead of a width.
     *
     *  @param text         The text to be measured
     *  @param length       Number of bytes of text to measure
     *  @param bounds       If not NULL, returns the bounds of the text,
     *                      relative to (0, 0).
     *  @return             The advance width of the text
     */
        #[link_name = "?measureText@SkPaint@@QEBAMPEBX_KPEAUSkRect@@@Z"]
        pub fn SkPaint_measureText(this: *const root::SkPaint,
                                   text: *const ::std::os::raw::c_void,
                                   length: usize, bounds: *mut root::SkRect)
         -> root::SkScalar;
    }
    extern "C" {
        /** Return the number of bytes of text that were measured. If
     *  isVerticalText() is true, then the vertical advances are used for
     *  the measurement.
     *
     *  @param text     The text to be measured
     *  @param length   Number of bytes of text to measure
     *  @param maxWidth Maximum width. Only the subset of text whose accumulated
     *                  widths are <= maxWidth are measured.
     *  @param measuredWidth Optional. If non-null, this returns the actual
     *                  width of the measured text.
     *  @return         The number of bytes of text that were measured. Will be
     *                  <= length.
     */
        #[link_name = "?breakText@SkPaint@@QEBA_KPEBX_KMPEAM@Z"]
        pub fn SkPaint_breakText(this: *const root::SkPaint,
                                 text: *const ::std::os::raw::c_void,
                                 length: usize, maxWidth: root::SkScalar,
                                 measuredWidth: *mut root::SkScalar) -> usize;
    }
    extern "C" {
        /** Return the advances for the text. These will be vertical advances if
     *  isVerticalText() returns true.
     *
     *  @param text         the text
     *  @param byteLength   number of bytes to of text
     *  @param widths       If not null, returns the array of advances for
     *                      the glyphs. If not NULL, must be at least a large
     *                      as the number of unichars in the specified text.
     *  @param bounds       If not null, returns the bounds for each of
     *                      character, relative to (0, 0)
     *  @return the number of unichars in the specified text.
     */
        #[link_name = "?getTextWidths@SkPaint@@QEBAHPEBX_KQEAMQEAUSkRect@@@Z"]
        pub fn SkPaint_getTextWidths(this: *const root::SkPaint,
                                     text: *const ::std::os::raw::c_void,
                                     byteLength: usize,
                                     widths: *mut root::SkScalar,
                                     bounds: *mut root::SkRect)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the path (outline) for the specified text.
     *  Note: just like SkCanvas::drawText, this will respect the Align setting
     *        in the paint.
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param x            The x-coordinate of the origin of the text.
     *  @param y            The y-coordinate of the origin of the text.
     *  @param path         The outline of the text.
     */
        #[link_name = "?getTextPath@SkPaint@@QEBAXPEBX_KMMPEAVSkPath@@@Z"]
        pub fn SkPaint_getTextPath(this: *const root::SkPaint,
                                   text: *const ::std::os::raw::c_void,
                                   length: usize, x: root::SkScalar,
                                   y: root::SkScalar,
                                   path: *mut root::SkPath);
    }
    extern "C" {
        /** Return the path (outline) for the specified text.
     *  Note: just like SkCanvas::drawText, this will respect the Align setting
     *        in the paint.
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param pos          array of positions, used to position each character
     *  @param path         The outline of the text.
     */
        #[link_name =
              "?getPosTextPath@SkPaint@@QEBAXPEBX_KQEBUSkPoint@@PEAVSkPath@@@Z"]
        pub fn SkPaint_getPosTextPath(this: *const root::SkPaint,
                                      text: *const ::std::os::raw::c_void,
                                      length: usize,
                                      pos: *const root::SkPoint,
                                      path: *mut root::SkPath);
    }
    extern "C" {
        /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  the string. The caller may pass nullptr for intervals to determine the size of the interval
     *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
     *  intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders. 
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param x            The x-coordinate of the origin of the text.
     *  @param y            The y-coordinate of the origin of the text.
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the found intersections.
     *
     *  @return             The number of intersections, which may be zero.
     */
        #[link_name = "?getTextIntercepts@SkPaint@@QEBAHPEBX_KMMQEBMPEAM@Z"]
        pub fn SkPaint_getTextIntercepts(this: *const root::SkPaint,
                                         text: *const ::std::os::raw::c_void,
                                         length: usize, x: root::SkScalar,
                                         y: root::SkScalar,
                                         bounds: *mut root::SkScalar,
                                         intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  string. The caller may pass nullptr for intervals to determine the size of the interval
     *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
     *  intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders. 
     *
     *  @param text         the text
     *  @param length       number of bytes of text
     *  @param pos          array of positions, used to position each character
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
     *
     *  @return             The number of intersections, which may be zero.
     */
        #[link_name =
              "?getPosTextIntercepts@SkPaint@@QEBAHPEBX_KQEBUSkPoint@@QEBMPEAM@Z"]
        pub fn SkPaint_getPosTextIntercepts(this: *const root::SkPaint,
                                            text:
                                                *const ::std::os::raw::c_void,
                                            length: usize,
                                            pos: *const root::SkPoint,
                                            bounds: *mut root::SkScalar,
                                            intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  string. The caller may pass nullptr for intervals to determine the size of the interval
     *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
     *  intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders.
     *
     *  @param text         The text.
     *  @param length       Number of bytes of text.
     *  @param xpos         Array of x-positions, used to position each character.
     *  @param constY       The shared Y coordinate for all of the positions.
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
     *
     *  @return             The number of intersections, which may be zero.
     */
        #[link_name =
              "?getPosTextHIntercepts@SkPaint@@QEBAHPEBX_KQEBMM2PEAM@Z"]
        pub fn SkPaint_getPosTextHIntercepts(this: *const root::SkPaint,
                                             text:
                                                 *const ::std::os::raw::c_void,
                                             length: usize,
                                             xpos: *const root::SkScalar,
                                             constY: root::SkScalar,
                                             bounds: *mut root::SkScalar,
                                             intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the number of intervals that intersect the intercept along the axis of the advance.
     *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
     *  text blob. The caller may pass nullptr for intervals to determine the size of the interval
     *  array. The computed intervals are cached by glyph to improve performance for multiple calls.
     *  This permits constructing an underline that skips the descenders.
     *
     *  @param blob         The text blob.
     *  @param bounds       The lower and upper line parallel to the advance.
     *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
     *
     *  @return             The number of intersections, which may be zero.
     */
        #[link_name =
              "?getTextBlobIntercepts@SkPaint@@QEBAHPEBVSkTextBlob@@QEBMPEAM@Z"]
        pub fn SkPaint_getTextBlobIntercepts(this: *const root::SkPaint,
                                             blob: *const root::SkTextBlob,
                                             bounds: *mut root::SkScalar,
                                             intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /**
     *  Return a rectangle that represents the union of the bounds of all
     *  of the glyphs, but each one positioned at (0,0). This may be conservatively large, and
     *  will not take into account any hinting, but will respect any text-scale-x or text-skew-x
     *  on this paint.
     */
        #[link_name = "?getFontBounds@SkPaint@@QEBA?AUSkRect@@XZ"]
        pub fn SkPaint_getFontBounds(this: *const root::SkPaint)
         -> root::SkRect;
    }
    extern "C" {
        #[link_name = "?nothingToDraw@SkPaint@@QEBA_NXZ"]
        pub fn SkPaint_nothingToDraw(this: *const root::SkPaint) -> bool;
    }
    extern "C" {
        /** Returns true if the current paint settings allow for fast computation of
     bounds (i.e. there is nothing complex like a patheffect that would make
     the bounds computation expensive.
     */
        #[link_name = "?canComputeFastBounds@SkPaint@@QEBA_NXZ"]
        pub fn SkPaint_canComputeFastBounds(this: *const root::SkPaint)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?doComputeFastBounds@SkPaint@@QEBAAEBUSkRect@@AEBU2@PEAU2@W4Style@1@@Z"]
        pub fn SkPaint_doComputeFastBounds(this: *const root::SkPaint,
                                           orig: *const root::SkRect,
                                           storage: *mut root::SkRect,
                                           arg1: root::SkPaint_Style)
         -> *const root::SkRect;
    }
    extern "C" {
        #[link_name = "?toString@SkPaint@@QEBAXPEAVSkString@@@Z"]
        pub fn SkPaint_toString(this: *const root::SkPaint,
                                str: *mut root::SkString);
    }
    extern "C" {
        #[link_name = "??0SkPaint@@QEAA@XZ"]
        pub fn SkPaint_SkPaint(this: *mut root::SkPaint);
    }
    extern "C" {
        #[link_name = "??0SkPaint@@QEAA@AEBV0@@Z"]
        pub fn SkPaint_SkPaint1(this: *mut root::SkPaint,
                                paint: *const root::SkPaint);
    }
    extern "C" {
        #[link_name = "??0SkPaint@@QEAA@$$QEAV0@@Z"]
        pub fn SkPaint_SkPaint2(this: *mut root::SkPaint,
                                paint: *mut root::SkPaint);
    }
    impl SkPaint {
        #[inline]
        pub unsafe fn getHash(&self) -> u32 { SkPaint_getHash(&*self) }
        #[inline]
        pub unsafe fn flatten(&self, arg1: *mut root::SkWriteBuffer) {
            SkPaint_flatten(&*self, arg1)
        }
        #[inline]
        pub unsafe fn unflatten(&mut self, arg1: *mut root::SkReadBuffer) {
            SkPaint_unflatten(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkPaint_reset(&mut *self) }
        #[inline]
        pub unsafe fn setHinting(&mut self,
                                 hintingLevel: root::SkPaint_Hinting) {
            SkPaint_setHinting(&mut *self, hintingLevel)
        }
        #[inline]
        pub unsafe fn setFlags(&mut self, flags: u32) {
            SkPaint_setFlags(&mut *self, flags)
        }
        #[inline]
        pub unsafe fn setAntiAlias(&mut self, aa: bool) {
            SkPaint_setAntiAlias(&mut *self, aa)
        }
        #[inline]
        pub unsafe fn setDither(&mut self, dither: bool) {
            SkPaint_setDither(&mut *self, dither)
        }
        #[inline]
        pub unsafe fn setLinearText(&mut self, linearText: bool) {
            SkPaint_setLinearText(&mut *self, linearText)
        }
        #[inline]
        pub unsafe fn setSubpixelText(&mut self, subpixelText: bool) {
            SkPaint_setSubpixelText(&mut *self, subpixelText)
        }
        #[inline]
        pub unsafe fn setLCDRenderText(&mut self, lcdText: bool) {
            SkPaint_setLCDRenderText(&mut *self, lcdText)
        }
        #[inline]
        pub unsafe fn setEmbeddedBitmapText(&mut self,
                                            useEmbeddedBitmapText: bool) {
            SkPaint_setEmbeddedBitmapText(&mut *self, useEmbeddedBitmapText)
        }
        #[inline]
        pub unsafe fn setAutohinted(&mut self, useAutohinter: bool) {
            SkPaint_setAutohinted(&mut *self, useAutohinter)
        }
        #[inline]
        pub unsafe fn setVerticalText(&mut self, arg1: bool) {
            SkPaint_setVerticalText(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setUnderlineText(&mut self, underlineText: bool) {
            SkPaint_setUnderlineText(&mut *self, underlineText)
        }
        #[inline]
        pub unsafe fn setStrikeThruText(&mut self, strikeThruText: bool) {
            SkPaint_setStrikeThruText(&mut *self, strikeThruText)
        }
        #[inline]
        pub unsafe fn setFakeBoldText(&mut self, fakeBoldText: bool) {
            SkPaint_setFakeBoldText(&mut *self, fakeBoldText)
        }
        #[inline]
        pub unsafe fn setDevKernText(&mut self, devKernText: bool) {
            SkPaint_setDevKernText(&mut *self, devKernText)
        }
        #[inline]
        pub unsafe fn setFilterQuality(&mut self,
                                       quality: root::SkFilterQuality) {
            SkPaint_setFilterQuality(&mut *self, quality)
        }
        #[inline]
        pub unsafe fn setStyle(&mut self, style: root::SkPaint_Style) {
            SkPaint_setStyle(&mut *self, style)
        }
        #[inline]
        pub unsafe fn setColor(&mut self, color: root::SkColor) {
            SkPaint_setColor(&mut *self, color)
        }
        #[inline]
        pub unsafe fn setAlpha(&mut self, a: root::U8CPU) {
            SkPaint_setAlpha(&mut *self, a)
        }
        #[inline]
        pub unsafe fn setARGB(&mut self, a: root::U8CPU, r: root::U8CPU,
                              g: root::U8CPU, b: root::U8CPU) {
            SkPaint_setARGB(&mut *self, a, r, g, b)
        }
        #[inline]
        pub unsafe fn setStrokeWidth(&mut self, width: root::SkScalar) {
            SkPaint_setStrokeWidth(&mut *self, width)
        }
        #[inline]
        pub unsafe fn setStrokeMiter(&mut self, miter: root::SkScalar) {
            SkPaint_setStrokeMiter(&mut *self, miter)
        }
        #[inline]
        pub unsafe fn setStrokeCap(&mut self, cap: root::SkPaint_Cap) {
            SkPaint_setStrokeCap(&mut *self, cap)
        }
        #[inline]
        pub unsafe fn setStrokeJoin(&mut self, join: root::SkPaint_Join) {
            SkPaint_setStrokeJoin(&mut *self, join)
        }
        #[inline]
        pub unsafe fn getFillPath(&self, src: *const root::SkPath,
                                  dst: *mut root::SkPath,
                                  cullRect: *const root::SkRect,
                                  resScale: root::SkScalar) -> bool {
            SkPaint_getFillPath(&*self, src, dst, cullRect, resScale)
        }
        #[inline]
        pub unsafe fn setShader(&mut self,
                                arg1: root::sk_sp<root::SkShader>) {
            SkPaint_setShader(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setColorFilter(&mut self,
                                     arg1: root::sk_sp<root::SkColorFilter>) {
            SkPaint_setColorFilter(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setPathEffect(&mut self,
                                    arg1: root::sk_sp<root::SkPathEffect>) {
            SkPaint_setPathEffect(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setMaskFilter(&mut self,
                                    arg1: root::sk_sp<root::SkMaskFilter>) {
            SkPaint_setMaskFilter(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setTypeface(&mut self,
                                  arg1: root::sk_sp<root::SkTypeface>) {
            SkPaint_setTypeface(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setRasterizer(&mut self,
                                    arg1: root::sk_sp<root::SkRasterizer>) {
            SkPaint_setRasterizer(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setImageFilter(&mut self,
                                     arg1: root::sk_sp<root::SkImageFilter>) {
            SkPaint_setImageFilter(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setDrawLooper(&mut self,
                                    arg1: root::sk_sp<root::SkDrawLooper>) {
            SkPaint_setDrawLooper(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setLooper(&mut self,
                                arg1: root::sk_sp<root::SkDrawLooper>) {
            SkPaint_setLooper(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setTextAlign(&mut self, align: root::SkPaint_Align) {
            SkPaint_setTextAlign(&mut *self, align)
        }
        #[inline]
        pub unsafe fn setTextSize(&mut self, textSize: root::SkScalar) {
            SkPaint_setTextSize(&mut *self, textSize)
        }
        #[inline]
        pub unsafe fn setTextScaleX(&mut self, scaleX: root::SkScalar) {
            SkPaint_setTextScaleX(&mut *self, scaleX)
        }
        #[inline]
        pub unsafe fn setTextSkewX(&mut self, skewX: root::SkScalar) {
            SkPaint_setTextSkewX(&mut *self, skewX)
        }
        #[inline]
        pub unsafe fn setTextEncoding(&mut self,
                                      encoding: root::SkPaint_TextEncoding) {
            SkPaint_setTextEncoding(&mut *self, encoding)
        }
        #[inline]
        pub unsafe fn getFontMetrics(&self,
                                     metrics: *mut root::SkPaint_FontMetrics,
                                     scale: root::SkScalar)
         -> root::SkScalar {
            SkPaint_getFontMetrics(&*self, metrics, scale)
        }
        #[inline]
        pub unsafe fn textToGlyphs(&self, text: *const ::std::os::raw::c_void,
                                   byteLength: usize,
                                   glyphs: *mut root::SkGlyphID)
         -> ::std::os::raw::c_int {
            SkPaint_textToGlyphs(&*self, text, byteLength, glyphs)
        }
        #[inline]
        pub unsafe fn containsText(&self, text: *const ::std::os::raw::c_void,
                                   byteLength: usize) -> bool {
            SkPaint_containsText(&*self, text, byteLength)
        }
        #[inline]
        pub unsafe fn glyphsToUnichars(&self, glyphs: *const root::SkGlyphID,
                                       count: ::std::os::raw::c_int,
                                       text: *mut root::SkUnichar) {
            SkPaint_glyphsToUnichars(&*self, glyphs, count, text)
        }
        #[inline]
        pub unsafe fn measureText(&self, text: *const ::std::os::raw::c_void,
                                  length: usize, bounds: *mut root::SkRect)
         -> root::SkScalar {
            SkPaint_measureText(&*self, text, length, bounds)
        }
        #[inline]
        pub unsafe fn breakText(&self, text: *const ::std::os::raw::c_void,
                                length: usize, maxWidth: root::SkScalar,
                                measuredWidth: *mut root::SkScalar) -> usize {
            SkPaint_breakText(&*self, text, length, maxWidth, measuredWidth)
        }
        #[inline]
        pub unsafe fn getTextWidths(&self,
                                    text: *const ::std::os::raw::c_void,
                                    byteLength: usize,
                                    widths: *mut root::SkScalar,
                                    bounds: *mut root::SkRect)
         -> ::std::os::raw::c_int {
            SkPaint_getTextWidths(&*self, text, byteLength, widths, bounds)
        }
        #[inline]
        pub unsafe fn getTextPath(&self, text: *const ::std::os::raw::c_void,
                                  length: usize, x: root::SkScalar,
                                  y: root::SkScalar,
                                  path: *mut root::SkPath) {
            SkPaint_getTextPath(&*self, text, length, x, y, path)
        }
        #[inline]
        pub unsafe fn getPosTextPath(&self,
                                     text: *const ::std::os::raw::c_void,
                                     length: usize, pos: *const root::SkPoint,
                                     path: *mut root::SkPath) {
            SkPaint_getPosTextPath(&*self, text, length, pos, path)
        }
        #[inline]
        pub unsafe fn getTextIntercepts(&self,
                                        text: *const ::std::os::raw::c_void,
                                        length: usize, x: root::SkScalar,
                                        y: root::SkScalar,
                                        bounds: *mut root::SkScalar,
                                        intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int {
            SkPaint_getTextIntercepts(&*self, text, length, x, y, bounds,
                                      intervals)
        }
        #[inline]
        pub unsafe fn getPosTextIntercepts(&self,
                                           text:
                                               *const ::std::os::raw::c_void,
                                           length: usize,
                                           pos: *const root::SkPoint,
                                           bounds: *mut root::SkScalar,
                                           intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int {
            SkPaint_getPosTextIntercepts(&*self, text, length, pos, bounds,
                                         intervals)
        }
        #[inline]
        pub unsafe fn getPosTextHIntercepts(&self,
                                            text:
                                                *const ::std::os::raw::c_void,
                                            length: usize,
                                            xpos: *const root::SkScalar,
                                            constY: root::SkScalar,
                                            bounds: *mut root::SkScalar,
                                            intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int {
            SkPaint_getPosTextHIntercepts(&*self, text, length, xpos, constY,
                                          bounds, intervals)
        }
        #[inline]
        pub unsafe fn getTextBlobIntercepts(&self,
                                            blob: *const root::SkTextBlob,
                                            bounds: *mut root::SkScalar,
                                            intervals: *mut root::SkScalar)
         -> ::std::os::raw::c_int {
            SkPaint_getTextBlobIntercepts(&*self, blob, bounds, intervals)
        }
        #[inline]
        pub unsafe fn getFontBounds(&self) -> root::SkRect {
            SkPaint_getFontBounds(&*self)
        }
        #[inline]
        pub unsafe fn nothingToDraw(&self) -> bool {
            SkPaint_nothingToDraw(&*self)
        }
        #[inline]
        pub unsafe fn canComputeFastBounds(&self) -> bool {
            SkPaint_canComputeFastBounds(&*self)
        }
        #[inline]
        pub unsafe fn doComputeFastBounds(&self, orig: *const root::SkRect,
                                          storage: *mut root::SkRect,
                                          arg1: root::SkPaint_Style)
         -> *const root::SkRect {
            SkPaint_doComputeFastBounds(&*self, orig, storage, arg1)
        }
        #[inline]
        pub unsafe fn toString(&self, str: *mut root::SkString) {
            SkPaint_toString(&*self, str)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPaint_SkPaint(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(paint: *const root::SkPaint) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPaint_SkPaint1(&mut __bindgen_tmp, paint);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(paint: *mut root::SkPaint) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPaint_SkPaint2(&mut __bindgen_tmp, paint);
            __bindgen_tmp
        }
    }
    /** \class SkPixelRef

    This class is the smart container for pixel memory, and is used with
    SkBitmap. A pixelref is installed into a bitmap, and then the bitmap can
    access the actual pixel memory by calling lockPixels/unlockPixels.

    This class can be shared/accessed between multiple threads.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPixelRef {
        pub _base: root::SkRefCnt,
        pub fMutex: root::SkMutex,
        pub fInfo: root::SkImageInfo,
        pub fRec: root::SkPixelRef_LockRec,
        pub fLockCount: ::std::os::raw::c_int,
        pub fTaggedGenID: u32,
        pub fGenIDChangeListeners: root::SkTDArray<*mut root::SkPixelRef_GenIDChangeListener>,
        pub fURI: root::SkString,
        pub fAddedToCache: u8,
        pub _bitfield_1: u8,
        pub fPreLocked: bool,
    }
    /**
     *  To access the actual pixels of a pixelref, it must be "locked".
     *  Calling lockPixels returns a LockRec struct (on success).
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPixelRef_LockRec {
        pub fPixels: *mut ::std::os::raw::c_void,
        pub fColorTable: *mut root::SkColorTable,
        pub fRowBytes: usize,
    }
    #[test]
    fn bindgen_test_layout_SkPixelRef_LockRec() {
        assert_eq!(::std::mem::size_of::<SkPixelRef_LockRec>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkPixelRef_LockRec>() , 8usize);
    }
    impl Clone for SkPixelRef_LockRec {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPixelRef_LockRequest {
        pub fSize: root::SkISize,
        pub fQuality: root::SkFilterQuality,
    }
    #[test]
    fn bindgen_test_layout_SkPixelRef_LockRequest() {
        assert_eq!(::std::mem::size_of::<SkPixelRef_LockRequest>() , 12usize);
        assert_eq!(::std::mem::align_of::<SkPixelRef_LockRequest>() , 4usize);
    }
    impl Clone for SkPixelRef_LockRequest {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPixelRef_LockResult {
        pub fUnlockProc: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                                        *mut ::std::os::raw::c_void)>,
        pub fUnlockContext: *mut ::std::os::raw::c_void,
        pub fPixels: *const ::std::os::raw::c_void,
        pub fCTable: *mut root::SkColorTable,
        pub fRowBytes: usize,
        pub fSize: root::SkISize,
    }
    #[test]
    fn bindgen_test_layout_SkPixelRef_LockResult() {
        assert_eq!(::std::mem::size_of::<SkPixelRef_LockResult>() , 48usize);
        assert_eq!(::std::mem::align_of::<SkPixelRef_LockResult>() , 8usize);
    }
    impl Clone for SkPixelRef_LockResult {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct SkPixelRef_GenIDChangeListener__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPixelRef_GenIDChangeListener {
        pub vtable_: *const SkPixelRef_GenIDChangeListener__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkPixelRef_GenIDChangeListener() {
        assert_eq!(::std::mem::size_of::<SkPixelRef_GenIDChangeListener>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<SkPixelRef_GenIDChangeListener>() ,
                   8usize);
    }
    pub const SkPixelRef_kMutable: root::SkPixelRef__bindgen_ty_1 =
        SkPixelRef__bindgen_ty_1::kMutable;
    pub const SkPixelRef_kTemporarilyImmutable: root::SkPixelRef__bindgen_ty_1
              =
        SkPixelRef__bindgen_ty_1::kTemporarilyImmutable;
    pub const SkPixelRef_kImmutable: root::SkPixelRef__bindgen_ty_1 =
        SkPixelRef__bindgen_ty_1::kImmutable;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPixelRef__bindgen_ty_1 {
        kMutable = 0,
        kTemporarilyImmutable = 1,
        kImmutable = 2,
    }
    pub type SkPixelRef_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkPixelRef() {
        assert_eq!(::std::mem::size_of::<SkPixelRef>() , 136usize);
        assert_eq!(::std::mem::align_of::<SkPixelRef>() , 8usize);
    }
    extern "C" {
        /**
     *  Call to access the pixel memory. Return true on success. Balance this
     *  with a call to unlockPixels().
     */
        #[link_name = "?lockPixels@SkPixelRef@@QEAA_NXZ"]
        pub fn SkPixelRef_lockPixels(this: *mut root::SkPixelRef) -> bool;
    }
    extern "C" {
        /**
     *  Call to access the pixel memory. On success, return true and fill out
     *  the specified rec. On failure, return false and ignore the rec parameter.
     *  Balance this with a call to unlockPixels().
     */
        #[link_name = "?lockPixels@SkPixelRef@@QEAA_NPEAULockRec@1@@Z"]
        pub fn SkPixelRef_lockPixels1(this: *mut root::SkPixelRef,
                                      rec: *mut root::SkPixelRef_LockRec)
         -> bool;
    }
    extern "C" {
        /** Call to balanace a previous call to lockPixels(). Returns the pixels
        (or null) after the unlock. NOTE: lock calls can be nested, but the
        matching number of unlock calls must be made in order to free the
        memory (if the subclass implements caching/deferred-decoding.)
    */
        #[link_name = "?unlockPixels@SkPixelRef@@QEAAXXZ"]
        pub fn SkPixelRef_unlockPixels(this: *mut root::SkPixelRef);
    }
    extern "C" {
        /**
     *  Some bitmaps can return a copy of their pixels for lockPixels(), but
     *  that copy, if modified, will not be pushed back. These bitmaps should
     *  not be used as targets for a raster device/canvas (since all pixels
     *  modifications will be lost when unlockPixels() is called.)
     */
        #[link_name = "?lockPixelsAreWritable@SkPixelRef@@QEBA_NXZ"]
        pub fn SkPixelRef_lockPixelsAreWritable(this: *const root::SkPixelRef)
         -> bool;
    }
    extern "C" {
        /** Returns a non-zero, unique value corresponding to the pixels in this
        pixelref. Each time the pixels are changed (and notifyPixelsChanged is
        called), a different generation ID will be returned.
    */
        #[link_name = "?getGenerationID@SkPixelRef@@QEBAIXZ"]
        pub fn SkPixelRef_getGenerationID(this: *const root::SkPixelRef)
         -> u32;
    }
    extern "C" {
        /**
     *  Call this if you have changed the contents of the pixels. This will in-
     *  turn cause a different generation ID value to be returned from
     *  getGenerationID().
     */
        #[link_name = "?notifyPixelsChanged@SkPixelRef@@QEAAXXZ"]
        pub fn SkPixelRef_notifyPixelsChanged(this: *mut root::SkPixelRef);
    }
    extern "C" {
        /**
     *  Change the info's AlphaType. Note that this does not automatically
     *  invalidate the generation ID. If the pixel values themselves have
     *  changed, then you must explicitly call notifyPixelsChanged() as well.
     */
        #[link_name = "?changeAlphaType@SkPixelRef@@QEAAXW4SkAlphaType@@@Z"]
        pub fn SkPixelRef_changeAlphaType(this: *mut root::SkPixelRef,
                                          at: root::SkAlphaType);
    }
    extern "C" {
        /** Marks this pixelref is immutable, meaning that the contents of its
        pixels will not change for the lifetime of the pixelref. This state can
        be set on a pixelref, but it cannot be cleared once it is set.
    */
        #[link_name = "?setImmutable@SkPixelRef@@QEAAXXZ"]
        pub fn SkPixelRef_setImmutable(this: *mut root::SkPixelRef);
    }
    extern "C" {
        #[link_name =
              "?requestLock@SkPixelRef@@QEAA_NAEBULockRequest@1@PEAULockResult@1@@Z"]
        pub fn SkPixelRef_requestLock(this: *mut root::SkPixelRef,
                                      arg1:
                                          *const root::SkPixelRef_LockRequest,
                                      arg2: *mut root::SkPixelRef_LockResult)
         -> bool;
    }
    extern "C" {
        /** Populates dst with the pixels of this pixelRef, converting them to colorType. */
        #[link_name =
              "?readPixels@SkPixelRef@@QEAA_NPEAVSkBitmap@@W4SkColorType@@PEBUSkIRect@@@Z"]
        pub fn SkPixelRef_readPixels(this: *mut root::SkPixelRef,
                                     dst: *mut root::SkBitmap,
                                     colorType: root::SkColorType,
                                     subset: *const root::SkIRect) -> bool;
    }
    extern "C" {
        #[link_name =
              "?addGenIDChangeListener@SkPixelRef@@QEAAXPEAUGenIDChangeListener@1@@Z"]
        pub fn SkPixelRef_addGenIDChangeListener(this: *mut root::SkPixelRef,
                                                 listener:
                                                     *mut root::SkPixelRef_GenIDChangeListener);
    }
    extern "C" {
        #[link_name =
              "?setPreLocked@SkPixelRef@@IEAAXPEAX_KPEAVSkColorTable@@@Z"]
        pub fn SkPixelRef_setPreLocked(this: *mut root::SkPixelRef,
                                       arg1: *mut ::std::os::raw::c_void,
                                       rowBytes: usize,
                                       arg2: *mut root::SkColorTable);
    }
    extern "C" {
        #[link_name = "??0SkPixelRef@@QEAA@AEBUSkImageInfo@@@Z"]
        pub fn SkPixelRef_SkPixelRef(this: *mut root::SkPixelRef,
                                     arg1: *const root::SkImageInfo);
    }
    impl SkPixelRef {
        #[inline]
        pub fn fMutability(&self) -> root::SkPixelRef__bindgen_ty_1 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (255usize as u8))
                                           >> 0u32) as u32)
            }
        }
        #[inline]
        pub fn set_fMutability(&mut self,
                               val: root::SkPixelRef__bindgen_ty_1) {
            self._bitfield_1 &= !(255usize as u8);
            self._bitfield_1 |=
                ((val as u32 as u8) << 0u32) & (255usize as u8);
        }
        #[inline]
        pub unsafe fn lockPixels(&mut self) -> bool {
            SkPixelRef_lockPixels(&mut *self)
        }
        #[inline]
        pub unsafe fn lockPixels1(&mut self,
                                  rec: *mut root::SkPixelRef_LockRec)
         -> bool {
            SkPixelRef_lockPixels1(&mut *self, rec)
        }
        #[inline]
        pub unsafe fn unlockPixels(&mut self) {
            SkPixelRef_unlockPixels(&mut *self)
        }
        #[inline]
        pub unsafe fn lockPixelsAreWritable(&self) -> bool {
            SkPixelRef_lockPixelsAreWritable(&*self)
        }
        #[inline]
        pub unsafe fn getGenerationID(&self) -> u32 {
            SkPixelRef_getGenerationID(&*self)
        }
        #[inline]
        pub unsafe fn notifyPixelsChanged(&mut self) {
            SkPixelRef_notifyPixelsChanged(&mut *self)
        }
        #[inline]
        pub unsafe fn changeAlphaType(&mut self, at: root::SkAlphaType) {
            SkPixelRef_changeAlphaType(&mut *self, at)
        }
        #[inline]
        pub unsafe fn setImmutable(&mut self) {
            SkPixelRef_setImmutable(&mut *self)
        }
        #[inline]
        pub unsafe fn requestLock(&mut self,
                                  arg1: *const root::SkPixelRef_LockRequest,
                                  arg2: *mut root::SkPixelRef_LockResult)
         -> bool {
            SkPixelRef_requestLock(&mut *self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn readPixels(&mut self, dst: *mut root::SkBitmap,
                                 colorType: root::SkColorType,
                                 subset: *const root::SkIRect) -> bool {
            SkPixelRef_readPixels(&mut *self, dst, colorType, subset)
        }
        #[inline]
        pub unsafe fn addGenIDChangeListener(&mut self,
                                             listener:
                                                 *mut root::SkPixelRef_GenIDChangeListener) {
            SkPixelRef_addGenIDChangeListener(&mut *self, listener)
        }
        #[inline]
        pub unsafe fn setPreLocked(&mut self,
                                   arg1: *mut ::std::os::raw::c_void,
                                   rowBytes: usize,
                                   arg2: *mut root::SkColorTable) {
            SkPixelRef_setPreLocked(&mut *self, arg1, rowBytes, arg2)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::SkImageInfo) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPixelRef_SkPixelRef(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPixelRefFactory {
        pub _base: root::SkRefCnt,
    }
    #[test]
    fn bindgen_test_layout_SkPixelRefFactory() {
        assert_eq!(::std::mem::size_of::<SkPixelRefFactory>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkPixelRefFactory>() , 8usize);
    }
    /** \class SkRegion

    The SkRegion class encapsulates the geometric region used to specify
    clipping areas for drawing.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkRegion {
        pub fBounds: root::SkIRect,
        pub fRunHead: *mut root::SkRegion_RunHead,
    }
    pub type SkRegion_RunType = i32;
    pub const SkRegion_kRunTypeSentinel: root::SkRegion__bindgen_ty_1 =
        SkRegion__bindgen_ty_1::kRunTypeSentinel;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRegion__bindgen_ty_1 { kRunTypeSentinel = 2147483647, }
    pub const SkRegion_Op_kLastOp: root::SkRegion_Op =
        SkRegion_Op::kReplace_Op;
    #[repr(i32)]
    /**
     *  The logical operations that can be performed when combining two regions.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRegion_Op {
        kDifference_Op = 0,
        kIntersect_Op = 1,
        kUnion_Op = 2,
        kXOR_Op = 3,
        kReverseDifference_Op = 4,
        kReplace_Op = 5,
    }
    /**
     *  Returns the sequence of rectangles, sorted in Y and X, that make up
     *  this region.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRegion_Iterator {
        pub fRgn: *const root::SkRegion,
        pub fRuns: *const root::SkRegion_RunType,
        pub fRect: root::SkIRect,
        pub fDone: bool,
    }
    #[test]
    fn bindgen_test_layout_SkRegion_Iterator() {
        assert_eq!(::std::mem::size_of::<SkRegion_Iterator>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkRegion_Iterator>() , 8usize);
    }
    extern "C" {
        #[link_name = "?rewind@Iterator@SkRegion@@QEAA_NXZ"]
        pub fn SkRegion_Iterator_rewind(this: *mut root::SkRegion_Iterator)
         -> bool;
    }
    extern "C" {
        #[link_name = "?reset@Iterator@SkRegion@@QEAAXAEBV2@@Z"]
        pub fn SkRegion_Iterator_reset(this: *mut root::SkRegion_Iterator,
                                       arg1: *const root::SkRegion);
    }
    extern "C" {
        #[link_name = "?next@Iterator@SkRegion@@QEAAXXZ"]
        pub fn SkRegion_Iterator_next(this: *mut root::SkRegion_Iterator);
    }
    extern "C" {
        #[link_name = "??0Iterator@SkRegion@@QEAA@AEBV1@@Z"]
        pub fn SkRegion_Iterator_Iterator(this: *mut root::SkRegion_Iterator,
                                          arg1: *const root::SkRegion);
    }
    impl Clone for SkRegion_Iterator {
        fn clone(&self) -> Self { *self }
    }
    impl SkRegion_Iterator {
        #[inline]
        pub unsafe fn rewind(&mut self) -> bool {
            SkRegion_Iterator_rewind(&mut *self)
        }
        #[inline]
        pub unsafe fn reset(&mut self, arg1: *const root::SkRegion) {
            SkRegion_Iterator_reset(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn next(&mut self) { SkRegion_Iterator_next(&mut *self) }
        #[inline]
        pub unsafe fn new(arg1: *const root::SkRegion) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkRegion_Iterator_Iterator(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    /**
     *  Returns the sequence of rectangles, sorted in Y and X, that make up
     *  this region intersected with the specified clip rectangle.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRegion_Cliperator {
        pub fIter: root::SkRegion_Iterator,
        pub fClip: root::SkIRect,
        pub fRect: root::SkIRect,
        pub fDone: bool,
    }
    #[test]
    fn bindgen_test_layout_SkRegion_Cliperator() {
        assert_eq!(::std::mem::size_of::<SkRegion_Cliperator>() , 80usize);
        assert_eq!(::std::mem::align_of::<SkRegion_Cliperator>() , 8usize);
    }
    extern "C" {
        #[link_name = "?next@Cliperator@SkRegion@@QEAAXXZ"]
        pub fn SkRegion_Cliperator_next(this: *mut root::SkRegion_Cliperator);
    }
    extern "C" {
        #[link_name = "??0Cliperator@SkRegion@@QEAA@AEBV1@AEBUSkIRect@@@Z"]
        pub fn SkRegion_Cliperator_Cliperator(this:
                                                  *mut root::SkRegion_Cliperator,
                                              arg1: *const root::SkRegion,
                                              clip: *const root::SkIRect);
    }
    impl Clone for SkRegion_Cliperator {
        fn clone(&self) -> Self { *self }
    }
    impl SkRegion_Cliperator {
        #[inline]
        pub unsafe fn next(&mut self) { SkRegion_Cliperator_next(&mut *self) }
        #[inline]
        pub unsafe fn new(arg1: *const root::SkRegion,
                          clip: *const root::SkIRect) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkRegion_Cliperator_Cliperator(&mut __bindgen_tmp, arg1, clip);
            __bindgen_tmp
        }
    }
    /**
     *  Returns the sequence of runs that make up this region for the specified
     *  Y scanline, clipped to the specified left and right X values.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRegion_Spanerator {
        pub fRuns: *const root::SkRegion_RunType,
        pub fLeft: ::std::os::raw::c_int,
        pub fRight: ::std::os::raw::c_int,
        pub fDone: bool,
    }
    #[test]
    fn bindgen_test_layout_SkRegion_Spanerator() {
        assert_eq!(::std::mem::size_of::<SkRegion_Spanerator>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkRegion_Spanerator>() , 8usize);
    }
    extern "C" {
        #[link_name = "?next@Spanerator@SkRegion@@QEAA_NPEAH0@Z"]
        pub fn SkRegion_Spanerator_next(this: *mut root::SkRegion_Spanerator,
                                        left: *mut ::std::os::raw::c_int,
                                        right: *mut ::std::os::raw::c_int)
         -> bool;
    }
    extern "C" {
        #[link_name = "??0Spanerator@SkRegion@@QEAA@AEBV1@HHH@Z"]
        pub fn SkRegion_Spanerator_Spanerator(this:
                                                  *mut root::SkRegion_Spanerator,
                                              arg1: *const root::SkRegion,
                                              y: ::std::os::raw::c_int,
                                              left: ::std::os::raw::c_int,
                                              right: ::std::os::raw::c_int);
    }
    impl Clone for SkRegion_Spanerator {
        fn clone(&self) -> Self { *self }
    }
    impl SkRegion_Spanerator {
        #[inline]
        pub unsafe fn next(&mut self, left: *mut ::std::os::raw::c_int,
                           right: *mut ::std::os::raw::c_int) -> bool {
            SkRegion_Spanerator_next(&mut *self, left, right)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::SkRegion,
                          y: ::std::os::raw::c_int,
                          left: ::std::os::raw::c_int,
                          right: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkRegion_Spanerator_Spanerator(&mut __bindgen_tmp, arg1, y, left,
                                           right);
            __bindgen_tmp
        }
    }
    pub const SkRegion_kOpCount: root::SkRegion__bindgen_ty_2 =
        SkRegion__bindgen_ty_2::kOpCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRegion__bindgen_ty_2 { kOpCount = 6, }
    pub const SkRegion_kRectRegionRuns: root::SkRegion__bindgen_ty_3 =
        SkRegion__bindgen_ty_3::kRectRegionRuns;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRegion__bindgen_ty_3 { kRectRegionRuns = 7, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRegion_RunHead {
        pub _address: u8,
    }
    impl Clone for SkRegion_RunHead {
        fn clone(&self) -> Self { *self }
    }
    pub const SkRegion_kOpCnt: ::std::os::raw::c_int = 6;
    #[test]
    fn bindgen_test_layout_SkRegion() {
        assert_eq!(::std::mem::size_of::<SkRegion>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkRegion>() , 8usize);
    }
    extern "C" {
        /**
     *  Swap the contents of this and the specified region. This operation
     *  is gauarenteed to never fail.
     */
        #[link_name = "?swap@SkRegion@@QEAAXAEAV1@@Z"]
        pub fn SkRegion_swap(this: *mut root::SkRegion,
                             arg1: *mut root::SkRegion);
    }
    extern "C" {
        /**
     *  Returns a value that grows approximately linearly with the number of
     *  intervals comprised in the region. Empty region will return 0, Rect
     *  will return 1, Complex will return a value > 1.
     *
     *  Use this to compare two regions, where the larger count likely
     *  indicates a more complex region.
     */
        #[link_name = "?computeRegionComplexity@SkRegion@@QEBAHXZ"]
        pub fn SkRegion_computeRegionComplexity(this: *const root::SkRegion)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /**
     *  Returns true if the region is non-empty, and if so, appends the
     *  boundary(s) of the region to the specified path.
     *  If the region is empty, returns false, and path is left unmodified.
     */
        #[link_name = "?getBoundaryPath@SkRegion@@QEBA_NPEAVSkPath@@@Z"]
        pub fn SkRegion_getBoundaryPath(this: *const root::SkRegion,
                                        path: *mut root::SkPath) -> bool;
    }
    extern "C" {
        /**
     *  Set the region to be empty, and return false, since the resulting
     *  region is empty
     */
        #[link_name = "?setEmpty@SkRegion@@QEAA_NXZ"]
        pub fn SkRegion_setEmpty(this: *mut root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  If rect is non-empty, set this region to that rectangle and return true,
     *  otherwise set this region to empty and return false.
     */
        #[link_name = "?setRect@SkRegion@@QEAA_NAEBUSkIRect@@@Z"]
        pub fn SkRegion_setRect(this: *mut root::SkRegion,
                                arg1: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /**
     *  If left < right and top < bottom, set this region to that rectangle and
     *  return true, otherwise set this region to empty and return false.
     */
        #[link_name = "?setRect@SkRegion@@QEAA_NHHHH@Z"]
        pub fn SkRegion_setRect1(this: *mut root::SkRegion, left: i32,
                                 top: i32, right: i32, bottom: i32) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the union of an array of rects. This is generally
     *  faster than calling region.op(rect, kUnion_Op) in a loop. If count is
     *  0, then this region is set to the empty region.
     *  @return true if the resulting region is non-empty
     */
        #[link_name = "?setRects@SkRegion@@QEAA_NQEBUSkIRect@@H@Z"]
        pub fn SkRegion_setRects(this: *mut root::SkRegion,
                                 rects: *const root::SkIRect,
                                 count: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the specified region, and return true if it is
     *  non-empty.
     */
        #[link_name = "?setRegion@SkRegion@@QEAA_NAEBV1@@Z"]
        pub fn SkRegion_setRegion(this: *mut root::SkRegion,
                                  arg1: *const root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the area described by the path, clipped.
     *  Return true if the resulting region is non-empty.
     *  This produces a region that is identical to the pixels that would be
     *  drawn by the path (with no antialiasing) with the specified clip.
     */
        #[link_name = "?setPath@SkRegion@@QEAA_NAEBVSkPath@@AEBV1@@Z"]
        pub fn SkRegion_setPath(this: *mut root::SkRegion,
                                arg1: *const root::SkPath,
                                clip: *const root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  Returns true if the specified rectangle has a non-empty intersection
     *  with this region.
     */
        #[link_name = "?intersects@SkRegion@@QEBA_NAEBUSkIRect@@@Z"]
        pub fn SkRegion_intersects(this: *const root::SkRegion,
                                   arg1: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /**
     *  Returns true if the specified region has a non-empty intersection
     *  with this region.
     */
        #[link_name = "?intersects@SkRegion@@QEBA_NAEBV1@@Z"]
        pub fn SkRegion_intersects1(this: *const root::SkRegion,
                                    arg1: *const root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  Return true if the specified x,y coordinate is inside the region.
     */
        #[link_name = "?contains@SkRegion@@QEBA_NHH@Z"]
        pub fn SkRegion_contains(this: *const root::SkRegion, x: i32, y: i32)
         -> bool;
    }
    extern "C" {
        /**
     *  Return true if the specified rectangle is completely inside the region.
     *  This works for simple (rectangular) and complex regions, and always
     *  returns the correct result. Note: if either this region or the rectangle
     *  is empty, contains() returns false.
     */
        #[link_name = "?contains@SkRegion@@QEBA_NAEBUSkIRect@@@Z"]
        pub fn SkRegion_contains1(this: *const root::SkRegion,
                                  arg1: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /**
     *  Return true if the specified region is completely inside the region.
     *  This works for simple (rectangular) and complex regions, and always
     *  returns the correct result. Note: if either region is empty, contains()
     *  returns false.
     */
        #[link_name = "?contains@SkRegion@@QEBA_NAEBV1@@Z"]
        pub fn SkRegion_contains2(this: *const root::SkRegion,
                                  arg1: *const root::SkRegion) -> bool;
    }
    extern "C" {
        /**
     *  Translate the region by the specified (dx, dy) amount, writing the
     *  resulting region into dst. Note: it is legal to pass this region as the
     *  dst parameter, effectively translating the region in place. If dst is
     *  null, nothing happens.
     */
        #[link_name = "?translate@SkRegion@@QEBAXHHPEAV1@@Z"]
        pub fn SkRegion_translate(this: *const root::SkRegion,
                                  dx: ::std::os::raw::c_int,
                                  dy: ::std::os::raw::c_int,
                                  dst: *mut root::SkRegion);
    }
    extern "C" {
        /**
     *  Set this region to the result of applying the Op to the specified
     *  rectangle and region: this = (rect op rgn).
     *  Return true if the resulting region is non-empty.
     */
        #[link_name = "?op@SkRegion@@QEAA_NAEBUSkIRect@@AEBV1@W4Op@1@@Z"]
        pub fn SkRegion_op(this: *mut root::SkRegion,
                           rect: *const root::SkIRect,
                           rgn: *const root::SkRegion,
                           arg1: root::SkRegion_Op) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the result of applying the Op to the specified
     *  region and rectangle: this = (rgn op rect).
     *  Return true if the resulting region is non-empty.
     */
        #[link_name = "?op@SkRegion@@QEAA_NAEBV1@AEBUSkIRect@@W4Op@1@@Z"]
        pub fn SkRegion_op1(this: *mut root::SkRegion,
                            rgn: *const root::SkRegion,
                            rect: *const root::SkIRect,
                            arg1: root::SkRegion_Op) -> bool;
    }
    extern "C" {
        /**
     *  Set this region to the result of applying the Op to the specified
     *  regions: this = (rgna op rgnb).
     *  Return true if the resulting region is non-empty.
     */
        #[link_name = "?op@SkRegion@@QEAA_NAEBV1@0W4Op@1@@Z"]
        pub fn SkRegion_op2(this: *mut root::SkRegion,
                            rgna: *const root::SkRegion,
                            rgnb: *const root::SkRegion,
                            op: root::SkRegion_Op) -> bool;
    }
    extern "C" {
        /**
     *  Write the region to the buffer, and return the number of bytes written.
     *  If buffer is NULL, it still returns the number of bytes.
     */
        #[link_name = "?writeToMemory@SkRegion@@QEBA_KPEAX@Z"]
        pub fn SkRegion_writeToMemory(this: *const root::SkRegion,
                                      buffer: *mut ::std::os::raw::c_void)
         -> usize;
    }
    extern "C" {
        /**
     * Initializes the region from the buffer
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
        #[link_name = "?readFromMemory@SkRegion@@QEAA_KPEBX_K@Z"]
        pub fn SkRegion_readFromMemory(this: *mut root::SkRegion,
                                       buffer: *const ::std::os::raw::c_void,
                                       length: usize) -> usize;
    }
    extern "C" {
        /**
     *  Returns a reference to a global empty region. Just a convenience for
     *  callers that need a const empty region.
     */
        #[link_name = "?GetEmptyRegion@SkRegion@@SAAEBV1@XZ"]
        pub fn SkRegion_GetEmptyRegion() -> *const root::SkRegion;
    }
    extern "C" {
        #[link_name = "?dump@SkRegion@@QEBAXXZ"]
        pub fn SkRegion_dump(this: *const root::SkRegion);
    }
    extern "C" {
        #[link_name = "?validate@SkRegion@@QEBAXXZ"]
        pub fn SkRegion_validate(this: *const root::SkRegion);
    }
    extern "C" {
        #[link_name = "?UnitTest@SkRegion@@SAXXZ"]
        pub fn SkRegion_UnitTest();
    }
    extern "C" {
        #[link_name = "?debugSetRuns@SkRegion@@QEAA_NQEBHH@Z"]
        pub fn SkRegion_debugSetRuns(this: *mut root::SkRegion,
                                     runs: *const root::SkRegion_RunType,
                                     count: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        #[link_name = "??0SkRegion@@QEAA@XZ"]
        pub fn SkRegion_SkRegion(this: *mut root::SkRegion);
    }
    extern "C" {
        #[link_name = "??0SkRegion@@QEAA@AEBV0@@Z"]
        pub fn SkRegion_SkRegion1(this: *mut root::SkRegion,
                                  arg1: *const root::SkRegion);
    }
    extern "C" {
        #[link_name = "??0SkRegion@@QEAA@AEBUSkIRect@@@Z"]
        pub fn SkRegion_SkRegion2(this: *mut root::SkRegion,
                                  arg1: *const root::SkIRect);
    }
    impl SkRegion {
        #[inline]
        pub unsafe fn swap(&mut self, arg1: *mut root::SkRegion) {
            SkRegion_swap(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn computeRegionComplexity(&self)
         -> ::std::os::raw::c_int {
            SkRegion_computeRegionComplexity(&*self)
        }
        #[inline]
        pub unsafe fn getBoundaryPath(&self, path: *mut root::SkPath)
         -> bool {
            SkRegion_getBoundaryPath(&*self, path)
        }
        #[inline]
        pub unsafe fn setEmpty(&mut self) -> bool {
            SkRegion_setEmpty(&mut *self)
        }
        #[inline]
        pub unsafe fn setRect(&mut self, arg1: *const root::SkIRect) -> bool {
            SkRegion_setRect(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setRect1(&mut self, left: i32, top: i32, right: i32,
                               bottom: i32) -> bool {
            SkRegion_setRect1(&mut *self, left, top, right, bottom)
        }
        #[inline]
        pub unsafe fn setRects(&mut self, rects: *const root::SkIRect,
                               count: ::std::os::raw::c_int) -> bool {
            SkRegion_setRects(&mut *self, rects, count)
        }
        #[inline]
        pub unsafe fn setRegion(&mut self, arg1: *const root::SkRegion)
         -> bool {
            SkRegion_setRegion(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setPath(&mut self, arg1: *const root::SkPath,
                              clip: *const root::SkRegion) -> bool {
            SkRegion_setPath(&mut *self, arg1, clip)
        }
        #[inline]
        pub unsafe fn intersects(&self, arg1: *const root::SkIRect) -> bool {
            SkRegion_intersects(&*self, arg1)
        }
        #[inline]
        pub unsafe fn intersects1(&self, arg1: *const root::SkRegion)
         -> bool {
            SkRegion_intersects1(&*self, arg1)
        }
        #[inline]
        pub unsafe fn contains(&self, x: i32, y: i32) -> bool {
            SkRegion_contains(&*self, x, y)
        }
        #[inline]
        pub unsafe fn contains1(&self, arg1: *const root::SkIRect) -> bool {
            SkRegion_contains1(&*self, arg1)
        }
        #[inline]
        pub unsafe fn contains2(&self, arg1: *const root::SkRegion) -> bool {
            SkRegion_contains2(&*self, arg1)
        }
        #[inline]
        pub unsafe fn translate(&self, dx: ::std::os::raw::c_int,
                                dy: ::std::os::raw::c_int,
                                dst: *mut root::SkRegion) {
            SkRegion_translate(&*self, dx, dy, dst)
        }
        #[inline]
        pub unsafe fn op(&mut self, rect: *const root::SkIRect,
                         rgn: *const root::SkRegion, arg1: root::SkRegion_Op)
         -> bool {
            SkRegion_op(&mut *self, rect, rgn, arg1)
        }
        #[inline]
        pub unsafe fn op1(&mut self, rgn: *const root::SkRegion,
                          rect: *const root::SkIRect, arg1: root::SkRegion_Op)
         -> bool {
            SkRegion_op1(&mut *self, rgn, rect, arg1)
        }
        #[inline]
        pub unsafe fn op2(&mut self, rgna: *const root::SkRegion,
                          rgnb: *const root::SkRegion, op: root::SkRegion_Op)
         -> bool {
            SkRegion_op2(&mut *self, rgna, rgnb, op)
        }
        #[inline]
        pub unsafe fn writeToMemory(&self,
                                    buffer: *mut ::std::os::raw::c_void)
         -> usize {
            SkRegion_writeToMemory(&*self, buffer)
        }
        #[inline]
        pub unsafe fn readFromMemory(&mut self,
                                     buffer: *const ::std::os::raw::c_void,
                                     length: usize) -> usize {
            SkRegion_readFromMemory(&mut *self, buffer, length)
        }
        #[inline]
        pub unsafe fn GetEmptyRegion() -> *const root::SkRegion {
            SkRegion_GetEmptyRegion()
        }
        #[inline]
        pub unsafe fn dump(&self) { SkRegion_dump(&*self) }
        #[inline]
        pub unsafe fn validate(&self) { SkRegion_validate(&*self) }
        #[inline]
        pub unsafe fn UnitTest() { SkRegion_UnitTest() }
        #[inline]
        pub unsafe fn debugSetRuns(&mut self,
                                   runs: *const root::SkRegion_RunType,
                                   count: ::std::os::raw::c_int) -> bool {
            SkRegion_debugSetRuns(&mut *self, runs, count)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkRegion_SkRegion(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::SkRegion) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkRegion_SkRegion1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(arg1: *const root::SkIRect) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkRegion_SkRegion2(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    /** \class SkBitmap

    The SkBitmap class specifies a raster bitmap. A bitmap has an integer width
    and height, and a format (colortype), and a pointer to the actual pixels.
    Bitmaps can be drawn into a SkCanvas, but they are also used to specify the
    target of a SkCanvas' drawing operations.
    A const SkBitmap exposes getAddr(), which lets a caller write its pixels;
    the constness is considered to apply to the bitmap's configuration, not
    its contents.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBitmap {
        pub fPixelRef: *mut root::SkPixelRef,
        pub fPixelLockCount: ::std::os::raw::c_int,
        pub fPixels: *mut ::std::os::raw::c_void,
        pub fColorTable: *mut root::SkColorTable,
        pub fPixelRefOrigin: root::SkIPoint,
        pub fInfo: root::SkImageInfo,
        pub fRowBytes: u32,
        pub fFlags: u8,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBitmap_Allocator {
        pub _base: root::SkRefCnt,
    }
    pub type SkBitmap_Allocator_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkBitmap_Allocator() {
        assert_eq!(::std::mem::size_of::<SkBitmap_Allocator>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkBitmap_Allocator>() , 8usize);
    }
    /** Subclass of Allocator that returns a pixelref that allocates its pixel
        memory from the heap. This is the default Allocator invoked by
        allocPixels().
    */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBitmap_HeapAllocator {
        pub _base: root::SkBitmap_Allocator,
    }
    #[test]
    fn bindgen_test_layout_SkBitmap_HeapAllocator() {
        assert_eq!(::std::mem::size_of::<SkBitmap_HeapAllocator>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkBitmap_HeapAllocator>() , 8usize);
    }
    #[repr(C)]
    pub struct SkBitmap_RLEPixels__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBitmap_RLEPixels {
        pub vtable_: *const SkBitmap_RLEPixels__bindgen_vtable,
        pub fYPtrs: *mut *mut u8,
        pub fHeight: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_SkBitmap_RLEPixels() {
        assert_eq!(::std::mem::size_of::<SkBitmap_RLEPixels>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkBitmap_RLEPixels>() , 8usize);
    }
    extern "C" {
        #[link_name = "??0RLEPixels@SkBitmap@@QEAA@HH@Z"]
        pub fn SkBitmap_RLEPixels_RLEPixels(this:
                                                *mut root::SkBitmap_RLEPixels,
                                            width: ::std::os::raw::c_int,
                                            height: ::std::os::raw::c_int);
    }
    impl SkBitmap_RLEPixels {
        #[inline]
        pub unsafe fn new(width: ::std::os::raw::c_int,
                          height: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkBitmap_RLEPixels_RLEPixels(&mut __bindgen_tmp, width, height);
            __bindgen_tmp
        }
    }
    pub const SkBitmap_Flags_kImageIsVolatile_Flag: root::SkBitmap_Flags =
        SkBitmap_Flags(2);
    impl ::std::ops::BitOr<root::SkBitmap_Flags> for root::SkBitmap_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkBitmap_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkBitmap_Flags(pub i32);
    #[test]
    fn bindgen_test_layout_SkBitmap() {
        assert_eq!(::std::mem::size_of::<SkBitmap>() , 72usize);
        assert_eq!(::std::mem::align_of::<SkBitmap>() , 8usize);
    }
    extern "C" {
        /** Swap the fields of the two bitmaps. This routine is guaranteed to never fail or throw.
    */
        #[link_name = "?swap@SkBitmap@@QEAAXAEAV1@@Z"]
        pub fn SkBitmap_swap(this: *mut root::SkBitmap,
                             other: *mut root::SkBitmap);
    }
    extern "C" {
        /**
     *  Set the bitmap's alphaType, returning true on success. If false is
     *  returned, then the specified new alphaType is incompatible with the
     *  colortype, and the current alphaType is unchanged.
     *
     *  Note: this changes the alphatype for the underlying pixels, which means
     *  that all bitmaps that might be sharing (subsets of) the pixels will
     *  be affected.
     */
        #[link_name = "?setAlphaType@SkBitmap@@QEAA_NW4SkAlphaType@@@Z"]
        pub fn SkBitmap_setAlphaType(this: *mut root::SkBitmap,
                                     arg1: root::SkAlphaType) -> bool;
    }
    extern "C" {
        /** Returns true if this bitmap is marked as immutable, meaning that the
        contents of its pixels will not change for the lifetime of the bitmap.
    */
        #[link_name = "?isImmutable@SkBitmap@@QEBA_NXZ"]
        pub fn SkBitmap_isImmutable(this: *const root::SkBitmap) -> bool;
    }
    extern "C" {
        /** Marks this bitmap as immutable, meaning that the contents of its
        pixels will not change for the lifetime of the bitmap and of the
        underlying pixelref. This state can be set, but it cannot be
        cleared once it is set. This state propagates to all other bitmaps
        that share the same pixelref.
    */
        #[link_name = "?setImmutable@SkBitmap@@QEAAXXZ"]
        pub fn SkBitmap_setImmutable(this: *mut root::SkBitmap);
    }
    extern "C" {
        /** Returns true if the bitmap is volatile (i.e. should not be cached by devices.)
    */
        #[link_name = "?isVolatile@SkBitmap@@QEBA_NXZ"]
        pub fn SkBitmap_isVolatile(this: *const root::SkBitmap) -> bool;
    }
    extern "C" {
        /** Specify whether this bitmap is volatile. Bitmaps are not volatile by
        default. Temporary bitmaps that are discarded after use should be
        marked as volatile. This provides a hint to the device that the bitmap
        should not be cached. Providing this hint when appropriate can
        improve performance by avoiding unnecessary overhead and resource
        consumption on the device.
    */
        #[link_name = "?setIsVolatile@SkBitmap@@QEAAX_N@Z"]
        pub fn SkBitmap_setIsVolatile(this: *mut root::SkBitmap, arg1: bool);
    }
    extern "C" {
        /** Reset the bitmap to its initial state (see default constructor). If we are a (shared)
        owner of the pixels, that ownership is decremented.
    */
        #[link_name = "?reset@SkBitmap@@QEAAXXZ"]
        pub fn SkBitmap_reset(this: *mut root::SkBitmap);
    }
    extern "C" {
        /**
     *  Return the bitmap's bounds [0, 0, width, height] as an SkRect
     */
        #[link_name = "?getBounds@SkBitmap@@QEBAXPEAUSkRect@@@Z"]
        pub fn SkBitmap_getBounds(this: *const root::SkBitmap,
                                  bounds: *mut root::SkRect);
    }
    extern "C" {
        #[link_name = "?getBounds@SkBitmap@@QEBAXPEAUSkIRect@@@Z"]
        pub fn SkBitmap_getBounds1(this: *const root::SkBitmap,
                                   bounds: *mut root::SkIRect);
    }
    extern "C" {
        #[link_name = "?setInfo@SkBitmap@@QEAA_NAEBUSkImageInfo@@_K@Z"]
        pub fn SkBitmap_setInfo(this: *mut root::SkBitmap,
                                arg1: *const root::SkImageInfo,
                                rowBytes: usize) -> bool;
    }
    extern "C" {
        /**
     *  Allocate the bitmap's pixels to match the requested image info. If the Factory
     *  is non-null, call it to allcoate the pixelref. If the ImageInfo requires
     *  a colortable, then ColorTable must be non-null, and will be ref'd.
     *  On failure, the bitmap will be set to empty and return false.
     */
        #[link_name =
              "?tryAllocPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@PEAVSkPixelRefFactory@@PEAVSkColorTable@@@Z"]
        pub fn SkBitmap_tryAllocPixels(this: *mut root::SkBitmap,
                                       arg1: *const root::SkImageInfo,
                                       arg2: *mut root::SkPixelRefFactory,
                                       arg3: *mut root::SkColorTable) -> bool;
    }
    extern "C" {
        /**
     *  Allocate the bitmap's pixels to match the requested image info and
     *  rowBytes. If the request cannot be met (e.g. the info is invalid or
     *  the requested rowBytes are not compatible with the info
     *  (e.g. rowBytes < info.minRowBytes() or rowBytes is not aligned with
     *  the pixel size specified by info.colorType()) then false is returned
     *  and the bitmap is set to empty.
     */
        #[link_name = "?tryAllocPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@_K@Z"]
        pub fn SkBitmap_tryAllocPixels1(this: *mut root::SkBitmap,
                                        info: *const root::SkImageInfo,
                                        rowBytes: usize) -> bool;
    }
    extern "C" {
        /**
     *  Install a pixelref that wraps the specified pixels and rowBytes, and
     *  optional ReleaseProc and context. When the pixels are no longer
     *  referenced, if releaseProc is not null, it will be called with the
     *  pixels and context as parameters.
     *  On failure, the bitmap will be set to empty and return false.
     *
     *  If specified, the releaseProc will always be called, even on failure. It is also possible
     *  for success but the releaseProc is immediately called (e.g. valid Info but NULL pixels).
     */
        #[link_name =
              "?installPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@PEAX_KPEAVSkColorTable@@P6AX11@Z1@Z"]
        pub fn SkBitmap_installPixels(this: *mut root::SkBitmap,
                                      arg1: *const root::SkImageInfo,
                                      pixels: *mut ::std::os::raw::c_void,
                                      rowBytes: usize,
                                      arg2: *mut root::SkColorTable,
                                      releaseProc:
                                          ::std::option::Option<unsafe extern "C" fn(addr:
                                                                                         *mut ::std::os::raw::c_void,
                                                                                     context:
                                                                                         *mut ::std::os::raw::c_void)>,
                                      context: *mut ::std::os::raw::c_void)
         -> bool;
    }
    extern "C" {
        /**
     *  Call installPixels with no ReleaseProc specified. This means
     *  that the caller must ensure that the specified pixels and
     *  colortable are valid for the lifetime of the created bitmap
     *  (and its pixelRef).
     */
        #[link_name = "?installPixels@SkBitmap@@QEAA_NAEBVSkPixmap@@@Z"]
        pub fn SkBitmap_installPixels1(this: *mut root::SkBitmap,
                                       arg1: *const root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Calls installPixels() with the value in the SkMask. The caller must
     *  ensure that the specified mask pixels are valid for the lifetime
     *  of the created bitmap (and its pixelRef).
     */
        #[link_name = "?installMaskPixels@SkBitmap@@QEAA_NAEBUSkMask@@@Z"]
        pub fn SkBitmap_installMaskPixels(this: *mut root::SkBitmap,
                                          arg1: *const root::SkMask) -> bool;
    }
    extern "C" {
        /** Use this to assign a new pixel address for an existing bitmap. This
        will automatically release any pixelref previously installed. Only call
        this if you are handling ownership/lifetime of the pixel memory.

        If the bitmap retains a reference to the colortable (assuming it is
        not null) it will take care of incrementing the reference count.

        @param pixels   Address for the pixels, managed by the caller.
        @param ctable   ColorTable (or null) that matches the specified pixels
    */
        #[link_name = "?setPixels@SkBitmap@@QEAAXPEAXPEAVSkColorTable@@@Z"]
        pub fn SkBitmap_setPixels(this: *mut root::SkBitmap,
                                  p: *mut ::std::os::raw::c_void,
                                  ctable: *mut root::SkColorTable);
    }
    extern "C" {
        /** Copies the bitmap's pixels to the location pointed at by dst and returns
        true if possible, returns false otherwise.

        In the case when the dstRowBytes matches the bitmap's rowBytes, the copy
        may be made faster by copying over the dst's per-row padding (for all
        rows but the last). By setting preserveDstPad to true the caller can
        disable this optimization and ensure that pixels in the padding are not
        overwritten.

        Always returns false for RLE formats.

        @param dst      Location of destination buffer.
        @param dstSize  Size of destination buffer. Must be large enough to hold
                        pixels using indicated stride.
        @param dstRowBytes  Width of each line in the buffer. If 0, uses
                            bitmap's internal stride.
        @param preserveDstPad Must we preserve padding in the dst
    */
        #[link_name = "?copyPixelsTo@SkBitmap@@QEBA_NQEAX_K1_N@Z"]
        pub fn SkBitmap_copyPixelsTo(this: *const root::SkBitmap,
                                     dst: *const ::std::os::raw::c_void,
                                     dstSize: usize, dstRowBytes: usize,
                                     preserveDstPad: bool) -> bool;
    }
    extern "C" {
        /** Use the specified Allocator to create the pixelref that manages the
        pixel memory. It will be sized based on the current ImageInfo.
        If this is called multiple times, a new pixelref object will be created
        each time.

        If the bitmap retains a reference to the colortable (assuming it is
        not null) it will take care of incrementing the reference count.

        @param allocator The Allocator to use to create a pixelref that can
                         manage the pixel memory for the current ImageInfo.
                         If allocator is NULL, the standard HeapAllocator will be used.
        @param ctable   ColorTable (or null) to use with the pixels that will
                        be allocated. Only used if colortype == kIndex_8_SkColorType.
                        If it is non-null and the colortype is not indexed, it will
                        be ignored.
        @return true if the allocation succeeds. If not the pixelref field of
                     the bitmap will be unchanged.
    */
        #[link_name =
              "?tryAllocPixels@SkBitmap@@QEAA_NPEAVAllocator@1@PEAVSkColorTable@@@Z"]
        pub fn SkBitmap_tryAllocPixels2(this: *mut root::SkBitmap,
                                        allocator:
                                            *mut root::SkBitmap_Allocator,
                                        ctable: *mut root::SkColorTable)
         -> bool;
    }
    extern "C" {
        /**
     *  Assign a pixelref and origin to the bitmap. Pixelrefs are reference,
     *  so the existing one (if any) will be unref'd and the new one will be
     *  ref'd. (x,y) specify the offset within the pixelref's pixels for the
     *  top/left corner of the bitmap. For a bitmap that encompases the entire
     *  pixels of the pixelref, these will be (0,0).
     */
        #[link_name = "?setPixelRef@SkBitmap@@QEAAPEAVSkPixelRef@@PEAV2@HH@Z"]
        pub fn SkBitmap_setPixelRef(this: *mut root::SkBitmap,
                                    pr: *mut root::SkPixelRef,
                                    dx: ::std::os::raw::c_int,
                                    dy: ::std::os::raw::c_int)
         -> *mut root::SkPixelRef;
    }
    extern "C" {
        /** Call this to ensure that the bitmap points to the current pixel address
        in the pixelref. Balance it with a call to unlockPixels(). These calls
        are harmless if there is no pixelref.
    */
        #[link_name = "?lockPixels@SkBitmap@@QEBAXXZ"]
        pub fn SkBitmap_lockPixels(this: *const root::SkBitmap);
    }
    extern "C" {
        /** When you are finished access the pixel memory, call this to balance a
        previous call to lockPixels(). This allows pixelrefs that implement
        cached/deferred image decoding to know when there are active clients of
        a given image.
    */
        #[link_name = "?unlockPixels@SkBitmap@@QEBAXXZ"]
        pub fn SkBitmap_unlockPixels(this: *const root::SkBitmap);
    }
    extern "C" {
        /**
     *  Some bitmaps can return a copy of their pixels for lockPixels(), but
     *  that copy, if modified, will not be pushed back. These bitmaps should
     *  not be used as targets for a raster device/canvas (since all pixels
     *  modifications will be lost when unlockPixels() is called.)
     */
        #[link_name = "?lockPixelsAreWritable@SkBitmap@@QEBA_NXZ"]
        pub fn SkBitmap_lockPixelsAreWritable(this: *const root::SkBitmap)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?requestLock@SkBitmap@@QEBA_NPEAVSkAutoPixmapUnlock@@@Z"]
        pub fn SkBitmap_requestLock(this: *const root::SkBitmap,
                                    result: *mut root::SkAutoPixmapUnlock)
         -> bool;
    }
    extern "C" {
        /** Returns a non-zero, unique value corresponding to the pixels in our
        pixelref. Each time the pixels are changed (and notifyPixelsChanged
        is called), a different generation ID will be returned. Finally, if
        there is no pixelRef then zero is returned.
    */
        #[link_name = "?getGenerationID@SkBitmap@@QEBAIXZ"]
        pub fn SkBitmap_getGenerationID(this: *const root::SkBitmap) -> u32;
    }
    extern "C" {
        /** Call this if you have changed the contents of the pixels. This will in-
        turn cause a different generation ID value to be returned from
        getGenerationID().
    */
        #[link_name = "?notifyPixelsChanged@SkBitmap@@QEBAXXZ"]
        pub fn SkBitmap_notifyPixelsChanged(this: *const root::SkBitmap);
    }
    extern "C" {
        /**
     *  Fill the entire bitmap with the specified color.
     *  If the bitmap's colortype does not support alpha (e.g. 565) then the alpha
     *  of the color is ignored (treated as opaque). If the colortype only supports
     *  alpha (e.g. A1 or A8) then the color's r,g,b components are ignored.
     */
        #[link_name = "?eraseColor@SkBitmap@@QEBAXI@Z"]
        pub fn SkBitmap_eraseColor(this: *const root::SkBitmap,
                                   c: root::SkColor);
    }
    extern "C" {
        /**
     *  Fill the specified area of this bitmap with the specified color.
     *  If the bitmap's colortype does not support alpha (e.g. 565) then the alpha
     *  of the color is ignored (treated as opaque). If the colortype only supports
     *  alpha (e.g. A1 or A8) then the color's r,g,b components are ignored.
     */
        #[link_name = "?erase@SkBitmap@@QEBAXIAEBUSkIRect@@@Z"]
        pub fn SkBitmap_erase(this: *const root::SkBitmap, c: root::SkColor,
                              area: *const root::SkIRect);
    }
    extern "C" {
        /** Returns the address of the specified pixel. This performs a runtime
        check to know the size of the pixels, and will return the same answer
        as the corresponding size-specific method (e.g. getAddr16). Since the
        check happens at runtime, it is much slower than using a size-specific
        version. Unlike the size-specific methods, this routine also checks if
        getPixels() returns null, and returns that. The size-specific routines
        perform a debugging assert that getPixels() is not null, but they do
        not do any runtime checks.
    */
        #[link_name = "?getAddr@SkBitmap@@QEBAPEAXHH@Z"]
        pub fn SkBitmap_getAddr(this: *const root::SkBitmap,
                                x: ::std::os::raw::c_int,
                                y: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        /** Set dst to be a setset of this bitmap. If possible, it will share the
        pixel memory, and just point into a subset of it. However, if the colortype
        does not support this, a local copy will be made and associated with
        the dst bitmap. If the subset rectangle, intersected with the bitmap's
        dimensions is empty, or if there is an unsupported colortype, false will be
        returned and dst will be untouched.
        @param dst  The bitmap that will be set to a subset of this bitmap
        @param subset The rectangle of pixels in this bitmap that dst will
                      reference.
        @return true if the subset copy was successfully made.
    */
        #[link_name = "?extractSubset@SkBitmap@@QEBA_NPEAV1@AEBUSkIRect@@@Z"]
        pub fn SkBitmap_extractSubset(this: *const root::SkBitmap,
                                      dst: *mut root::SkBitmap,
                                      subset: *const root::SkIRect) -> bool;
    }
    extern "C" {
        /** Makes a deep copy of this bitmap, respecting the requested colorType,
     *  and allocating the dst pixels on the cpu.
     *  Returns false if either there is an error (i.e. the src does not have
     *  pixels) or the request cannot be satisfied (e.g. the src has per-pixel
     *  alpha, and the requested colortype does not support alpha).
     *  @param dst The bitmap to be sized and allocated
     *  @param ct The desired colorType for dst
     *  @param allocator Allocator used to allocate the pixelref for the dst
     *                   bitmap. If this is null, the standard HeapAllocator
     *                   will be used.
     *  @return true if the copy was made.
     */
        #[link_name =
              "?copyTo@SkBitmap@@QEBA_NPEAV1@W4SkColorType@@PEAVAllocator@1@@Z"]
        pub fn SkBitmap_copyTo(this: *const root::SkBitmap,
                               dst: *mut root::SkBitmap,
                               ct: root::SkColorType,
                               arg1: *mut root::SkBitmap_Allocator) -> bool;
    }
    extern "C" {
        /**
     *  Copy the bitmap's pixels into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (SkImageInfo). The src pixels are read
     *  starting at the specified (srcX,srcY) offset, relative to the top-left corner.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the bitmap. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the bitmap bounds.
     *  - If the requested colortype/alphatype cannot be converted from the src's types.
     *  - If the src pixels are not available.
     */
        #[link_name =
              "?readPixels@SkBitmap@@QEBA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
        pub fn SkBitmap_readPixels(this: *const root::SkBitmap,
                                   dstInfo: *const root::SkImageInfo,
                                   dstPixels: *mut ::std::os::raw::c_void,
                                   dstRowBytes: usize,
                                   srcX: ::std::os::raw::c_int,
                                   srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Returns true if this bitmap's pixels can be converted into the requested
     *  colorType, such that copyTo() could succeed.
     */
        #[link_name = "?canCopyTo@SkBitmap@@QEBA_NW4SkColorType@@@Z"]
        pub fn SkBitmap_canCopyTo(this: *const root::SkBitmap,
                                  colorType: root::SkColorType) -> bool;
    }
    extern "C" {
        /** Makes a deep copy of this bitmap, keeping the copied pixels
     *  in the same domain as the source: If the src pixels are allocated for
     *  the cpu, then so will the dst. If the src pixels are allocated on the
     *  gpu (typically as a texture), the it will do the same for the dst.
     *  If the request cannot be fulfilled, returns false and dst is unmodified.
     */
        #[link_name = "?deepCopyTo@SkBitmap@@QEBA_NPEAV1@@Z"]
        pub fn SkBitmap_deepCopyTo(this: *const root::SkBitmap,
                                   dst: *mut root::SkBitmap) -> bool;
    }
    extern "C" {
        /** Set dst to contain alpha layer of this bitmap. If destination bitmap
        fails to be initialized, e.g. because allocator can't allocate pixels
        for it, dst will not be modified and false will be returned.

        @param dst The bitmap to be filled with alpha layer
        @param paint The paint to draw with
        @param allocator Allocator used to allocate the pixelref for the dst
                         bitmap. If this is null, the standard HeapAllocator
                         will be used.
        @param offset If not null, it is set to top-left coordinate to position
                      the returned bitmap so that it visually lines up with the
                      original
    */
        #[link_name =
              "?extractAlpha@SkBitmap@@QEBA_NPEAV1@PEBVSkPaint@@PEAVAllocator@1@PEAUSkIPoint@@@Z"]
        pub fn SkBitmap_extractAlpha(this: *const root::SkBitmap,
                                     dst: *mut root::SkBitmap,
                                     paint: *const root::SkPaint,
                                     allocator: *mut root::SkBitmap_Allocator,
                                     offset: *mut root::SkIPoint) -> bool;
    }
    extern "C" {
        /**
     *  If the pixels are available from this bitmap (w/o locking) return true, and fill out the
     *  specified pixmap (if not null). If the pixels are not available (either because there are
     *  none, or becuase accessing them would require locking or other machinary) return false and
     *  ignore the pixmap parameter.
     *
     *  Note: if this returns true, the results (in the pixmap) are only valid until the bitmap
     *  is changed in anyway, in which case the results are invalid.
     */
        #[link_name = "?peekPixels@SkBitmap@@QEBA_NPEAVSkPixmap@@@Z"]
        pub fn SkBitmap_peekPixels(this: *const root::SkBitmap,
                                   arg1: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        #[link_name = "?validate@SkBitmap@@QEBAXXZ"]
        pub fn SkBitmap_validate(this: *const root::SkBitmap);
    }
    extern "C" {
        #[link_name = "?toString@SkBitmap@@QEBAXPEAVSkString@@@Z"]
        pub fn SkBitmap_toString(this: *const root::SkBitmap,
                                 str: *mut root::SkString);
    }
    extern "C" {
        /**
     *  Default construct creates a bitmap with zero width and height, and no pixels.
     *  Its colortype is set to kUnknown_SkColorType.
     */
        #[link_name = "??0SkBitmap@@QEAA@XZ"]
        pub fn SkBitmap_SkBitmap(this: *mut root::SkBitmap);
    }
    extern "C" {
        /**
     *  Copy the settings from the src into this bitmap. If the src has pixels
     *  allocated, they will be shared, not copied, so that the two bitmaps will
     *  reference the same memory for the pixels. If a deep copy is needed,
     *  where the new bitmap has its own separate copy of the pixels, use
     *  deepCopyTo().
     */
        #[link_name = "??0SkBitmap@@QEAA@AEBV0@@Z"]
        pub fn SkBitmap_SkBitmap1(this: *mut root::SkBitmap,
                                  src: *const root::SkBitmap);
    }
    extern "C" {
        /**
     *  Copy the settings from the src into this bitmap. If the src has pixels
     *  allocated, ownership of the pixels will be taken.
     */
        #[link_name = "??0SkBitmap@@QEAA@$$QEAV0@@Z"]
        pub fn SkBitmap_SkBitmap2(this: *mut root::SkBitmap,
                                  src: *mut root::SkBitmap);
    }
    impl SkBitmap {
        #[inline]
        pub unsafe fn swap(&mut self, other: *mut root::SkBitmap) {
            SkBitmap_swap(&mut *self, other)
        }
        #[inline]
        pub unsafe fn setAlphaType(&mut self, arg1: root::SkAlphaType)
         -> bool {
            SkBitmap_setAlphaType(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn isImmutable(&self) -> bool {
            SkBitmap_isImmutable(&*self)
        }
        #[inline]
        pub unsafe fn setImmutable(&mut self) {
            SkBitmap_setImmutable(&mut *self)
        }
        #[inline]
        pub unsafe fn isVolatile(&self) -> bool {
            SkBitmap_isVolatile(&*self)
        }
        #[inline]
        pub unsafe fn setIsVolatile(&mut self, arg1: bool) {
            SkBitmap_setIsVolatile(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkBitmap_reset(&mut *self) }
        #[inline]
        pub unsafe fn getBounds(&self, bounds: *mut root::SkRect) {
            SkBitmap_getBounds(&*self, bounds)
        }
        #[inline]
        pub unsafe fn getBounds1(&self, bounds: *mut root::SkIRect) {
            SkBitmap_getBounds1(&*self, bounds)
        }
        #[inline]
        pub unsafe fn setInfo(&mut self, arg1: *const root::SkImageInfo,
                              rowBytes: usize) -> bool {
            SkBitmap_setInfo(&mut *self, arg1, rowBytes)
        }
        #[inline]
        pub unsafe fn tryAllocPixels(&mut self,
                                     arg1: *const root::SkImageInfo,
                                     arg2: *mut root::SkPixelRefFactory,
                                     arg3: *mut root::SkColorTable) -> bool {
            SkBitmap_tryAllocPixels(&mut *self, arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn tryAllocPixels1(&mut self,
                                      info: *const root::SkImageInfo,
                                      rowBytes: usize) -> bool {
            SkBitmap_tryAllocPixels1(&mut *self, info, rowBytes)
        }
        #[inline]
        pub unsafe fn installPixels(&mut self, arg1: *const root::SkImageInfo,
                                    pixels: *mut ::std::os::raw::c_void,
                                    rowBytes: usize,
                                    arg2: *mut root::SkColorTable,
                                    releaseProc:
                                        ::std::option::Option<unsafe extern "C" fn(addr:
                                                                                       *mut ::std::os::raw::c_void,
                                                                                   context:
                                                                                       *mut ::std::os::raw::c_void)>,
                                    context: *mut ::std::os::raw::c_void)
         -> bool {
            SkBitmap_installPixels(&mut *self, arg1, pixels, rowBytes, arg2,
                                   releaseProc, context)
        }
        #[inline]
        pub unsafe fn installPixels1(&mut self, arg1: *const root::SkPixmap)
         -> bool {
            SkBitmap_installPixels1(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn installMaskPixels(&mut self, arg1: *const root::SkMask)
         -> bool {
            SkBitmap_installMaskPixels(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn setPixels(&mut self, p: *mut ::std::os::raw::c_void,
                                ctable: *mut root::SkColorTable) {
            SkBitmap_setPixels(&mut *self, p, ctable)
        }
        #[inline]
        pub unsafe fn copyPixelsTo(&self, dst: *const ::std::os::raw::c_void,
                                   dstSize: usize, dstRowBytes: usize,
                                   preserveDstPad: bool) -> bool {
            SkBitmap_copyPixelsTo(&*self, dst, dstSize, dstRowBytes,
                                  preserveDstPad)
        }
        #[inline]
        pub unsafe fn tryAllocPixels2(&mut self,
                                      allocator:
                                          *mut root::SkBitmap_Allocator,
                                      ctable: *mut root::SkColorTable)
         -> bool {
            SkBitmap_tryAllocPixels2(&mut *self, allocator, ctable)
        }
        #[inline]
        pub unsafe fn setPixelRef(&mut self, pr: *mut root::SkPixelRef,
                                  dx: ::std::os::raw::c_int,
                                  dy: ::std::os::raw::c_int)
         -> *mut root::SkPixelRef {
            SkBitmap_setPixelRef(&mut *self, pr, dx, dy)
        }
        #[inline]
        pub unsafe fn lockPixels(&self) { SkBitmap_lockPixels(&*self) }
        #[inline]
        pub unsafe fn unlockPixels(&self) { SkBitmap_unlockPixels(&*self) }
        #[inline]
        pub unsafe fn lockPixelsAreWritable(&self) -> bool {
            SkBitmap_lockPixelsAreWritable(&*self)
        }
        #[inline]
        pub unsafe fn requestLock(&self,
                                  result: *mut root::SkAutoPixmapUnlock)
         -> bool {
            SkBitmap_requestLock(&*self, result)
        }
        #[inline]
        pub unsafe fn getGenerationID(&self) -> u32 {
            SkBitmap_getGenerationID(&*self)
        }
        #[inline]
        pub unsafe fn notifyPixelsChanged(&self) {
            SkBitmap_notifyPixelsChanged(&*self)
        }
        #[inline]
        pub unsafe fn eraseColor(&self, c: root::SkColor) {
            SkBitmap_eraseColor(&*self, c)
        }
        #[inline]
        pub unsafe fn erase(&self, c: root::SkColor,
                            area: *const root::SkIRect) {
            SkBitmap_erase(&*self, c, area)
        }
        #[inline]
        pub unsafe fn getAddr(&self, x: ::std::os::raw::c_int,
                              y: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void {
            SkBitmap_getAddr(&*self, x, y)
        }
        #[inline]
        pub unsafe fn extractSubset(&self, dst: *mut root::SkBitmap,
                                    subset: *const root::SkIRect) -> bool {
            SkBitmap_extractSubset(&*self, dst, subset)
        }
        #[inline]
        pub unsafe fn copyTo(&self, dst: *mut root::SkBitmap,
                             ct: root::SkColorType,
                             arg1: *mut root::SkBitmap_Allocator) -> bool {
            SkBitmap_copyTo(&*self, dst, ct, arg1)
        }
        #[inline]
        pub unsafe fn readPixels(&self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int) -> bool {
            SkBitmap_readPixels(&*self, dstInfo, dstPixels, dstRowBytes, srcX,
                                srcY)
        }
        #[inline]
        pub unsafe fn canCopyTo(&self, colorType: root::SkColorType) -> bool {
            SkBitmap_canCopyTo(&*self, colorType)
        }
        #[inline]
        pub unsafe fn deepCopyTo(&self, dst: *mut root::SkBitmap) -> bool {
            SkBitmap_deepCopyTo(&*self, dst)
        }
        #[inline]
        pub unsafe fn extractAlpha(&self, dst: *mut root::SkBitmap,
                                   paint: *const root::SkPaint,
                                   allocator: *mut root::SkBitmap_Allocator,
                                   offset: *mut root::SkIPoint) -> bool {
            SkBitmap_extractAlpha(&*self, dst, paint, allocator, offset)
        }
        #[inline]
        pub unsafe fn peekPixels(&self, arg1: *mut root::SkPixmap) -> bool {
            SkBitmap_peekPixels(&*self, arg1)
        }
        #[inline]
        pub unsafe fn validate(&self) { SkBitmap_validate(&*self) }
        #[inline]
        pub unsafe fn toString(&self, str: *mut root::SkString) {
            SkBitmap_toString(&*self, str)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkBitmap_SkBitmap(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(src: *const root::SkBitmap) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkBitmap_SkBitmap1(&mut __bindgen_tmp, src);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(src: *mut root::SkBitmap) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkBitmap_SkBitmap2(&mut __bindgen_tmp, src);
            __bindgen_tmp
        }
    }
    #[repr(i32)]
    /**
 *  Enum describing format of encoded data.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkEncodedImageFormat {
        kBMP = 0,
        kGIF = 1,
        kICO = 2,
        kJPEG = 3,
        kPNG = 4,
        kWBMP = 5,
        kWEBP = 6,
        kPKM = 7,
        kKTX = 8,
        kASTC = 9,
        kDNG = 10,
    }
    #[repr(C)]
    pub struct SkStream__bindgen_vtable {
    }
    /**
 *  SkStream -- abstraction for a source of bytes. Subclasses can be backed by
 *  memory, or a file, or something else.
 *
 *  NOTE:
 *
 *  Classic "streams" APIs are sort of async, in that on a request for N
 *  bytes, they may return fewer than N bytes on a given call, in which case
 *  the caller can "try again" to get more bytes, eventually (modulo an error)
 *  receiving their total N bytes.
 *
 *  Skia streams behave differently. They are effectively synchronous, and will
 *  always return all N bytes of the request if possible. If they return fewer
 *  (the read() call returns the number of bytes read) then that means there is
 *  no more data (at EOF or hit an error). The caller should *not* call again
 *  in hopes of fulfilling more of the request.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkStream {
        pub vtable_: *const SkStream__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkStream() {
        assert_eq!(::std::mem::size_of::<SkStream>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkStream>() , 8usize);
    }
    extern "C" {
        /**
     *  Attempts to open the specified file as a stream, returns nullptr on failure.
     */
        #[link_name =
              "?MakeFromFile@SkStream@@SA?AV?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@QEBD@Z"]
        pub fn SkStream_MakeFromFile(path: *const ::std::os::raw::c_char)
         ->
             root::std::unique_ptr<root::SkStreamAsset,
                                   root::std::default_delete<root::SkStreamAsset>>;
    }
    extern "C" {
        #[link_name = "?readS8@SkStream@@QEAACXZ"]
        pub fn SkStream_readS8(this: *mut root::SkStream) -> i8;
    }
    extern "C" {
        #[link_name = "?readS16@SkStream@@QEAAFXZ"]
        pub fn SkStream_readS16(this: *mut root::SkStream) -> i16;
    }
    extern "C" {
        #[link_name = "?readS32@SkStream@@QEAAHXZ"]
        pub fn SkStream_readS32(this: *mut root::SkStream) -> i32;
    }
    extern "C" {
        #[link_name = "?readScalar@SkStream@@QEAAMXZ"]
        pub fn SkStream_readScalar(this: *mut root::SkStream)
         -> root::SkScalar;
    }
    extern "C" {
        #[link_name = "?readPackedUInt@SkStream@@QEAA_KXZ"]
        pub fn SkStream_readPackedUInt(this: *mut root::SkStream) -> usize;
    }
    impl SkStream {
        #[inline]
        pub unsafe fn MakeFromFile(path: *const ::std::os::raw::c_char)
         ->
             root::std::unique_ptr<root::SkStreamAsset,
                                   root::std::default_delete<root::SkStreamAsset>> {
            SkStream_MakeFromFile(path)
        }
        #[inline]
        pub unsafe fn readS8(&mut self) -> i8 { SkStream_readS8(&mut *self) }
        #[inline]
        pub unsafe fn readS16(&mut self) -> i16 {
            SkStream_readS16(&mut *self)
        }
        #[inline]
        pub unsafe fn readS32(&mut self) -> i32 {
            SkStream_readS32(&mut *self)
        }
        #[inline]
        pub unsafe fn readScalar(&mut self) -> root::SkScalar {
            SkStream_readScalar(&mut *self)
        }
        #[inline]
        pub unsafe fn readPackedUInt(&mut self) -> usize {
            SkStream_readPackedUInt(&mut *self)
        }
    }
    /** SkStreamRewindable is a SkStream for which rewind and duplicate are required. */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkStreamRewindable {
        pub _base: root::SkStream,
    }
    #[test]
    fn bindgen_test_layout_SkStreamRewindable() {
        assert_eq!(::std::mem::size_of::<SkStreamRewindable>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkStreamRewindable>() , 8usize);
    }
    /** SkStreamSeekable is a SkStreamRewindable for which position, seek, move, and fork are required. */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkStreamSeekable {
        pub _base: root::SkStreamRewindable,
    }
    #[test]
    fn bindgen_test_layout_SkStreamSeekable() {
        assert_eq!(::std::mem::size_of::<SkStreamSeekable>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkStreamSeekable>() , 8usize);
    }
    /** SkStreamAsset is a SkStreamSeekable for which getLength is required. */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkStreamAsset {
        pub _base: root::SkStreamSeekable,
    }
    #[test]
    fn bindgen_test_layout_SkStreamAsset() {
        assert_eq!(::std::mem::size_of::<SkStreamAsset>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkStreamAsset>() , 8usize);
    }
    #[repr(C)]
    pub struct SkWStream__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkWStream {
        pub vtable_: *const SkWStream__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkWStream() {
        assert_eq!(::std::mem::size_of::<SkWStream>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkWStream>() , 8usize);
    }
    extern "C" {
        #[link_name = "?write8@SkWStream@@QEAA_NI@Z"]
        pub fn SkWStream_write8(this: *mut root::SkWStream, arg1: root::U8CPU)
         -> bool;
    }
    extern "C" {
        #[link_name = "?write16@SkWStream@@QEAA_NI@Z"]
        pub fn SkWStream_write16(this: *mut root::SkWStream,
                                 arg1: root::U16CPU) -> bool;
    }
    extern "C" {
        #[link_name = "?write32@SkWStream@@QEAA_NI@Z"]
        pub fn SkWStream_write32(this: *mut root::SkWStream, arg1: u32)
         -> bool;
    }
    extern "C" {
        #[link_name = "?writeDecAsText@SkWStream@@QEAA_NH@Z"]
        pub fn SkWStream_writeDecAsText(this: *mut root::SkWStream, arg1: i32)
         -> bool;
    }
    extern "C" {
        #[link_name = "?writeBigDecAsText@SkWStream@@QEAA_N_JH@Z"]
        pub fn SkWStream_writeBigDecAsText(this: *mut root::SkWStream,
                                           arg1: i64,
                                           minDigits: ::std::os::raw::c_int)
         -> bool;
    }
    extern "C" {
        #[link_name = "?writeHexAsText@SkWStream@@QEAA_NIH@Z"]
        pub fn SkWStream_writeHexAsText(this: *mut root::SkWStream, arg1: u32,
                                        minDigits: ::std::os::raw::c_int)
         -> bool;
    }
    extern "C" {
        #[link_name = "?writeScalarAsText@SkWStream@@QEAA_NM@Z"]
        pub fn SkWStream_writeScalarAsText(this: *mut root::SkWStream,
                                           arg1: root::SkScalar) -> bool;
    }
    extern "C" {
        #[link_name = "?writeScalar@SkWStream@@QEAA_NM@Z"]
        pub fn SkWStream_writeScalar(this: *mut root::SkWStream,
                                     arg1: root::SkScalar) -> bool;
    }
    extern "C" {
        #[link_name = "?writePackedUInt@SkWStream@@QEAA_N_K@Z"]
        pub fn SkWStream_writePackedUInt(this: *mut root::SkWStream,
                                         arg1: usize) -> bool;
    }
    extern "C" {
        #[link_name = "?writeStream@SkWStream@@QEAA_NPEAVSkStream@@_K@Z"]
        pub fn SkWStream_writeStream(this: *mut root::SkWStream,
                                     input: *mut root::SkStream,
                                     length: usize) -> bool;
    }
    extern "C" {
        /**
     * This returns the number of bytes in the stream required to store
     * 'value'.
     */
        #[link_name = "?SizeOfPackedUInt@SkWStream@@SAH_K@Z"]
        pub fn SkWStream_SizeOfPackedUInt(value: usize)
         -> ::std::os::raw::c_int;
    }
    impl SkWStream {
        #[inline]
        pub unsafe fn write8(&mut self, arg1: root::U8CPU) -> bool {
            SkWStream_write8(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn write16(&mut self, arg1: root::U16CPU) -> bool {
            SkWStream_write16(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn write32(&mut self, arg1: u32) -> bool {
            SkWStream_write32(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn writeDecAsText(&mut self, arg1: i32) -> bool {
            SkWStream_writeDecAsText(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn writeBigDecAsText(&mut self, arg1: i64,
                                        minDigits: ::std::os::raw::c_int)
         -> bool {
            SkWStream_writeBigDecAsText(&mut *self, arg1, minDigits)
        }
        #[inline]
        pub unsafe fn writeHexAsText(&mut self, arg1: u32,
                                     minDigits: ::std::os::raw::c_int)
         -> bool {
            SkWStream_writeHexAsText(&mut *self, arg1, minDigits)
        }
        #[inline]
        pub unsafe fn writeScalarAsText(&mut self, arg1: root::SkScalar)
         -> bool {
            SkWStream_writeScalarAsText(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn writeScalar(&mut self, arg1: root::SkScalar) -> bool {
            SkWStream_writeScalar(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn writePackedUInt(&mut self, arg1: usize) -> bool {
            SkWStream_writePackedUInt(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn writeStream(&mut self, input: *mut root::SkStream,
                                  length: usize) -> bool {
            SkWStream_writeStream(&mut *self, input, length)
        }
        #[inline]
        pub unsafe fn SizeOfPackedUInt(value: usize)
         -> ::std::os::raw::c_int {
            SkWStream_SizeOfPackedUInt(value)
        }
    }
    pub const SkBlendMode_kLastCoeffMode: root::SkBlendMode =
        SkBlendMode::kScreen;
    pub const SkBlendMode_kLastSeparableMode: root::SkBlendMode =
        SkBlendMode::kMultiply;
    pub const SkBlendMode_kLastMode: root::SkBlendMode =
        SkBlendMode::kLuminosity;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkBlendMode {
        kClear = 0,
        kSrc = 1,
        kDst = 2,
        kSrcOver = 3,
        kDstOver = 4,
        kSrcIn = 5,
        kDstIn = 6,
        kSrcOut = 7,
        kDstOut = 8,
        kSrcATop = 9,
        kDstATop = 10,
        kXor = 11,
        kPlus = 12,
        kModulate = 13,
        kScreen = 14,
        kOverlay = 15,
        kDarken = 16,
        kLighten = 17,
        kColorDodge = 18,
        kColorBurn = 19,
        kHardLight = 20,
        kSoftLight = 21,
        kDifference = 22,
        kExclusion = 23,
        kMultiply = 24,
        kHue = 25,
        kSaturation = 26,
        kColor = 27,
        kLuminosity = 28,
    }
    /**
 *  ColorFilters are optional objects in the drawing pipeline. When present in
 *  a paint, they are called with the "src" colors, and return new colors, which
 *  are then passed onto the next stage (either ImageFilter or Xfermode).
 *
 *  All subclasses are required to be reentrant-safe : it must be legal to share
 *  the same instance between several threads.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkColorFilter {
        pub _base: root::SkFlattenable,
    }
    pub const SkColorFilter_Flags_kAlphaUnchanged_Flag:
              root::SkColorFilter_Flags =
        SkColorFilter_Flags(1);
    impl ::std::ops::BitOr<root::SkColorFilter_Flags> for
     root::SkColorFilter_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkColorFilter_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkColorFilter_Flags(pub i32);
    pub type SkColorFilter_INHERITED = root::SkFlattenable;
    #[test]
    fn bindgen_test_layout_SkColorFilter() {
        assert_eq!(::std::mem::size_of::<SkColorFilter>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkColorFilter>() , 8usize);
    }
    extern "C" {
        #[link_name =
              "?appendStages@SkColorFilter@@QEBA_NPEAVSkRasterPipeline@@PEAVSkColorSpace@@PEAVSkFallbackAlloc@@_N@Z"]
        pub fn SkColorFilter_appendStages(this: *const root::SkColorFilter,
                                          arg1: *mut root::SkRasterPipeline,
                                          arg2: *mut root::SkColorSpace,
                                          arg3: *mut root::SkFallbackAlloc,
                                          shaderIsOpaque: bool) -> bool;
    }
    extern "C" {
        /**
     *  Apply this colorfilter to the specified SkColor. This routine handles
     *  converting to SkPMColor, calling the filter, and then converting back
     *  to SkColor. This method is not virtual, but will call filterSpan()
     *   which is virtual.
     */
        #[link_name = "?filterColor@SkColorFilter@@QEBAII@Z"]
        pub fn SkColorFilter_filterColor(this: *const root::SkColorFilter,
                                         arg1: root::SkColor)
         -> root::SkColor;
    }
    extern "C" {
        /**
     *  Filters a single color.
     */
        #[link_name =
              "?filterColor4f@SkColorFilter@@QEBA?AUSkColor4f@@AEBU2@@Z"]
        pub fn SkColorFilter_filterColor4f(this: *const root::SkColorFilter,
                                           arg1: *const root::SkColor4f)
         -> root::SkColor4f;
    }
    extern "C" {
        /** Create a colorfilter that uses the specified color and mode.
        If the Mode is DST, this function will return NULL (since that
        mode will have no effect on the result).
        @param c    The source color used with the specified mode
        @param mode The blend that is applied to each color in
                        the colorfilter's filterSpan[16,32] methods
        @return colorfilter object that applies the src color and mode,
                    or NULL if the mode will have no effect.
    */
        #[link_name =
              "?MakeModeFilter@SkColorFilter@@SA?AV?$sk_sp@VSkColorFilter@@@@IW4SkBlendMode@@@Z"]
        pub fn SkColorFilter_MakeModeFilter(c: root::SkColor,
                                            mode: root::SkBlendMode)
         -> root::sk_sp<root::SkColorFilter>;
    }
    extern "C" {
        /** Construct a colorfilter whose effect is to first apply the inner filter and then apply
     *  the outer filter to the result of the inner's.
     *  The reference counts for outer and inner are incremented.
     *
     *  Due to internal limits, it is possible that this will return NULL, so the caller must
     *  always check.
     */
        #[link_name =
              "?MakeComposeFilter@SkColorFilter@@SA?AV?$sk_sp@VSkColorFilter@@@@V2@0@Z"]
        pub fn SkColorFilter_MakeComposeFilter(outer:
                                                   root::sk_sp<root::SkColorFilter>,
                                               inner:
                                                   root::sk_sp<root::SkColorFilter>)
         -> root::sk_sp<root::SkColorFilter>;
    }
    extern "C" {
        /** Construct a color filter that transforms a color by a 4x5 matrix. The matrix is in row-
     *  major order and the translation column is specified in unnormalized, 0...255, space.
     */
        #[link_name =
              "?MakeMatrixFilterRowMajor255@SkColorFilter@@SA?AV?$sk_sp@VSkColorFilter@@@@QEBM@Z"]
        pub fn SkColorFilter_MakeMatrixFilterRowMajor255(array:
                                                             *mut root::SkScalar)
         -> root::sk_sp<root::SkColorFilter>;
    }
    extern "C" {
        #[link_name = "?InitializeFlattenables@SkColorFilter@@SAXXZ"]
        pub fn SkColorFilter_InitializeFlattenables();
    }
    impl SkColorFilter {
        #[inline]
        pub unsafe fn appendStages(&self, arg1: *mut root::SkRasterPipeline,
                                   arg2: *mut root::SkColorSpace,
                                   arg3: *mut root::SkFallbackAlloc,
                                   shaderIsOpaque: bool) -> bool {
            SkColorFilter_appendStages(&*self, arg1, arg2, arg3,
                                       shaderIsOpaque)
        }
        #[inline]
        pub unsafe fn filterColor(&self, arg1: root::SkColor)
         -> root::SkColor {
            SkColorFilter_filterColor(&*self, arg1)
        }
        #[inline]
        pub unsafe fn filterColor4f(&self, arg1: *const root::SkColor4f)
         -> root::SkColor4f {
            SkColorFilter_filterColor4f(&*self, arg1)
        }
        #[inline]
        pub unsafe fn MakeModeFilter(c: root::SkColor,
                                     mode: root::SkBlendMode)
         -> root::sk_sp<root::SkColorFilter> {
            SkColorFilter_MakeModeFilter(c, mode)
        }
        #[inline]
        pub unsafe fn MakeComposeFilter(outer:
                                            root::sk_sp<root::SkColorFilter>,
                                        inner:
                                            root::sk_sp<root::SkColorFilter>)
         -> root::sk_sp<root::SkColorFilter> {
            SkColorFilter_MakeComposeFilter(outer, inner)
        }
        #[inline]
        pub unsafe fn MakeMatrixFilterRowMajor255(array: *mut root::SkScalar)
         -> root::sk_sp<root::SkColorFilter> {
            SkColorFilter_MakeMatrixFilterRowMajor255(array)
        }
        #[inline]
        pub unsafe fn InitializeFlattenables() {
            SkColorFilter_InitializeFlattenables()
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDescriptor {
        pub _address: u8,
    }
    impl Clone for SkDescriptor {
        fn clone(&self) -> Self { *self }
    }
    /** \class SkDrawLooper
    Subclasses of SkDrawLooper can be attached to a SkPaint. Where they are,
    and something is drawn to a canvas with that paint, the looper subclass will
    be called, allowing it to modify the canvas and/or paint for that draw call.
    More than that, via the next() method, the looper can modify the draw to be
    invoked multiple times (hence the name loop-er), allow it to perform effects
    like shadows or frame/fills, that require more than one pass.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkDrawLooper {
        pub _base: root::SkFlattenable,
    }
    #[repr(C)]
    pub struct SkDrawLooper_Context__bindgen_vtable {
    }
    /**
     *  Holds state during a draw. Users call next() until it returns false.
     *
     *  Subclasses of SkDrawLooper should create a subclass of this object to
     *  hold state specific to their subclass.
     */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkDrawLooper_Context {
        pub vtable_: *const SkDrawLooper_Context__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkDrawLooper_Context() {
        assert_eq!(::std::mem::size_of::<SkDrawLooper_Context>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkDrawLooper_Context>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDrawLooper_BlurShadowRec {
        pub fSigma: root::SkScalar,
        pub fOffset: root::SkVector,
        pub fColor: root::SkColor,
        pub fStyle: root::SkBlurStyle,
        pub fQuality: root::SkBlurQuality,
    }
    #[test]
    fn bindgen_test_layout_SkDrawLooper_BlurShadowRec() {
        assert_eq!(::std::mem::size_of::<SkDrawLooper_BlurShadowRec>() ,
                   24usize);
        assert_eq!(::std::mem::align_of::<SkDrawLooper_BlurShadowRec>() ,
                   4usize);
    }
    impl Clone for SkDrawLooper_BlurShadowRec {
        fn clone(&self) -> Self { *self }
    }
    pub type SkDrawLooper_INHERITED = root::SkFlattenable;
    #[test]
    fn bindgen_test_layout_SkDrawLooper() {
        assert_eq!(::std::mem::size_of::<SkDrawLooper>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkDrawLooper>() , 8usize);
    }
    extern "C" {
        /**
     * The fast bounds functions are used to enable the paint to be culled early
     * in the drawing pipeline. If a subclass can support this feature it must
     * return true for the canComputeFastBounds() function.  If that function
     * returns false then computeFastBounds behavior is undefined otherwise it
     * is expected to have the following behavior. Given the parent paint and
     * the parent's bounding rect the subclass must fill in and return the
     * storage rect, where the storage rect is with the union of the src rect
     * and the looper's bounding rect.
     */
        #[link_name =
              "?canComputeFastBounds@SkDrawLooper@@QEBA_NAEBVSkPaint@@@Z"]
        pub fn SkDrawLooper_canComputeFastBounds(this:
                                                     *const root::SkDrawLooper,
                                                 paint: *const root::SkPaint)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?computeFastBounds@SkDrawLooper@@QEBAXAEBVSkPaint@@AEBUSkRect@@PEAU3@@Z"]
        pub fn SkDrawLooper_computeFastBounds(this: *const root::SkDrawLooper,
                                              paint: *const root::SkPaint,
                                              src: *const root::SkRect,
                                              dst: *mut root::SkRect);
    }
    impl SkDrawLooper {
        #[inline]
        pub unsafe fn canComputeFastBounds(&self, paint: *const root::SkPaint)
         -> bool {
            SkDrawLooper_canComputeFastBounds(&*self, paint)
        }
        #[inline]
        pub unsafe fn computeFastBounds(&self, paint: *const root::SkPaint,
                                        src: *const root::SkRect,
                                        dst: *mut root::SkRect) {
            SkDrawLooper_computeFastBounds(&*self, paint, src, dst)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkGlyph {
        pub _address: u8,
    }
    impl Clone for SkGlyph {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkGlyphCache {
        pub _address: u8,
    }
    impl Clone for SkGlyphCache {
        fn clone(&self) -> Self { *self }
    }
    /**
 *  Base class for image filters. If one is installed in the paint, then
 *  all drawing occurs as usual, but it is as if the drawing happened into an
 *  offscreen (before the xfermode is applied). This offscreen bitmap will
 *  then be handed to the imagefilter, who in turn creates a new bitmap which
 *  is what will finally be drawn to the device (using the original xfermode).
 */
    #[repr(C)]
    pub struct SkImageFilter {
        pub _base: root::SkFlattenable,
        pub fInputs: [u64; 4usize],
        pub fUsesSrcInput: bool,
        pub fCropRect: root::SkImageFilter_CropRect,
        pub fUniqueID: u32,
        pub fCacheKeys: [u64; 4usize],
        pub fMutex: root::SkMutex,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImageFilter_OutputProperties {
        pub fColorSpace: *mut root::SkColorSpace,
    }
    #[test]
    fn bindgen_test_layout_SkImageFilter_OutputProperties() {
        assert_eq!(::std::mem::size_of::<SkImageFilter_OutputProperties>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<SkImageFilter_OutputProperties>() ,
                   8usize);
    }
    impl Clone for SkImageFilter_OutputProperties {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImageFilter_Context {
        pub fCTM: root::SkMatrix,
        pub fClipBounds: root::SkIRect,
        pub fCache: *mut root::SkImageFilterCache,
        pub fOutputProperties: root::SkImageFilter_OutputProperties,
    }
    #[test]
    fn bindgen_test_layout_SkImageFilter_Context() {
        assert_eq!(::std::mem::size_of::<SkImageFilter_Context>() , 72usize);
        assert_eq!(::std::mem::align_of::<SkImageFilter_Context>() , 8usize);
    }
    impl Clone for SkImageFilter_Context {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImageFilter_CropRect {
        pub fRect: root::SkRect,
        pub fFlags: u32,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkImageFilter_CropRect_CropEdge {
        kHasLeft_CropEdge = 1,
        kHasTop_CropEdge = 2,
        kHasWidth_CropEdge = 4,
        kHasHeight_CropEdge = 8,
        kHasAll_CropEdge = 15,
    }
    #[test]
    fn bindgen_test_layout_SkImageFilter_CropRect() {
        assert_eq!(::std::mem::size_of::<SkImageFilter_CropRect>() , 20usize);
        assert_eq!(::std::mem::align_of::<SkImageFilter_CropRect>() , 4usize);
    }
    extern "C" {
        #[link_name =
              "?toString@CropRect@SkImageFilter@@QEBAXPEAVSkString@@@Z"]
        pub fn SkImageFilter_CropRect_toString(this:
                                                   *const root::SkImageFilter_CropRect,
                                               str: *mut root::SkString);
    }
    extern "C" {
        /**
         *  Apply this cropRect to the imageBounds. If a given edge of the cropRect is not
         *  set, then the corresponding edge from imageBounds will be used. If "embiggen"
         *  is true, the crop rect is allowed to enlarge the size of the rect, otherwise
         *  it may only reduce the rect. Filters that can affect transparent black should 
         *  pass "true", while all other filters should pass "false".
         *
         *  Note: imageBounds is in "device" space, as the output cropped rectangle will be,
         *  so the matrix is ignored for those. It is only applied the croprect's bounds.
         */
        #[link_name =
              "?applyTo@CropRect@SkImageFilter@@QEBAXAEBUSkIRect@@AEBVSkMatrix@@_NPEAU3@@Z"]
        pub fn SkImageFilter_CropRect_applyTo(this:
                                                  *const root::SkImageFilter_CropRect,
                                              imageBounds:
                                                  *const root::SkIRect,
                                              arg1: *const root::SkMatrix,
                                              embiggen: bool,
                                              cropped: *mut root::SkIRect);
    }
    impl Clone for SkImageFilter_CropRect {
        fn clone(&self) -> Self { *self }
    }
    impl SkImageFilter_CropRect {
        #[inline]
        pub unsafe fn toString(&self, str: *mut root::SkString) {
            SkImageFilter_CropRect_toString(&*self, str)
        }
        #[inline]
        pub unsafe fn applyTo(&self, imageBounds: *const root::SkIRect,
                              arg1: *const root::SkMatrix, embiggen: bool,
                              cropped: *mut root::SkIRect) {
            SkImageFilter_CropRect_applyTo(&*self, imageBounds, arg1,
                                           embiggen, cropped)
        }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkImageFilter_TileUsage {
        kPossible_TileUsage = 0,
        kNever_TileUsage = 1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkImageFilter_MapDirection {
        kForward_MapDirection = 0,
        kReverse_MapDirection = 1,
    }
    #[repr(C)]
    pub struct SkImageFilter_Common {
        pub fCropRect: root::SkImageFilter_CropRect,
        pub fInputs: [u64; 4usize],
    }
    #[test]
    fn bindgen_test_layout_SkImageFilter_Common() {
        assert_eq!(::std::mem::size_of::<SkImageFilter_Common>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkImageFilter_Common>() , 8usize);
    }
    extern "C" {
        /**
         *  Attempt to unflatten the cropRect and the expected number of input filters.
         *  If any number of input filters is valid, pass -1.
         *  If this fails (i.e. corrupt buffer or contents) then return false and common will
         *  be left uninitialized.
         *  If this returns true, then inputCount() is the number of found input filters, each
         *  of which may be NULL or a valid imagefilter.
         */
        #[link_name =
              "?unflatten@Common@SkImageFilter@@QEAA_NAEAVSkReadBuffer@@H@Z"]
        pub fn SkImageFilter_Common_unflatten(this:
                                                  *mut root::SkImageFilter_Common,
                                              arg1: *mut root::SkReadBuffer,
                                              expectedInputs:
                                                  ::std::os::raw::c_int)
         -> bool;
    }
    impl SkImageFilter_Common {
        #[inline]
        pub unsafe fn unflatten(&mut self, arg1: *mut root::SkReadBuffer,
                                expectedInputs: ::std::os::raw::c_int)
         -> bool {
            SkImageFilter_Common_unflatten(&mut *self, arg1, expectedInputs)
        }
    }
    pub type SkImageFilter_INHERITED = root::SkFlattenable;
    #[test]
    fn bindgen_test_layout_SkImageFilter() {
        assert_eq!(::std::mem::size_of::<SkImageFilter>() , 136usize);
        assert_eq!(::std::mem::align_of::<SkImageFilter>() , 8usize);
    }
    extern "C" {
        /**
     *  Request a new filtered image to be created from the src image.
     *
     *  The context contains the environment in which the filter is occurring.
     *  It includes the clip bounds, CTM and cache.
     *
     *  Offset is the amount to translate the resulting image relative to the
     *  src when it is drawn. This is an out-param.
     *
     *  If the result image cannot be created, or the result would be
     *  transparent black, return null, in which case the offset parameter
     *  should be ignored by the caller.
     *
     *  TODO: Right now the imagefilters sometimes return empty result bitmaps/
     *        specialimages. That doesn't seem quite right.
     */
        #[link_name =
              "?filterImage@SkImageFilter@@QEBA?AV?$sk_sp@VSkSpecialImage@@@@PEAVSkSpecialImage@@AEBVContext@1@PEAUSkIPoint@@@Z"]
        pub fn SkImageFilter_filterImage(this: *const root::SkImageFilter,
                                         src: *mut root::SkSpecialImage,
                                         arg1:
                                             *const root::SkImageFilter_Context,
                                         offset: *mut root::SkIPoint)
         -> root::sk_sp<root::SkSpecialImage>;
    }
    extern "C" {
        /**
     * Map a device-space rect recursively forward or backward through the
     * filter DAG. kForward_MapDirection is used to determine which pixels of
     * the destination canvas a source image rect would touch after filtering.
     * kReverse_MapDirection is used to determine which rect of the source
     * image would be required to fill the given rect (typically, clip bounds).
     * Used for clipping and temp-buffer allocations, so the result need not
     * be exact, but should never be smaller than the real answer. The default
     * implementation recursively unions all input bounds, or returns the
     * source rect if no inputs.
     */
        #[link_name =
              "?filterBounds@SkImageFilter@@QEBA?AUSkIRect@@AEBU2@AEBVSkMatrix@@W4MapDirection@1@@Z"]
        pub fn SkImageFilter_filterBounds(this: *const root::SkImageFilter,
                                          src: *const root::SkIRect,
                                          ctm: *const root::SkMatrix,
                                          arg1:
                                              root::SkImageFilter_MapDirection)
         -> root::SkIRect;
    }
    extern "C" {
        #[link_name =
              "?DrawWithFP@SkImageFilter@@SA?AV?$sk_sp@VSkSpecialImage@@@@PEAVGrContext@@V?$sk_sp@VGrFragmentProcessor@@@@AEBUSkIRect@@AEBVOutputProperties@1@@Z"]
        pub fn SkImageFilter_DrawWithFP(context: *mut root::GrContext,
                                        fp:
                                            root::sk_sp<root::GrFragmentProcessor>,
                                        bounds: *const root::SkIRect,
                                        outputProperties:
                                            *const root::SkImageFilter_OutputProperties)
         -> root::sk_sp<root::SkSpecialImage>;
    }
    extern "C" {
        #[link_name =
              "?MakeBlur@SkImageFilter@@SA?AV?$sk_sp@VSkImageFilter@@@@MMV2@PEBVCropRect@1@@Z"]
        pub fn SkImageFilter_MakeBlur(sigmaX: root::SkScalar,
                                      sigmaY: root::SkScalar,
                                      input: root::sk_sp<root::SkImageFilter>,
                                      cropRect:
                                          *const root::SkImageFilter_CropRect)
         -> root::sk_sp<root::SkImageFilter>;
    }
    extern "C" {
        /**
     *  Returns true (and optionally returns a ref'd filter) if this imagefilter can be completely
     *  replaced by the returned colorfilter. i.e. the two effects will affect drawing in the
     *  same way.
     */
        #[link_name =
              "?asAColorFilter@SkImageFilter@@QEBA_NPEAPEAVSkColorFilter@@@Z"]
        pub fn SkImageFilter_asAColorFilter(this: *const root::SkImageFilter,
                                            filterPtr:
                                                *mut *mut root::SkColorFilter)
         -> bool;
    }
    extern "C" {
        #[link_name = "?canComputeFastBounds@SkImageFilter@@QEBA_NXZ"]
        pub fn SkImageFilter_canComputeFastBounds(this:
                                                      *const root::SkImageFilter)
         -> bool;
    }
    extern "C" {
        /**
     *  If this filter can be represented by another filter + a localMatrix, return that filter,
     *  else return null.
     */
        #[link_name =
              "?makeWithLocalMatrix@SkImageFilter@@QEBA?AV?$sk_sp@VSkImageFilter@@@@AEBVSkMatrix@@@Z"]
        pub fn SkImageFilter_makeWithLocalMatrix(this:
                                                     *const root::SkImageFilter,
                                                 arg1: *const root::SkMatrix)
         -> root::sk_sp<root::SkImageFilter>;
    }
    extern "C" {
        /**
     *  ImageFilters can natively handle scaling and translate components in the CTM. Only some of
     *  them can handle affine (or more complex) matrices. This call returns true iff the filter
     *  and all of its (non-null) inputs can handle these more complex matrices.
     */
        #[link_name = "?canHandleComplexCTM@SkImageFilter@@QEBA_NXZ"]
        pub fn SkImageFilter_canHandleComplexCTM(this:
                                                     *const root::SkImageFilter)
         -> bool;
    }
    extern "C" {
        /**
     * Return an imagefilter which transforms its input by the given matrix.
     */
        #[link_name =
              "?MakeMatrixFilter@SkImageFilter@@SA?AV?$sk_sp@VSkImageFilter@@@@AEBVSkMatrix@@W4SkFilterQuality@@V2@@Z"]
        pub fn SkImageFilter_MakeMatrixFilter(matrix: *const root::SkMatrix,
                                              quality: root::SkFilterQuality,
                                              input:
                                                  root::sk_sp<root::SkImageFilter>)
         -> root::sk_sp<root::SkImageFilter>;
    }
    extern "C" {
        #[link_name = "?InitializeFlattenables@SkImageFilter@@SAXXZ"]
        pub fn SkImageFilter_InitializeFlattenables();
    }
    extern "C" {
        #[link_name =
              "?filterInput@SkImageFilter@@IEBA?AV?$sk_sp@VSkSpecialImage@@@@HPEAVSkSpecialImage@@AEBVContext@1@PEAUSkIPoint@@@Z"]
        pub fn SkImageFilter_filterInput(this: *const root::SkImageFilter,
                                         index: ::std::os::raw::c_int,
                                         src: *mut root::SkSpecialImage,
                                         arg1:
                                             *const root::SkImageFilter_Context,
                                         offset: *mut root::SkIPoint)
         -> root::sk_sp<root::SkSpecialImage>;
    }
    extern "C" {
        /** Given a "srcBounds" rect, computes destination bounds for this filter.
     *  "dstBounds" are computed by transforming the crop rect by the context's
     *  CTM, applying it to the initial bounds, and intersecting the result with
     *  the context's clip bounds.  "srcBounds" (if non-null) are computed by
     *  intersecting the initial bounds with "dstBounds", to ensure that we never
     *  sample outside of the crop rect (this restriction may be relaxed in the
     *  future).
     */
        #[link_name =
              "?applyCropRect@SkImageFilter@@IEBA_NAEBVContext@1@AEBUSkIRect@@PEAU3@@Z"]
        pub fn SkImageFilter_applyCropRect(this: *const root::SkImageFilter,
                                           arg1:
                                               *const root::SkImageFilter_Context,
                                           srcBounds: *const root::SkIRect,
                                           dstBounds: *mut root::SkIRect)
         -> bool;
    }
    extern "C" {
        /** A variant of the above call which takes the original source bitmap and
     *  source offset. If the resulting crop rect is not entirely contained by
     *  the source bitmap's bounds, it creates a new bitmap in "result" and
     *  pads the edges with transparent black. In that case, the srcOffset is
     *  modified to be the same as the bounds, since no further adjustment is
     *  needed by the caller. This version should only be used by filters
     *  which are not capable of processing a smaller source bitmap into a
     *  larger destination.
     */
        #[link_name =
              "?applyCropRect@SkImageFilter@@IEBA?AV?$sk_sp@VSkSpecialImage@@@@AEBVContext@1@PEAVSkSpecialImage@@PEAUSkIPoint@@PEAUSkIRect@@@Z"]
        pub fn SkImageFilter_applyCropRect1(this: *const root::SkImageFilter,
                                            arg1:
                                                *const root::SkImageFilter_Context,
                                            src: *mut root::SkSpecialImage,
                                            srcOffset: *mut root::SkIPoint,
                                            bounds: *mut root::SkIRect)
         -> root::sk_sp<root::SkSpecialImage>;
    }
    extern "C" {
        /**
     *  Creates a modified Context for use when recursing up the image filter DAG.
     *  The clip bounds are adjusted to accommodate any margins that this
     *  filter requires by calling this node's
     *  onFilterNodeBounds(..., kReverse_MapDirection).
     */
        #[link_name = "?mapContext@SkImageFilter@@IEBA?AVContext@1@AEBV21@@Z"]
        pub fn SkImageFilter_mapContext(this: *const root::SkImageFilter,
                                        ctx:
                                            *const root::SkImageFilter_Context)
         -> root::SkImageFilter_Context;
    }
    extern "C" {
        #[link_name =
              "??0SkImageFilter@@IEAA@PEAV?$sk_sp@VSkImageFilter@@@@HPEBVCropRect@0@@Z"]
        pub fn SkImageFilter_SkImageFilter(this: *mut root::SkImageFilter,
                                           inputs:
                                               *mut root::sk_sp<root::SkImageFilter>,
                                           inputCount: ::std::os::raw::c_int,
                                           cropRect:
                                               *const root::SkImageFilter_CropRect);
    }
    extern "C" {
        /**
     *  Constructs a new SkImageFilter read from an SkReadBuffer object.
     *
     *  @param inputCount    The exact number of inputs expected for this SkImageFilter object.
     *                       -1 can be used if the filter accepts any number of inputs.
     *  @param rb            SkReadBuffer object from which the SkImageFilter is read.
     */
        #[link_name = "??0SkImageFilter@@IEAA@HAEAVSkReadBuffer@@@Z"]
        pub fn SkImageFilter_SkImageFilter1(this: *mut root::SkImageFilter,
                                            inputCount: ::std::os::raw::c_int,
                                            rb: *mut root::SkReadBuffer);
    }
    impl SkImageFilter {
        #[inline]
        pub unsafe fn filterImage(&self, src: *mut root::SkSpecialImage,
                                  arg1: *const root::SkImageFilter_Context,
                                  offset: *mut root::SkIPoint)
         -> root::sk_sp<root::SkSpecialImage> {
            SkImageFilter_filterImage(&*self, src, arg1, offset)
        }
        #[inline]
        pub unsafe fn filterBounds(&self, src: *const root::SkIRect,
                                   ctm: *const root::SkMatrix,
                                   arg1: root::SkImageFilter_MapDirection)
         -> root::SkIRect {
            SkImageFilter_filterBounds(&*self, src, ctm, arg1)
        }
        #[inline]
        pub unsafe fn DrawWithFP(context: *mut root::GrContext,
                                 fp: root::sk_sp<root::GrFragmentProcessor>,
                                 bounds: *const root::SkIRect,
                                 outputProperties:
                                     *const root::SkImageFilter_OutputProperties)
         -> root::sk_sp<root::SkSpecialImage> {
            SkImageFilter_DrawWithFP(context, fp, bounds, outputProperties)
        }
        #[inline]
        pub unsafe fn MakeBlur(sigmaX: root::SkScalar, sigmaY: root::SkScalar,
                               input: root::sk_sp<root::SkImageFilter>,
                               cropRect: *const root::SkImageFilter_CropRect)
         -> root::sk_sp<root::SkImageFilter> {
            SkImageFilter_MakeBlur(sigmaX, sigmaY, input, cropRect)
        }
        #[inline]
        pub unsafe fn asAColorFilter(&self,
                                     filterPtr: *mut *mut root::SkColorFilter)
         -> bool {
            SkImageFilter_asAColorFilter(&*self, filterPtr)
        }
        #[inline]
        pub unsafe fn canComputeFastBounds(&self) -> bool {
            SkImageFilter_canComputeFastBounds(&*self)
        }
        #[inline]
        pub unsafe fn makeWithLocalMatrix(&self, arg1: *const root::SkMatrix)
         -> root::sk_sp<root::SkImageFilter> {
            SkImageFilter_makeWithLocalMatrix(&*self, arg1)
        }
        #[inline]
        pub unsafe fn canHandleComplexCTM(&self) -> bool {
            SkImageFilter_canHandleComplexCTM(&*self)
        }
        #[inline]
        pub unsafe fn MakeMatrixFilter(matrix: *const root::SkMatrix,
                                       quality: root::SkFilterQuality,
                                       input:
                                           root::sk_sp<root::SkImageFilter>)
         -> root::sk_sp<root::SkImageFilter> {
            SkImageFilter_MakeMatrixFilter(matrix, quality, input)
        }
        #[inline]
        pub unsafe fn InitializeFlattenables() {
            SkImageFilter_InitializeFlattenables()
        }
        #[inline]
        pub unsafe fn filterInput(&self, index: ::std::os::raw::c_int,
                                  src: *mut root::SkSpecialImage,
                                  arg1: *const root::SkImageFilter_Context,
                                  offset: *mut root::SkIPoint)
         -> root::sk_sp<root::SkSpecialImage> {
            SkImageFilter_filterInput(&*self, index, src, arg1, offset)
        }
        #[inline]
        pub unsafe fn applyCropRect(&self,
                                    arg1: *const root::SkImageFilter_Context,
                                    srcBounds: *const root::SkIRect,
                                    dstBounds: *mut root::SkIRect) -> bool {
            SkImageFilter_applyCropRect(&*self, arg1, srcBounds, dstBounds)
        }
        #[inline]
        pub unsafe fn applyCropRect1(&self,
                                     arg1: *const root::SkImageFilter_Context,
                                     src: *mut root::SkSpecialImage,
                                     srcOffset: *mut root::SkIPoint,
                                     bounds: *mut root::SkIRect)
         -> root::sk_sp<root::SkSpecialImage> {
            SkImageFilter_applyCropRect1(&*self, arg1, src, srcOffset, bounds)
        }
        #[inline]
        pub unsafe fn mapContext(&self,
                                 ctx: *const root::SkImageFilter_Context)
         -> root::SkImageFilter_Context {
            SkImageFilter_mapContext(&*self, ctx)
        }
        #[inline]
        pub unsafe fn new(inputs: *mut root::sk_sp<root::SkImageFilter>,
                          inputCount: ::std::os::raw::c_int,
                          cropRect: *const root::SkImageFilter_CropRect)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkImageFilter_SkImageFilter(&mut __bindgen_tmp, inputs,
                                        inputCount, cropRect);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(inputCount: ::std::os::raw::c_int,
                           rb: *mut root::SkReadBuffer) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkImageFilter_SkImageFilter1(&mut __bindgen_tmp, inputCount, rb);
            __bindgen_tmp
        }
    }
    /** \class SkMaskFilter

    SkMaskFilter is the base class for object that perform transformations on
    an alpha-channel mask before drawing it. A subclass of SkMaskFilter may be
    installed into a SkPaint. Once there, each time a primitive is drawn, it
    is first scan converted into a SkMask::kA8_Format mask, and handed to the
    filter, calling its filterMask() method. If this returns true, then the
    new mask is used to render into the device.

    Blur and emboss are implemented as subclasses of SkMaskFilter.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkMaskFilter {
        pub _base: root::SkFlattenable,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMaskFilter_BlurRec {
        pub fSigma: root::SkScalar,
        pub fStyle: root::SkBlurStyle,
        pub fQuality: root::SkBlurQuality,
    }
    #[test]
    fn bindgen_test_layout_SkMaskFilter_BlurRec() {
        assert_eq!(::std::mem::size_of::<SkMaskFilter_BlurRec>() , 12usize);
        assert_eq!(::std::mem::align_of::<SkMaskFilter_BlurRec>() , 4usize);
    }
    impl Clone for SkMaskFilter_BlurRec {
        fn clone(&self) -> Self { *self }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMaskFilter_FilterReturn {
        kFalse_FilterReturn = 0,
        kTrue_FilterReturn = 1,
        kUnimplemented_FilterReturn = 2,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkMaskFilter_NinePatch {
        pub fMask: root::SkMask,
        pub fOuterRect: root::SkIRect,
        pub fCenter: root::SkIPoint,
        pub fCache: *mut root::SkCachedData,
    }
    #[test]
    fn bindgen_test_layout_SkMaskFilter_NinePatch() {
        assert_eq!(::std::mem::size_of::<SkMaskFilter_NinePatch>() , 64usize);
        assert_eq!(::std::mem::align_of::<SkMaskFilter_NinePatch>() , 8usize);
    }
    pub type SkMaskFilter_INHERITED = root::SkFlattenable;
    #[test]
    fn bindgen_test_layout_SkMaskFilter() {
        assert_eq!(::std::mem::size_of::<SkMaskFilter>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkMaskFilter>() , 8usize);
    }
    /** \class SkPath

    The SkPath class encapsulates compound (multiple contour) geometric paths
    consisting of straight line segments, quadratic curves, and cubic curves.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPath {
        pub fPathRef: root::sk_sp<root::SkPathRef>,
        pub fLastMoveToIndex: ::std::os::raw::c_int,
        pub fFillType: u8,
        pub fConvexity: u8,
        pub fFirstDirection: u8,
        pub fIsVolatile: root::SkBool8,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPath_Direction { kCW_Direction = 0, kCCW_Direction = 1, }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPath_FillType {
        kWinding_FillType = 0,
        kEvenOdd_FillType = 1,
        kInverseWinding_FillType = 2,
        kInverseEvenOdd_FillType = 3,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPath_Convexity {
        kUnknown_Convexity = 0,
        kConvex_Convexity = 1,
        kConcave_Convexity = 2,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPath_ArcSize { kSmall_ArcSize = 0, kLarge_ArcSize = 1, }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPath_AddPathMode {
        kAppend_AddPathMode = 0,
        kExtend_AddPathMode = 1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPath_SegmentMask {
        kLine_SegmentMask = 1,
        kQuad_SegmentMask = 2,
        kConic_SegmentMask = 4,
        kCubic_SegmentMask = 8,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPath_Verb {
        kMove_Verb = 0,
        kLine_Verb = 1,
        kQuad_Verb = 2,
        kConic_Verb = 3,
        kCubic_Verb = 4,
        kClose_Verb = 5,
        kDone_Verb = 6,
    }
    /** Iterate through all of the segments (lines, quadratics, cubics) of
        each contours in a path.

        The iterator cleans up the segments along the way, removing degenerate
        segments and adding close verbs where necessary. When the forceClose
        argument is provided, each contour (as defined by a new starting
        move command) will be completed with a close verb regardless of the
        contour's contents.
    */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPath_Iter {
        pub fPts: *const root::SkPoint,
        pub fVerbs: *const u8,
        pub fVerbStop: *const u8,
        pub fConicWeights: *const root::SkScalar,
        pub fMoveTo: root::SkPoint,
        pub fLastPt: root::SkPoint,
        pub fForceClose: root::SkBool8,
        pub fNeedClose: root::SkBool8,
        pub fCloseLine: root::SkBool8,
        pub fSegmentState: root::SkBool8,
    }
    #[test]
    fn bindgen_test_layout_SkPath_Iter() {
        assert_eq!(::std::mem::size_of::<SkPath_Iter>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkPath_Iter>() , 8usize);
    }
    extern "C" {
        #[link_name = "?setPath@Iter@SkPath@@QEAAXAEBV2@_N@Z"]
        pub fn SkPath_Iter_setPath(this: *mut root::SkPath_Iter,
                                   arg1: *const root::SkPath,
                                   forceClose: bool);
    }
    extern "C" {
        /** Returns true if the current contour is closed (has a kClose_Verb)
            @return true if the current contour is closed (has a kClose_Verb)
        */
        #[link_name = "?isClosedContour@Iter@SkPath@@QEBA_NXZ"]
        pub fn SkPath_Iter_isClosedContour(this: *const root::SkPath_Iter)
         -> bool;
    }
    extern "C" {
        #[link_name = "??0Iter@SkPath@@QEAA@XZ"]
        pub fn SkPath_Iter_Iter(this: *mut root::SkPath_Iter);
    }
    extern "C" {
        #[link_name = "??0Iter@SkPath@@QEAA@AEBV1@_N@Z"]
        pub fn SkPath_Iter_Iter1(this: *mut root::SkPath_Iter,
                                 arg1: *const root::SkPath, forceClose: bool);
    }
    impl Clone for SkPath_Iter {
        fn clone(&self) -> Self { *self }
    }
    impl SkPath_Iter {
        #[inline]
        pub unsafe fn setPath(&mut self, arg1: *const root::SkPath,
                              forceClose: bool) {
            SkPath_Iter_setPath(&mut *self, arg1, forceClose)
        }
        #[inline]
        pub unsafe fn isClosedContour(&self) -> bool {
            SkPath_Iter_isClosedContour(&*self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPath_Iter_Iter(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::SkPath, forceClose: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPath_Iter_Iter1(&mut __bindgen_tmp, arg1, forceClose);
            __bindgen_tmp
        }
    }
    /** Iterate through the verbs in the path, providing the associated points.
    */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPath_RawIter {
        pub fRawIter: root::SkPathRef_Iter,
    }
    #[test]
    fn bindgen_test_layout_SkPath_RawIter() {
        assert_eq!(::std::mem::size_of::<SkPath_RawIter>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkPath_RawIter>() , 8usize);
    }
    impl Clone for SkPath_RawIter {
        fn clone(&self) -> Self { *self }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPath_SerializationOffsets {
        kUnused1_SerializationShift = 28,
        kDirection_SerializationShift = 26,
        kIsVolatile_SerializationShift = 25,
        kConvexity_SerializationShift = 16,
        kFillType_SerializationShift = 8,
    }
    pub const SkPath_SerializationVersions_kCurrent_Version:
              root::SkPath_SerializationVersions =
        SkPath_SerializationVersions::kPathPrivLastMoveToIndex_Version;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPath_SerializationVersions {
        kPathPrivFirstDirection_Version = 1,
        kPathPrivLastMoveToIndex_Version = 2,
    }
    pub const SkPath_kPathRefGenIDBitCnt: ::std::os::raw::c_int = 32;
    #[test]
    fn bindgen_test_layout_SkPath() {
        assert_eq!(::std::mem::size_of::<SkPath>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkPath>() , 8usize);
    }
    extern "C" {
        /** Return true if the paths contain an equal array of verbs and weights. Paths
     *  with equal verb counts can be readily interpolated. If the paths contain one
     *  or more conics, the conics' weights must also match.
     *
     *  @param compare  The path to compare.
     *
     *  @return true if the paths have the same verbs and weights.
     */
        #[link_name = "?isInterpolatable@SkPath@@QEBA_NAEBV1@@Z"]
        pub fn SkPath_isInterpolatable(this: *const root::SkPath,
                                       compare: *const root::SkPath) -> bool;
    }
    extern "C" {
        /** Interpolate between two paths with same-sized point arrays.
     *  The out path contains the verbs and weights of this path.
     *  The out points are a weighted average of this path and the ending path. 
     *
     *  @param ending  The path to interpolate between.
     *  @param weight  The weight, from 0 to 1. The output points are set to
     *                 (this->points * weight) + ending->points * (1 - weight).
     *  @return true if the paths could be interpolated.
     */
        #[link_name = "?interpolate@SkPath@@QEBA_NAEBV1@MPEAV1@@Z"]
        pub fn SkPath_interpolate(this: *const root::SkPath,
                                  ending: *const root::SkPath,
                                  weight: root::SkScalar,
                                  out: *mut root::SkPath) -> bool;
    }
    extern "C" {
        /**
     *  Store a convexity setting in the path. There is no automatic check to
     *  see if this value actually agrees with the return value that would be
     *  computed by getConvexity().
     *
     *  Note: even if this is set to a "known" value, if the path is later
     *  changed (e.g. lineTo(), addRect(), etc.) then the cached value will be
     *  reset to kUnknown_Convexity.
     */
        #[link_name = "?setConvexity@SkPath@@QEAAXW4Convexity@1@@Z"]
        pub fn SkPath_setConvexity(this: *mut root::SkPath,
                                   arg1: root::SkPath_Convexity);
    }
    extern "C" {
        /** Clear any lines and curves from the path, making it empty. This frees up
        internal storage associated with those segments.
        On Android, does not change fSourcePath.
    */
        #[link_name = "?reset@SkPath@@QEAAXXZ"]
        pub fn SkPath_reset(this: *mut root::SkPath);
    }
    extern "C" {
        /** Similar to reset(), in that all lines and curves are removed from the
        path. However, any internal storage for those lines/curves is retained,
        making reuse of the path potentially faster.
        On Android, does not change fSourcePath.
    */
        #[link_name = "?rewind@SkPath@@QEAAXXZ"]
        pub fn SkPath_rewind(this: *mut root::SkPath);
    }
    extern "C" {
        /** Return true if the last contour of this path ends with a close verb.
     */
        #[link_name = "?isLastContourClosed@SkPath@@QEBA_NXZ"]
        pub fn SkPath_isLastContourClosed(this: *const root::SkPath) -> bool;
    }
    extern "C" {
        /**
     *  Returns true if the path specifies a single line (i.e. it contains just
     *  a moveTo and a lineTo). If so, and line[] is not null, it sets the 2
     *  points in line[] to the end-points of the line. If the path is not a
     *  line, returns false and ignores line[].
     */
        #[link_name = "?isLine@SkPath@@QEBA_NQEAUSkPoint@@@Z"]
        pub fn SkPath_isLine(this: *const root::SkPath,
                             line: *mut root::SkPoint) -> bool;
    }
    extern "C" {
        /** Return the number of points in the path
     */
        #[link_name = "?countPoints@SkPath@@QEBAHXZ"]
        pub fn SkPath_countPoints(this: *const root::SkPath)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the point at the specified index. If the index is out of range
         (i.e. is not 0 <= index < countPoints()) then the returned coordinates
         will be (0,0)
     */
        #[link_name = "?getPoint@SkPath@@QEBA?AUSkPoint@@H@Z"]
        pub fn SkPath_getPoint(this: *const root::SkPath,
                               index: ::std::os::raw::c_int) -> root::SkPoint;
    }
    extern "C" {
        /** Returns the number of points in the path. Up to max points are copied.

        @param points If not null, receives up to max points
        @param max The maximum number of points to copy into points
        @return the actual number of points in the path
    */
        #[link_name = "?getPoints@SkPath@@QEBAHQEAUSkPoint@@H@Z"]
        pub fn SkPath_getPoints(this: *const root::SkPath,
                                points: *mut root::SkPoint,
                                max: ::std::os::raw::c_int)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the number of verbs in the path
     */
        #[link_name = "?countVerbs@SkPath@@QEBAHXZ"]
        pub fn SkPath_countVerbs(this: *const root::SkPath)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Returns the number of verbs in the path. Up to max verbs are copied. The
        verbs are copied as one byte per verb.

        @param verbs If not null, receives up to max verbs
        @param max The maximum number of verbs to copy into verbs
        @return the actual number of verbs in the path
    */
        #[link_name = "?getVerbs@SkPath@@QEBAHQEAEH@Z"]
        pub fn SkPath_getVerbs(this: *const root::SkPath, verbs: *mut u8,
                               max: ::std::os::raw::c_int)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        // Swap contents of this and other. Guaranteed not to throw
        #[link_name = "?swap@SkPath@@QEAAXAEAV1@@Z"]
        pub fn SkPath_swap(this: *mut root::SkPath, other: *mut root::SkPath);
    }
    extern "C" {
        /**
     * Does a conservative test to see whether a rectangle is inside a path. Currently it only
     * will ever return true for single convex contour paths. The empty-status of the rect is not
     * considered (e.g. a rect that is a point can be inside a path). Points or line segments where
     * the rect edge touches the path border are not considered containment violations.
     */
        #[link_name =
              "?conservativelyContainsRect@SkPath@@QEBA_NAEBUSkRect@@@Z"]
        pub fn SkPath_conservativelyContainsRect(this: *const root::SkPath,
                                                 rect: *const root::SkRect)
         -> bool;
    }
    extern "C" {
        /** Hint to the path to prepare for adding more points. This can allow the
        path to more efficiently grow its storage.

        @param extraPtCount The number of extra points the path should
                            preallocate for.
    */
        #[link_name = "?incReserve@SkPath@@QEAAXI@Z"]
        pub fn SkPath_incReserve(this: *mut root::SkPath,
                                 extraPtCount: ::std::os::raw::c_uint);
    }
    extern "C" {
        /** Set the beginning of the next contour to the point (x,y).

        @param x    The x-coordinate of the start of a new contour
        @param y    The y-coordinate of the start of a new contour
    */
        #[link_name = "?moveTo@SkPath@@QEAAXMM@Z"]
        pub fn SkPath_moveTo(this: *mut root::SkPath, x: root::SkScalar,
                             y: root::SkScalar);
    }
    extern "C" {
        /** Set the beginning of the next contour relative to the last point on the
        previous contour. If there is no previous contour, this is treated the
        same as moveTo().

        @param dx   The amount to add to the x-coordinate of the end of the
                    previous contour, to specify the start of a new contour
        @param dy   The amount to add to the y-coordinate of the end of the
                    previous contour, to specify the start of a new contour
    */
        #[link_name = "?rMoveTo@SkPath@@QEAAXMM@Z"]
        pub fn SkPath_rMoveTo(this: *mut root::SkPath, dx: root::SkScalar,
                              dy: root::SkScalar);
    }
    extern "C" {
        /** Add a line from the last point to the specified point (x,y). If no
        moveTo() call has been made for this contour, the first point is
        automatically set to (0,0).

        @param x    The x-coordinate of the end of a line
        @param y    The y-coordinate of the end of a line
    */
        #[link_name = "?lineTo@SkPath@@QEAAXMM@Z"]
        pub fn SkPath_lineTo(this: *mut root::SkPath, x: root::SkScalar,
                             y: root::SkScalar);
    }
    extern "C" {
        /** Same as lineTo, but the coordinates are considered relative to the last
        point on this contour. If there is no previous point, then a moveTo(0,0)
        is inserted automatically.

        @param dx   The amount to add to the x-coordinate of the previous point
                    on this contour, to specify a line
        @param dy   The amount to add to the y-coordinate of the previous point
                    on this contour, to specify a line
    */
        #[link_name = "?rLineTo@SkPath@@QEAAXMM@Z"]
        pub fn SkPath_rLineTo(this: *mut root::SkPath, dx: root::SkScalar,
                              dy: root::SkScalar);
    }
    extern "C" {
        /** Add a quadratic bezier from the last point, approaching control point
        (x1,y1), and ending at (x2,y2). If no moveTo() call has been made for
        this contour, the first point is automatically set to (0,0).

        @param x1   The x-coordinate of the control point on a quadratic curve
        @param y1   The y-coordinate of the control point on a quadratic curve
        @param x2   The x-coordinate of the end point on a quadratic curve
        @param y2   The y-coordinate of the end point on a quadratic curve
    */
        #[link_name = "?quadTo@SkPath@@QEAAXMMMM@Z"]
        pub fn SkPath_quadTo(this: *mut root::SkPath, x1: root::SkScalar,
                             y1: root::SkScalar, x2: root::SkScalar,
                             y2: root::SkScalar);
    }
    extern "C" {
        /** Same as quadTo, but the coordinates are considered relative to the last
        point on this contour. If there is no previous point, then a moveTo(0,0)
        is inserted automatically.

        @param dx1   The amount to add to the x-coordinate of the last point on
                this contour, to specify the control point of a quadratic curve
        @param dy1   The amount to add to the y-coordinate of the last point on
                this contour, to specify the control point of a quadratic curve
        @param dx2   The amount to add to the x-coordinate of the last point on
                     this contour, to specify the end point of a quadratic curve
        @param dy2   The amount to add to the y-coordinate of the last point on
                     this contour, to specify the end point of a quadratic curve
    */
        #[link_name = "?rQuadTo@SkPath@@QEAAXMMMM@Z"]
        pub fn SkPath_rQuadTo(this: *mut root::SkPath, dx1: root::SkScalar,
                              dy1: root::SkScalar, dx2: root::SkScalar,
                              dy2: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?conicTo@SkPath@@QEAAXMMMMM@Z"]
        pub fn SkPath_conicTo(this: *mut root::SkPath, x1: root::SkScalar,
                              y1: root::SkScalar, x2: root::SkScalar,
                              y2: root::SkScalar, w: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?rConicTo@SkPath@@QEAAXMMMMM@Z"]
        pub fn SkPath_rConicTo(this: *mut root::SkPath, dx1: root::SkScalar,
                               dy1: root::SkScalar, dx2: root::SkScalar,
                               dy2: root::SkScalar, w: root::SkScalar);
    }
    extern "C" {
        /** Add a cubic bezier from the last point, approaching control points
        (x1,y1) and (x2,y2), and ending at (x3,y3). If no moveTo() call has been
        made for this contour, the first point is automatically set to (0,0).

        @param x1   The x-coordinate of the 1st control point on a cubic curve
        @param y1   The y-coordinate of the 1st control point on a cubic curve
        @param x2   The x-coordinate of the 2nd control point on a cubic curve
        @param y2   The y-coordinate of the 2nd control point on a cubic curve
        @param x3   The x-coordinate of the end point on a cubic curve
        @param y3   The y-coordinate of the end point on a cubic curve
    */
        #[link_name = "?cubicTo@SkPath@@QEAAXMMMMMM@Z"]
        pub fn SkPath_cubicTo(this: *mut root::SkPath, x1: root::SkScalar,
                              y1: root::SkScalar, x2: root::SkScalar,
                              y2: root::SkScalar, x3: root::SkScalar,
                              y3: root::SkScalar);
    }
    extern "C" {
        /** Same as cubicTo, but the coordinates are considered relative to the
        current point on this contour. If there is no previous point, then a
        moveTo(0,0) is inserted automatically.

        @param dx1   The amount to add to the x-coordinate of the last point on
                this contour, to specify the 1st control point of a cubic curve
        @param dy1   The amount to add to the y-coordinate of the last point on
                this contour, to specify the 1st control point of a cubic curve
        @param dx2   The amount to add to the x-coordinate of the last point on
                this contour, to specify the 2nd control point of a cubic curve
        @param dy2   The amount to add to the y-coordinate of the last point on
                this contour, to specify the 2nd control point of a cubic curve
        @param dx3   The amount to add to the x-coordinate of the last point on
                     this contour, to specify the end point of a cubic curve
        @param dy3   The amount to add to the y-coordinate of the last point on
                     this contour, to specify the end point of a cubic curve
    */
        #[link_name = "?rCubicTo@SkPath@@QEAAXMMMMMM@Z"]
        pub fn SkPath_rCubicTo(this: *mut root::SkPath, x1: root::SkScalar,
                               y1: root::SkScalar, x2: root::SkScalar,
                               y2: root::SkScalar, x3: root::SkScalar,
                               y3: root::SkScalar);
    }
    extern "C" {
        /**
     *  Append the specified arc to the path. If the start of the arc is different from the path's
     *  current last point, then an automatic lineTo() is added to connect the current contour
     *  to the start of the arc. However, if the path is empty, then we call moveTo() with
     *  the first point of the arc. The sweep angle is treated mod 360.
     *
     *  @param oval The bounding oval defining the shape and size of the arc
     *  @param startAngle Starting angle (in degrees) where the arc begins
     *  @param sweepAngle Sweep angle (in degrees) measured clockwise. This is treated mod 360.
     *  @param forceMoveTo If true, always begin a new contour with the arc
     */
        #[link_name = "?arcTo@SkPath@@QEAAXAEBUSkRect@@MM_N@Z"]
        pub fn SkPath_arcTo(this: *mut root::SkPath,
                            oval: *const root::SkRect,
                            startAngle: root::SkScalar,
                            sweepAngle: root::SkScalar, forceMoveTo: bool);
    }
    extern "C" {
        /**
     *  Append a line and arc to the current path. This is the same as the PostScript call "arct".
     */
        #[link_name = "?arcTo@SkPath@@QEAAXMMMMM@Z"]
        pub fn SkPath_arcTo1(this: *mut root::SkPath, x1: root::SkScalar,
                             y1: root::SkScalar, x2: root::SkScalar,
                             y2: root::SkScalar, radius: root::SkScalar);
    }
    extern "C" {
        /**
     *  Append an elliptical arc from the current point in the format used by SVG.
     *  The center of the ellipse is computed to satisfy the constraints below.
     *
     *  @param rx,ry The radii in the x and y directions respectively.
     *  @param xAxisRotate The angle in degrees relative to the x-axis.
     *  @param largeArc Determines whether the smallest or largest arc possible
     *         is drawn.
     *  @param sweep Determines if the arc should be swept in an anti-clockwise or
     *         clockwise direction. Note that this enum value is opposite the SVG
     *         arc sweep value.
     *  @param x,y The destination coordinates.
     */
        #[link_name = "?arcTo@SkPath@@QEAAXMMMW4ArcSize@1@W4Direction@1@MM@Z"]
        pub fn SkPath_arcTo2(this: *mut root::SkPath, rx: root::SkScalar,
                             ry: root::SkScalar, xAxisRotate: root::SkScalar,
                             largeArc: root::SkPath_ArcSize,
                             sweep: root::SkPath_Direction, x: root::SkScalar,
                             y: root::SkScalar);
    }
    extern "C" {
        /** Same as arcTo format used by SVG, but the destination coordinate is relative to the
     *  last point on this contour. If there is no previous point, then a
     *  moveTo(0,0) is inserted automatically.
     *
     *  @param rx,ry The radii in the x and y directions respectively.
     *  @param xAxisRotate The angle in degrees relative to the x-axis.
     *  @param largeArc Determines whether the smallest or largest arc possible
     *         is drawn.
     *  @param sweep Determines if the arc should be swept in an anti-clockwise or
     *         clockwise direction. Note that this enum value is opposite the SVG
     *         arc sweep value.
     *  @param dx,dy The destination coordinates relative to the last point.
     */
        #[link_name =
              "?rArcTo@SkPath@@QEAAXMMMW4ArcSize@1@W4Direction@1@MM@Z"]
        pub fn SkPath_rArcTo(this: *mut root::SkPath, rx: root::SkScalar,
                             ry: root::SkScalar, xAxisRotate: root::SkScalar,
                             largeArc: root::SkPath_ArcSize,
                             sweep: root::SkPath_Direction,
                             dx: root::SkScalar, dy: root::SkScalar);
    }
    extern "C" {
        /** Close the current contour. If the current point is not equal to the
        first point of the contour, a line segment is automatically added.
    */
        #[link_name = "?close@SkPath@@QEAAXXZ"]
        pub fn SkPath_close(this: *mut root::SkPath);
    }
    extern "C" {
        /**
     *  Chop a conic into N quads, stored continguously in pts[], where
     *  N = 1 << pow2. The amount of storage needed is (1 + 2 * N)
     */
        #[link_name =
              "?ConvertConicToQuads@SkPath@@SAHAEBUSkPoint@@00MQEAU2@H@Z"]
        pub fn SkPath_ConvertConicToQuads(p0: *const root::SkPoint,
                                          p1: *const root::SkPoint,
                                          p2: *const root::SkPoint,
                                          w: root::SkScalar,
                                          pts: *mut root::SkPoint,
                                          pow2: ::std::os::raw::c_int)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /**
     *  Returns true if the path specifies a rectangle.
     *
     *  If this returns false, then all output parameters are ignored, and left
     *  unchanged. If this returns true, then each of the output parameters
     *  are checked for NULL. If they are not, they return their value.
     *
     *  @param rect If not null, set to the bounds of the rectangle.
     *              Note : this bounds may be smaller than the path's bounds, since it is just
     *              the bounds of the "drawable" parts of the path. e.g. a trailing MoveTo would
     *              be ignored in this rect, but not by the path's bounds
     *  @param isClosed If not null, set to true if the path is closed
     *  @param direction If not null, set to the rectangle's direction
     *  @return true if the path specifies a rectangle
     */
        #[link_name =
              "?isRect@SkPath@@QEBA_NPEAUSkRect@@PEA_NPEAW4Direction@1@@Z"]
        pub fn SkPath_isRect(this: *const root::SkPath,
                             rect: *mut root::SkRect, isClosed: *mut bool,
                             direction: *mut root::SkPath_Direction) -> bool;
    }
    extern "C" {
        /** Returns true if the path specifies a pair of nested rectangles, or would draw a
        pair of nested rectangles when filled. If so, and if
        rect is not null, set rect[0] to the outer rectangle and rect[1] to the inner
        rectangle. If so, and dirs is not null, set dirs[0] to the direction of
        the outer rectangle and dirs[1] to the direction of the inner rectangle. If
        the path does not specify a pair of nested rectangles, return
        false and ignore rect and dirs.

        @param rect If not null, returns the path as a pair of nested rectangles
        @param dirs If not null, returns the direction of the rects
        @return true if the path describes a pair of nested rectangles
    */
        #[link_name =
              "?isNestedFillRects@SkPath@@QEBA_NQEAUSkRect@@QEAW4Direction@1@@Z"]
        pub fn SkPath_isNestedFillRects(this: *const root::SkPath,
                                        rect: *mut root::SkRect,
                                        dirs: *mut root::SkPath_Direction)
         -> bool;
    }
    extern "C" {
        /**
     *  Add a closed rectangle contour to the path
     *  @param rect The rectangle to add as a closed contour to the path
     *  @param dir  The direction to wind the rectangle's contour.
     *
     *  Note: the contour initial point index is 0 (as defined below).
     */
        #[link_name = "?addRect@SkPath@@QEAAXAEBUSkRect@@W4Direction@1@@Z"]
        pub fn SkPath_addRect(this: *mut root::SkPath,
                              rect: *const root::SkRect,
                              dir: root::SkPath_Direction);
    }
    extern "C" {
        /**
     *  Add a closed rectangle contour to the path
     *  @param rect  The rectangle to add as a closed contour to the path
     *  @param dir   The direction to wind the rectangle's contour.
     *  @param start Initial point of the contour (initial moveTo), expressed as
     *               a corner index, starting in the upper-left position, clock-wise:
     *
     *  0         1
     *   *-------*
     *   |       |
     *   *-------*
     *  3         2
     */
        #[link_name = "?addRect@SkPath@@QEAAXAEBUSkRect@@W4Direction@1@I@Z"]
        pub fn SkPath_addRect1(this: *mut root::SkPath,
                               rect: *const root::SkRect,
                               dir: root::SkPath_Direction,
                               start: ::std::os::raw::c_uint);
    }
    extern "C" {
        /**
     *  Add a closed rectangle contour to the path
     *
     *  @param left     The left side of a rectangle to add as a closed contour
     *                  to the path
     *  @param top      The top of a rectangle to add as a closed contour to the
     *                  path
     *  @param right    The right side of a rectangle to add as a closed contour
     *                  to the path
     *  @param bottom   The bottom of a rectangle to add as a closed contour to
     *                  the path
     *  @param dir  The direction to wind the rectangle's contour.
     *
     *  Note: the contour initial point index is 0 (as defined above).
     */
        #[link_name = "?addRect@SkPath@@QEAAXMMMMW4Direction@1@@Z"]
        pub fn SkPath_addRect2(this: *mut root::SkPath, left: root::SkScalar,
                               top: root::SkScalar, right: root::SkScalar,
                               bottom: root::SkScalar,
                               dir: root::SkPath_Direction);
    }
    extern "C" {
        /**
     *  Add a closed oval contour to the path
     *
     *  @param oval The bounding oval to add as a closed contour to the path
     *  @param dir  The direction to wind the oval's contour.
     *
     *  Note: the contour initial point index is 1 (as defined below).
     */
        #[link_name = "?addOval@SkPath@@QEAAXAEBUSkRect@@W4Direction@1@@Z"]
        pub fn SkPath_addOval(this: *mut root::SkPath,
                              oval: *const root::SkRect,
                              dir: root::SkPath_Direction);
    }
    extern "C" {
        /**
     *  Add a closed oval contour to the path
     *
     *  @param oval  The bounding oval to add as a closed contour to the path
     *  @param dir   The direction to wind the oval's contour.
     *  @param start Initial point of the contour (initial moveTo), expressed
     *               as an ellipse vertex index, starting at the top, clock-wise
     *               (90/0/270/180deg order):
     *
     *        0
     *       -*-
     *     |     |
     *   3 *     * 1
     *     |     |
     *       -*-
     *        2
     */
        #[link_name = "?addOval@SkPath@@QEAAXAEBUSkRect@@W4Direction@1@I@Z"]
        pub fn SkPath_addOval1(this: *mut root::SkPath,
                               oval: *const root::SkRect,
                               dir: root::SkPath_Direction,
                               start: ::std::os::raw::c_uint);
    }
    extern "C" {
        /**
     *  Add a closed circle contour to the path. The circle contour begins at
     *  the right-most point (as though 1 were passed to addOval's 'start' param).
     *
     *  @param x        The x-coordinate of the center of a circle to add as a
     *                  closed contour to the path
     *  @param y        The y-coordinate of the center of a circle to add as a
     *                  closed contour to the path
     *  @param radius   The radius of a circle to add as a closed contour to the
     *                  path
     *  @param dir  The direction to wind the circle's contour.
     */
        #[link_name = "?addCircle@SkPath@@QEAAXMMMW4Direction@1@@Z"]
        pub fn SkPath_addCircle(this: *mut root::SkPath, x: root::SkScalar,
                                y: root::SkScalar, radius: root::SkScalar,
                                dir: root::SkPath_Direction);
    }
    extern "C" {
        /** Add the specified arc to the path as a new contour.

        @param oval The bounds of oval used to define the size of the arc
        @param startAngle Starting angle (in degrees) where the arc begins
        @param sweepAngle Sweep angle (in degrees) measured clockwise
    */
        #[link_name = "?addArc@SkPath@@QEAAXAEBUSkRect@@MM@Z"]
        pub fn SkPath_addArc(this: *mut root::SkPath,
                             oval: *const root::SkRect,
                             startAngle: root::SkScalar,
                             sweepAngle: root::SkScalar);
    }
    extern "C" {
        /**
     *  Add a closed round-rectangle contour to the path
     *  @param rect The bounds of a round-rectangle to add as a closed contour
     *  @param rx   The x-radius of the rounded corners on the round-rectangle
     *  @param ry   The y-radius of the rounded corners on the round-rectangle
     *  @param dir  The direction to wind the rectangle's contour.
     */
        #[link_name =
              "?addRoundRect@SkPath@@QEAAXAEBUSkRect@@MMW4Direction@1@@Z"]
        pub fn SkPath_addRoundRect(this: *mut root::SkPath,
                                   rect: *const root::SkRect,
                                   rx: root::SkScalar, ry: root::SkScalar,
                                   dir: root::SkPath_Direction);
    }
    extern "C" {
        /**
     *  Add a closed round-rectangle contour to the path. Each corner receives
     *  two radius values [X, Y]. The corners are ordered top-left, top-right,
     *  bottom-right, bottom-left.
     *  @param rect The bounds of a round-rectangle to add as a closed contour
     *  @param radii Array of 8 scalars, 4 [X,Y] pairs for each corner
     *  @param dir  The direction to wind the rectangle's contour.
     * Note: The radii here now go through the same constraint handling as the
     *       SkRRect radii (i.e., either radii at a corner being 0 implies a
     *       sqaure corner and oversized radii are proportionally scaled down).
     */
        #[link_name =
              "?addRoundRect@SkPath@@QEAAXAEBUSkRect@@QEBMW4Direction@1@@Z"]
        pub fn SkPath_addRoundRect1(this: *mut root::SkPath,
                                    rect: *const root::SkRect,
                                    radii: *const root::SkScalar,
                                    dir: root::SkPath_Direction);
    }
    extern "C" {
        /**
     *  Add an SkRRect contour to the path
     *  @param rrect The rounded rect to add as a closed contour
     *  @param dir   The winding direction for the new contour.
     *
     *  Note: the contour initial point index is either 6 (for dir == kCW_Direction)
     *        or 7 (for dir == kCCW_Direction), as defined below.
     *
     */
        #[link_name = "?addRRect@SkPath@@QEAAXAEBVSkRRect@@W4Direction@1@@Z"]
        pub fn SkPath_addRRect(this: *mut root::SkPath,
                               rrect: *const root::SkRRect,
                               dir: root::SkPath_Direction);
    }
    extern "C" {
        /**
     *  Add an SkRRect contour to the path
     *  @param rrect The rounded rect to add as a closed contour
     *  @param dir   The winding direction for the new contour.
     *  @param start Initial point of the contour (initial moveTo), expressed as
     *               an index of the radii minor/major points, ordered clock-wise:
     *
     *      0    1
     *      *----*
     *   7 *      * 2
     *     |      |
     *   6 *      * 3
     *      *----*
     *      5    4
     */
        #[link_name = "?addRRect@SkPath@@QEAAXAEBVSkRRect@@W4Direction@1@I@Z"]
        pub fn SkPath_addRRect1(this: *mut root::SkPath,
                                rrect: *const root::SkRRect,
                                dir: root::SkPath_Direction,
                                start: ::std::os::raw::c_uint);
    }
    extern "C" {
        /**
     *  Add a new contour made of just lines. This is just a fast version of
     *  the following:
     *      this->moveTo(pts[0]);
     *      for (int i = 1; i < count; ++i) {
     *          this->lineTo(pts[i]);
     *      }
     *      if (close) {
     *          this->close();
     *      }
     */
        #[link_name = "?addPoly@SkPath@@QEAAXQEBUSkPoint@@H_N@Z"]
        pub fn SkPath_addPoly(this: *mut root::SkPath,
                              pts: *const root::SkPoint,
                              count: ::std::os::raw::c_int, close: bool);
    }
    extern "C" {
        /** Add a copy of src to the path, offset by (dx,dy)
        @param src  The path to add as a new contour
        @param dx   The amount to translate the path in X as it is added
        @param dx   The amount to translate the path in Y as it is added
    */
        #[link_name = "?addPath@SkPath@@QEAAXAEBV1@MMW4AddPathMode@1@@Z"]
        pub fn SkPath_addPath(this: *mut root::SkPath,
                              src: *const root::SkPath, dx: root::SkScalar,
                              dy: root::SkScalar,
                              mode: root::SkPath_AddPathMode);
    }
    extern "C" {
        /** Add a copy of src to the path, transformed by matrix
        @param src  The path to add as a new contour
        @param matrix  Transform applied to src
        @param mode  Determines how path is added
    */
        #[link_name =
              "?addPath@SkPath@@QEAAXAEBV1@AEBVSkMatrix@@W4AddPathMode@1@@Z"]
        pub fn SkPath_addPath1(this: *mut root::SkPath,
                               src: *const root::SkPath,
                               matrix: *const root::SkMatrix,
                               mode: root::SkPath_AddPathMode);
    }
    extern "C" {
        /**
     *  Same as addPath(), but reverses the src input
     */
        #[link_name = "?reverseAddPath@SkPath@@QEAAXAEBV1@@Z"]
        pub fn SkPath_reverseAddPath(this: *mut root::SkPath,
                                     src: *const root::SkPath);
    }
    extern "C" {
        /** Offset the path by (dx,dy), returning true on success

        @param dx   The amount in the X direction to offset the entire path
        @param dy   The amount in the Y direction to offset the entire path
        @param dst  The translated path is written here
    */
        #[link_name = "?offset@SkPath@@QEBAXMMPEAV1@@Z"]
        pub fn SkPath_offset(this: *const root::SkPath, dx: root::SkScalar,
                             dy: root::SkScalar, dst: *mut root::SkPath);
    }
    extern "C" {
        /** Transform the points in this path by matrix, and write the answer into
        dst.

        @param matrix   The matrix to apply to the path
        @param dst      The transformed path is written here
    */
        #[link_name = "?transform@SkPath@@QEBAXAEBVSkMatrix@@PEAV1@@Z"]
        pub fn SkPath_transform(this: *const root::SkPath,
                                matrix: *const root::SkMatrix,
                                dst: *mut root::SkPath);
    }
    extern "C" {
        /** Return the last point on the path. If no points have been added, (0,0)
        is returned. If there are no points, this returns false, otherwise it
        returns true.

        @param lastPt   The last point on the path is returned here
    */
        #[link_name = "?getLastPt@SkPath@@QEBA_NPEAUSkPoint@@@Z"]
        pub fn SkPath_getLastPt(this: *const root::SkPath,
                                lastPt: *mut root::SkPoint) -> bool;
    }
    extern "C" {
        /** Set the last point on the path. If no points have been added,
        moveTo(x,y) is automatically called.

        @param x    The new x-coordinate for the last point
        @param y    The new y-coordinate for the last point
    */
        #[link_name = "?setLastPt@SkPath@@QEAAXMM@Z"]
        pub fn SkPath_setLastPt(this: *mut root::SkPath, x: root::SkScalar,
                                y: root::SkScalar);
    }
    extern "C" {
        /**
     *  Returns true if the point { x, y } is contained by the path, taking into
     *  account the FillType.
     */
        #[link_name = "?contains@SkPath@@QEBA_NMM@Z"]
        pub fn SkPath_contains(this: *const root::SkPath, x: root::SkScalar,
                               y: root::SkScalar) -> bool;
    }
    extern "C" {
        #[link_name = "?dump@SkPath@@QEBAXPEAVSkWStream@@_N1@Z"]
        pub fn SkPath_dump(this: *const root::SkPath,
                           arg1: *mut root::SkWStream, forceClose: bool,
                           dumpAsHex: bool);
    }
    extern "C" {
        #[link_name = "?dump@SkPath@@QEBAXXZ"]
        pub fn SkPath_dump1(this: *const root::SkPath);
    }
    extern "C" {
        #[link_name = "?dumpHex@SkPath@@QEBAXXZ"]
        pub fn SkPath_dumpHex(this: *const root::SkPath);
    }
    extern "C" {
        /**
     *  Write the path to the buffer, and return the number of bytes written.
     *  If buffer is NULL, it still returns the number of bytes.
     */
        #[link_name = "?writeToMemory@SkPath@@QEBA_KPEAX@Z"]
        pub fn SkPath_writeToMemory(this: *const root::SkPath,
                                    buffer: *mut ::std::os::raw::c_void)
         -> usize;
    }
    extern "C" {
        /**
     * Initializes the path from the buffer
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
        #[link_name = "?readFromMemory@SkPath@@QEAA_KPEBX_K@Z"]
        pub fn SkPath_readFromMemory(this: *mut root::SkPath,
                                     buffer: *const ::std::os::raw::c_void,
                                     length: usize) -> usize;
    }
    extern "C" {
        /** Returns a non-zero, globally unique value corresponding to the set of verbs
        and points in the path (but not the fill type [except on Android skbug.com/1762]).
        Each time the path is modified, a different generation ID will be returned.
    */
        #[link_name = "?getGenerationID@SkPath@@QEBAIXZ"]
        pub fn SkPath_getGenerationID(this: *const root::SkPath) -> u32;
    }
    extern "C" {
        #[link_name = "?validate@SkPath@@QEBAXXZ"]
        pub fn SkPath_validate(this: *const root::SkPath);
    }
    extern "C" {
        #[link_name = "??0SkPath@@QEAA@XZ"]
        pub fn SkPath_SkPath(this: *mut root::SkPath);
    }
    extern "C" {
        #[link_name = "??0SkPath@@QEAA@AEBV0@@Z"]
        pub fn SkPath_SkPath1(this: *mut root::SkPath,
                              arg1: *const root::SkPath);
    }
    impl SkPath {
        #[inline]
        pub unsafe fn isInterpolatable(&self, compare: *const root::SkPath)
         -> bool {
            SkPath_isInterpolatable(&*self, compare)
        }
        #[inline]
        pub unsafe fn interpolate(&self, ending: *const root::SkPath,
                                  weight: root::SkScalar,
                                  out: *mut root::SkPath) -> bool {
            SkPath_interpolate(&*self, ending, weight, out)
        }
        #[inline]
        pub unsafe fn setConvexity(&mut self, arg1: root::SkPath_Convexity) {
            SkPath_setConvexity(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkPath_reset(&mut *self) }
        #[inline]
        pub unsafe fn rewind(&mut self) { SkPath_rewind(&mut *self) }
        #[inline]
        pub unsafe fn isLastContourClosed(&self) -> bool {
            SkPath_isLastContourClosed(&*self)
        }
        #[inline]
        pub unsafe fn isLine(&self, line: *mut root::SkPoint) -> bool {
            SkPath_isLine(&*self, line)
        }
        #[inline]
        pub unsafe fn countPoints(&self) -> ::std::os::raw::c_int {
            SkPath_countPoints(&*self)
        }
        #[inline]
        pub unsafe fn getPoint(&self, index: ::std::os::raw::c_int)
         -> root::SkPoint {
            SkPath_getPoint(&*self, index)
        }
        #[inline]
        pub unsafe fn getPoints(&self, points: *mut root::SkPoint,
                                max: ::std::os::raw::c_int)
         -> ::std::os::raw::c_int {
            SkPath_getPoints(&*self, points, max)
        }
        #[inline]
        pub unsafe fn countVerbs(&self) -> ::std::os::raw::c_int {
            SkPath_countVerbs(&*self)
        }
        #[inline]
        pub unsafe fn getVerbs(&self, verbs: *mut u8,
                               max: ::std::os::raw::c_int)
         -> ::std::os::raw::c_int {
            SkPath_getVerbs(&*self, verbs, max)
        }
        #[inline]
        pub unsafe fn swap(&mut self, other: *mut root::SkPath) {
            SkPath_swap(&mut *self, other)
        }
        #[inline]
        pub unsafe fn conservativelyContainsRect(&self,
                                                 rect: *const root::SkRect)
         -> bool {
            SkPath_conservativelyContainsRect(&*self, rect)
        }
        #[inline]
        pub unsafe fn incReserve(&mut self,
                                 extraPtCount: ::std::os::raw::c_uint) {
            SkPath_incReserve(&mut *self, extraPtCount)
        }
        #[inline]
        pub unsafe fn moveTo(&mut self, x: root::SkScalar,
                             y: root::SkScalar) {
            SkPath_moveTo(&mut *self, x, y)
        }
        #[inline]
        pub unsafe fn rMoveTo(&mut self, dx: root::SkScalar,
                              dy: root::SkScalar) {
            SkPath_rMoveTo(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn lineTo(&mut self, x: root::SkScalar,
                             y: root::SkScalar) {
            SkPath_lineTo(&mut *self, x, y)
        }
        #[inline]
        pub unsafe fn rLineTo(&mut self, dx: root::SkScalar,
                              dy: root::SkScalar) {
            SkPath_rLineTo(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn quadTo(&mut self, x1: root::SkScalar,
                             y1: root::SkScalar, x2: root::SkScalar,
                             y2: root::SkScalar) {
            SkPath_quadTo(&mut *self, x1, y1, x2, y2)
        }
        #[inline]
        pub unsafe fn rQuadTo(&mut self, dx1: root::SkScalar,
                              dy1: root::SkScalar, dx2: root::SkScalar,
                              dy2: root::SkScalar) {
            SkPath_rQuadTo(&mut *self, dx1, dy1, dx2, dy2)
        }
        #[inline]
        pub unsafe fn conicTo(&mut self, x1: root::SkScalar,
                              y1: root::SkScalar, x2: root::SkScalar,
                              y2: root::SkScalar, w: root::SkScalar) {
            SkPath_conicTo(&mut *self, x1, y1, x2, y2, w)
        }
        #[inline]
        pub unsafe fn rConicTo(&mut self, dx1: root::SkScalar,
                               dy1: root::SkScalar, dx2: root::SkScalar,
                               dy2: root::SkScalar, w: root::SkScalar) {
            SkPath_rConicTo(&mut *self, dx1, dy1, dx2, dy2, w)
        }
        #[inline]
        pub unsafe fn cubicTo(&mut self, x1: root::SkScalar,
                              y1: root::SkScalar, x2: root::SkScalar,
                              y2: root::SkScalar, x3: root::SkScalar,
                              y3: root::SkScalar) {
            SkPath_cubicTo(&mut *self, x1, y1, x2, y2, x3, y3)
        }
        #[inline]
        pub unsafe fn rCubicTo(&mut self, x1: root::SkScalar,
                               y1: root::SkScalar, x2: root::SkScalar,
                               y2: root::SkScalar, x3: root::SkScalar,
                               y3: root::SkScalar) {
            SkPath_rCubicTo(&mut *self, x1, y1, x2, y2, x3, y3)
        }
        #[inline]
        pub unsafe fn arcTo(&mut self, oval: *const root::SkRect,
                            startAngle: root::SkScalar,
                            sweepAngle: root::SkScalar, forceMoveTo: bool) {
            SkPath_arcTo(&mut *self, oval, startAngle, sweepAngle,
                         forceMoveTo)
        }
        #[inline]
        pub unsafe fn arcTo1(&mut self, x1: root::SkScalar,
                             y1: root::SkScalar, x2: root::SkScalar,
                             y2: root::SkScalar, radius: root::SkScalar) {
            SkPath_arcTo1(&mut *self, x1, y1, x2, y2, radius)
        }
        #[inline]
        pub unsafe fn arcTo2(&mut self, rx: root::SkScalar,
                             ry: root::SkScalar, xAxisRotate: root::SkScalar,
                             largeArc: root::SkPath_ArcSize,
                             sweep: root::SkPath_Direction, x: root::SkScalar,
                             y: root::SkScalar) {
            SkPath_arcTo2(&mut *self, rx, ry, xAxisRotate, largeArc, sweep, x,
                          y)
        }
        #[inline]
        pub unsafe fn rArcTo(&mut self, rx: root::SkScalar,
                             ry: root::SkScalar, xAxisRotate: root::SkScalar,
                             largeArc: root::SkPath_ArcSize,
                             sweep: root::SkPath_Direction,
                             dx: root::SkScalar, dy: root::SkScalar) {
            SkPath_rArcTo(&mut *self, rx, ry, xAxisRotate, largeArc, sweep,
                          dx, dy)
        }
        #[inline]
        pub unsafe fn close(&mut self) { SkPath_close(&mut *self) }
        #[inline]
        pub unsafe fn ConvertConicToQuads(p0: *const root::SkPoint,
                                          p1: *const root::SkPoint,
                                          p2: *const root::SkPoint,
                                          w: root::SkScalar,
                                          pts: *mut root::SkPoint,
                                          pow2: ::std::os::raw::c_int)
         -> ::std::os::raw::c_int {
            SkPath_ConvertConicToQuads(p0, p1, p2, w, pts, pow2)
        }
        #[inline]
        pub unsafe fn isRect(&self, rect: *mut root::SkRect,
                             isClosed: *mut bool,
                             direction: *mut root::SkPath_Direction) -> bool {
            SkPath_isRect(&*self, rect, isClosed, direction)
        }
        #[inline]
        pub unsafe fn isNestedFillRects(&self, rect: *mut root::SkRect,
                                        dirs: *mut root::SkPath_Direction)
         -> bool {
            SkPath_isNestedFillRects(&*self, rect, dirs)
        }
        #[inline]
        pub unsafe fn addRect(&mut self, rect: *const root::SkRect,
                              dir: root::SkPath_Direction) {
            SkPath_addRect(&mut *self, rect, dir)
        }
        #[inline]
        pub unsafe fn addRect1(&mut self, rect: *const root::SkRect,
                               dir: root::SkPath_Direction,
                               start: ::std::os::raw::c_uint) {
            SkPath_addRect1(&mut *self, rect, dir, start)
        }
        #[inline]
        pub unsafe fn addRect2(&mut self, left: root::SkScalar,
                               top: root::SkScalar, right: root::SkScalar,
                               bottom: root::SkScalar,
                               dir: root::SkPath_Direction) {
            SkPath_addRect2(&mut *self, left, top, right, bottom, dir)
        }
        #[inline]
        pub unsafe fn addOval(&mut self, oval: *const root::SkRect,
                              dir: root::SkPath_Direction) {
            SkPath_addOval(&mut *self, oval, dir)
        }
        #[inline]
        pub unsafe fn addOval1(&mut self, oval: *const root::SkRect,
                               dir: root::SkPath_Direction,
                               start: ::std::os::raw::c_uint) {
            SkPath_addOval1(&mut *self, oval, dir, start)
        }
        #[inline]
        pub unsafe fn addCircle(&mut self, x: root::SkScalar,
                                y: root::SkScalar, radius: root::SkScalar,
                                dir: root::SkPath_Direction) {
            SkPath_addCircle(&mut *self, x, y, radius, dir)
        }
        #[inline]
        pub unsafe fn addArc(&mut self, oval: *const root::SkRect,
                             startAngle: root::SkScalar,
                             sweepAngle: root::SkScalar) {
            SkPath_addArc(&mut *self, oval, startAngle, sweepAngle)
        }
        #[inline]
        pub unsafe fn addRoundRect(&mut self, rect: *const root::SkRect,
                                   rx: root::SkScalar, ry: root::SkScalar,
                                   dir: root::SkPath_Direction) {
            SkPath_addRoundRect(&mut *self, rect, rx, ry, dir)
        }
        #[inline]
        pub unsafe fn addRoundRect1(&mut self, rect: *const root::SkRect,
                                    radii: *const root::SkScalar,
                                    dir: root::SkPath_Direction) {
            SkPath_addRoundRect1(&mut *self, rect, radii, dir)
        }
        #[inline]
        pub unsafe fn addRRect(&mut self, rrect: *const root::SkRRect,
                               dir: root::SkPath_Direction) {
            SkPath_addRRect(&mut *self, rrect, dir)
        }
        #[inline]
        pub unsafe fn addRRect1(&mut self, rrect: *const root::SkRRect,
                                dir: root::SkPath_Direction,
                                start: ::std::os::raw::c_uint) {
            SkPath_addRRect1(&mut *self, rrect, dir, start)
        }
        #[inline]
        pub unsafe fn addPoly(&mut self, pts: *const root::SkPoint,
                              count: ::std::os::raw::c_int, close: bool) {
            SkPath_addPoly(&mut *self, pts, count, close)
        }
        #[inline]
        pub unsafe fn addPath(&mut self, src: *const root::SkPath,
                              dx: root::SkScalar, dy: root::SkScalar,
                              mode: root::SkPath_AddPathMode) {
            SkPath_addPath(&mut *self, src, dx, dy, mode)
        }
        #[inline]
        pub unsafe fn addPath1(&mut self, src: *const root::SkPath,
                               matrix: *const root::SkMatrix,
                               mode: root::SkPath_AddPathMode) {
            SkPath_addPath1(&mut *self, src, matrix, mode)
        }
        #[inline]
        pub unsafe fn reverseAddPath(&mut self, src: *const root::SkPath) {
            SkPath_reverseAddPath(&mut *self, src)
        }
        #[inline]
        pub unsafe fn offset(&self, dx: root::SkScalar, dy: root::SkScalar,
                             dst: *mut root::SkPath) {
            SkPath_offset(&*self, dx, dy, dst)
        }
        #[inline]
        pub unsafe fn transform(&self, matrix: *const root::SkMatrix,
                                dst: *mut root::SkPath) {
            SkPath_transform(&*self, matrix, dst)
        }
        #[inline]
        pub unsafe fn getLastPt(&self, lastPt: *mut root::SkPoint) -> bool {
            SkPath_getLastPt(&*self, lastPt)
        }
        #[inline]
        pub unsafe fn setLastPt(&mut self, x: root::SkScalar,
                                y: root::SkScalar) {
            SkPath_setLastPt(&mut *self, x, y)
        }
        #[inline]
        pub unsafe fn contains(&self, x: root::SkScalar, y: root::SkScalar)
         -> bool {
            SkPath_contains(&*self, x, y)
        }
        #[inline]
        pub unsafe fn dump(&self, arg1: *mut root::SkWStream,
                           forceClose: bool, dumpAsHex: bool) {
            SkPath_dump(&*self, arg1, forceClose, dumpAsHex)
        }
        #[inline]
        pub unsafe fn dump1(&self) { SkPath_dump1(&*self) }
        #[inline]
        pub unsafe fn dumpHex(&self) { SkPath_dumpHex(&*self) }
        #[inline]
        pub unsafe fn writeToMemory(&self,
                                    buffer: *mut ::std::os::raw::c_void)
         -> usize {
            SkPath_writeToMemory(&*self, buffer)
        }
        #[inline]
        pub unsafe fn readFromMemory(&mut self,
                                     buffer: *const ::std::os::raw::c_void,
                                     length: usize) -> usize {
            SkPath_readFromMemory(&mut *self, buffer, length)
        }
        #[inline]
        pub unsafe fn getGenerationID(&self) -> u32 {
            SkPath_getGenerationID(&*self)
        }
        #[inline]
        pub unsafe fn validate(&self) { SkPath_validate(&*self) }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPath_SkPath(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::SkPath) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPath_SkPath1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    /** \class SkPathEffect

    SkPathEffect is the base class for objects in the SkPaint that affect
    the geometry of a drawing primitive before it is transformed by the
    canvas' matrix and drawn.

    Dashing is implemented as a subclass of SkPathEffect.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPathEffect {
        pub _base: root::SkFlattenable,
    }
    /** \class PointData

        PointData aggregates all the information needed to draw the point
        primitives returned by an 'asPoints' call.
    */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPathEffect_PointData {
        pub fFlags: u32,
        pub fPoints: *mut root::SkPoint,
        pub fNumPoints: ::std::os::raw::c_int,
        pub fSize: root::SkVector,
        pub fClipRect: root::SkRect,
        pub fPath: root::SkPath,
        pub fFirst: root::SkPath,
        pub fLast: root::SkPath,
    }
    pub const SkPathEffect_PointData_PointFlags_kCircles_PointFlag:
              root::SkPathEffect_PointData_PointFlags =
        SkPathEffect_PointData_PointFlags(1);
    pub const SkPathEffect_PointData_PointFlags_kUsePath_PointFlag:
              root::SkPathEffect_PointData_PointFlags =
        SkPathEffect_PointData_PointFlags(2);
    pub const SkPathEffect_PointData_PointFlags_kUseClip_PointFlag:
              root::SkPathEffect_PointData_PointFlags =
        SkPathEffect_PointData_PointFlags(4);
    impl ::std::ops::BitOr<root::SkPathEffect_PointData_PointFlags> for
     root::SkPathEffect_PointData_PointFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkPathEffect_PointData_PointFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkPathEffect_PointData_PointFlags(pub i32);
    #[test]
    fn bindgen_test_layout_SkPathEffect_PointData() {
        assert_eq!(::std::mem::size_of::<SkPathEffect_PointData>() , 96usize);
        assert_eq!(::std::mem::align_of::<SkPathEffect_PointData>() , 8usize);
    }
    #[repr(i32)]
    /**
     *  If the PathEffect can be represented as a dash pattern, asADash will return kDash_DashType
     *  and None otherwise. If a non NULL info is passed in, the various DashInfo will be filled
     *  in if the PathEffect can be a dash pattern. If passed in info has an fCount equal or
     *  greater to that of the effect, it will memcpy the values of the dash intervals into the
     *  info. Thus the general approach will be call asADash once with default info to get DashType
     *  and fCount. If effect can be represented as a dash pattern, allocate space for the intervals
     *  in info, then call asADash again with the same info and the intervals will get copied in.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPathEffect_DashType { kNone_DashType = 0, kDash_DashType = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPathEffect_DashInfo {
        //< Length of on/off intervals for dashed lines
        pub fIntervals: *mut root::SkScalar,
        //< Number of intervals in the dash. Should be even number
        pub fCount: i32,
        //< Offset into the dashed interval pattern
        pub fPhase: root::SkScalar,
    }
    #[test]
    fn bindgen_test_layout_SkPathEffect_DashInfo() {
        assert_eq!(::std::mem::size_of::<SkPathEffect_DashInfo>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkPathEffect_DashInfo>() , 8usize);
    }
    impl Clone for SkPathEffect_DashInfo {
        fn clone(&self) -> Self { *self }
    }
    pub type SkPathEffect_INHERITED = root::SkFlattenable;
    #[test]
    fn bindgen_test_layout_SkPathEffect() {
        assert_eq!(::std::mem::size_of::<SkPathEffect>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkPathEffect>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkRasterizer {
        pub _base: root::SkFlattenable,
    }
    pub type SkRasterizer_INHERITED = root::SkFlattenable;
    #[test]
    fn bindgen_test_layout_SkRasterizer() {
        assert_eq!(::std::mem::size_of::<SkRasterizer>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkRasterizer>() , 8usize);
    }
    extern "C" {
        /** Turn the path into a mask, respecting the specified local->device matrix.
    */
        #[link_name =
              "?rasterize@SkRasterizer@@QEBA_NAEBVSkPath@@AEBVSkMatrix@@PEBUSkIRect@@PEAVSkMaskFilter@@PEAUSkMask@@W4CreateMode@6@@Z"]
        pub fn SkRasterizer_rasterize(this: *const root::SkRasterizer,
                                      path: *const root::SkPath,
                                      matrix: *const root::SkMatrix,
                                      clipBounds: *const root::SkIRect,
                                      filter: *mut root::SkMaskFilter,
                                      mask: *mut root::SkMask,
                                      mode: root::SkMask_CreateMode) -> bool;
    }
    impl SkRasterizer {
        #[inline]
        pub unsafe fn rasterize(&self, path: *const root::SkPath,
                                matrix: *const root::SkMatrix,
                                clipBounds: *const root::SkIRect,
                                filter: *mut root::SkMaskFilter,
                                mask: *mut root::SkMask,
                                mode: root::SkMask_CreateMode) -> bool {
            SkRasterizer_rasterize(&*self, path, matrix, clipBounds, filter,
                                   mask, mode)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkScalerContextEffects {
        pub _address: u8,
    }
    impl Clone for SkScalerContextEffects {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_13() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkPicture>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkPicture>>() ,
                   8usize);
    }
    /** \class SkShader
 *
 *  Shaders specify the source color(s) for what is being drawn. If a paint
 *  has no shader, then the paint's color is used. If the paint has a
 *  shader, then the shader's color(s) are use instead, but they are
 *  modulated by the paint's alpha. This makes it easy to create a shader
 *  once (e.g. bitmap tiling or gradient) and then change its transparency
 *  w/o having to modify the original shader... only the paint's alpha needs
 *  to be modified.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkShader {
        pub _base: root::SkFlattenable,
        pub fLocalMatrix: root::SkMatrix,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_TileMode {
        kClamp_TileMode = 0,
        kRepeat_TileMode = 1,
        kMirror_TileMode = 2,
    }
    pub const SkShader_kTileModeCount: root::SkShader__bindgen_ty_1 =
        SkShader__bindgen_ty_1::kTileModeCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader__bindgen_ty_1 { kTileModeCount = 3, }
    pub const SkShader_Flags_kOpaqueAlpha_Flag: root::SkShader_Flags =
        SkShader_Flags(1);
    pub const SkShader_Flags_kConstInY32_Flag: root::SkShader_Flags =
        SkShader_Flags(2);
    pub const SkShader_Flags_kPrefers4f_Flag: root::SkShader_Flags =
        SkShader_Flags(4);
    impl ::std::ops::BitOr<root::SkShader_Flags> for root::SkShader_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkShader_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkShader_Flags(pub i32);
    /**
     *  ContextRec acts as a parameter bundle for creating Contexts.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_ContextRec {
        pub fPaint: *const root::SkPaint,
        pub fMatrix: *const root::SkMatrix,
        pub fLocalMatrix: *const root::SkMatrix,
        pub fPreferredDstType: root::SkShader_ContextRec_DstType,
        pub fDstColorSpace: *mut root::SkColorSpace,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_ContextRec_DstType {
        kPMColor_DstType = 0,
        kPM4f_DstType = 1,
    }
    #[test]
    fn bindgen_test_layout_SkShader_ContextRec() {
        assert_eq!(::std::mem::size_of::<SkShader_ContextRec>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkShader_ContextRec>() , 8usize);
    }
    impl Clone for SkShader_ContextRec {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct SkShader_Context__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkShader_Context {
        pub vtable_: *const SkShader_Context__bindgen_vtable,
        pub fShader: *const root::SkShader,
        pub fCTM: root::SkMatrix,
        pub fTotalInverse: root::SkMatrix,
        pub fPaintAlpha: u8,
        pub fTotalInverseClass: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_Context_BlitState {
        pub fCtx: *mut root::SkShader_Context,
        pub fMode: root::SkBlendMode,
        pub fStorage: [*mut ::std::os::raw::c_void; 2usize],
        pub fBlitBW: root::SkShader_Context_BlitBW,
        pub fBlitAA: root::SkShader_Context_BlitAA,
    }
    pub const SkShader_Context_BlitState_N:
              root::SkShader_Context_BlitState__bindgen_ty_1 =
        SkShader_Context_BlitState__bindgen_ty_1::N;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_Context_BlitState__bindgen_ty_1 { N = 2, }
    #[test]
    fn bindgen_test_layout_SkShader_Context_BlitState() {
        assert_eq!(::std::mem::size_of::<SkShader_Context_BlitState>() ,
                   48usize);
        assert_eq!(::std::mem::align_of::<SkShader_Context_BlitState>() ,
                   8usize);
    }
    impl Clone for SkShader_Context_BlitState {
        fn clone(&self) -> Self { *self }
    }
    pub type SkShader_Context_BlitBW =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::SkShader_Context_BlitState,
                                                   x: ::std::os::raw::c_int,
                                                   y: ::std::os::raw::c_int,
                                                   arg2:
                                                       *const root::SkPixmap,
                                                   count:
                                                       ::std::os::raw::c_int)>;
    pub type SkShader_Context_BlitAA =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::SkShader_Context_BlitState,
                                                   x: ::std::os::raw::c_int,
                                                   y: ::std::os::raw::c_int,
                                                   arg2:
                                                       *const root::SkPixmap,
                                                   count:
                                                       ::std::os::raw::c_int,
                                                   arg3:
                                                       *const root::SkAlpha)>;
    /**
         * The const void* ctx is only const because all the implementations are const.
         * This can be changed to non-const if a new shade proc needs to change the ctx.
         */
    pub type SkShader_Context_ShadeProc =
        ::std::option::Option<unsafe extern "C" fn(ctx:
                                                       *const ::std::os::raw::c_void,
                                                   x: ::std::os::raw::c_int,
                                                   y: ::std::os::raw::c_int,
                                                   arg1: *mut root::SkPMColor,
                                                   count:
                                                       ::std::os::raw::c_int)>;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_Context_MatrixClass {
        kLinear_MatrixClass = 0,
        kFixedStepInX_MatrixClass = 1,
        kPerspective_MatrixClass = 2,
    }
    pub type SkShader_Context_INHERITED = root::SkNoncopyable;
    #[test]
    fn bindgen_test_layout_SkShader_Context() {
        assert_eq!(::std::mem::size_of::<SkShader_Context>() , 104usize);
        assert_eq!(::std::mem::align_of::<SkShader_Context>() , 8usize);
    }
    extern "C" {
        #[link_name =
              "?ComputeMatrixClass@Context@SkShader@@KA?AW4MatrixClass@12@AEBVSkMatrix@@@Z"]
        pub fn SkShader_Context_ComputeMatrixClass(arg1:
                                                       *const root::SkMatrix)
         -> root::SkShader_Context_MatrixClass;
    }
    extern "C" {
        #[link_name = "??0Context@SkShader@@QEAA@AEBV1@AEBUContextRec@1@@Z"]
        pub fn SkShader_Context_Context(this: *mut root::SkShader_Context,
                                        shader: *const root::SkShader,
                                        arg1:
                                            *const root::SkShader_ContextRec);
    }
    impl SkShader_Context {
        #[inline]
        pub unsafe fn ComputeMatrixClass(arg1: *const root::SkMatrix)
         -> root::SkShader_Context_MatrixClass {
            SkShader_Context_ComputeMatrixClass(arg1)
        }
        #[inline]
        pub unsafe fn new(shader: *const root::SkShader,
                          arg1: *const root::SkShader_ContextRec) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkShader_Context_Context(&mut __bindgen_tmp, shader, arg1);
            __bindgen_tmp
        }
    }
    pub const SkShader_GradientType_kLast_GradientType:
              root::SkShader_GradientType =
        SkShader_GradientType::kConical_GradientType;
    #[repr(i32)]
    /**
     *  If the shader subclass can be represented as a gradient, asAGradient
     *  returns the matching GradientType enum (or kNone_GradientType if it
     *  cannot). Also, if info is not null, asAGradient populates info with
     *  the relevant (see below) parameters for the gradient.  fColorCount
     *  is both an input and output parameter.  On input, it indicates how
     *  many entries in fColors and fColorOffsets can be used, if they are
     *  non-NULL.  After asAGradient has run, fColorCount indicates how
     *  many color-offset pairs there are in the gradient.  If there is
     *  insufficient space to store all of the color-offset pairs, fColors
     *  and fColorOffsets will not be altered.  fColorOffsets specifies
     *  where on the range of 0 to 1 to transition to the given color.
     *  The meaning of fPoint and fRadius is dependant on the type of gradient.
     *
     *  None:
     *      info is ignored.
     *  Color:
     *      fColorOffsets[0] is meaningless.
     *  Linear:
     *      fPoint[0] and fPoint[1] are the end-points of the gradient
     *  Radial:
     *      fPoint[0] and fRadius[0] are the center and radius
     *  Conical:
     *      fPoint[0] and fRadius[0] are the center and radius of the 1st circle
     *      fPoint[1] and fRadius[1] are the center and radius of the 2nd circle
     *  Sweep:
     *      fPoint[0] is the center of the sweep.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkShader_GradientType {
        kNone_GradientType = 0,
        kColor_GradientType = 1,
        kLinear_GradientType = 2,
        kRadial_GradientType = 3,
        kSweep_GradientType = 4,
        kConical_GradientType = 5,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_GradientInfo {
        //< In-out parameter, specifies passed size
        pub fColorCount: ::std::os::raw::c_int,
        //< The colors in the gradient.
        pub fColors: *mut root::SkColor,
        //< The unit offset for color transitions.
        pub fColorOffsets: *mut root::SkScalar,
        //< Type specific, see above.
        pub fPoint: [root::SkPoint; 2usize],
        //< Type specific, see above.
        pub fRadius: [root::SkScalar; 2usize],
        //< The tile mode used.
        pub fTileMode: root::SkShader_TileMode,
        //< see SkGradientShader::Flags
        pub fGradientFlags: u32,
    }
    #[test]
    fn bindgen_test_layout_SkShader_GradientInfo() {
        assert_eq!(::std::mem::size_of::<SkShader_GradientInfo>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkShader_GradientInfo>() , 8usize);
    }
    impl Clone for SkShader_GradientInfo {
        fn clone(&self) -> Self { *self }
    }
    /**
     *  If the shader subclass is composed of two shaders, return true, and if rec is not NULL,
     *  fill it out with info about the shader.
     *
     *  These are bare pointers; the ownership and reference count are unchanged.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_ComposeRec {
        pub fShaderA: *const root::SkShader,
        pub fShaderB: *const root::SkShader,
        pub fBlendMode: root::SkBlendMode,
    }
    #[test]
    fn bindgen_test_layout_SkShader_ComposeRec() {
        assert_eq!(::std::mem::size_of::<SkShader_ComposeRec>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkShader_ComposeRec>() , 8usize);
    }
    impl Clone for SkShader_ComposeRec {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkShader_AsFPArgs {
        pub fContext: *mut root::GrContext,
        pub fViewMatrix: *const root::SkMatrix,
        pub fLocalMatrix: *const root::SkMatrix,
        pub fFilterQuality: root::SkFilterQuality,
        pub fDstColorSpace: *mut root::SkColorSpace,
        pub fColorMode: root::SkDestinationSurfaceColorMode,
    }
    #[test]
    fn bindgen_test_layout_SkShader_AsFPArgs() {
        assert_eq!(::std::mem::size_of::<SkShader_AsFPArgs>() , 48usize);
        assert_eq!(::std::mem::align_of::<SkShader_AsFPArgs>() , 8usize);
    }
    impl Clone for SkShader_AsFPArgs {
        fn clone(&self) -> Self { *self }
    }
    pub type SkShader_INHERITED = root::SkFlattenable;
    #[test]
    fn bindgen_test_layout_SkShader() {
        assert_eq!(::std::mem::size_of::<SkShader>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkShader>() , 8usize);
    }
    extern "C" {
        /**
     *  Create the actual object that does the shading.
     *  Size of storage must be >= contextSize.
     */
        #[link_name =
              "?createContext@SkShader@@QEBAPEAVContext@1@AEBUContextRec@1@PEAX@Z"]
        pub fn SkShader_createContext(this: *const root::SkShader,
                                      arg1: *const root::SkShader_ContextRec,
                                      storage: *mut ::std::os::raw::c_void)
         -> *mut root::SkShader_Context;
    }
    extern "C" {
        /**
     *  Return the size of a Context returned by createContext.
     */
        #[link_name = "?contextSize@SkShader@@QEBA_KAEBUContextRec@1@@Z"]
        pub fn SkShader_contextSize(this: *const root::SkShader,
                                    arg1: *const root::SkShader_ContextRec)
         -> usize;
    }
    extern "C" {
        /**
     *  If the shader can represent its "average" luminance in a single color, return true and
     *  if color is not NULL, return that color. If it cannot, return false and ignore the color
     *  parameter.
     *
     *  Note: if this returns true, the returned color will always be opaque, as only the RGB
     *  components are used to compute luminance.
     */
        #[link_name = "?asLuminanceColor@SkShader@@QEBA_NPEAI@Z"]
        pub fn SkShader_asLuminanceColor(this: *const root::SkShader,
                                         arg1: *mut root::SkColor) -> bool;
    }
    extern "C" {
        /**
     *  Return a shader that will apply the specified localMatrix to this shader.
     *  The specified matrix will be applied before any matrix associated with this shader.
     */
        #[link_name =
              "?makeWithLocalMatrix@SkShader@@QEBA?AV?$sk_sp@VSkShader@@@@AEBVSkMatrix@@@Z"]
        pub fn SkShader_makeWithLocalMatrix(this: *const root::SkShader,
                                            arg1: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  Create a new shader that produces the same colors as invoking this shader and then applying
     *  the colorfilter.
     */
        #[link_name =
              "?makeWithColorFilter@SkShader@@QEBA?AV?$sk_sp@VSkShader@@@@V?$sk_sp@VSkColorFilter@@@@@Z"]
        pub fn SkShader_makeWithColorFilter(this: *const root::SkShader,
                                            arg1:
                                                root::sk_sp<root::SkColorFilter>)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  Call this to create a new "empty" shader, that will not draw anything.
     */
        #[link_name =
              "?MakeEmptyShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@XZ"]
        pub fn SkShader_MakeEmptyShader() -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  Call this to create a new shader that just draws the specified color. This should always
     *  draw the same as a paint with this color (and no shader).
     */
        #[link_name =
              "?MakeColorShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@I@Z"]
        pub fn SkShader_MakeColorShader(arg1: root::SkColor)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  Create a shader that draws the specified color (in the specified colorspace).
     *
     *  This works around the limitation that SkPaint::setColor() only takes byte values, and does
     *  not support specific colorspaces.
     */
        #[link_name =
              "?MakeColorShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@AEBUSkColor4f@@V?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkShader_MakeColorShader1(arg1: *const root::SkColor4f,
                                         arg2:
                                             root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        #[link_name =
              "?MakeComposeShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@V2@0W4SkBlendMode@@@Z"]
        pub fn SkShader_MakeComposeShader(dst: root::sk_sp<root::SkShader>,
                                          src: root::sk_sp<root::SkShader>,
                                          arg1: root::SkBlendMode)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /** Call this to create a new shader that will draw with the specified bitmap.
     *
     *  If the bitmap cannot be used (e.g. has no pixels, or its dimensions
     *  exceed implementation limits (currently at 64K - 1)) then SkEmptyShader
     *  may be returned.
     *
     *  If the src is kA8_Config then that mask will be colorized using the color on
     *  the paint.
     *
     *  @param src  The bitmap to use inside the shader
     *  @param tmx  The tiling mode to use when sampling the bitmap in the x-direction.
     *  @param tmy  The tiling mode to use when sampling the bitmap in the y-direction.
     *  @return     Returns a new shader object. Note: this function never returns null.
    */
        #[link_name =
              "?MakeBitmapShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@AEBVSkBitmap@@W4TileMode@1@1PEBVSkMatrix@@@Z"]
        pub fn SkShader_MakeBitmapShader(src: *const root::SkBitmap,
                                         tmx: root::SkShader_TileMode,
                                         tmy: root::SkShader_TileMode,
                                         localMatrix: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /** Call this to create a new shader that will draw with the specified picture.
     *
     *  @param src  The picture to use inside the shader (if not NULL, its ref count
     *              is incremented). The SkPicture must not be changed after
     *              successfully creating a picture shader.
     *  @param tmx  The tiling mode to use when sampling the bitmap in the x-direction.
     *  @param tmy  The tiling mode to use when sampling the bitmap in the y-direction.
     *  @param tile The tile rectangle in picture coordinates: this represents the subset
     *              (or superset) of the picture used when building a tile. It is not
     *              affected by localMatrix and does not imply scaling (only translation
     *              and cropping). If null, the tile rect is considered equal to the picture
     *              bounds.
     *  @return     Returns a new shader object. Note: this function never returns null.
    */
        #[link_name =
              "?MakePictureShader@SkShader@@SA?AV?$sk_sp@VSkShader@@@@V?$sk_sp@VSkPicture@@@@W4TileMode@1@1PEBVSkMatrix@@PEBUSkRect@@@Z"]
        pub fn SkShader_MakePictureShader(src: root::sk_sp<root::SkPicture>,
                                          tmx: root::SkShader_TileMode,
                                          tmy: root::SkShader_TileMode,
                                          localMatrix: *const root::SkMatrix,
                                          tile: *const root::SkRect)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        #[link_name = "?InitializeFlattenables@SkShader@@SAXXZ"]
        pub fn SkShader_InitializeFlattenables();
    }
    extern "C" {
        #[link_name =
              "?appendStages@SkShader@@QEBA_NPEAVSkRasterPipeline@@PEAVSkColorSpace@@PEAVSkFallbackAlloc@@AEBVSkMatrix@@AEBVSkPaint@@@Z"]
        pub fn SkShader_appendStages(this: *const root::SkShader,
                                     arg1: *mut root::SkRasterPipeline,
                                     arg2: *mut root::SkColorSpace,
                                     arg3: *mut root::SkFallbackAlloc,
                                     ctm: *const root::SkMatrix,
                                     arg4: *const root::SkPaint) -> bool;
    }
    extern "C" {
        #[link_name =
              "?computeTotalInverse@SkShader@@IEBA_NAEBUContextRec@1@PEAVSkMatrix@@@Z"]
        pub fn SkShader_computeTotalInverse(this: *const root::SkShader,
                                            arg1:
                                                *const root::SkShader_ContextRec,
                                            totalInverse: *mut root::SkMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "??0SkShader@@QEAA@PEBVSkMatrix@@@Z"]
        pub fn SkShader_SkShader(this: *mut root::SkShader,
                                 localMatrix: *const root::SkMatrix);
    }
    impl SkShader {
        #[inline]
        pub unsafe fn createContext(&self,
                                    arg1: *const root::SkShader_ContextRec,
                                    storage: *mut ::std::os::raw::c_void)
         -> *mut root::SkShader_Context {
            SkShader_createContext(&*self, arg1, storage)
        }
        #[inline]
        pub unsafe fn contextSize(&self,
                                  arg1: *const root::SkShader_ContextRec)
         -> usize {
            SkShader_contextSize(&*self, arg1)
        }
        #[inline]
        pub unsafe fn asLuminanceColor(&self, arg1: *mut root::SkColor)
         -> bool {
            SkShader_asLuminanceColor(&*self, arg1)
        }
        #[inline]
        pub unsafe fn makeWithLocalMatrix(&self, arg1: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader> {
            SkShader_makeWithLocalMatrix(&*self, arg1)
        }
        #[inline]
        pub unsafe fn makeWithColorFilter(&self,
                                          arg1:
                                              root::sk_sp<root::SkColorFilter>)
         -> root::sk_sp<root::SkShader> {
            SkShader_makeWithColorFilter(&*self, arg1)
        }
        #[inline]
        pub unsafe fn MakeEmptyShader() -> root::sk_sp<root::SkShader> {
            SkShader_MakeEmptyShader()
        }
        #[inline]
        pub unsafe fn MakeColorShader(arg1: root::SkColor)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakeColorShader(arg1)
        }
        #[inline]
        pub unsafe fn MakeColorShader1(arg1: *const root::SkColor4f,
                                       arg2: root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakeColorShader1(arg1, arg2)
        }
        #[inline]
        pub unsafe fn MakeComposeShader(dst: root::sk_sp<root::SkShader>,
                                        src: root::sk_sp<root::SkShader>,
                                        arg1: root::SkBlendMode)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakeComposeShader(dst, src, arg1)
        }
        #[inline]
        pub unsafe fn MakeBitmapShader(src: *const root::SkBitmap,
                                       tmx: root::SkShader_TileMode,
                                       tmy: root::SkShader_TileMode,
                                       localMatrix: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakeBitmapShader(src, tmx, tmy, localMatrix)
        }
        #[inline]
        pub unsafe fn MakePictureShader(src: root::sk_sp<root::SkPicture>,
                                        tmx: root::SkShader_TileMode,
                                        tmy: root::SkShader_TileMode,
                                        localMatrix: *const root::SkMatrix,
                                        tile: *const root::SkRect)
         -> root::sk_sp<root::SkShader> {
            SkShader_MakePictureShader(src, tmx, tmy, localMatrix, tile)
        }
        #[inline]
        pub unsafe fn InitializeFlattenables() {
            SkShader_InitializeFlattenables()
        }
        #[inline]
        pub unsafe fn appendStages(&self, arg1: *mut root::SkRasterPipeline,
                                   arg2: *mut root::SkColorSpace,
                                   arg3: *mut root::SkFallbackAlloc,
                                   ctm: *const root::SkMatrix,
                                   arg4: *const root::SkPaint) -> bool {
            SkShader_appendStages(&*self, arg1, arg2, arg3, ctm, arg4)
        }
        #[inline]
        pub unsafe fn computeTotalInverse(&self,
                                          arg1:
                                              *const root::SkShader_ContextRec,
                                          totalInverse: *mut root::SkMatrix)
         -> bool {
            SkShader_computeTotalInverse(&*self, arg1, totalInverse)
        }
        #[inline]
        pub unsafe fn new(localMatrix: *const root::SkMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkShader_SkShader(&mut __bindgen_tmp, localMatrix);
            __bindgen_tmp
        }
    }
    #[repr(i32)]
    /**
 *  Description of how the LCD strips are arranged for each pixel. If this is unknown, or the
 *  pixels are meant to be "portable" and/or transformed before showing (e.g. rotated, scaled)
 *  then use kUnknown_SkPixelGeometry.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPixelGeometry {
        kUnknown_SkPixelGeometry = 0,
        kRGB_H_SkPixelGeometry = 1,
        kBGR_H_SkPixelGeometry = 2,
        kRGB_V_SkPixelGeometry = 3,
        kBGR_V_SkPixelGeometry = 4,
    }
    /**
 *  Describes properties and constraints of a given SkSurface. The rendering engine can parse these
 *  during drawing, and can sometimes optimize its performance (e.g. disabling an expensive
 *  feature).
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkSurfaceProps {
        pub fFlags: u32,
        pub fPixelGeometry: root::SkPixelGeometry,
    }
    pub const SkSurfaceProps_Flags_kUseDeviceIndependentFonts_Flag:
              root::SkSurfaceProps_Flags =
        SkSurfaceProps_Flags(1);
    impl ::std::ops::BitOr<root::SkSurfaceProps_Flags> for
     root::SkSurfaceProps_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkSurfaceProps_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkSurfaceProps_Flags(pub i32);
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkSurfaceProps_InitType { kLegacyFontHost_InitType = 0, }
    extern "C" {
        #[link_name =
              "?kUseDistanceFieldFonts_Flag@SkSurfaceProps@@2W4Flags@1@B"]
        pub static SkSurfaceProps_kUseDistanceFieldFonts_Flag:
                   root::SkSurfaceProps_Flags;
    }
    #[test]
    fn bindgen_test_layout_SkSurfaceProps() {
        assert_eq!(::std::mem::size_of::<SkSurfaceProps>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkSurfaceProps>() , 4usize);
    }
    extern "C" {
        #[link_name = "??0SkSurfaceProps@@QEAA@IW4SkPixelGeometry@@@Z"]
        pub fn SkSurfaceProps_SkSurfaceProps(this: *mut root::SkSurfaceProps,
                                             flags: u32,
                                             arg1: root::SkPixelGeometry);
    }
    extern "C" {
        #[link_name = "??0SkSurfaceProps@@QEAA@W4InitType@0@@Z"]
        pub fn SkSurfaceProps_SkSurfaceProps1(this: *mut root::SkSurfaceProps,
                                              arg1:
                                                  root::SkSurfaceProps_InitType);
    }
    extern "C" {
        #[link_name = "??0SkSurfaceProps@@QEAA@IW4InitType@0@@Z"]
        pub fn SkSurfaceProps_SkSurfaceProps2(this: *mut root::SkSurfaceProps,
                                              flags: u32,
                                              arg1:
                                                  root::SkSurfaceProps_InitType);
    }
    extern "C" {
        #[link_name = "??0SkSurfaceProps@@QEAA@AEBV0@@Z"]
        pub fn SkSurfaceProps_SkSurfaceProps3(this: *mut root::SkSurfaceProps,
                                              other:
                                                  *const root::SkSurfaceProps);
    }
    impl Clone for SkSurfaceProps {
        fn clone(&self) -> Self { *self }
    }
    impl SkSurfaceProps {
        #[inline]
        pub unsafe fn new(flags: u32, arg1: root::SkPixelGeometry) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkSurfaceProps_SkSurfaceProps(&mut __bindgen_tmp, flags, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: root::SkSurfaceProps_InitType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkSurfaceProps_SkSurfaceProps1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(flags: u32, arg1: root::SkSurfaceProps_InitType)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkSurfaceProps_SkSurfaceProps2(&mut __bindgen_tmp, flags, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(other: *const root::SkSurfaceProps) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkSurfaceProps_SkSurfaceProps3(&mut __bindgen_tmp, other);
            __bindgen_tmp
        }
    }
    #[test]
    fn __bindgen_test_layout_template_14() {
        assert_eq!(::std::mem::size_of::<root::SkNVRefCnt<root::SkTextBlob>>()
                   , 4usize);
        assert_eq!(::std::mem::align_of::<root::SkNVRefCnt<root::SkTextBlob>>()
                   , 4usize);
    }
    #[test]
    fn __bindgen_test_layout_template_15() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkTextBlob>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkTextBlob>>() ,
                   8usize);
    }
    /** \class SkTextBlob

    SkTextBlob combines multiple text runs into an immutable, ref-counted structure.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkTextBlob {
        pub _base: root::SkNVRefCnt<root::SkTextBlob>,
        pub fRunCount: ::std::os::raw::c_int,
        pub fBounds: root::SkRect,
        pub fUniqueID: u32,
        pub fStorageSize: usize,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkTextBlob_GlyphPositioning {
        kDefault_Positioning = 0,
        kHorizontal_Positioning = 1,
        kFull_Positioning = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkTextBlob_RunRecord {
        pub _address: u8,
    }
    impl Clone for SkTextBlob_RunRecord {
        fn clone(&self) -> Self { *self }
    }
    pub type SkTextBlob_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkTextBlob() {
        assert_eq!(::std::mem::size_of::<SkTextBlob>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkTextBlob>() , 8usize);
    }
    extern "C" {
        /**
     *  Serialize to a buffer.
     */
        #[link_name = "?flatten@SkTextBlob@@QEBAXAEAVSkWriteBuffer@@@Z"]
        pub fn SkTextBlob_flatten(this: *const root::SkTextBlob,
                                  arg1: *mut root::SkWriteBuffer);
    }
    extern "C" {
        /**
     *  Recreate an SkTextBlob that was serialized into a buffer.
     *
     *  @param  SkReadBuffer Serialized blob data.
     *  @return A new SkTextBlob representing the serialized data, or NULL if the buffer is
     *          invalid.
     */
        #[link_name =
              "?MakeFromBuffer@SkTextBlob@@SA?AV?$sk_sp@VSkTextBlob@@@@AEAVSkReadBuffer@@@Z"]
        pub fn SkTextBlob_MakeFromBuffer(arg1: *mut root::SkReadBuffer)
         -> root::sk_sp<root::SkTextBlob>;
    }
    impl SkTextBlob {
        #[inline]
        pub unsafe fn flatten(&self, arg1: *mut root::SkWriteBuffer) {
            SkTextBlob_flatten(&*self, arg1)
        }
        #[inline]
        pub unsafe fn MakeFromBuffer(arg1: *mut root::SkReadBuffer)
         -> root::sk_sp<root::SkTextBlob> {
            SkTextBlob_MakeFromBuffer(arg1)
        }
    }
    /** \class SkWeakRefCnt

    SkWeakRefCnt is the base class for objects that may be shared by multiple
    objects. When an existing strong owner wants to share a reference, it calls
    ref(). When a strong owner wants to release its reference, it calls
    unref(). When the shared object's strong reference count goes to zero as
    the result of an unref() call, its (virtual) weak_dispose method is called.
    It is an error for the destructor to be called explicitly (or via the
    object going out of scope on the stack or calling delete) if
    getRefCnt() > 1.

    In addition to strong ownership, an owner may instead obtain a weak
    reference by calling weak_ref(). A call to weak_ref() must be balanced by a
    call to weak_unref(). To obtain a strong reference from a weak reference,
    call try_ref(). If try_ref() returns true, the owner's pointer is now also
    a strong reference on which unref() must be called. Note that this does not
    affect the original weak reference, weak_unref() must still be called. When
    the weak reference count goes to zero, the object is deleted. While the
    weak reference count is positive and the strong reference count is zero the
    object still exists, but will be in the disposed state. It is up to the
    object to define what this means.

    Note that a strong reference implicitly implies a weak reference. As a
    result, it is allowable for the owner of a strong ref to call try_ref().
    This will have the same effect as calling ref(), but may be more expensive.

    Example:

    SkWeakRefCnt myRef = strongRef.weak_ref();
    ... // strongRef.unref() may or may not be called
    if (myRef.try_ref()) {
        ... // use myRef
        myRef.unref();
    } else {
        // myRef is in the disposed state
    }
    myRef.weak_unref();
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkWeakRefCnt {
        pub _base: root::SkRefCnt,
        pub fWeakCnt: u32,
    }
    pub type SkWeakRefCnt_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkWeakRefCnt() {
        assert_eq!(::std::mem::size_of::<SkWeakRefCnt>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkWeakRefCnt>() , 8usize);
    }
    pub type SkFontID = u32;
    #[repr(C)]
    #[derive(Copy)]
    pub struct SkFontStyle {
        pub fUnion: root::SkFontStyle__bindgen_ty_1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkFontStyle_Weight {
        kInvisible_Weight = 0,
        kThin_Weight = 100,
        kExtraLight_Weight = 200,
        kLight_Weight = 300,
        kNormal_Weight = 400,
        kMedium_Weight = 500,
        kSemiBold_Weight = 600,
        kBold_Weight = 700,
        kExtraBold_Weight = 800,
        kBlack_Weight = 900,
        kExtraBlack_Weight = 1000,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkFontStyle_Width {
        kUltraCondensed_Width = 1,
        kExtraCondensed_Width = 2,
        kCondensed_Width = 3,
        kSemiCondensed_Width = 4,
        kNormal_Width = 5,
        kSemiExpanded_Width = 6,
        kExpanded_Width = 7,
        kExtraExpanded_Width = 8,
        kUltraExpanded_Width = 9,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkFontStyle_Slant {
        kUpright_Slant = 0,
        kItalic_Slant = 1,
        kOblique_Slant = 2,
    }
    #[repr(C)]
    #[derive(Copy)]
    pub union SkFontStyle__bindgen_ty_1 {
        pub fR: root::SkFontStyle__bindgen_ty_1__bindgen_ty_1,
        pub fU32: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkFontStyle__bindgen_ty_1__bindgen_ty_1 {
        pub fWeight: u16,
        pub fWidth: u8,
        pub fSlant: u8,
    }
    #[test]
    fn bindgen_test_layout_SkFontStyle__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<SkFontStyle__bindgen_ty_1__bindgen_ty_1>()
                   , 4usize);
        assert_eq!(::std::mem::align_of::<SkFontStyle__bindgen_ty_1__bindgen_ty_1>()
                   , 2usize);
    }
    impl Clone for SkFontStyle__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_SkFontStyle__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<SkFontStyle__bindgen_ty_1>() ,
                   4usize);
        assert_eq!(::std::mem::align_of::<SkFontStyle__bindgen_ty_1>() ,
                   4usize);
    }
    impl Clone for SkFontStyle__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_SkFontStyle() {
        assert_eq!(::std::mem::size_of::<SkFontStyle>() , 4usize);
        assert_eq!(::std::mem::align_of::<SkFontStyle>() , 4usize);
    }
    extern "C" {
        #[link_name = "?FromOldStyle@SkFontStyle@@SA?AV1@I@Z"]
        pub fn SkFontStyle_FromOldStyle(oldStyle: ::std::os::raw::c_uint)
         -> root::SkFontStyle;
    }
    extern "C" {
        #[link_name = "??0SkFontStyle@@QEAA@XZ"]
        pub fn SkFontStyle_SkFontStyle(this: *mut root::SkFontStyle);
    }
    extern "C" {
        #[link_name = "??0SkFontStyle@@QEAA@HHW4Slant@0@@Z"]
        pub fn SkFontStyle_SkFontStyle1(this: *mut root::SkFontStyle,
                                        weight: ::std::os::raw::c_int,
                                        width: ::std::os::raw::c_int,
                                        arg1: root::SkFontStyle_Slant);
    }
    impl Clone for SkFontStyle {
        fn clone(&self) -> Self { *self }
    }
    impl SkFontStyle {
        #[inline]
        pub unsafe fn FromOldStyle(oldStyle: ::std::os::raw::c_uint)
         -> root::SkFontStyle {
            SkFontStyle_FromOldStyle(oldStyle)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkFontStyle_SkFontStyle(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(weight: ::std::os::raw::c_int,
                           width: ::std::os::raw::c_int,
                           arg1: root::SkFontStyle_Slant) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkFontStyle_SkFontStyle1(&mut __bindgen_tmp, weight, width, arg1);
            __bindgen_tmp
        }
    }
    /** Machine endian. */
    pub type SkFontTableTag = u32;
    /** \class SkTypeface

    The SkTypeface class specifies the typeface and intrinsic style of a font.
    This is used in the paint, along with optionally algorithmic settings like
    textSize, textSkewX, textScaleX, kFakeBoldText_Mask, to specify
    how text appears when drawn (and measured).

    Typeface objects are immutable, and so they can be shared between threads.
*/
    #[repr(C)]
    pub struct SkTypeface {
        pub _base: root::SkWeakRefCnt,
        pub fUniqueID: root::SkFontID,
        pub fStyle: root::SkFontStyle,
        pub fBounds: root::SkRect,
        pub fBoundsOnce: root::SkOnce,
        pub fIsFixedPitch: bool,
    }
    #[repr(i32)]
    /** Style specifies the intrinsic style attributes of a given typeface
    */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkTypeface_Style {
        kNormal = 0,
        kBold = 1,
        kItalic = 2,
        kBoldItalic = 3,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkTypeface_Encoding {
        kUTF8_Encoding = 0,
        kUTF16_Encoding = 1,
        kUTF32_Encoding = 2,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkTypeface_LocalizedString {
        pub fString: root::SkString,
        pub fLanguage: root::SkString,
    }
    #[test]
    fn bindgen_test_layout_SkTypeface_LocalizedString() {
        assert_eq!(::std::mem::size_of::<SkTypeface_LocalizedString>() ,
                   16usize);
        assert_eq!(::std::mem::align_of::<SkTypeface_LocalizedString>() ,
                   8usize);
    }
    #[repr(C)]
    pub struct SkTypeface_LocalizedStrings__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkTypeface_LocalizedStrings {
        pub vtable_: *const SkTypeface_LocalizedStrings__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkTypeface_LocalizedStrings() {
        assert_eq!(::std::mem::size_of::<SkTypeface_LocalizedStrings>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<SkTypeface_LocalizedStrings>() ,
                   8usize);
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkTypeface_PerGlyphInfo {
        kNo_PerGlyphInfo = 0,
        kGlyphNames_PerGlyphInfo = 1,
        kToUnicode_PerGlyphInfo = 2,
    }
    pub type SkTypeface_INHERITED = root::SkWeakRefCnt;
    #[test]
    fn bindgen_test_layout_SkTypeface() {
        assert_eq!(::std::mem::size_of::<SkTypeface>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkTypeface>() , 8usize);
    }
    extern "C" {
        /** Return the uniqueID for the specified typeface. If the face is null,
        resolve it to the default font and return its uniqueID. Will never
        return 0.
    */
        #[link_name = "?UniqueID@SkTypeface@@SAIPEBV1@@Z"]
        pub fn SkTypeface_UniqueID(face: *const root::SkTypeface)
         -> root::SkFontID;
    }
    extern "C" {
        /** Returns true if the two typefaces reference the same underlying font,
        handling either being null (treating null as the default font)
     */
        #[link_name = "?Equal@SkTypeface@@SA_NPEBV1@0@Z"]
        pub fn SkTypeface_Equal(facea: *const root::SkTypeface,
                                faceb: *const root::SkTypeface) -> bool;
    }
    extern "C" {
        /** Returns the default typeface, which is never nullptr. */
        #[link_name =
              "?MakeDefault@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@W4Style@1@@Z"]
        pub fn SkTypeface_MakeDefault(style: root::SkTypeface_Style)
         -> root::sk_sp<root::SkTypeface>;
    }
    extern "C" {
        /** Creates a new reference to the typeface that most closely matches the
      requested familyName and fontStyle. This method allows extended font
      face specifiers as in the SkFontStyle type. Will never return null.

      @param familyName  May be NULL. The name of the font family.
      @param fontStyle   The style of the typeface.
      @return reference to the closest-matching typeface. Call must call
              unref() when they are done.
    */
        #[link_name =
              "?MakeFromName@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@QEBDVSkFontStyle@@@Z"]
        pub fn SkTypeface_MakeFromName(familyName:
                                           *const ::std::os::raw::c_char,
                                       fontStyle: root::SkFontStyle)
         -> root::sk_sp<root::SkTypeface>;
    }
    extern "C" {
        /** Return the typeface that most closely matches the requested typeface and style.
        Use this to pick a new style from the same family of the existing typeface.
        If family is nullptr, this selects from the default font's family.

        @param family  May be NULL. The name of the existing type face.
        @param s       The style (normal, bold, italic) of the type face.
        @return the closest-matching typeface.
    */
        #[link_name =
              "?MakeFromTypeface@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@PEAV1@W4Style@1@@Z"]
        pub fn SkTypeface_MakeFromTypeface(family: *mut root::SkTypeface,
                                           arg1: root::SkTypeface_Style)
         -> root::sk_sp<root::SkTypeface>;
    }
    extern "C" {
        /** Return a new typeface given a file. If the file does not exist, or is
        not a valid font file, returns nullptr.
    */
        #[link_name =
              "?MakeFromFile@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@QEBDH@Z"]
        pub fn SkTypeface_MakeFromFile(path: *const ::std::os::raw::c_char,
                                       index: ::std::os::raw::c_int)
         -> root::sk_sp<root::SkTypeface>;
    }
    extern "C" {
        /** Return a new typeface given a stream. If the stream is
        not a valid font file, returns nullptr. Ownership of the stream is
        transferred, so the caller must not reference it again.
    */
        #[link_name =
              "?MakeFromStream@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@PEAVSkStreamAsset@@H@Z"]
        pub fn SkTypeface_MakeFromStream(stream: *mut root::SkStreamAsset,
                                         index: ::std::os::raw::c_int)
         -> root::sk_sp<root::SkTypeface>;
    }
    extern "C" {
        /** Return a new typeface given font data and configuration. If the data
        is not valid font data, returns nullptr.
    */
        #[link_name =
              "?MakeFromFontData@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@V?$unique_ptr@VSkFontData@@U?$default_delete@VSkFontData@@@std@@@std@@@Z"]
        pub fn SkTypeface_MakeFromFontData(arg1:
                                               root::std::unique_ptr<root::SkFontData,
                                                                     root::std::default_delete<root::SkFontData>>)
         -> root::sk_sp<root::SkTypeface>;
    }
    extern "C" {
        /** Write a unique signature to a stream, sufficient to reconstruct a
        typeface referencing the same font when Deserialize is called.
     */
        #[link_name = "?serialize@SkTypeface@@QEBAXPEAVSkWStream@@@Z"]
        pub fn SkTypeface_serialize(this: *const root::SkTypeface,
                                    arg1: *mut root::SkWStream);
    }
    extern "C" {
        /** Given the data previously written by serialize(), return a new instance
        of a typeface referring to the same font. If that font is not available,
        return nullptr.
        Does not affect ownership of SkStream.
     */
        #[link_name =
              "?MakeDeserialize@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@PEAVSkStream@@@Z"]
        pub fn SkTypeface_MakeDeserialize(arg1: *mut root::SkStream)
         -> root::sk_sp<root::SkTypeface>;
    }
    extern "C" {
        /**
     *  Given an array of character codes, of the specified encoding,
     *  optionally return their corresponding glyph IDs (if glyphs is not NULL).
     *
     *  @param chars pointer to the array of character codes
     *  @param encoding how the characters are encoded
     *  @param glyphs (optional) returns the corresponding glyph IDs for each
     *          character code, up to glyphCount values. If a character code is
     *          not found in the typeface, the corresponding glyph ID will be 0.
     *  @param glyphCount number of code points in 'chars' to process. If glyphs
     *          is not NULL, then it must point sufficient memory to write
     *          glyphCount values into it.
     *  @return the number of number of continuous non-zero glyph IDs computed
     *          from the beginning of chars. This value is valid, even if the
     *          glyphs parameter is NULL.
     */
        #[link_name =
              "?charsToGlyphs@SkTypeface@@QEBAHPEBXW4Encoding@1@QEAGH@Z"]
        pub fn SkTypeface_charsToGlyphs(this: *const root::SkTypeface,
                                        chars: *const ::std::os::raw::c_void,
                                        encoding: root::SkTypeface_Encoding,
                                        glyphs: *mut root::SkGlyphID,
                                        glyphCount: ::std::os::raw::c_int)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /**
     *  Return the number of glyphs in the typeface.
     */
        #[link_name = "?countGlyphs@SkTypeface@@QEBAHXZ"]
        pub fn SkTypeface_countGlyphs(this: *const root::SkTypeface)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Return the number of tables in the font. */
        #[link_name = "?countTables@SkTypeface@@QEBAHXZ"]
        pub fn SkTypeface_countTables(this: *const root::SkTypeface)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Copy into tags[] (allocated by the caller) the list of table tags in
     *  the font, and return the number. This will be the same as CountTables()
     *  or 0 if an error occured. If tags == NULL, this only returns the count
     *  (the same as calling countTables()).
     */
        #[link_name = "?getTableTags@SkTypeface@@QEBAHQEAI@Z"]
        pub fn SkTypeface_getTableTags(this: *const root::SkTypeface,
                                       tags: *mut root::SkFontTableTag)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Given a table tag, return the size of its contents, or 0 if not present
     */
        #[link_name = "?getTableSize@SkTypeface@@QEBA_KI@Z"]
        pub fn SkTypeface_getTableSize(this: *const root::SkTypeface,
                                       arg1: root::SkFontTableTag) -> usize;
    }
    extern "C" {
        /** Copy the contents of a table into data (allocated by the caller). Note
     *  that the contents of the table will be in their native endian order
     *  (which for most truetype tables is big endian). If the table tag is
     *  not found, or there is an error copying the data, then 0 is returned.
     *  If this happens, it is possible that some or all of the memory pointed
     *  to by data may have been written to, even though an error has occured.
     *
     *  @param fontID the font to copy the table from
     *  @param tag  The table tag whose contents are to be copied
     *  @param offset The offset in bytes into the table's contents where the
     *  copy should start from.
     *  @param length The number of bytes, starting at offset, of table data
     *  to copy.
     *  @param data storage address where the table contents are copied to
     *  @return the number of bytes actually copied into data. If offset+length
     *  exceeds the table's size, then only the bytes up to the table's
     *  size are actually copied, and this is the value returned. If
     *  offset > the table's size, or tag is not a valid table,
     *  then 0 is returned.
     */
        #[link_name = "?getTableData@SkTypeface@@QEBA_KI_K0PEAX@Z"]
        pub fn SkTypeface_getTableData(this: *const root::SkTypeface,
                                       tag: root::SkFontTableTag,
                                       offset: usize, length: usize,
                                       data: *mut ::std::os::raw::c_void)
         -> usize;
    }
    extern "C" {
        /**
     *  Return the units-per-em value for this typeface, or zero if there is an
     *  error.
     */
        #[link_name = "?getUnitsPerEm@SkTypeface@@QEBAHXZ"]
        pub fn SkTypeface_getUnitsPerEm(this: *const root::SkTypeface)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /**
     *  Given a run of glyphs, return the associated horizontal adjustments.
     *  Adjustments are in "design units", which are integers relative to the
     *  typeface's units per em (see getUnitsPerEm).
     *
     *  Some typefaces are known to never support kerning. Calling this method
     *  with all zeros (e.g. getKerningPairAdustments(NULL, 0, NULL)) returns
     *  a boolean indicating if the typeface might support kerning. If it
     *  returns false, then it will always return false (no kerning) for all
     *  possible glyph runs. If it returns true, then it *may* return true for
     *  somne glyph runs.
     *
     *  If count is non-zero, then the glyphs parameter must point to at least
     *  [count] valid glyph IDs, and the adjustments parameter must be
     *  sized to at least [count - 1] entries. If the method returns true, then
     *  [count-1] entries in the adjustments array will be set. If the method
     *  returns false, then no kerning should be applied, and the adjustments
     *  array will be in an undefined state (possibly some values may have been
     *  written, but none of them should be interpreted as valid values).
     */
        #[link_name =
              "?getKerningPairAdjustments@SkTypeface@@QEBA_NQEBGHQEAH@Z"]
        pub fn SkTypeface_getKerningPairAdjustments(this:
                                                        *const root::SkTypeface,
                                                    glyphs:
                                                        *const root::SkGlyphID,
                                                    count:
                                                        ::std::os::raw::c_int,
                                                    adjustments: *mut i32)
         -> bool;
    }
    extern "C" {
        /**
     *  Returns an iterator which will attempt to enumerate all of the
     *  family names specified by the font.
     *  It is the caller's responsibility to unref() the returned pointer.
     */
        #[link_name =
              "?createFamilyNameIterator@SkTypeface@@QEBAPEAVLocalizedStrings@1@XZ"]
        pub fn SkTypeface_createFamilyNameIterator(this:
                                                       *const root::SkTypeface)
         -> *mut root::SkTypeface_LocalizedStrings;
    }
    extern "C" {
        /**
     *  Return the family name for this typeface. It will always be returned
     *  encoded as UTF8, but the language of the name is whatever the host
     *  platform chooses.
     */
        #[link_name = "?getFamilyName@SkTypeface@@QEBAXPEAVSkString@@@Z"]
        pub fn SkTypeface_getFamilyName(this: *const root::SkTypeface,
                                        name: *mut root::SkString);
    }
    extern "C" {
        /**
     *  Return a stream for the contents of the font data, or NULL on failure.
     *  If ttcIndex is not null, it is set to the TrueTypeCollection index
     *  of this typeface within the stream, or 0 if the stream is not a
     *  collection.
     *  The caller is responsible for deleting the stream.
     */
        #[link_name = "?openStream@SkTypeface@@QEBAPEAVSkStreamAsset@@PEAH@Z"]
        pub fn SkTypeface_openStream(this: *const root::SkTypeface,
                                     ttcIndex: *mut ::std::os::raw::c_int)
         -> *mut root::SkStreamAsset;
    }
    extern "C" {
        /**
     *  Return the font data, or nullptr on failure.
     */
        #[link_name =
              "?makeFontData@SkTypeface@@QEBA?AV?$unique_ptr@VSkFontData@@U?$default_delete@VSkFontData@@@std@@@std@@XZ"]
        pub fn SkTypeface_makeFontData(this: *const root::SkTypeface)
         ->
             root::std::unique_ptr<root::SkFontData,
                                   root::std::default_delete<root::SkFontData>>;
    }
    extern "C" {
        /**
     *  Return a scalercontext for the given descriptor. If this fails, then
     *  if allowFailure is true, this returns NULL, else it returns a
     *  dummy scalercontext that will not crash, but will draw nothing.
     */
        #[link_name =
              "?createScalerContext@SkTypeface@@QEBA?AV?$unique_ptr@VSkScalerContext@@U?$default_delete@VSkScalerContext@@@std@@@std@@AEBUSkScalerContextEffects@@PEBVSkDescriptor@@_N@Z"]
        pub fn SkTypeface_createScalerContext(this: *const root::SkTypeface,
                                              arg1:
                                                  *const root::SkScalerContextEffects,
                                              arg2: *const root::SkDescriptor,
                                              allowFailure: bool)
         ->
             root::std::unique_ptr<root::SkScalerContext,
                                   root::std::default_delete<root::SkScalerContext>>;
    }
    extern "C" {
        /**
     *  Return a rectangle (scaled to 1-pt) that represents the union of the bounds of all
     *  of the glyphs, but each one positioned at (0,). This may be conservatively large, and
     *  will not take into account any hinting or other size-specific adjustments.
     */
        #[link_name = "?getBounds@SkTypeface@@QEBA?AUSkRect@@XZ"]
        pub fn SkTypeface_getBounds(this: *const root::SkTypeface)
         -> root::SkRect;
    }
    extern "C" {
        #[link_name = "?GetDefaultTypeface@SkTypeface@@KAPEAV1@W4Style@1@@Z"]
        pub fn SkTypeface_GetDefaultTypeface(style: root::SkTypeface_Style)
         -> *mut root::SkTypeface;
    }
    extern "C" {
        /** uniqueID must be unique and non-zero
    */
        #[link_name = "??0SkTypeface@@IEAA@AEBVSkFontStyle@@_N@Z"]
        pub fn SkTypeface_SkTypeface(this: *mut root::SkTypeface,
                                     style: *const root::SkFontStyle,
                                     isFixedPitch: bool);
    }
    impl SkTypeface {
        #[inline]
        pub unsafe fn UniqueID(face: *const root::SkTypeface)
         -> root::SkFontID {
            SkTypeface_UniqueID(face)
        }
        #[inline]
        pub unsafe fn Equal(facea: *const root::SkTypeface,
                            faceb: *const root::SkTypeface) -> bool {
            SkTypeface_Equal(facea, faceb)
        }
        #[inline]
        pub unsafe fn MakeDefault(style: root::SkTypeface_Style)
         -> root::sk_sp<root::SkTypeface> {
            SkTypeface_MakeDefault(style)
        }
        #[inline]
        pub unsafe fn MakeFromName(familyName: *const ::std::os::raw::c_char,
                                   fontStyle: root::SkFontStyle)
         -> root::sk_sp<root::SkTypeface> {
            SkTypeface_MakeFromName(familyName, fontStyle)
        }
        #[inline]
        pub unsafe fn MakeFromTypeface(family: *mut root::SkTypeface,
                                       arg1: root::SkTypeface_Style)
         -> root::sk_sp<root::SkTypeface> {
            SkTypeface_MakeFromTypeface(family, arg1)
        }
        #[inline]
        pub unsafe fn MakeFromFile(path: *const ::std::os::raw::c_char,
                                   index: ::std::os::raw::c_int)
         -> root::sk_sp<root::SkTypeface> {
            SkTypeface_MakeFromFile(path, index)
        }
        #[inline]
        pub unsafe fn MakeFromStream(stream: *mut root::SkStreamAsset,
                                     index: ::std::os::raw::c_int)
         -> root::sk_sp<root::SkTypeface> {
            SkTypeface_MakeFromStream(stream, index)
        }
        #[inline]
        pub unsafe fn MakeFromFontData(arg1:
                                           root::std::unique_ptr<root::SkFontData,
                                                                 root::std::default_delete<root::SkFontData>>)
         -> root::sk_sp<root::SkTypeface> {
            SkTypeface_MakeFromFontData(arg1)
        }
        #[inline]
        pub unsafe fn serialize(&self, arg1: *mut root::SkWStream) {
            SkTypeface_serialize(&*self, arg1)
        }
        #[inline]
        pub unsafe fn MakeDeserialize(arg1: *mut root::SkStream)
         -> root::sk_sp<root::SkTypeface> {
            SkTypeface_MakeDeserialize(arg1)
        }
        #[inline]
        pub unsafe fn charsToGlyphs(&self,
                                    chars: *const ::std::os::raw::c_void,
                                    encoding: root::SkTypeface_Encoding,
                                    glyphs: *mut root::SkGlyphID,
                                    glyphCount: ::std::os::raw::c_int)
         -> ::std::os::raw::c_int {
            SkTypeface_charsToGlyphs(&*self, chars, encoding, glyphs,
                                     glyphCount)
        }
        #[inline]
        pub unsafe fn countGlyphs(&self) -> ::std::os::raw::c_int {
            SkTypeface_countGlyphs(&*self)
        }
        #[inline]
        pub unsafe fn countTables(&self) -> ::std::os::raw::c_int {
            SkTypeface_countTables(&*self)
        }
        #[inline]
        pub unsafe fn getTableTags(&self, tags: *mut root::SkFontTableTag)
         -> ::std::os::raw::c_int {
            SkTypeface_getTableTags(&*self, tags)
        }
        #[inline]
        pub unsafe fn getTableSize(&self, arg1: root::SkFontTableTag)
         -> usize {
            SkTypeface_getTableSize(&*self, arg1)
        }
        #[inline]
        pub unsafe fn getTableData(&self, tag: root::SkFontTableTag,
                                   offset: usize, length: usize,
                                   data: *mut ::std::os::raw::c_void)
         -> usize {
            SkTypeface_getTableData(&*self, tag, offset, length, data)
        }
        #[inline]
        pub unsafe fn getUnitsPerEm(&self) -> ::std::os::raw::c_int {
            SkTypeface_getUnitsPerEm(&*self)
        }
        #[inline]
        pub unsafe fn getKerningPairAdjustments(&self,
                                                glyphs:
                                                    *const root::SkGlyphID,
                                                count: ::std::os::raw::c_int,
                                                adjustments: *mut i32)
         -> bool {
            SkTypeface_getKerningPairAdjustments(&*self, glyphs, count,
                                                 adjustments)
        }
        #[inline]
        pub unsafe fn createFamilyNameIterator(&self)
         -> *mut root::SkTypeface_LocalizedStrings {
            SkTypeface_createFamilyNameIterator(&*self)
        }
        #[inline]
        pub unsafe fn getFamilyName(&self, name: *mut root::SkString) {
            SkTypeface_getFamilyName(&*self, name)
        }
        #[inline]
        pub unsafe fn openStream(&self, ttcIndex: *mut ::std::os::raw::c_int)
         -> *mut root::SkStreamAsset {
            SkTypeface_openStream(&*self, ttcIndex)
        }
        #[inline]
        pub unsafe fn makeFontData(&self)
         ->
             root::std::unique_ptr<root::SkFontData,
                                   root::std::default_delete<root::SkFontData>> {
            SkTypeface_makeFontData(&*self)
        }
        #[inline]
        pub unsafe fn createScalerContext(&self,
                                          arg1:
                                              *const root::SkScalerContextEffects,
                                          arg2: *const root::SkDescriptor,
                                          allowFailure: bool)
         ->
             root::std::unique_ptr<root::SkScalerContext,
                                   root::std::default_delete<root::SkScalerContext>> {
            SkTypeface_createScalerContext(&*self, arg1, arg2, allowFailure)
        }
        #[inline]
        pub unsafe fn getBounds(&self) -> root::SkRect {
            SkTypeface_getBounds(&*self)
        }
        #[inline]
        pub unsafe fn GetDefaultTypeface(style: root::SkTypeface_Style)
         -> *mut root::SkTypeface {
            SkTypeface_GetDefaultTypeface(style)
        }
        #[inline]
        pub unsafe fn new(style: *const root::SkFontStyle, isFixedPitch: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkTypeface_SkTypeface(&mut __bindgen_tmp, style, isFixedPitch);
            __bindgen_tmp
        }
    }
    pub const GrPixelConfig_kLast_GrPixelConfig: root::GrPixelConfig =
        GrPixelConfig::kRGBA_half_GrPixelConfig;
    #[repr(i32)]
    /**
 * Pixel configurations.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum GrPixelConfig {
        kUnknown_GrPixelConfig = 0,
        kAlpha_8_GrPixelConfig = 1,
        kIndex_8_GrPixelConfig = 2,
        kRGB_565_GrPixelConfig = 3,
        kRGBA_4444_GrPixelConfig = 4,
        kRGBA_8888_GrPixelConfig = 5,
        kBGRA_8888_GrPixelConfig = 6,
        kSRGBA_8888_GrPixelConfig = 7,
        kSBGRA_8888_GrPixelConfig = 8,
        kRGBA_8888_sint_GrPixelConfig = 9,
        kETC1_GrPixelConfig = 10,
        kLATC_GrPixelConfig = 11,
        kR11_EAC_GrPixelConfig = 12,
        kASTC_12x12_GrPixelConfig = 13,
        kRGBA_float_GrPixelConfig = 14,
        kAlpha_half_GrPixelConfig = 15,
        kRGBA_half_GrPixelConfig = 16,
    }
    pub type GrBackendObject = isize;
    #[repr(i32)]
    /**
 * Some textures will be stored such that the upper and left edges of the content meet at the
 * the origin (in texture coord space) and for other textures the lower and left edges meet at
 * the origin. kDefault_GrSurfaceOrigin sets textures to TopLeft, and render targets
 * to BottomLeft.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum GrSurfaceOrigin {
        kDefault_GrSurfaceOrigin = 0,
        kTopLeft_GrSurfaceOrigin = 1,
        kBottomLeft_GrSurfaceOrigin = 2,
    }
    pub const GrBackendTextureFlags_kNone_GrBackendTextureFlag:
              root::GrBackendTextureFlags =
        GrBackendTextureFlags(0);
    pub const GrBackendTextureFlags_kRenderTarget_GrBackendTextureFlag:
              root::GrBackendTextureFlags =
        GrBackendTextureFlags(1);
    impl ::std::ops::BitOr<root::GrBackendTextureFlags> for
     root::GrBackendTextureFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            GrBackendTextureFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    /**
 * Gr can wrap an existing texture created by the client with a GrTexture
 * object. The client is responsible for ensuring that the texture lives at
 * least as long as the GrTexture object wrapping it. We require the client to
 * explicitly provide information about the texture, such as width, height,
 * and pixel config, rather than querying the 3D APIfor these values. We expect
 * these to be immutable even if the 3D API doesn't require this (OpenGL).
 *
 * Textures that are also render targets are supported as well. Gr will manage
 * any ancillary 3D API (stencil buffer, FBO id, etc) objects necessary for
 * Gr to draw into the render target. To access the render target object
 * call GrTexture::asRenderTarget().
 *
 * If in addition to the render target flag, the caller also specifies a sample
 * count Gr will create an MSAA buffer that resolves into the texture. Gr auto-
 * resolves when it reads from the texture. The client can explictly resolve
 * using the GrRenderTarget interface.
 *
 * Note: These flags currently form a subset of GrTexture's flags.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct GrBackendTextureFlags(pub i32);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrBackendTextureDesc {
        pub fFlags: root::GrBackendTextureFlags,
        pub fOrigin: root::GrSurfaceOrigin,
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fConfig: root::GrPixelConfig,
        /**
     * If the render target flag is set and sample count is greater than 0
     * then Gr will create an MSAA buffer that resolves to the texture.
     */
        pub fSampleCnt: ::std::os::raw::c_int,
        /**
     * Handle to the 3D API object.
     * OpenGL: Texture ID.
     * Vulkan: GrVkImageInfo*
     */
        pub fTextureHandle: root::GrBackendObject,
    }
    #[test]
    fn bindgen_test_layout_GrBackendTextureDesc() {
        assert_eq!(::std::mem::size_of::<GrBackendTextureDesc>() , 32usize);
        assert_eq!(::std::mem::align_of::<GrBackendTextureDesc>() , 8usize);
    }
    impl Clone for GrBackendTextureDesc {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Gr can wrap an existing render target created by the client in the 3D API
 * with a GrRenderTarget object. The client is responsible for ensuring that the
 * underlying 3D API object lives at least as long as the GrRenderTarget object
 * wrapping it. We require the client to explicitly provide information about
 * the target, such as width, height, and pixel config rather than querying the
 * 3D API for these values. We expect these properties to be immutable even if
 * the 3D API doesn't require this (OpenGL).
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrBackendRenderTargetDesc {
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fConfig: root::GrPixelConfig,
        pub fOrigin: root::GrSurfaceOrigin,
        /**
     * The number of samples per pixel. Gr uses this to influence decisions
     * about applying other forms of anti-aliasing.
     */
        pub fSampleCnt: ::std::os::raw::c_int,
        /**
     * Number of bits of stencil per-pixel.
     */
        pub fStencilBits: ::std::os::raw::c_int,
        /**
     * Handle to the 3D API object.
     * OpenGL: FBO ID
     * Vulkan: GrVkImageInfo*
     */
        pub fRenderTargetHandle: root::GrBackendObject,
    }
    #[test]
    fn bindgen_test_layout_GrBackendRenderTargetDesc() {
        assert_eq!(::std::mem::size_of::<GrBackendRenderTargetDesc>() ,
                   32usize);
        assert_eq!(::std::mem::align_of::<GrBackendRenderTargetDesc>() ,
                   8usize);
    }
    impl Clone for GrBackendRenderTargetDesc {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkFallbackAlloc {
        pub _address: u8,
    }
    impl Clone for SkFallbackAlloc {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_16() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkImage>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkImage>>() ,
                   8usize);
    }
    /**
 *  SkImage is an abstraction for drawing a rectagle of pixels, though the
 *  particular type of image could be actually storing its data on the GPU, or
 *  as drawing commands (picture or PDF or otherwise), ready to be played back
 *  into another canvas.
 *
 *  The content of SkImage is always immutable, though the actual storage may
 *  change, if for example that image can be re-created via encoded data or
 *  other means.
 *
 *  SkImage always has a non-zero dimensions. If there is a request to create a new image, either
 *  directly or via SkSurface, and either of the requested dimensions are zero, then NULL will be
 *  returned.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkImage {
        pub _base: root::SkRefCnt,
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fUniqueID: u32,
    }
    pub type SkImage_Info = root::SkImageInfo;
    pub type SkImage_ReleaseContext = *mut ::std::os::raw::c_void;
    pub type SkImage_RasterReleaseProc =
        ::std::option::Option<unsafe extern "C" fn(pixels:
                                                       *const ::std::os::raw::c_void,
                                                   arg1:
                                                       root::SkImage_ReleaseContext)>;
    pub type SkImage_TextureReleaseProc =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       root::SkImage_ReleaseContext)>;
    #[repr(i32)]
    /**
     *  Hints to image calls where the system might cache computed intermediates (e.g. the results
     *  of decoding or a read-back from the GPU. Passing kAllow signals that the system's default
     *  behavior is fine. Passing kDisallow signals that caching should be avoided.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkImage_CachingHint {
        kAllow_CachingHint = 0,
        kDisallow_CachingHint = 1,
    }
    /** Drawing params for which a deferred texture image data should be optimized. */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImage_DeferredTextureImageUsageParams {
        pub fMatrix: root::SkMatrix,
        pub fQuality: root::SkFilterQuality,
        pub fPreScaleMipLevel: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_SkImage_DeferredTextureImageUsageParams() {
        assert_eq!(::std::mem::size_of::<SkImage_DeferredTextureImageUsageParams>()
                   , 48usize);
        assert_eq!(::std::mem::align_of::<SkImage_DeferredTextureImageUsageParams>()
                   , 4usize);
    }
    impl Clone for SkImage_DeferredTextureImageUsageParams {
        fn clone(&self) -> Self { *self }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkImage_LegacyBitmapMode {
        kRO_LegacyBitmapMode = 0,
        kRW_LegacyBitmapMode = 1,
    }
    pub type SkImage_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkImage() {
        assert_eq!(::std::mem::size_of::<SkImage>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkImage>() , 8usize);
    }
    extern "C" {
        #[link_name =
              "?MakeRasterCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkPixmap@@@Z"]
        pub fn SkImage_MakeRasterCopy(arg1: *const root::SkPixmap)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name =
              "?MakeRasterData@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBUSkImageInfo@@V?$sk_sp@VSkData@@@@_K@Z"]
        pub fn SkImage_MakeRasterData(arg1: *const root::SkImage_Info,
                                      pixels: root::sk_sp<root::SkData>,
                                      rowBytes: usize)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Return a new Image referencing the specified pixels. These must remain valid and unchanged
     *  until the specified release-proc is called, indicating that Skia no longer has a reference
     *  to the pixels.
     *
     *  Returns NULL if the requested pixmap info is unsupported.
     */
        #[link_name =
              "?MakeFromRaster@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkPixmap@@P6AXPEBXPEAX@Z2@Z"]
        pub fn SkImage_MakeFromRaster(arg1: *const root::SkPixmap,
                                      arg2: root::SkImage_RasterReleaseProc,
                                      arg3: root::SkImage_ReleaseContext)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Construct a new image from the specified bitmap. If the bitmap is marked immutable, and
     *  its pixel memory is shareable, it may be shared instead of copied.
     */
        #[link_name =
              "?MakeFromBitmap@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkBitmap@@@Z"]
        pub fn SkImage_MakeFromBitmap(arg1: *const root::SkBitmap)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Construct a new SkImage based on the given ImageGenerator. Returns NULL on error.
     *  This function will always take ownership of the passed generator.
     *
     *  If a subset is specified, it must be contained within the generator's bounds.
     */
        #[link_name =
              "?MakeFromGenerator@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVSkImageGenerator@@PEBUSkIRect@@@Z"]
        pub fn SkImage_MakeFromGenerator(arg1: *mut root::SkImageGenerator,
                                         subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Construct a new SkImage based on the specified encoded data. Returns NULL on failure,
     *  which can mean that the format of the encoded data was not recognized/supported.
     *
     *  If a subset is specified, it must be contained within the encoded data's bounds.
     */
        #[link_name =
              "?MakeFromEncoded@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkData@@@@PEBUSkIRect@@@Z"]
        pub fn SkImage_MakeFromEncoded(encoded: root::sk_sp<root::SkData>,
                                       subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
    *  Create a new image from the specified descriptor. The underlying platform texture must stay
    *  valid and unaltered until the specified release-proc is invoked, indicating that Skia
    *  no longer is holding a reference to it.
    *
    *  Will return NULL if the specified descriptor is unsupported.
    */
        #[link_name =
              "?MakeFromTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@P6AXPEAX@Z4@Z"]
        pub fn SkImage_MakeFromTexture(arg1: *mut root::GrContext,
                                       arg2:
                                           *const root::GrBackendTextureDesc,
                                       arg3: root::SkAlphaType,
                                       arg4: root::sk_sp<root::SkColorSpace>,
                                       arg5: root::SkImage_TextureReleaseProc,
                                       arg6: root::SkImage_ReleaseContext)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Create a new image from the specified descriptor. Note - Skia will delete or recycle the
     *  texture when the image is released.
     *
     *  Will return NULL if the specified descriptor is unsupported.
     */
        #[link_name =
              "?MakeFromAdoptedTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkImage_MakeFromAdoptedTexture(arg1: *mut root::GrContext,
                                              arg2:
                                                  *const root::GrBackendTextureDesc,
                                              arg3: root::SkAlphaType,
                                              arg4:
                                                  root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Create a new image by copying the pixels from the specified y, u, v textures. The data
     *  from the textures is immediately ingested into the image and the textures can be modified or
     *  deleted after the function returns. The image will have the dimensions of the y texture.
     */
        #[link_name =
              "?MakeFromYUVTexturesCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@W4SkYUVColorSpace@@QEB_JQEBU?$SkTSize@H@@W4GrSurfaceOrigin@@V?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkImage_MakeFromYUVTexturesCopy(arg1: *mut root::GrContext,
                                               arg2: root::SkYUVColorSpace,
                                               yuvTextureHandles:
                                                   *mut root::GrBackendObject,
                                               yuvSizes: *mut root::SkISize,
                                               arg3: root::GrSurfaceOrigin,
                                               arg4:
                                                   root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Create a new image by copying the pixels from the specified y and uv textures. The data
     *  from the textures is immediately ingested into the image and the textures can be modified or
     *  deleted after the function returns. The image will have the dimensions of the y texture.
     */
        #[link_name =
              "?MakeFromNV12TexturesCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@W4SkYUVColorSpace@@QEB_JQEBU?$SkTSize@H@@W4GrSurfaceOrigin@@V?$sk_sp@VSkColorSpace@@@@@Z"]
        pub fn SkImage_MakeFromNV12TexturesCopy(arg1: *mut root::GrContext,
                                                arg2: root::SkYUVColorSpace,
                                                nv12TextureHandles:
                                                    *mut root::GrBackendObject,
                                                nv12Sizes: *mut root::SkISize,
                                                arg3: root::GrSurfaceOrigin,
                                                arg4:
                                                    root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name =
              "?MakeFromPicture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkPicture@@@@AEBU?$SkTSize@H@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
        pub fn SkImage_MakeFromPicture(arg1: root::sk_sp<root::SkPicture>,
                                       dimensions: *const root::SkISize,
                                       arg2: *const root::SkMatrix,
                                       arg3: *const root::SkPaint)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name =
              "?MakeTextureFromPixmap@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@AEBVSkPixmap@@W4SkBudgeted@@@Z"]
        pub fn SkImage_MakeTextureFromPixmap(arg1: *mut root::GrContext,
                                             arg2: *const root::SkPixmap,
                                             budgeted: root::SkBudgeted)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name = "?alphaType@SkImage@@QEBA?AW4SkAlphaType@@XZ"]
        pub fn SkImage_alphaType(this: *const root::SkImage)
         -> root::SkAlphaType;
    }
    extern "C" {
        /**
     *  Returns true fi the image will be drawn as a mask, with no intrinsic color of its own.
     */
        #[link_name = "?isAlphaOnly@SkImage@@QEBA_NXZ"]
        pub fn SkImage_isAlphaOnly(this: *const root::SkImage) -> bool;
    }
    extern "C" {
        /**
     * Extracts YUV planes from the SkImage and stores them in client-provided memory. The sizes
     * planes and rowBytes arrays are ordered [y, u, v].
     */
        #[link_name =
              "?readYUV8Planes@SkImage@@QEBA_NQEBU?$SkTSize@H@@QEBQEAXQEB_KW4SkYUVColorSpace@@@Z"]
        pub fn SkImage_readYUV8Planes(this: *const root::SkImage,
                                      arg1: *mut root::SkISize,
                                      planes:
                                          *mut *const ::std::os::raw::c_void,
                                      rowBytes: *mut usize,
                                      arg2: root::SkYUVColorSpace) -> bool;
    }
    extern "C" {
        #[link_name =
              "?makeShader@SkImage@@QEBA?AV?$sk_sp@VSkShader@@@@W4TileMode@SkShader@@0PEBVSkMatrix@@@Z"]
        pub fn SkImage_makeShader(this: *const root::SkImage,
                                  arg1: root::SkShader_TileMode,
                                  arg2: root::SkShader_TileMode,
                                  localMatrix: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader>;
    }
    extern "C" {
        /**
     *  If the image has direct access to its pixels (i.e. they are in local RAM)
     *  return true, and if not null, return in the pixmap parameter the info about the
     *  images pixels.
     *
     *  On failure, return false and ignore the pixmap parameter.
     */
        #[link_name = "?peekPixels@SkImage@@QEBA_NPEAVSkPixmap@@@Z"]
        pub fn SkImage_peekPixels(this: *const root::SkImage,
                                  pixmap: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Some images have to perform preliminary work in preparation for drawing. This can be
     *  decoding, uploading to a GPU, or other tasks. These happen automatically when an image
     *  is drawn, and often they are cached so that the cost is only paid the first time.
     *
     *  Preroll() can be called before drawing to try to perform this prepatory work ahead of time.
     *  For images that have no such work, this returns instantly. Others may do some thing to
     *  prepare their cache and then return.
     *
     *  If the image will drawn to a GPU-backed canvas or surface, pass the associated GrContext.
     *  If the image will be drawn to any other type of canvas or surface, pass null.
     */
        #[link_name = "?preroll@SkImage@@QEBAXPEAVGrContext@@@Z"]
        pub fn SkImage_preroll(this: *const root::SkImage,
                               arg1: *mut root::GrContext);
    }
    extern "C" {
        #[link_name = "?getTexture@SkImage@@QEBAPEAVGrTexture@@XZ"]
        pub fn SkImage_getTexture(this: *const root::SkImage)
         -> *mut root::GrTexture;
    }
    extern "C" {
        /**
     *  Returns true if the image is texture backed.
     */
        #[link_name = "?isTextureBacked@SkImage@@QEBA_NXZ"]
        pub fn SkImage_isTextureBacked(this: *const root::SkImage) -> bool;
    }
    extern "C" {
        /**
     *  Retrieves the backend API handle of the texture. If flushPendingGrContextIO then the
     *  GrContext will issue to the backend API any deferred IO operations on the texture before
     *  returning.
     */
        #[link_name = "?getTextureHandle@SkImage@@QEBA_J_N@Z"]
        pub fn SkImage_getTextureHandle(this: *const root::SkImage,
                                        flushPendingGrContextIO: bool)
         -> root::GrBackendObject;
    }
    extern "C" {
        /**
     *  Copy the pixels from the image into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (dstInfo). The image pixels are read
     *  starting at the specified (srcX,srcY) location.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the image. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the image bounds.
     *  - If the requested colortype/alphatype cannot be converted from the image's types.
     */
        #[link_name =
              "?readPixels@SkImage@@QEBA_NAEBUSkImageInfo@@PEAX_KHHW4CachingHint@1@@Z"]
        pub fn SkImage_readPixels(this: *const root::SkImage,
                                  dstInfo: *const root::SkImageInfo,
                                  dstPixels: *mut ::std::os::raw::c_void,
                                  dstRowBytes: usize,
                                  srcX: ::std::os::raw::c_int,
                                  srcY: ::std::os::raw::c_int,
                                  arg1: root::SkImage_CachingHint) -> bool;
    }
    extern "C" {
        #[link_name =
              "?readPixels@SkImage@@QEBA_NAEBVSkPixmap@@HHW4CachingHint@1@@Z"]
        pub fn SkImage_readPixels1(this: *const root::SkImage,
                                   dst: *const root::SkPixmap,
                                   srcX: ::std::os::raw::c_int,
                                   srcY: ::std::os::raw::c_int,
                                   arg1: root::SkImage_CachingHint) -> bool;
    }
    extern "C" {
        /**
     *  Copy the pixels from this image into the dst pixmap, converting as needed into dst's
     *  colortype/alphatype. If the conversion cannot be performed, false is returned.
     *
     *  If dst's dimensions differ from the src dimension, the image will be scaled, applying the
     *  specified filter-quality.
     */
        #[link_name =
              "?scalePixels@SkImage@@QEBA_NAEBVSkPixmap@@W4SkFilterQuality@@W4CachingHint@1@@Z"]
        pub fn SkImage_scalePixels(this: *const root::SkImage,
                                   dst: *const root::SkPixmap,
                                   arg1: root::SkFilterQuality,
                                   arg2: root::SkImage_CachingHint) -> bool;
    }
    extern "C" {
        /**
     *  Encode the image's pixels and return the result as a new SkData, which
     *  the caller must manage (i.e. call unref() when they are done).
     *
     *  If the image type cannot be encoded, or the requested encoder type is
     *  not supported, this will return NULL.
     *
     *  Note: this will attempt to encode the image's pixels in the specified format,
     *  even if the image returns a data from refEncoded(). That data will be ignored.
     */
        #[link_name =
              "?encode@SkImage@@QEBAPEAVSkData@@W4SkEncodedImageFormat@@H@Z"]
        pub fn SkImage_encode(this: *const root::SkImage,
                              arg1: root::SkEncodedImageFormat,
                              quality: ::std::os::raw::c_int)
         -> *mut root::SkData;
    }
    extern "C" {
        /**
     *  Encode the image and return the result as a caller-managed SkData.  This will
     *  attempt to reuse existing encoded data (as returned by refEncoded).
     *
     *  We defer to the SkPixelSerializer both for vetting existing encoded data
     *  (useEncodedData) and for encoding the image (encode) when no such data is
     *  present or is rejected by the serializer.
     *
     *  If not specified, we use a default serializer which 1) always accepts existing data
     *  (in any format) and 2) encodes to PNG.
     *
     *  If no compatible encoded data exists and encoding fails, this method will also
     *  fail (return NULL).
     */
        #[link_name =
              "?encode@SkImage@@QEBAPEAVSkData@@PEAVSkPixelSerializer@@@Z"]
        pub fn SkImage_encode1(this: *const root::SkImage,
                               arg1: *mut root::SkPixelSerializer)
         -> *mut root::SkData;
    }
    extern "C" {
        /**
     *  If the image already has its contents in encoded form (e.g. PNG or JPEG), return a ref
     *  to that data (which the caller must call unref() on). The caller is responsible for calling
     *  unref on the data when they are done.
     *
     *  If the image does not already has its contents in encoded form, return NULL.
     *
     *  Note: to force the image to return its contents as encoded data, try calling encode(...).
     */
        #[link_name = "?refEncoded@SkImage@@QEBAPEAVSkData@@XZ"]
        pub fn SkImage_refEncoded(this: *const root::SkImage)
         -> *mut root::SkData;
    }
    extern "C" {
        #[link_name = "?toString@SkImage@@QEBAPEBDPEAVSkString@@@Z"]
        pub fn SkImage_toString(this: *const root::SkImage,
                                arg1: *mut root::SkString)
         -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        /**
     *  Return a new image that is a subset of this image. The underlying implementation may
     *  share the pixels, or it may make a copy.
     *
     *  If subset does not intersect the bounds of this image, or the copy/share cannot be made,
     *  NULL will be returned.
     */
        #[link_name =
              "?makeSubset@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@AEBUSkIRect@@@Z"]
        pub fn SkImage_makeSubset(this: *const root::SkImage,
                                  subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Ensures that an image is backed by a texture (when GrContext is non-null). If no
     *  transformation is required, the returned image may be the same as this image. If the this
     *  image is from a different GrContext, this will fail.
     */
        #[link_name =
              "?makeTextureImage@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@@Z"]
        pub fn SkImage_makeTextureImage(this: *const root::SkImage,
                                        arg1: *mut root::GrContext)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     * If the image is texture-backed this will make a raster copy of it (or nullptr if reading back
     * the pixels fails). Otherwise, it returns the original image.
     */
        #[link_name =
              "?makeNonTextureImage@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@XZ"]
        pub fn SkImage_makeNonTextureImage(this: *const root::SkImage)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Apply a given image filter to this image, and return the filtered result.
     *
     *  The subset represents the active portion of this image. The return value is similarly an
     *  SkImage, with an active subset (outSubset). This is usually used with texture-backed
     *  images, where the texture may be approx-match and thus larger than the required size.
     *
     *  clipBounds constrains the device-space extent of the image which may be produced to the
     *  given rect.
     *
     *  offset is the amount to translate the resulting image relative to the src when it is drawn.
     *  This is an out-param.
     *
     *  If the result image cannot be created, or the result would be transparent black, null
     *  is returned, in which case the offset and outSubset parameters should be ignored by the
     *  caller.
     */
        #[link_name =
              "?makeWithFilter@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@PEBVSkImageFilter@@AEBUSkIRect@@1PEAU4@PEAUSkIPoint@@@Z"]
        pub fn SkImage_makeWithFilter(this: *const root::SkImage,
                                      filter: *const root::SkImageFilter,
                                      subset: *const root::SkIRect,
                                      clipBounds: *const root::SkIRect,
                                      outSubset: *mut root::SkIRect,
                                      offset: *mut root::SkIPoint)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     * This method allows clients to capture the data necessary to turn a SkImage into a texture-
     * backed image. If the original image is codec-backed this will decode into a format optimized
     * for the context represented by the proxy. This method is thread safe with respect to the
     * GrContext whence the proxy came. Clients allocate and manage the storage of the deferred
     * texture data and control its lifetime. No cleanup is required, thus it is safe to simply free
     * the memory out from under the data.
     *
     * The same method is used both for getting the size necessary for pre-uploaded texture data
     * and for retrieving the data. The params array represents the set of draws over which to
     * optimize the pre-upload data.
     *
     * When called with a null buffer this returns the size that the client must allocate in order
     * to create deferred texture data for this image (or zero if this is an inappropriate
     * candidate). The buffer allocated by the client should be 8 byte aligned.
     *
     * When buffer is not null this fills in the deferred texture data for this image in the
     * provided buffer (assuming this is an appropriate candidate image and the buffer is
     * appropriately aligned). Upon success the size written is returned, otherwise 0.
     *
     * dstColorSpace is the color space of the surface where this texture will ultimately be used.
     * If the method determines that mip-maps are needed, this helps determine the correct strategy
     * for building them (gamma-correct or not).
     */
        #[link_name =
              "?getDeferredTextureImageData@SkImage@@QEBA_KAEBVGrContextThreadSafeProxy@@QEBUDeferredTextureImageUsageParams@1@HPEAXPEAVSkColorSpace@@@Z"]
        pub fn SkImage_getDeferredTextureImageData(this: *const root::SkImage,
                                                   arg1:
                                                       *const root::GrContextThreadSafeProxy,
                                                   arg2:
                                                       *const root::SkImage_DeferredTextureImageUsageParams,
                                                   paramCnt:
                                                       ::std::os::raw::c_int,
                                                   buffer:
                                                       *mut ::std::os::raw::c_void,
                                                   dstColorSpace:
                                                       *mut root::SkColorSpace)
         -> usize;
    }
    extern "C" {
        /**
     * Returns a texture-backed image from data produced in SkImage::getDeferredTextureImageData.
     * The context must be the context that provided the proxy passed to
     * getDeferredTextureImageData.
     */
        #[link_name =
              "?MakeFromDeferredTextureImageData@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrContext@@PEBXW4SkBudgeted@@@Z"]
        pub fn SkImage_MakeFromDeferredTextureImageData(arg1:
                                                            *mut root::GrContext,
                                                        arg2:
                                                            *const ::std::os::raw::c_void,
                                                        arg3:
                                                            root::SkBudgeted)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Attempt to create a bitmap with the same pixels as the image. The result will always be
     *  a raster-backed bitmap (texture-backed bitmaps are DEPRECATED, and not supported here).
     *
     *  If the mode is kRO (read-only), the resulting bitmap will be marked as immutable.
     *
     *  On succcess, returns true. On failure, returns false and the bitmap parameter will be reset
     *  to empty.
     */
        #[link_name =
              "?asLegacyBitmap@SkImage@@QEBA_NPEAVSkBitmap@@W4LegacyBitmapMode@1@@Z"]
        pub fn SkImage_asLegacyBitmap(this: *const root::SkImage,
                                      arg1: *mut root::SkBitmap,
                                      arg2: root::SkImage_LegacyBitmapMode)
         -> bool;
    }
    extern "C" {
        /**
     *  Returns true if the image is backed by an image-generator or other src that creates
     *  (and caches) its pixels / texture on-demand.
     */
        #[link_name = "?isLazyGenerated@SkImage@@QEBA_NXZ"]
        pub fn SkImage_isLazyGenerated(this: *const root::SkImage) -> bool;
    }
    extern "C" {
        #[link_name = "??0SkImage@@IEAA@HHI@Z"]
        pub fn SkImage_SkImage(this: *mut root::SkImage,
                               width: ::std::os::raw::c_int,
                               height: ::std::os::raw::c_int, uniqueID: u32);
    }
    impl SkImage {
        #[inline]
        pub unsafe fn MakeRasterCopy(arg1: *const root::SkPixmap)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeRasterCopy(arg1)
        }
        #[inline]
        pub unsafe fn MakeRasterData(arg1: *const root::SkImage_Info,
                                     pixels: root::sk_sp<root::SkData>,
                                     rowBytes: usize)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeRasterData(arg1, pixels, rowBytes)
        }
        #[inline]
        pub unsafe fn MakeFromRaster(arg1: *const root::SkPixmap,
                                     arg2: root::SkImage_RasterReleaseProc,
                                     arg3: root::SkImage_ReleaseContext)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromRaster(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn MakeFromBitmap(arg1: *const root::SkBitmap)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromBitmap(arg1)
        }
        #[inline]
        pub unsafe fn MakeFromGenerator(arg1: *mut root::SkImageGenerator,
                                        subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromGenerator(arg1, subset)
        }
        #[inline]
        pub unsafe fn MakeFromEncoded(encoded: root::sk_sp<root::SkData>,
                                      subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromEncoded(encoded, subset)
        }
        #[inline]
        pub unsafe fn MakeFromTexture(arg1: *mut root::GrContext,
                                      arg2: *const root::GrBackendTextureDesc,
                                      arg3: root::SkAlphaType,
                                      arg4: root::sk_sp<root::SkColorSpace>,
                                      arg5: root::SkImage_TextureReleaseProc,
                                      arg6: root::SkImage_ReleaseContext)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromTexture(arg1, arg2, arg3, arg4, arg5, arg6)
        }
        #[inline]
        pub unsafe fn MakeFromAdoptedTexture(arg1: *mut root::GrContext,
                                             arg2:
                                                 *const root::GrBackendTextureDesc,
                                             arg3: root::SkAlphaType,
                                             arg4:
                                                 root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromAdoptedTexture(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromYUVTexturesCopy(arg1: *mut root::GrContext,
                                              arg2: root::SkYUVColorSpace,
                                              yuvTextureHandles:
                                                  *mut root::GrBackendObject,
                                              yuvSizes: *mut root::SkISize,
                                              arg3: root::GrSurfaceOrigin,
                                              arg4:
                                                  root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromYUVTexturesCopy(arg1, arg2, yuvTextureHandles,
                                            yuvSizes, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromNV12TexturesCopy(arg1: *mut root::GrContext,
                                               arg2: root::SkYUVColorSpace,
                                               nv12TextureHandles:
                                                   *mut root::GrBackendObject,
                                               nv12Sizes: *mut root::SkISize,
                                               arg3: root::GrSurfaceOrigin,
                                               arg4:
                                                   root::sk_sp<root::SkColorSpace>)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromNV12TexturesCopy(arg1, arg2, nv12TextureHandles,
                                             nv12Sizes, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromPicture(arg1: root::sk_sp<root::SkPicture>,
                                      dimensions: *const root::SkISize,
                                      arg2: *const root::SkMatrix,
                                      arg3: *const root::SkPaint)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromPicture(arg1, dimensions, arg2, arg3)
        }
        #[inline]
        pub unsafe fn MakeTextureFromPixmap(arg1: *mut root::GrContext,
                                            arg2: *const root::SkPixmap,
                                            budgeted: root::SkBudgeted)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeTextureFromPixmap(arg1, arg2, budgeted)
        }
        #[inline]
        pub unsafe fn alphaType(&self) -> root::SkAlphaType {
            SkImage_alphaType(&*self)
        }
        #[inline]
        pub unsafe fn isAlphaOnly(&self) -> bool {
            SkImage_isAlphaOnly(&*self)
        }
        #[inline]
        pub unsafe fn readYUV8Planes(&self, arg1: *mut root::SkISize,
                                     planes:
                                         *mut *const ::std::os::raw::c_void,
                                     rowBytes: *mut usize,
                                     arg2: root::SkYUVColorSpace) -> bool {
            SkImage_readYUV8Planes(&*self, arg1, planes, rowBytes, arg2)
        }
        #[inline]
        pub unsafe fn makeShader(&self, arg1: root::SkShader_TileMode,
                                 arg2: root::SkShader_TileMode,
                                 localMatrix: *const root::SkMatrix)
         -> root::sk_sp<root::SkShader> {
            SkImage_makeShader(&*self, arg1, arg2, localMatrix)
        }
        #[inline]
        pub unsafe fn peekPixels(&self, pixmap: *mut root::SkPixmap) -> bool {
            SkImage_peekPixels(&*self, pixmap)
        }
        #[inline]
        pub unsafe fn preroll(&self, arg1: *mut root::GrContext) {
            SkImage_preroll(&*self, arg1)
        }
        #[inline]
        pub unsafe fn getTexture(&self) -> *mut root::GrTexture {
            SkImage_getTexture(&*self)
        }
        #[inline]
        pub unsafe fn isTextureBacked(&self) -> bool {
            SkImage_isTextureBacked(&*self)
        }
        #[inline]
        pub unsafe fn getTextureHandle(&self, flushPendingGrContextIO: bool)
         -> root::GrBackendObject {
            SkImage_getTextureHandle(&*self, flushPendingGrContextIO)
        }
        #[inline]
        pub unsafe fn readPixels(&self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int,
                                 arg1: root::SkImage_CachingHint) -> bool {
            SkImage_readPixels(&*self, dstInfo, dstPixels, dstRowBytes, srcX,
                               srcY, arg1)
        }
        #[inline]
        pub unsafe fn readPixels1(&self, dst: *const root::SkPixmap,
                                  srcX: ::std::os::raw::c_int,
                                  srcY: ::std::os::raw::c_int,
                                  arg1: root::SkImage_CachingHint) -> bool {
            SkImage_readPixels1(&*self, dst, srcX, srcY, arg1)
        }
        #[inline]
        pub unsafe fn scalePixels(&self, dst: *const root::SkPixmap,
                                  arg1: root::SkFilterQuality,
                                  arg2: root::SkImage_CachingHint) -> bool {
            SkImage_scalePixels(&*self, dst, arg1, arg2)
        }
        #[inline]
        pub unsafe fn encode(&self, arg1: root::SkEncodedImageFormat,
                             quality: ::std::os::raw::c_int)
         -> *mut root::SkData {
            SkImage_encode(&*self, arg1, quality)
        }
        #[inline]
        pub unsafe fn encode1(&self, arg1: *mut root::SkPixelSerializer)
         -> *mut root::SkData {
            SkImage_encode1(&*self, arg1)
        }
        #[inline]
        pub unsafe fn refEncoded(&self) -> *mut root::SkData {
            SkImage_refEncoded(&*self)
        }
        #[inline]
        pub unsafe fn toString(&self, arg1: *mut root::SkString)
         -> *const ::std::os::raw::c_char {
            SkImage_toString(&*self, arg1)
        }
        #[inline]
        pub unsafe fn makeSubset(&self, subset: *const root::SkIRect)
         -> root::sk_sp<root::SkImage> {
            SkImage_makeSubset(&*self, subset)
        }
        #[inline]
        pub unsafe fn makeTextureImage(&self, arg1: *mut root::GrContext)
         -> root::sk_sp<root::SkImage> {
            SkImage_makeTextureImage(&*self, arg1)
        }
        #[inline]
        pub unsafe fn makeNonTextureImage(&self)
         -> root::sk_sp<root::SkImage> {
            SkImage_makeNonTextureImage(&*self)
        }
        #[inline]
        pub unsafe fn makeWithFilter(&self,
                                     filter: *const root::SkImageFilter,
                                     subset: *const root::SkIRect,
                                     clipBounds: *const root::SkIRect,
                                     outSubset: *mut root::SkIRect,
                                     offset: *mut root::SkIPoint)
         -> root::sk_sp<root::SkImage> {
            SkImage_makeWithFilter(&*self, filter, subset, clipBounds,
                                   outSubset, offset)
        }
        #[inline]
        pub unsafe fn getDeferredTextureImageData(&self,
                                                  arg1:
                                                      *const root::GrContextThreadSafeProxy,
                                                  arg2:
                                                      *const root::SkImage_DeferredTextureImageUsageParams,
                                                  paramCnt:
                                                      ::std::os::raw::c_int,
                                                  buffer:
                                                      *mut ::std::os::raw::c_void,
                                                  dstColorSpace:
                                                      *mut root::SkColorSpace)
         -> usize {
            SkImage_getDeferredTextureImageData(&*self, arg1, arg2, paramCnt,
                                                buffer, dstColorSpace)
        }
        #[inline]
        pub unsafe fn MakeFromDeferredTextureImageData(arg1:
                                                           *mut root::GrContext,
                                                       arg2:
                                                           *const ::std::os::raw::c_void,
                                                       arg3: root::SkBudgeted)
         -> root::sk_sp<root::SkImage> {
            SkImage_MakeFromDeferredTextureImageData(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn asLegacyBitmap(&self, arg1: *mut root::SkBitmap,
                                     arg2: root::SkImage_LegacyBitmapMode)
         -> bool {
            SkImage_asLegacyBitmap(&*self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn isLazyGenerated(&self) -> bool {
            SkImage_isLazyGenerated(&*self)
        }
        #[inline]
        pub unsafe fn new(width: ::std::os::raw::c_int,
                          height: ::std::os::raw::c_int, uniqueID: u32)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkImage_SkImage(&mut __bindgen_tmp, width, height, uniqueID);
            __bindgen_tmp
        }
    }
    /** \class SkPicture

    An SkPicture records drawing commands made to a canvas to be played back at a later time.
    This base class handles serialization and a few other miscellany.
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPicture {
        pub _base: root::SkRefCnt,
        pub fUniqueID: u32,
    }
    /**
     *  Function signature defining a function that sets up an SkBitmap from encoded data. On
     *  success, the SkBitmap should have its Config, width, height, rowBytes and pixelref set.
     *  If the installed pixelref has decoded the data into pixels, then the src buffer need not be
     *  copied. If the pixelref defers the actual decode until its lockPixels() is called, then it
     *  must make a copy of the src buffer.
     *  @param src Encoded data.
     *  @param length Size of the encoded data, in bytes.
     *  @param dst SkBitmap to install the pixel ref on.
     *  @param bool Whether or not a pixel ref was successfully installed.
     */
    pub type SkPicture_InstallPixelRefProc =
        ::std::option::Option<unsafe extern "C" fn(src:
                                                       *const ::std::os::raw::c_void,
                                                   length: usize,
                                                   dst: *mut root::SkBitmap)
                                  -> bool>;
    #[repr(C)]
    pub struct SkPicture_AbortCallback__bindgen_vtable {
    }
    /**
    *  Subclasses of this can be passed to playback(). During the playback
    *  of the picture, this callback will periodically be invoked. If its
    *  abort() returns true, then picture playback will be interrupted.
    *
    *  The resulting drawing is undefined, as there is no guarantee how often the
    *  callback will be invoked. If the abort happens inside some level of nested
    *  calls to save(), restore will automatically be called to return the state
    *  to the same level it was before the playback call was made.
    */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPicture_AbortCallback {
        pub vtable_: *const SkPicture_AbortCallback__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkPicture_AbortCallback() {
        assert_eq!(::std::mem::size_of::<SkPicture_AbortCallback>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkPicture_AbortCallback>() ,
                   8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPicture_DeletionMessage {
        pub fUniqueID: i32,
    }
    #[test]
    fn bindgen_test_layout_SkPicture_DeletionMessage() {
        assert_eq!(::std::mem::size_of::<SkPicture_DeletionMessage>() ,
                   4usize);
        assert_eq!(::std::mem::align_of::<SkPicture_DeletionMessage>() ,
                   4usize);
    }
    impl Clone for SkPicture_DeletionMessage {
        fn clone(&self) -> Self { *self }
    }
    pub const SkPicture_MIN_PICTURE_VERSION: u32 = 35;
    pub const SkPicture_CURRENT_PICTURE_VERSION: u32 = 51;
    #[test]
    fn bindgen_test_layout_SkPicture() {
        assert_eq!(::std::mem::size_of::<SkPicture>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkPicture>() , 8usize);
    }
    extern "C" {
        /**
     *  Recreate a picture that was serialized into a stream.
     *
     *  Any serialized images in the stream will be passed the image-deserializer, or if that is
     *  null, to the default deserializer that will call SkImage::MakeFromEncoded().
     */
        #[link_name =
              "?MakeFromStream@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEAVSkStream@@PEAVSkImageDeserializer@@@Z"]
        pub fn SkPicture_MakeFromStream(arg1: *mut root::SkStream,
                                        arg2: *mut root::SkImageDeserializer)
         -> root::sk_sp<root::SkPicture>;
    }
    extern "C" {
        #[link_name =
              "?MakeFromStream@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEAVSkStream@@@Z"]
        pub fn SkPicture_MakeFromStream1(arg1: *mut root::SkStream)
         -> root::sk_sp<root::SkPicture>;
    }
    extern "C" {
        #[link_name =
              "?MakeFromData@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEBX_KPEAVSkImageDeserializer@@@Z"]
        pub fn SkPicture_MakeFromData(data: *const ::std::os::raw::c_void,
                                      size: usize,
                                      arg1: *mut root::SkImageDeserializer)
         -> root::sk_sp<root::SkPicture>;
    }
    extern "C" {
        #[link_name =
              "?MakeFromData@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEBVSkData@@PEAVSkImageDeserializer@@@Z"]
        pub fn SkPicture_MakeFromData1(data: *const root::SkData,
                                       arg1: *mut root::SkImageDeserializer)
         -> root::sk_sp<root::SkPicture>;
    }
    extern "C" {
        /**
     *  Recreate a picture that was serialized into a buffer. If the creation requires bitmap
     *  decoding, the decoder must be set on the SkReadBuffer parameter by calling
     *  SkReadBuffer::setBitmapDecoder() before calling SkPicture::CreateFromBuffer().
     *  @param SkReadBuffer Serialized picture data.
     *  @return A new SkPicture representing the serialized data, or NULL if the buffer is
     *          invalid.
     */
        #[link_name =
              "?MakeFromBuffer@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@AEAVSkReadBuffer@@@Z"]
        pub fn SkPicture_MakeFromBuffer(arg1: *mut root::SkReadBuffer)
         -> root::sk_sp<root::SkPicture>;
    }
    extern "C" {
        /** Returns a non-zero value unique among all pictures. */
        #[link_name = "?uniqueID@SkPicture@@QEBAIXZ"]
        pub fn SkPicture_uniqueID(this: *const root::SkPicture) -> u32;
    }
    extern "C" {
        /**
     *  Serialize the picture to SkData. If non nullptr, pixel-serializer will be used to
     *  customize how images reference by the picture are serialized/compressed.
     */
        #[link_name =
              "?serialize@SkPicture@@QEBA?AV?$sk_sp@VSkData@@@@PEAVSkPixelSerializer@@@Z"]
        pub fn SkPicture_serialize(this: *const root::SkPicture,
                                   arg1: *mut root::SkPixelSerializer)
         -> root::sk_sp<root::SkData>;
    }
    extern "C" {
        /**
     *  Serialize to a stream. If non nullptr, pixel-serializer will be used to
     *  customize how images reference by the picture are serialized/compressed.
     */
        #[link_name =
              "?serialize@SkPicture@@QEBAXPEAVSkWStream@@PEAVSkPixelSerializer@@@Z"]
        pub fn SkPicture_serialize1(this: *const root::SkPicture,
                                    arg1: *mut root::SkWStream,
                                    arg2: *mut root::SkPixelSerializer);
    }
    extern "C" {
        /**
     *  Serialize to a buffer.
     */
        #[link_name = "?flatten@SkPicture@@QEBAXAEAVSkWriteBuffer@@@Z"]
        pub fn SkPicture_flatten(this: *const root::SkPicture,
                                 arg1: *mut root::SkWriteBuffer);
    }
    extern "C" {
        /** Return true if the SkStream/Buffer represents a serialized picture, and
        fills out SkPictInfo. After this function returns, the data source is not
        rewound so it will have to be manually reset before passing to
        CreateFromStream or CreateFromBuffer. Note, CreateFromStream and
        CreateFromBuffer perform this check internally so these entry points are
        intended for stand alone tools.
        If false is returned, SkPictInfo is unmodified.
    */
        #[link_name =
              "?InternalOnly_StreamIsSKP@SkPicture@@SA_NPEAVSkStream@@PEAUSkPictInfo@@@Z"]
        pub fn SkPicture_InternalOnly_StreamIsSKP(arg1: *mut root::SkStream,
                                                  arg2: *mut root::SkPictInfo)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?InternalOnly_BufferIsSKP@SkPicture@@SA_NPEAVSkReadBuffer@@PEAUSkPictInfo@@@Z"]
        pub fn SkPicture_InternalOnly_BufferIsSKP(arg1:
                                                      *mut root::SkReadBuffer,
                                                  arg2: *mut root::SkPictInfo)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?SetPictureIOSecurityPrecautionsEnabled_Dangerous@SkPicture@@SAX_N@Z"]
        pub fn SkPicture_SetPictureIOSecurityPrecautionsEnabled_Dangerous(set:
                                                                              bool);
    }
    extern "C" {
        #[link_name =
              "?PictureIOSecurityPrecautionsEnabled@SkPicture@@SA_NXZ"]
        pub fn SkPicture_PictureIOSecurityPrecautionsEnabled() -> bool;
    }
    impl SkPicture {
        #[inline]
        pub unsafe fn MakeFromStream(arg1: *mut root::SkStream,
                                     arg2: *mut root::SkImageDeserializer)
         -> root::sk_sp<root::SkPicture> {
            SkPicture_MakeFromStream(arg1, arg2)
        }
        #[inline]
        pub unsafe fn MakeFromStream1(arg1: *mut root::SkStream)
         -> root::sk_sp<root::SkPicture> {
            SkPicture_MakeFromStream1(arg1)
        }
        #[inline]
        pub unsafe fn MakeFromData(data: *const ::std::os::raw::c_void,
                                   size: usize,
                                   arg1: *mut root::SkImageDeserializer)
         -> root::sk_sp<root::SkPicture> {
            SkPicture_MakeFromData(data, size, arg1)
        }
        #[inline]
        pub unsafe fn MakeFromData1(data: *const root::SkData,
                                    arg1: *mut root::SkImageDeserializer)
         -> root::sk_sp<root::SkPicture> {
            SkPicture_MakeFromData1(data, arg1)
        }
        #[inline]
        pub unsafe fn MakeFromBuffer(arg1: *mut root::SkReadBuffer)
         -> root::sk_sp<root::SkPicture> {
            SkPicture_MakeFromBuffer(arg1)
        }
        #[inline]
        pub unsafe fn uniqueID(&self) -> u32 { SkPicture_uniqueID(&*self) }
        #[inline]
        pub unsafe fn serialize(&self, arg1: *mut root::SkPixelSerializer)
         -> root::sk_sp<root::SkData> {
            SkPicture_serialize(&*self, arg1)
        }
        #[inline]
        pub unsafe fn serialize1(&self, arg1: *mut root::SkWStream,
                                 arg2: *mut root::SkPixelSerializer) {
            SkPicture_serialize1(&*self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn flatten(&self, arg1: *mut root::SkWriteBuffer) {
            SkPicture_flatten(&*self, arg1)
        }
        #[inline]
        pub unsafe fn InternalOnly_StreamIsSKP(arg1: *mut root::SkStream,
                                               arg2: *mut root::SkPictInfo)
         -> bool {
            SkPicture_InternalOnly_StreamIsSKP(arg1, arg2)
        }
        #[inline]
        pub unsafe fn InternalOnly_BufferIsSKP(arg1: *mut root::SkReadBuffer,
                                               arg2: *mut root::SkPictInfo)
         -> bool {
            SkPicture_InternalOnly_BufferIsSKP(arg1, arg2)
        }
        #[inline]
        pub unsafe fn SetPictureIOSecurityPrecautionsEnabled_Dangerous(set:
                                                                           bool) {
            SkPicture_SetPictureIOSecurityPrecautionsEnabled_Dangerous(set)
        }
        #[inline]
        pub unsafe fn PictureIOSecurityPrecautionsEnabled() -> bool {
            SkPicture_PictureIOSecurityPrecautionsEnabled()
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRasterPipeline {
        pub _address: u8,
    }
    impl Clone for SkRasterPipeline {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrContext {
        pub _address: u8,
    }
    impl Clone for GrContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrFragmentProcessor {
        pub _address: u8,
    }
    impl Clone for GrFragmentProcessor {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_17() {
        assert_eq!(::std::mem::size_of::<root::std::unique_ptr<root::SkCanvas,
                                            root::std::default_delete<root::SkCanvas>>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::std::unique_ptr<root::SkCanvas,
                                             root::std::default_delete<root::SkCanvas>>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_18() {
        assert_eq!(::std::mem::size_of::<root::sk_sp<root::SkSurface>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::sk_sp<root::SkSurface>>() ,
                   8usize);
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkClipOp {
        kDifference_SkClipOp = 0,
        kIntersect_SkClipOp = 1,
        kUnion_SkClipOp = 2,
        kXOR_SkClipOp = 3,
        kReverseDifference_SkClipOp = 4,
        kReplace_SkClipOp = 5,
    }
    #[repr(C)]
    pub struct SkCanvas__bindgen_vtable {
    }
    /** \class SkCanvas

    A Canvas encapsulates all of the state about drawing into a device (bitmap).
    This includes a reference to the device itself, and a stack of matrix/clip
    values. For any given draw call (e.g. drawRect), the geometry of the object
    being drawn is transformed by the concatenation of all the matrices in the
    stack. The transformed geometry is clipped by the intersection of all of
    the clips in the stack.

    While the Canvas holds the state of the drawing device, the state (style)
    of the object being drawn is held by the Paint, which is provided as a
    parameter to each of the draw() methods. The Paint holds attributes such as
    color, typeface, textSize, strokeWidth, shader (e.g. gradients, patterns),
    etc.
*/
    #[repr(C)]
    pub struct SkCanvas {
        pub vtable_: *const SkCanvas__bindgen_vtable,
        pub fClipStack: root::sk_sp<root::SkClipStack>,
        pub fMCStack: root::SkDeque,
        pub fMCRec: *mut root::SkCanvas_MCRec,
        pub fMCRecStorage: [isize; 512usize],
        pub fDeviceCMStorage: [isize; 22usize],
        pub fProps: root::SkSurfaceProps,
        pub fSaveCount: ::std::os::raw::c_int,
        pub fMetaData: *mut root::SkMetaData,
        pub fSurfaceBase: *mut root::SkSurface_Base,
        pub fDeviceCMDirty: bool,
        /**
     *  Keep track of the device clip bounds and if the matrix is scale-translate.  This allows
     *  us to do a fast quick reject in the common case.
     */
        pub fIsScaleTranslate: bool,
        pub fDeviceClipBounds: root::SkRect,
        pub fAllowSoftClip: bool,
        pub fAllowSimplifyClip: bool,
        pub fConservativeRasterClip: bool,
    }
    pub const SkCanvas_PrivateSaveLayerFlags_kDontClipToLayer_PrivateSaveLayerFlag:
              root::SkCanvas_PrivateSaveLayerFlags =
        SkCanvas_PrivateSaveLayerFlags(-2147483648);
    impl ::std::ops::BitOr<root::SkCanvas_PrivateSaveLayerFlags> for
     root::SkCanvas_PrivateSaveLayerFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkCanvas_PrivateSaveLayerFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkCanvas_PrivateSaveLayerFlags(pub i32);
    pub const SkCanvas_kIsOpaque_SaveLayerFlag: root::SkCanvas__bindgen_ty_1 =
        SkCanvas__bindgen_ty_1::kIsOpaque_SaveLayerFlag;
    pub const SkCanvas_kPreserveLCDText_SaveLayerFlag:
              root::SkCanvas__bindgen_ty_1 =
        SkCanvas__bindgen_ty_1::kPreserveLCDText_SaveLayerFlag;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas__bindgen_ty_1 {
        kIsOpaque_SaveLayerFlag = 1,
        kPreserveLCDText_SaveLayerFlag = 2,
    }
    pub type SkCanvas_SaveLayerFlags = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkCanvas_SaveLayerRec {
        pub fBounds: *const root::SkRect,
        pub fPaint: *const root::SkPaint,
        pub fBackdrop: *const root::SkImageFilter,
        pub fSaveLayerFlags: root::SkCanvas_SaveLayerFlags,
    }
    #[test]
    fn bindgen_test_layout_SkCanvas_SaveLayerRec() {
        assert_eq!(::std::mem::size_of::<SkCanvas_SaveLayerRec>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkCanvas_SaveLayerRec>() , 8usize);
    }
    impl Clone for SkCanvas_SaveLayerRec {
        fn clone(&self) -> Self { *self }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_PointMode {
        kPoints_PointMode = 0,
        kLines_PointMode = 1,
        kPolygon_PointMode = 2,
    }
    #[repr(i32)]
    /**
     *  Controls the behavior at the edge of the src-rect, when specified in drawImageRect,
     *  trading off speed for exactness.
     *
     *  When filtering is enabled (in the Paint), skia may need to sample in a neighborhood around
     *  the pixels in the image. If there is a src-rect specified, it is intended to restrict the
     *  pixels that will be read. However, for performance reasons, some implementations may slow
     *  down if they cannot read 1-pixel past the src-rect boundary at times.
     *
     *  This enum allows the caller to specify if such a 1-pixel "slop" will be visually acceptable.
     *  If it is, the caller should pass kFast, and it may result in a faster draw. If the src-rect
     *  must be strictly respected, the caller should pass kStrict.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_SrcRectConstraint {
        kStrict_SrcRectConstraint = 0,
        kFast_SrcRectConstraint = 1,
    }
    /**
     *  Specifies coordinates to divide a bitmap into (xCount*yCount) rects.
     *
     *  If the lattice divs or bounds are invalid, the entire lattice
     *  struct will be ignored on the draw call.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkCanvas_Lattice {
        pub fXDivs: *const ::std::os::raw::c_int,
        pub fYDivs: *const ::std::os::raw::c_int,
        pub fFlags: *const root::SkCanvas_Lattice_Flags,
        pub fXCount: ::std::os::raw::c_int,
        pub fYCount: ::std::os::raw::c_int,
        pub fBounds: *const root::SkIRect,
    }
    pub const SkCanvas_Lattice_Flags_kTransparent_Flags:
              root::SkCanvas_Lattice_Flags =
        SkCanvas_Lattice_Flags(1);
    impl ::std::ops::BitOr<root::SkCanvas_Lattice_Flags> for
     root::SkCanvas_Lattice_Flags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkCanvas_Lattice_Flags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkCanvas_Lattice_Flags(pub u8);
    #[test]
    fn bindgen_test_layout_SkCanvas_Lattice() {
        assert_eq!(::std::mem::size_of::<SkCanvas_Lattice>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkCanvas_Lattice>() , 8usize);
    }
    impl Clone for SkCanvas_Lattice {
        fn clone(&self) -> Self { *self }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_VertexMode {
        kTriangles_VertexMode = 0,
        kTriangleStrip_VertexMode = 1,
        kTriangleFan_VertexMode = 2,
    }
    pub type SkCanvas_ClipVisitor = root::SkCanvasClipVisitor;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_SaveLayerStrategy {
        kFullLayer_SaveLayerStrategy = 0,
        kNoLayer_SaveLayerStrategy = 1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_ClipEdgeStyle {
        kHard_ClipEdgeStyle = 0,
        kSoft_ClipEdgeStyle = 1,
    }
    /** After calling saveLayer(), there can be any number of devices that make
     up the top-most drawing area. LayerIter can be used to iterate through
     those devices. Note that the iterator is only valid until the next API
     call made on the canvas. Ownership of all pointers in the iterator stays
     with the canvas, so none of them should be modified or deleted.
     */
    #[repr(C)]
    pub struct SkCanvas_LayerIter {
        pub fStorage: [isize; 32usize],
        pub fImpl: *mut root::SkCanvas_LayerIter_SkDrawIter,
        pub fDefaultPaint: root::SkPaint,
        pub fDone: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkCanvas_LayerIter_SkDrawIter {
        pub _address: u8,
    }
    impl Clone for SkCanvas_LayerIter_SkDrawIter {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_SkCanvas_LayerIter() {
        assert_eq!(::std::mem::size_of::<SkCanvas_LayerIter>() , 368usize);
        assert_eq!(::std::mem::align_of::<SkCanvas_LayerIter>() , 8usize);
    }
    extern "C" {
        /** Cycle to the next device */
        #[link_name = "?next@LayerIter@SkCanvas@@QEAAXXZ"]
        pub fn SkCanvas_LayerIter_next(this: *mut root::SkCanvas_LayerIter);
    }
    extern "C" {
        #[link_name = "?device@LayerIter@SkCanvas@@QEBAPEAVSkBaseDevice@@XZ"]
        pub fn SkCanvas_LayerIter_device(this:
                                             *const root::SkCanvas_LayerIter)
         -> *mut root::SkBaseDevice;
    }
    extern "C" {
        #[link_name = "?matrix@LayerIter@SkCanvas@@QEBAAEBVSkMatrix@@XZ"]
        pub fn SkCanvas_LayerIter_matrix(this:
                                             *const root::SkCanvas_LayerIter)
         -> *const root::SkMatrix;
    }
    extern "C" {
        #[link_name = "?clip@LayerIter@SkCanvas@@QEBAAEBVSkRasterClip@@XZ"]
        pub fn SkCanvas_LayerIter_clip(this: *const root::SkCanvas_LayerIter)
         -> *const root::SkRasterClip;
    }
    extern "C" {
        #[link_name = "?paint@LayerIter@SkCanvas@@QEBAAEBVSkPaint@@XZ"]
        pub fn SkCanvas_LayerIter_paint(this: *const root::SkCanvas_LayerIter)
         -> *const root::SkPaint;
    }
    extern "C" {
        #[link_name = "?x@LayerIter@SkCanvas@@QEBAHXZ"]
        pub fn SkCanvas_LayerIter_x(this: *const root::SkCanvas_LayerIter)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "?y@LayerIter@SkCanvas@@QEBAHXZ"]
        pub fn SkCanvas_LayerIter_y(this: *const root::SkCanvas_LayerIter)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Initialize iterator with canvas, and set values for 1st device */
        #[link_name = "??0LayerIter@SkCanvas@@QEAA@PEAV1@@Z"]
        pub fn SkCanvas_LayerIter_LayerIter(this:
                                                *mut root::SkCanvas_LayerIter,
                                            arg1: *mut root::SkCanvas);
    }
    impl SkCanvas_LayerIter {
        #[inline]
        pub unsafe fn next(&mut self) { SkCanvas_LayerIter_next(&mut *self) }
        #[inline]
        pub unsafe fn device(&self) -> *mut root::SkBaseDevice {
            SkCanvas_LayerIter_device(&*self)
        }
        #[inline]
        pub unsafe fn matrix(&self) -> *const root::SkMatrix {
            SkCanvas_LayerIter_matrix(&*self)
        }
        #[inline]
        pub unsafe fn clip(&self) -> *const root::SkRasterClip {
            SkCanvas_LayerIter_clip(&*self)
        }
        #[inline]
        pub unsafe fn paint(&self) -> *const root::SkPaint {
            SkCanvas_LayerIter_paint(&*self)
        }
        #[inline]
        pub unsafe fn x(&self) -> ::std::os::raw::c_int {
            SkCanvas_LayerIter_x(&*self)
        }
        #[inline]
        pub unsafe fn y(&self) -> ::std::os::raw::c_int {
            SkCanvas_LayerIter_y(&*self)
        }
        #[inline]
        pub unsafe fn new(arg1: *mut root::SkCanvas) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkCanvas_LayerIter_LayerIter(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas_ShaderOverrideOpacity {
        kNone_ShaderOverrideOpacity = 0,
        kOpaque_ShaderOverrideOpacity = 1,
        kNotOpaque_ShaderOverrideOpacity = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkCanvas_MCRec {
        pub _address: u8,
    }
    impl Clone for SkCanvas_MCRec {
        fn clone(&self) -> Self { *self }
    }
    pub const SkCanvas_kMCRecSize: root::SkCanvas__bindgen_ty_2 =
        SkCanvas__bindgen_ty_2::kMCRecSize;
    pub const SkCanvas_kMCRecCount: root::SkCanvas__bindgen_ty_2 =
        SkCanvas__bindgen_ty_2::kMCRecCount;
    pub const SkCanvas_kDeviceCMSize: root::SkCanvas__bindgen_ty_2 =
        SkCanvas__bindgen_ty_2::kDeviceCMSize;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkCanvas__bindgen_ty_2 {
        kMCRecSize = 128,
        kMCRecCount = 32,
        kDeviceCMSize = 176,
    }
    pub const SkCanvas_InitFlags_kDefault_InitFlags: root::SkCanvas_InitFlags
              =
        SkCanvas_InitFlags(0);
    pub const SkCanvas_InitFlags_kConservativeRasterClip_InitFlag:
              root::SkCanvas_InitFlags =
        SkCanvas_InitFlags(1);
    impl ::std::ops::BitOr<root::SkCanvas_InitFlags> for
     root::SkCanvas_InitFlags {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            SkCanvas_InitFlags(self.0 | other.0)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct SkCanvas_InitFlags(pub i32);
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkCanvas_AutoValidateClip {
        pub fCanvas: *const root::SkCanvas,
    }
    #[test]
    fn bindgen_test_layout_SkCanvas_AutoValidateClip() {
        assert_eq!(::std::mem::size_of::<SkCanvas_AutoValidateClip>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<SkCanvas_AutoValidateClip>() ,
                   8usize);
    }
    pub type SkCanvas_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkCanvas() {
        assert_eq!(::std::mem::size_of::<SkCanvas>() , 4408usize);
        assert_eq!(::std::mem::align_of::<SkCanvas>() , 8usize);
    }
    extern "C" {
        /**
     *  Attempt to allocate raster canvas, matching the ImageInfo, that will draw directly into the
     *  specified pixels. To access the pixels after drawing to them, the caller should call
     *  flush() or call peekPixels(...).
     *
     *  On failure, return NULL. This can fail for several reasons:
     *  1. invalid ImageInfo (e.g. negative dimensions)
     *  2. unsupported ImageInfo for a canvas
     *      - kUnknown_SkColorType, kIndex_8_SkColorType
     *      - kUnknown_SkAlphaType
     *      - this list is not complete, so others may also be unsupported
     *
     *  Note: it is valid to request a supported ImageInfo, but with zero
     *  dimensions.
     */
        #[link_name =
              "?MakeRasterDirect@SkCanvas@@SA?AV?$unique_ptr@VSkCanvas@@U?$default_delete@VSkCanvas@@@std@@@std@@AEBUSkImageInfo@@PEAX_K@Z"]
        pub fn SkCanvas_MakeRasterDirect(arg1: *const root::SkImageInfo,
                                         arg2: *mut ::std::os::raw::c_void,
                                         arg3: usize)
         ->
             root::std::unique_ptr<root::SkCanvas,
                                   root::std::default_delete<root::SkCanvas>>;
    }
    extern "C" {
        #[link_name = "?getMetaData@SkCanvas@@QEAAAEAVSkMetaData@@XZ"]
        pub fn SkCanvas_getMetaData(this: *mut root::SkCanvas)
         -> *mut root::SkMetaData;
    }
    extern "C" {
        /**
     *  Return ImageInfo for this canvas. If the canvas is not backed by pixels
     *  (cpu or gpu), then the info's ColorType will be kUnknown_SkColorType.
     */
        #[link_name = "?imageInfo@SkCanvas@@QEBA?AUSkImageInfo@@XZ"]
        pub fn SkCanvas_imageInfo(this: *const root::SkCanvas)
         -> root::SkImageInfo;
    }
    extern "C" {
        /**
     *  If the canvas is backed by pixels (cpu or gpu), this writes a copy of the SurfaceProps
     *  for the canvas to the location supplied by the caller, and returns true. Otherwise,
     *  return false and leave the supplied props unchanged.
     */
        #[link_name = "?getProps@SkCanvas@@QEBA_NPEAVSkSurfaceProps@@@Z"]
        pub fn SkCanvas_getProps(this: *const root::SkCanvas,
                                 arg1: *mut root::SkSurfaceProps) -> bool;
    }
    extern "C" {
        /**
     *  Trigger the immediate execution of all pending draw operations. For the GPU
     *  backend this will resolve all rendering to the GPU surface backing the
     *  SkSurface that owns this canvas.
     */
        #[link_name = "?flush@SkCanvas@@QEAAXXZ"]
        pub fn SkCanvas_flush(this: *mut root::SkCanvas);
    }
    extern "C" {
        #[link_name = "?getDevice@SkCanvas@@IEBAPEAVSkBaseDevice@@XZ"]
        pub fn SkCanvas_getDevice(this: *const root::SkCanvas)
         -> *mut root::SkBaseDevice;
    }
    extern "C" {
        /**
     *  Create a new surface matching the specified info, one that attempts to
     *  be maximally compatible when used with this canvas. If there is no matching Surface type,
     *  NULL is returned.
     *
     *  If surfaceprops is specified, those are passed to the new surface, otherwise the new surface
     *  inherits the properties of the surface that owns this canvas. If this canvas has no parent
     *  surface, then the new surface is created with default properties.
     */
        #[link_name =
              "?makeSurface@SkCanvas@@QEAA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkCanvas_makeSurface(this: *mut root::SkCanvas,
                                    arg1: *const root::SkImageInfo,
                                    arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     * Return the GPU context of the device that is associated with the canvas.
     * For a canvas with non-GPU device, NULL is returned.
     */
        #[link_name = "?getGrContext@SkCanvas@@QEAAPEAVGrContext@@XZ"]
        pub fn SkCanvas_getGrContext(this: *mut root::SkCanvas)
         -> *mut root::GrContext;
    }
    extern "C" {
        /**
     *  If the canvas has writable pixels in its top layer (and is not recording to a picture
     *  or other non-raster target) and has direct access to its pixels (i.e. they are in
     *  local RAM) return the address of those pixels, and if not null,
     *  return the ImageInfo, rowBytes and origin. The returned address is only valid
     *  while the canvas object is in scope and unchanged. Any API calls made on
     *  canvas (or its parent surface if any) will invalidate the
     *  returned address (and associated information).
     *
     *  On failure, returns NULL and the info, rowBytes, and origin parameters are ignored.
     */
        #[link_name =
              "?accessTopLayerPixels@SkCanvas@@QEAAPEAXPEAUSkImageInfo@@PEA_KPEAUSkIPoint@@@Z"]
        pub fn SkCanvas_accessTopLayerPixels(this: *mut root::SkCanvas,
                                             info: *mut root::SkImageInfo,
                                             rowBytes: *mut usize,
                                             origin: *mut root::SkIPoint)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        /**
     *  If the canvas has readable pixels in its base layer (and is not recording to a picture
     *  or other non-raster target) and has direct access to its pixels (i.e. they are in
     *  local RAM) return true, and if not null, return in the pixmap parameter information about
     *  the pixels. The pixmap's pixel address is only valid
     *  while the canvas object is in scope and unchanged. Any API calls made on
     *  canvas (or its parent surface if any) will invalidate the pixel address
     *  (and associated information).
     *
     *  On failure, returns false and the pixmap parameter will be ignored.
     */
        #[link_name = "?peekPixels@SkCanvas@@QEAA_NPEAVSkPixmap@@@Z"]
        pub fn SkCanvas_peekPixels(this: *mut root::SkCanvas,
                                   arg1: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Copy the pixels from the base-layer into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (SkImageInfo). The base-layer pixels are read
     *  starting at the specified (srcX,srcY) location in the coordinate system of the base-layer.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the base-layer. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the base-layer bounds.
     *  - If the requested colortype/alphatype cannot be converted from the base-layer's types.
     *  - If this canvas is not backed by pixels (e.g. picture or PDF)
     */
        #[link_name =
              "?readPixels@SkCanvas@@QEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
        pub fn SkCanvas_readPixels(this: *mut root::SkCanvas,
                                   dstInfo: *const root::SkImageInfo,
                                   dstPixels: *mut ::std::os::raw::c_void,
                                   dstRowBytes: usize,
                                   srcX: ::std::os::raw::c_int,
                                   srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Helper for calling readPixels(info). This call will check if bitmap has been allocated.
     *  If not, it will attempt to call allocPixels(). If this fails, it will return false. If not,
     *  it calls through to readPixels(info) and returns its result.
     */
        #[link_name = "?readPixels@SkCanvas@@QEAA_NPEAVSkBitmap@@HH@Z"]
        pub fn SkCanvas_readPixels1(this: *mut root::SkCanvas,
                                    bitmap: *mut root::SkBitmap,
                                    srcX: ::std::os::raw::c_int,
                                    srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Helper for allocating pixels and then calling readPixels(info). The bitmap is resized
     *  to the intersection of srcRect and the base-layer bounds. On success, pixels will be
     *  allocated in bitmap and true returned. On failure, false is returned and bitmap will be
     *  set to empty.
     */
        #[link_name =
              "?readPixels@SkCanvas@@QEAA_NAEBUSkIRect@@PEAVSkBitmap@@@Z"]
        pub fn SkCanvas_readPixels2(this: *mut root::SkCanvas,
                                    srcRect: *const root::SkIRect,
                                    bitmap: *mut root::SkBitmap) -> bool;
    }
    extern "C" {
        /**
     *  This method affects the pixels in the base-layer, and operates in pixel coordinates,
     *  ignoring the matrix and clip.
     *
     *  The specified ImageInfo and (x,y) offset specifies a rectangle: target.
     *
     *      target.setXYWH(x, y, info.width(), info.height());
     *
     *  Target is intersected with the bounds of the base-layer. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size), the "src" specified by info+pixels+rowBytes
     *  and the "dst" by the canvas' backend. Replace the dst pixels with the corresponding src
     *  pixels, performing any colortype/alphatype transformations needed (in the case where the
     *  src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If the src colortype/alphatype cannot be converted to the canvas' types
     *  - If this canvas is not backed by pixels (e.g. picture or PDF)
     */
        #[link_name =
              "?writePixels@SkCanvas@@QEAA_NAEBUSkImageInfo@@PEBX_KHH@Z"]
        pub fn SkCanvas_writePixels(this: *mut root::SkCanvas,
                                    arg1: *const root::SkImageInfo,
                                    pixels: *const ::std::os::raw::c_void,
                                    rowBytes: usize, x: ::std::os::raw::c_int,
                                    y: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Helper for calling writePixels(info) by passing its pixels and rowbytes. If the bitmap
     *  is just wrapping a texture, returns false and does nothing.
     */
        #[link_name = "?writePixels@SkCanvas@@QEAA_NAEBVSkBitmap@@HH@Z"]
        pub fn SkCanvas_writePixels1(this: *mut root::SkCanvas,
                                     bitmap: *const root::SkBitmap,
                                     x: ::std::os::raw::c_int,
                                     y: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /** This call saves the current matrix, clip, and drawFilter, and pushes a
        copy onto a private stack. Subsequent calls to translate, scale,
        rotate, skew, concat or clipRect, clipPath, and setDrawFilter all
        operate on this copy.
        When the balancing call to restore() is made, the previous matrix, clip,
        and drawFilter are restored.

        @return The value to pass to restoreToCount() to balance this save()
    */
        #[link_name = "?save@SkCanvas@@QEAAHXZ"]
        pub fn SkCanvas_save(this: *mut root::SkCanvas)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** This behaves the same as save(), but in addition it allocates an
        offscreen bitmap. All drawing calls are directed there, and only when
        the balancing call to restore() is made is that offscreen transfered to
        the canvas (or the previous layer).
        @param bounds (may be null) This rect, if non-null, is used as a hint to
                      limit the size of the offscreen, and thus drawing may be
                      clipped to it, though that clipping is not guaranteed to
                      happen. If exact clipping is desired, use clipRect().
        @param paint (may be null) This is copied, and is applied to the
                     offscreen when restore() is called
        @return The value to pass to restoreToCount() to balance this save()
    */
        #[link_name = "?saveLayer@SkCanvas@@QEAAHPEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_saveLayer(this: *mut root::SkCanvas,
                                  bounds: *const root::SkRect,
                                  paint: *const root::SkPaint)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /**
     *  Temporary name.
     *  Will allow any requests for LCD text to be respected, so the caller must be careful to
     *  only draw on top of opaque sections of the layer to get good results.
     */
        #[link_name =
              "?saveLayerPreserveLCDTextRequests@SkCanvas@@QEAAHPEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_saveLayerPreserveLCDTextRequests(this:
                                                             *mut root::SkCanvas,
                                                         bounds:
                                                             *const root::SkRect,
                                                         paint:
                                                             *const root::SkPaint)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** This behaves the same as save(), but in addition it allocates an
        offscreen bitmap. All drawing calls are directed there, and only when
        the balancing call to restore() is made is that offscreen transfered to
        the canvas (or the previous layer).
        @param bounds (may be null) This rect, if non-null, is used as a hint to
                      limit the size of the offscreen, and thus drawing may be
                      clipped to it, though that clipping is not guaranteed to
                      happen. If exact clipping is desired, use clipRect().
        @param alpha  This is applied to the offscreen when restore() is called.
        @return The value to pass to restoreToCount() to balance this save()
    */
        #[link_name = "?saveLayerAlpha@SkCanvas@@QEAAHPEBUSkRect@@I@Z"]
        pub fn SkCanvas_saveLayerAlpha(this: *mut root::SkCanvas,
                                       bounds: *const root::SkRect,
                                       alpha: root::U8CPU)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "?saveLayer@SkCanvas@@QEAAHAEBUSaveLayerRec@1@@Z"]
        pub fn SkCanvas_saveLayer1(this: *mut root::SkCanvas,
                                   arg1: *const root::SkCanvas_SaveLayerRec)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** This call balances a previous call to save(), and is used to remove all
        modifications to the matrix/clip/drawFilter state since the last save
        call.
        It is an error to call restore() more times than save() was called.
    */
        #[link_name = "?restore@SkCanvas@@QEAAXXZ"]
        pub fn SkCanvas_restore(this: *mut root::SkCanvas);
    }
    extern "C" {
        /** Returns the number of matrix/clip states on the SkCanvas' private stack.
        This will equal # save() calls - # restore() calls + 1. The save count on
        a new canvas is 1.
    */
        #[link_name = "?getSaveCount@SkCanvas@@QEBAHXZ"]
        pub fn SkCanvas_getSaveCount(this: *const root::SkCanvas)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /** Efficient way to pop any calls to save() that happened after the save
        count reached saveCount. It is an error for saveCount to be greater than
        getSaveCount(). To pop all the way back to the initial matrix/clip context
        pass saveCount == 1.
        @param saveCount    The number of save() levels to restore from
    */
        #[link_name = "?restoreToCount@SkCanvas@@QEAAXH@Z"]
        pub fn SkCanvas_restoreToCount(this: *mut root::SkCanvas,
                                       saveCount: ::std::os::raw::c_int);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified translation
        @param dx   The distance to translate in X
        @param dy   The distance to translate in Y
    */
        #[link_name = "?translate@SkCanvas@@QEAAXMM@Z"]
        pub fn SkCanvas_translate(this: *mut root::SkCanvas,
                                  dx: root::SkScalar, dy: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified scale.
        @param sx   The amount to scale in X
        @param sy   The amount to scale in Y
    */
        #[link_name = "?scale@SkCanvas@@QEAAXMM@Z"]
        pub fn SkCanvas_scale(this: *mut root::SkCanvas, sx: root::SkScalar,
                              sy: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified rotation about the origin.
        @param degrees  The amount to rotate, in degrees
    */
        #[link_name = "?rotate@SkCanvas@@QEAAXM@Z"]
        pub fn SkCanvas_rotate(this: *mut root::SkCanvas,
                               degrees: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified rotation about a given point.
        @param degrees  The amount to rotate, in degrees
        @param px  The x coordinate of the point to rotate about.
        @param py  The y coordinate of the point to rotate about.
    */
        #[link_name = "?rotate@SkCanvas@@QEAAXMMM@Z"]
        pub fn SkCanvas_rotate1(this: *mut root::SkCanvas,
                                degrees: root::SkScalar, px: root::SkScalar,
                                py: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified skew.
        @param sx   The amount to skew in X
        @param sy   The amount to skew in Y
    */
        #[link_name = "?skew@SkCanvas@@QEAAXMM@Z"]
        pub fn SkCanvas_skew(this: *mut root::SkCanvas, sx: root::SkScalar,
                             sy: root::SkScalar);
    }
    extern "C" {
        /** Preconcat the current matrix with the specified matrix.
        @param matrix   The matrix to preconcatenate with the current matrix
    */
        #[link_name = "?concat@SkCanvas@@QEAAXAEBVSkMatrix@@@Z"]
        pub fn SkCanvas_concat(this: *mut root::SkCanvas,
                               matrix: *const root::SkMatrix);
    }
    extern "C" {
        /** Replace the current matrix with a copy of the specified matrix.
        @param matrix The matrix that will be copied into the current matrix.
    */
        #[link_name = "?setMatrix@SkCanvas@@QEAAXAEBVSkMatrix@@@Z"]
        pub fn SkCanvas_setMatrix(this: *mut root::SkCanvas,
                                  matrix: *const root::SkMatrix);
    }
    extern "C" {
        /** Helper for setMatrix(identity). Sets the current matrix to identity.
    */
        #[link_name = "?resetMatrix@SkCanvas@@QEAAXXZ"]
        pub fn SkCanvas_resetMatrix(this: *mut root::SkCanvas);
    }
    extern "C" {
        /**
     *  Modify the current clip with the specified rectangle.
     *  @param rect The rect to combine with the current clip
     *  @param op The region op to apply to the current clip
     *  @param doAntiAlias true if the clip should be antialiased
     */
        #[link_name = "?clipRect@SkCanvas@@QEAAXAEBUSkRect@@W4SkClipOp@@_N@Z"]
        pub fn SkCanvas_clipRect(this: *mut root::SkCanvas,
                                 rect: *const root::SkRect,
                                 arg1: root::SkClipOp, doAntiAlias: bool);
    }
    extern "C" {
        /**
     *  Modify the current clip with the specified SkRRect.
     *  @param rrect The rrect to combine with the current clip
     *  @param op The region op to apply to the current clip
     *  @param doAntiAlias true if the clip should be antialiased
     */
        #[link_name =
              "?clipRRect@SkCanvas@@QEAAXAEBVSkRRect@@W4SkClipOp@@_N@Z"]
        pub fn SkCanvas_clipRRect(this: *mut root::SkCanvas,
                                  rrect: *const root::SkRRect,
                                  op: root::SkClipOp, doAntiAlias: bool);
    }
    extern "C" {
        /**
     *  Modify the current clip with the specified path.
     *  @param path The path to combine with the current clip
     *  @param op The region op to apply to the current clip
     *  @param doAntiAlias true if the clip should be antialiased
     */
        #[link_name = "?clipPath@SkCanvas@@QEAAXAEBVSkPath@@W4SkClipOp@@_N@Z"]
        pub fn SkCanvas_clipPath(this: *mut root::SkCanvas,
                                 path: *const root::SkPath,
                                 op: root::SkClipOp, doAntiAlias: bool);
    }
    extern "C" {
        /** Modify the current clip with the specified region. Note that unlike
        clipRect() and clipPath() which transform their arguments by the current
        matrix, clipRegion() assumes its argument is already in device
        coordinates, and so no transformation is performed.
        @param deviceRgn    The region to apply to the current clip
        @param op The region op to apply to the current clip
    */
        #[link_name =
              "?clipRegion@SkCanvas@@QEAAXAEBVSkRegion@@W4SkClipOp@@@Z"]
        pub fn SkCanvas_clipRegion(this: *mut root::SkCanvas,
                                   deviceRgn: *const root::SkRegion,
                                   op: root::SkClipOp);
    }
    extern "C" {
        /** Return true if the specified rectangle, after being transformed by the
        current matrix, would lie completely outside of the current clip. Call
        this to check if an area you intend to draw into is clipped out (and
        therefore you can skip making the draw calls).
        @param rect the rect to compare with the current clip
        @return true if the rect (transformed by the canvas' matrix) does not
                     intersect with the canvas' clip
    */
        #[link_name = "?quickReject@SkCanvas@@QEBA_NAEBUSkRect@@@Z"]
        pub fn SkCanvas_quickReject(this: *const root::SkCanvas,
                                    rect: *const root::SkRect) -> bool;
    }
    extern "C" {
        /** Return true if the specified path, after being transformed by the
        current matrix, would lie completely outside of the current clip. Call
        this to check if an area you intend to draw into is clipped out (and
        therefore you can skip making the draw calls). Note, for speed it may
        return false even if the path itself might not intersect the clip
        (i.e. the bounds of the path intersects, but the path does not).
        @param path The path to compare with the current clip
        @return true if the path (transformed by the canvas' matrix) does not
                     intersect with the canvas' clip
    */
        #[link_name = "?quickReject@SkCanvas@@QEBA_NAEBVSkPath@@@Z"]
        pub fn SkCanvas_quickReject1(this: *const root::SkCanvas,
                                     path: *const root::SkPath) -> bool;
    }
    extern "C" {
        /** Fill the entire canvas' bitmap (restricted to the current clip) with the
        specified ARGB color, using the specified mode.
        @param a    the alpha component (0..255) of the color to fill the canvas
        @param r    the red component (0..255) of the color to fill the canvas
        @param g    the green component (0..255) of the color to fill the canvas
        @param b    the blue component (0..255) of the color to fill the canvas
        @param mode the mode to apply the color in (defaults to SrcOver)
    */
        #[link_name = "?drawARGB@SkCanvas@@QEAAXIIIIW4SkBlendMode@@@Z"]
        pub fn SkCanvas_drawARGB(this: *mut root::SkCanvas, a: root::U8CPU,
                                 r: root::U8CPU, g: root::U8CPU,
                                 b: root::U8CPU, mode: root::SkBlendMode);
    }
    extern "C" {
        /** Fill the entire canvas' bitmap (restricted to the current clip) with the
        specified color and mode.
        @param color    the color to draw with
        @param mode the mode to apply the color in (defaults to SrcOver)
    */
        #[link_name = "?drawColor@SkCanvas@@QEAAXIW4SkBlendMode@@@Z"]
        pub fn SkCanvas_drawColor(this: *mut root::SkCanvas,
                                  color: root::SkColor,
                                  mode: root::SkBlendMode);
    }
    extern "C" {
        /**
     *  Fill the entire canvas (restricted to the current clip) with the
     *  specified paint.
     *  @param paint    The paint used to fill the canvas
     */
        #[link_name = "?drawPaint@SkCanvas@@QEAAXAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPaint(this: *mut root::SkCanvas,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw a series of points, interpreted based on the PointMode mode. For
        all modes, the count parameter is interpreted as the total number of
        points. For kLine mode, count/2 line segments are drawn.
        For kPoint mode, each point is drawn centered at its coordinate, and its
        size is specified by the paint's stroke-width. It draws as a square,
        unless the paint's cap-type is round, in which the points are drawn as
        circles.
        For kLine mode, each pair of points is drawn as a line segment,
        respecting the paint's settings for cap/join/width.
        For kPolygon mode, the entire array is drawn as a series of connected
        line segments.
        Note that, while similar, kLine and kPolygon modes draw slightly
        differently than the equivalent path built with a series of moveto,
        lineto calls, in that the path will draw all of its contours at once,
        with no interactions if contours intersect each other (think XOR
        xfermode). drawPoints always draws each element one at a time.
        @param mode     PointMode specifying how to draw the array of points.
        @param count    The number of points in the array
        @param pts      Array of points to draw
        @param paint    The paint used to draw the points
    */
        #[link_name =
              "?drawPoints@SkCanvas@@QEAAXW4PointMode@1@_KQEBUSkPoint@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPoints(this: *mut root::SkCanvas,
                                   mode: root::SkCanvas_PointMode,
                                   count: usize, pts: *const root::SkPoint,
                                   paint: *const root::SkPaint);
    }
    extern "C" {
        /** Helper method for drawing a single point. See drawPoints() for a more
        details.
    */
        #[link_name = "?drawPoint@SkCanvas@@QEAAXMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPoint(this: *mut root::SkCanvas,
                                  x: root::SkScalar, y: root::SkScalar,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draws a single pixel in the specified color.
        @param x        The X coordinate of which pixel to draw
        @param y        The Y coordiante of which pixel to draw
        @param color    The color to draw
    */
        #[link_name = "?drawPoint@SkCanvas@@QEAAXMMI@Z"]
        pub fn SkCanvas_drawPoint1(this: *mut root::SkCanvas,
                                   x: root::SkScalar, y: root::SkScalar,
                                   color: root::SkColor);
    }
    extern "C" {
        /** Draw a line segment with the specified start and stop x,y coordinates,
        using the specified paint. NOTE: since a line is always "framed", the
        paint's Style is ignored.
        @param x0    The x-coordinate of the start point of the line
        @param y0    The y-coordinate of the start point of the line
        @param x1    The x-coordinate of the end point of the line
        @param y1    The y-coordinate of the end point of the line
        @param paint The paint used to draw the line
    */
        #[link_name = "?drawLine@SkCanvas@@QEAAXMMMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawLine(this: *mut root::SkCanvas,
                                 x0: root::SkScalar, y0: root::SkScalar,
                                 x1: root::SkScalar, y1: root::SkScalar,
                                 paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified rectangle using the specified paint. The rectangle
        will be filled or stroked based on the Style in the paint.
        @param rect     The rect to be drawn
        @param paint    The paint used to draw the rect
    */
        #[link_name = "?drawRect@SkCanvas@@QEAAXAEBUSkRect@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRect(this: *mut root::SkCanvas,
                                 rect: *const root::SkRect,
                                 paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified rectangle using the specified paint. The rectangle
        will be filled or framed based on the Style in the paint.
        @param left     The left side of the rectangle to be drawn
        @param top      The top side of the rectangle to be drawn
        @param right    The right side of the rectangle to be drawn
        @param bottom   The bottom side of the rectangle to be drawn
        @param paint    The paint used to draw the rect
    */
        #[link_name = "?drawRectCoords@SkCanvas@@QEAAXMMMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRectCoords(this: *mut root::SkCanvas,
                                       left: root::SkScalar,
                                       top: root::SkScalar,
                                       right: root::SkScalar,
                                       bottom: root::SkScalar,
                                       paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the outline of the specified region using the specified paint.
        @param region   The region to be drawn
        @param paint    The paint used to draw the region
    */
        #[link_name =
              "?drawRegion@SkCanvas@@QEAAXAEBVSkRegion@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRegion(this: *mut root::SkCanvas,
                                   region: *const root::SkRegion,
                                   paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified oval using the specified paint. The oval will be
        filled or framed based on the Style in the paint.
        @param oval     The rectangle bounds of the oval to be drawn
        @param paint    The paint used to draw the oval
    */
        #[link_name = "?drawOval@SkCanvas@@QEAAXAEBUSkRect@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawOval(this: *mut root::SkCanvas,
                                 oval: *const root::SkRect,
                                 arg1: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the specified RRect using the specified paint The rrect will be filled or stroked
     *  based on the Style in the paint.
     *
     *  @param rrect    The round-rect to draw
     *  @param paint    The paint used to draw the round-rect
     */
        #[link_name =
              "?drawRRect@SkCanvas@@QEAAXAEBVSkRRect@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRRect(this: *mut root::SkCanvas,
                                  rrect: *const root::SkRRect,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the annulus formed by the outer and inner rrects. The results
     *  are undefined if the outer does not contain the inner.
     */
        #[link_name =
              "?drawDRRect@SkCanvas@@QEAAXAEBVSkRRect@@0AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawDRRect(this: *mut root::SkCanvas,
                                   outer: *const root::SkRRect,
                                   inner: *const root::SkRRect,
                                   arg1: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified circle using the specified paint. If radius is <= 0,
        then nothing will be drawn. The circle will be filled
        or framed based on the Style in the paint.
        @param cx       The x-coordinate of the center of the cirle to be drawn
        @param cy       The y-coordinate of the center of the cirle to be drawn
        @param radius   The radius of the cirle to be drawn
        @param paint    The paint used to draw the circle
    */
        #[link_name = "?drawCircle@SkCanvas@@QEAAXMMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawCircle(this: *mut root::SkCanvas,
                                   cx: root::SkScalar, cy: root::SkScalar,
                                   radius: root::SkScalar,
                                   paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified arc, which will be scaled to fit inside the
        specified oval. Sweep angles are not treated as modulo 360 and thus can
        exceed a full sweep of the oval. Note that this differs slightly from
        SkPath::arcTo, which treats the sweep angle mod 360. If the oval is empty
        or the sweep angle is zero nothing is drawn. If useCenter is true the oval
        center is inserted into the implied path before the arc and the path is
        closed back to the, center forming a wedge. Otherwise, the implied path
        contains just the arc and is not closed.
        @param oval The bounds of oval used to define the shape of the arc.
        @param startAngle Starting angle (in degrees) where the arc begins
        @param sweepAngle Sweep angle (in degrees) measured clockwise.
        @param useCenter true means include the center of the oval.
        @param paint    The paint used to draw the arc
    */
        #[link_name =
              "?drawArc@SkCanvas@@QEAAXAEBUSkRect@@MM_NAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawArc(this: *mut root::SkCanvas,
                                oval: *const root::SkRect,
                                startAngle: root::SkScalar,
                                sweepAngle: root::SkScalar, useCenter: bool,
                                paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified round-rect using the specified paint. The round-rect
        will be filled or framed based on the Style in the paint.
        @param rect     The rectangular bounds of the roundRect to be drawn
        @param rx       The x-radius of the oval used to round the corners
        @param ry       The y-radius of the oval used to round the corners
        @param paint    The paint used to draw the roundRect
    */
        #[link_name =
              "?drawRoundRect@SkCanvas@@QEAAXAEBUSkRect@@MMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawRoundRect(this: *mut root::SkCanvas,
                                      rect: *const root::SkRect,
                                      rx: root::SkScalar, ry: root::SkScalar,
                                      paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified path using the specified paint. The path will be
        filled or framed based on the Style in the paint.
        @param path     The path to be drawn
        @param paint    The paint used to draw the path
    */
        #[link_name = "?drawPath@SkCanvas@@QEAAXAEBVSkPath@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPath(this: *mut root::SkCanvas,
                                 path: *const root::SkPath,
                                 paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified image, with its top/left corner at (x,y), using the
        specified paint, transformed by the current matrix.

        @param image    The image to be drawn
        @param left     The position of the left side of the image being drawn
        @param top      The position of the top side of the image being drawn
        @param paint    The paint used to draw the image, or NULL
     */
        #[link_name =
              "?drawImage@SkCanvas@@QEAAXPEBVSkImage@@MMPEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawImage(this: *mut root::SkCanvas,
                                  image: *const root::SkImage,
                                  left: root::SkScalar, top: root::SkScalar,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified image, scaling and translating so that it fills the specified
     *  dst rect. If the src rect is non-null, only that subset of the image is transformed
     *  and drawn.
     *
     *  @param image      The image to be drawn
     *  @param src        Optional: specify the subset of the image to be drawn
     *  @param dst        The destination rectangle where the scaled/translated
     *                    image will be drawn
     *  @param paint      The paint used to draw the image, or NULL
     *  @param constraint Control the tradeoff between speed and exactness w.r.t. the src-rect.
     */
        #[link_name =
              "?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkRect@@1PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawImageRect(this: *mut root::SkCanvas,
                                      image: *const root::SkImage,
                                      src: *const root::SkRect,
                                      dst: *const root::SkRect,
                                      paint: *const root::SkPaint,
                                      constraint:
                                          root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawImageRect1(this: *mut root::SkCanvas,
                                       image: *const root::SkImage,
                                       isrc: *const root::SkIRect,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint,
                                       arg1:
                                           root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawImageRect2(this: *mut root::SkCanvas,
                                       image: *const root::SkImage,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint,
                                       arg1:
                                           root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        /**
     *  Draw the image stretched differentially to fit into dst.
     *  center is a rect within the image, and logically divides the image
     *  into 9 sections (3x3). For example, if the middle pixel of a [5x5]
     *  image is the "center", then the center-rect should be [2, 2, 3, 3].
     *
     *  If the dst is >= the image size, then...
     *  - The 4 corners are not stretched at all.
     *  - The sides are stretched in only one axis.
     *  - The center is stretched in both axes.
     * Else, for each axis where dst < image,
     *  - The corners shrink proportionally
     *  - The sides (along the shrink axis) and center are not drawn
     */
        #[link_name =
              "?drawImageNine@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawImageNine(this: *mut root::SkCanvas,
                                      arg1: *const root::SkImage,
                                      center: *const root::SkIRect,
                                      dst: *const root::SkRect,
                                      paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified bitmap, with its top/left corner at (x,y), using the
        specified paint, transformed by the current matrix. Note: if the paint
        contains a maskfilter that generates a mask which extends beyond the
        bitmap's original width/height, then the bitmap will be drawn as if it
        were in a Shader with CLAMP mode. Thus the color outside of the original
        width/height will be the edge color replicated.

        If a shader is present on the paint it will be ignored, except in the
        case where the bitmap is kAlpha_8_SkColorType. In that case, the color is
        generated by the shader.

        @param bitmap   The bitmap to be drawn
        @param left     The position of the left side of the bitmap being drawn
        @param top      The position of the top side of the bitmap being drawn
        @param paint    The paint used to draw the bitmap, or NULL
    */
        #[link_name =
              "?drawBitmap@SkCanvas@@QEAAXAEBVSkBitmap@@MMPEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawBitmap(this: *mut root::SkCanvas,
                                   bitmap: *const root::SkBitmap,
                                   left: root::SkScalar, top: root::SkScalar,
                                   paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the specified bitmap, scaling and translating so that it fills the specified
     *  dst rect. If the src rect is non-null, only that subset of the bitmap is transformed
     *  and drawn.
     *
     *  @param bitmap     The bitmap to be drawn
     *  @param src        Optional: specify the subset of the bitmap to be drawn
     *  @param dst        The destination rectangle where the scaled/translated
     *                    bitmap will be drawn
     *  @param paint      The paint used to draw the bitmap, or NULL
     *  @param constraint Control the tradeoff between speed and exactness w.r.t. the src-rect.
     */
        #[link_name =
              "?drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkRect@@1PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawBitmapRect(this: *mut root::SkCanvas,
                                       bitmap: *const root::SkBitmap,
                                       src: *const root::SkRect,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint,
                                       arg1:
                                           root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawBitmapRect1(this: *mut root::SkCanvas,
                                        bitmap: *const root::SkBitmap,
                                        isrc: *const root::SkIRect,
                                        dst: *const root::SkRect,
                                        paint: *const root::SkPaint,
                                        arg1:
                                            root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkRect@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_drawBitmapRect2(this: *mut root::SkCanvas,
                                        bitmap: *const root::SkBitmap,
                                        dst: *const root::SkRect,
                                        paint: *const root::SkPaint,
                                        arg1:
                                            root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        /**
     *  Draw the bitmap stretched or shrunk differentially to fit into dst.
     *  center is a rect within the bitmap, and logically divides the bitmap
     *  into 9 sections (3x3). For example, if the middle pixel of a [5x5]
     *  bitmap is the "center", then the center-rect should be [2, 2, 3, 3].
     *
     *  If the dst is >= the bitmap size, then...
     *  - The 4 corners are not stretched at all.
     *  - The sides are stretched in only one axis.
     *  - The center is stretched in both axes.
     * Else, for each axis where dst < bitmap,
     *  - The corners shrink proportionally
     *  - The sides (along the shrink axis) and center are not drawn
     */
        #[link_name =
              "?drawBitmapNine@SkCanvas@@QEAAXAEBVSkBitmap@@AEBUSkIRect@@AEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawBitmapNine(this: *mut root::SkCanvas,
                                       bitmap: *const root::SkBitmap,
                                       center: *const root::SkIRect,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the bitmap stretched or shrunk differentially to fit into dst.
     *
     *  Moving horizontally across the bitmap, alternating rects will be "scalable"
     *  (in the x-dimension) to fit into dst or must be left "fixed".  The first rect
     *  is treated as "fixed", but it's possible to specify an empty first rect by
     *  making lattice.fXDivs[0] = 0.
     *
     *  The scale factor for all "scalable" rects will be the same, and may be greater
     *  than or less than 1 (meaning we can stretch or shrink).  If the number of
     *  "fixed" pixels is greater than the width of the dst, we will collapse all of
     *  the "scalable" regions and appropriately downscale the "fixed" regions.
     *
     *  The same interpretation also applies to the y-dimension.
     */
        #[link_name =
              "?drawBitmapLattice@SkCanvas@@QEAAXAEBVSkBitmap@@AEBULattice@1@AEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawBitmapLattice(this: *mut root::SkCanvas,
                                          bitmap: *const root::SkBitmap,
                                          lattice:
                                              *const root::SkCanvas_Lattice,
                                          dst: *const root::SkRect,
                                          paint: *const root::SkPaint);
    }
    extern "C" {
        #[link_name =
              "?drawImageLattice@SkCanvas@@QEAAXPEBVSkImage@@AEBULattice@1@AEBUSkRect@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawImageLattice(this: *mut root::SkCanvas,
                                         image: *const root::SkImage,
                                         lattice:
                                             *const root::SkCanvas_Lattice,
                                         dst: *const root::SkRect,
                                         paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with origin at (x,y), using the specified paint.
        The origin is interpreted based on the Align setting in the paint.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param x        The x-coordinate of the origin of the text being drawn
        @param y        The y-coordinate of the origin of the text being drawn
        @param paint    The paint used for the text (e.g. color, size, style)
    */
        #[link_name = "?drawText@SkCanvas@@QEAAXPEBX_KMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawText(this: *mut root::SkCanvas,
                                 text: *const ::std::os::raw::c_void,
                                 byteLength: usize, x: root::SkScalar,
                                 y: root::SkScalar,
                                 paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with each character/glyph origin specified by the pos[]
        array. The origin is interpreted by the Align setting in the paint.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param pos      Array of positions, used to position each character
        @param paint    The paint used for the text (e.g. color, size, style)
        */
        #[link_name =
              "?drawPosText@SkCanvas@@QEAAXPEBX_KQEBUSkPoint@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPosText(this: *mut root::SkCanvas,
                                    text: *const ::std::os::raw::c_void,
                                    byteLength: usize,
                                    pos: *const root::SkPoint,
                                    paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with each character/glyph origin specified by the x
        coordinate taken from the xpos[] array, and the y from the constY param.
        The origin is interpreted by the Align setting in the paint.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param xpos     Array of x-positions, used to position each character
        @param constY   The shared Y coordinate for all of the positions
        @param paint    The paint used for the text (e.g. color, size, style)
        */
        #[link_name =
              "?drawPosTextH@SkCanvas@@QEAAXPEBX_KQEBMMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPosTextH(this: *mut root::SkCanvas,
                                     text: *const ::std::os::raw::c_void,
                                     byteLength: usize,
                                     xpos: *const root::SkScalar,
                                     constY: root::SkScalar,
                                     paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with origin at (x,y), using the specified paint, along
        the specified path. The paint's Align setting determins where along the
        path to start the text.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param path         The path the text should follow for its baseline
        @param hOffset      The distance along the path to add to the text's
                            starting position
        @param vOffset      The distance above(-) or below(+) the path to
                            position the text
        @param paint        The paint used for the text
    */
        #[link_name =
              "?drawTextOnPathHV@SkCanvas@@QEAAXPEBX_KAEBVSkPath@@MMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawTextOnPathHV(this: *mut root::SkCanvas,
                                         text: *const ::std::os::raw::c_void,
                                         byteLength: usize,
                                         path: *const root::SkPath,
                                         hOffset: root::SkScalar,
                                         vOffset: root::SkScalar,
                                         paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text, with origin at (x,y), using the specified paint, along
        the specified path. The paint's Align setting determins where along the
        path to start the text.
        @param text The text to be drawn
        @param byteLength   The number of bytes to read from the text parameter
        @param path         The path the text should follow for its baseline
        @param matrix       (may be null) Applied to the text before it is
                            mapped onto the path
        @param paint        The paint used for the text
        */
        #[link_name =
              "?drawTextOnPath@SkCanvas@@QEAAXPEBX_KAEBVSkPath@@PEBVSkMatrix@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawTextOnPath(this: *mut root::SkCanvas,
                                       text: *const ::std::os::raw::c_void,
                                       byteLength: usize,
                                       path: *const root::SkPath,
                                       matrix: *const root::SkMatrix,
                                       paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the text with each character/glyph individually transformed by its xform.
     *  If cullRect is not null, it is a conservative bounds of what will be drawn
     *  taking into account the xforms and the paint, and will be used to accelerate culling.
     */
        #[link_name =
              "?drawTextRSXform@SkCanvas@@QEAAXPEBX_KQEBUSkRSXform@@PEBUSkRect@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawTextRSXform(this: *mut root::SkCanvas,
                                        text: *const ::std::os::raw::c_void,
                                        byteLength: usize,
                                        arg1: *const root::SkRSXform,
                                        cullRect: *const root::SkRect,
                                        paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the text blob, offset by (x,y), using the specified paint.
        @param blob     The text blob to be drawn
        @param x        The x-offset of the text being drawn
        @param y        The y-offset of the text being drawn
        @param paint    The paint used for the text (e.g. color, size, style)
    */
        #[link_name =
              "?drawTextBlob@SkCanvas@@QEAAXPEBVSkTextBlob@@MMAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawTextBlob(this: *mut root::SkCanvas,
                                     blob: *const root::SkTextBlob,
                                     x: root::SkScalar, y: root::SkScalar,
                                     paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the picture into this canvas.
     *
     *  If matrix is non-null, apply that matrix to the CTM when drawing this picture. This is
     *  logically equivalent to
     *      save/concat/drawPicture/restore
     *
     *  If paint is non-null, draw the picture into a temporary buffer, and then apply the paint's
     *  alpha/colorfilter/imagefilter/xfermode to that buffer as it is drawn to the canvas.
     *  This is logically equivalent to
     *      saveLayer(paint)/drawPicture/restore
     */
        #[link_name =
              "?drawPicture@SkCanvas@@QEAAXPEBVSkPicture@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPicture(this: *mut root::SkCanvas,
                                    arg1: *const root::SkPicture,
                                    matrix: *const root::SkMatrix,
                                    paint: *const root::SkPaint);
    }
    extern "C" {
        /** Draw the array of vertices, interpreted as triangles (based on mode).

        If both textures and vertex-colors are NULL, it strokes hairlines with
        the paint's color. This behavior is a useful debugging mode to visualize
        the mesh.

        @param vmode How to interpret the array of vertices
        @param vertexCount The number of points in the vertices array (and
                    corresponding texs and colors arrays if non-null)
        @param vertices Array of vertices for the mesh
        @param texs May be null. If not null, specifies the coordinate
                    in _texture_ space (not uv space) for each vertex.
        @param colors May be null. If not null, specifies a color for each
                      vertex, to be interpolated across the triangle.
        @param mode Used if both texs and colors are present. In this
                    case the colors are combined with the texture using mode,
                    before being drawn using the paint. 
        @param indices If not null, array of indices to reference into the
                    vertex (texs, colors) array.
        @param indexCount number of entries in the indices array (if not null)
        @param paint Specifies the shader/texture if present.
    */
        #[link_name =
              "?drawVertices@SkCanvas@@QEAAXW4VertexMode@1@HQEBUSkPoint@@1QEBIW4SkBlendMode@@QEBGHAEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawVertices(this: *mut root::SkCanvas,
                                     vmode: root::SkCanvas_VertexMode,
                                     vertexCount: ::std::os::raw::c_int,
                                     vertices: *const root::SkPoint,
                                     texs: *const root::SkPoint,
                                     colors: *const root::SkColor,
                                     mode: root::SkBlendMode,
                                     indices: *const u16,
                                     indexCount: ::std::os::raw::c_int,
                                     paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     Draw a cubic coons patch

     @param cubic specifies the 4 bounding cubic bezier curves of a patch with clockwise order
                    starting at the top left corner.
     @param colors specifies the colors for the corners which will be bilerp across the patch,
                    their order is clockwise starting at the top left corner.
     @param texCoords specifies the texture coordinates that will be bilerp across the patch,
                    their order is the same as the colors.
     @param mode specifies how are the colors and the textures combined if both of them are
                    present.
     @param paint Specifies the shader/texture if present.
     */
        #[link_name =
              "?drawPatch@SkCanvas@@QEAAXQEBUSkPoint@@QEBI0W4SkBlendMode@@AEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawPatch(this: *mut root::SkCanvas,
                                  cubics: *mut root::SkPoint,
                                  colors: *mut root::SkColor,
                                  texCoords: *mut root::SkPoint,
                                  mode: root::SkBlendMode,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw a set of sprites from the atlas. Each is specified by a tex rectangle in the
     *  coordinate space of the atlas, and a corresponding xform which transforms the tex rectangle
     *  into a quad.
     *
     *      xform maps [0, 0, tex.width, tex.height] -> quad
     *
     *  The color array is optional. When specified, each color modulates the pixels in its
     *  corresponding quad (via the specified SkBlendMode).
     *
     *  The cullRect is optional. When specified, it must be a conservative bounds of all of the
     *  resulting transformed quads, allowing the canvas to skip drawing if the cullRect does not
     *  intersect the current clip.
     *
     *  The paint is optional. If specified, its antialiasing, alpha, color-filter, image-filter
     *  and blendmode are used to affect each of the quads.
     */
        #[link_name =
              "?drawAtlas@SkCanvas@@QEAAXPEBVSkImage@@QEBUSkRSXform@@QEBUSkRect@@QEBIHW4SkBlendMode@@PEBU4@PEBVSkPaint@@@Z"]
        pub fn SkCanvas_drawAtlas(this: *mut root::SkCanvas,
                                  atlas: *const root::SkImage,
                                  xform: *const root::SkRSXform,
                                  tex: *const root::SkRect,
                                  colors: *const root::SkColor,
                                  count: ::std::os::raw::c_int,
                                  arg1: root::SkBlendMode,
                                  cullRect: *const root::SkRect,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  Draw the contents of this drawable into the canvas. If the canvas is async
     *  (e.g. it is recording into a picture) then the drawable will be referenced instead,
     *  to have its draw() method called when the picture is finalized.
     *
     *  If the intent is to force the contents of the drawable into this canvas immediately,
     *  then drawable->draw(canvas) may be called.
     */
        #[link_name =
              "?drawDrawable@SkCanvas@@QEAAXPEAVSkDrawable@@PEBVSkMatrix@@@Z"]
        pub fn SkCanvas_drawDrawable(this: *mut root::SkCanvas,
                                     drawable: *mut root::SkDrawable,
                                     arg1: *const root::SkMatrix);
    }
    extern "C" {
        #[link_name = "?drawDrawable@SkCanvas@@QEAAXPEAVSkDrawable@@MM@Z"]
        pub fn SkCanvas_drawDrawable1(this: *mut root::SkCanvas,
                                      arg1: *mut root::SkDrawable,
                                      x: root::SkScalar, y: root::SkScalar);
    }
    extern "C" {
        /**
     *  Send an "annotation" to the canvas. The annotation is a key/value pair, where the key is
     *  a null-terminated utf8 string, and the value is a blob of data stored in an SkData
     *  (which may be null). The annotation is associated with the specified rectangle.
     *
     *  The caller still retains its ownership of the data (if any).
     *
     *  Note: on may canvas types, this information is ignored, but some canvases (e.g. recording
     *  a picture or drawing to a PDF document) will pass on this information.
     */
        #[link_name =
              "?drawAnnotation@SkCanvas@@QEAAXAEBUSkRect@@QEBDPEAVSkData@@@Z"]
        pub fn SkCanvas_drawAnnotation(this: *mut root::SkCanvas,
                                       arg1: *const root::SkRect,
                                       key: *const ::std::os::raw::c_char,
                                       value: *mut root::SkData);
    }
    extern "C" {
        /** Return the current matrix on the canvas.
        This does not account for the translate in any of the devices.
        @return The current matrix on the canvas.
    */
        #[link_name = "?getTotalMatrix@SkCanvas@@QEBAAEBVSkMatrix@@XZ"]
        pub fn SkCanvas_getTotalMatrix(this: *const root::SkCanvas)
         -> *const root::SkMatrix;
    }
    extern "C" {
        /**
     *  Replays the clip operations, back to front, that have been applied to
     *  the canvas, calling the appropriate method on the visitor for each
     *  clip. All clips have already been transformed into device space.
     */
        #[link_name =
              "?replayClips@SkCanvas@@QEBAXPEAVSkCanvasClipVisitor@@@Z"]
        pub fn SkCanvas_replayClips(this: *const root::SkCanvas,
                                    arg1: *mut root::SkCanvas_ClipVisitor);
    }
    extern "C" {
        ///////////////////////////////////////////////////////////////////////////
        #[link_name =
              "?internal_private_accessTopLayerRenderTargetContext@SkCanvas@@QEAAPEAVGrRenderTargetContext@@XZ"]
        pub fn SkCanvas_internal_private_accessTopLayerRenderTargetContext(this:
                                                                               *mut root::SkCanvas)
         -> *mut root::GrRenderTargetContext;
    }
    extern "C" {
        #[link_name =
              "?Internal_Private_SetIgnoreSaveLayerBounds@SkCanvas@@SAX_N@Z"]
        pub fn SkCanvas_Internal_Private_SetIgnoreSaveLayerBounds(arg1: bool);
    }
    extern "C" {
        #[link_name =
              "?Internal_Private_GetIgnoreSaveLayerBounds@SkCanvas@@SA_NXZ"]
        pub fn SkCanvas_Internal_Private_GetIgnoreSaveLayerBounds() -> bool;
    }
    extern "C" {
        #[link_name =
              "?Internal_Private_SetTreatSpriteAsBitmap@SkCanvas@@SAX_N@Z"]
        pub fn SkCanvas_Internal_Private_SetTreatSpriteAsBitmap(arg1: bool);
    }
    extern "C" {
        #[link_name =
              "?Internal_Private_GetTreatSpriteAsBitmap@SkCanvas@@SA_NXZ"]
        pub fn SkCanvas_Internal_Private_GetTreatSpriteAsBitmap() -> bool;
    }
    extern "C" {
        #[link_name =
              "?legacy_drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@PEBUSkRect@@AEBU3@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_legacy_drawImageRect(this: *mut root::SkCanvas,
                                             image: *const root::SkImage,
                                             src: *const root::SkRect,
                                             dst: *const root::SkRect,
                                             paint: *const root::SkPaint,
                                             constraint:
                                                 root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        #[link_name =
              "?legacy_drawBitmapRect@SkCanvas@@QEAAXAEBVSkBitmap@@PEBUSkRect@@AEBU3@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"]
        pub fn SkCanvas_legacy_drawBitmapRect(this: *mut root::SkCanvas,
                                              bitmap: *const root::SkBitmap,
                                              src: *const root::SkRect,
                                              dst: *const root::SkRect,
                                              paint: *const root::SkPaint,
                                              constraint:
                                                  root::SkCanvas_SrcRectConstraint);
    }
    extern "C" {
        /**
     * Returns CTM and clip bounds, translated from canvas coordinates to top layer coordinates.
     */
        #[link_name =
              "?temporary_internal_describeTopLayer@SkCanvas@@QEAAXPEAVSkMatrix@@PEAUSkIRect@@@Z"]
        pub fn SkCanvas_temporary_internal_describeTopLayer(this:
                                                                *mut root::SkCanvas,
                                                            matrix:
                                                                *mut root::SkMatrix,
                                                            clip_bounds:
                                                                *mut root::SkIRect);
    }
    extern "C" {
        #[link_name =
              "?clipRectBounds@SkCanvas@@IEAA_NPEBUSkRect@@IPEAUSkIRect@@PEBVSkImageFilter@@@Z"]
        pub fn SkCanvas_clipRectBounds(this: *mut root::SkCanvas,
                                       bounds: *const root::SkRect,
                                       arg1: root::SkCanvas_SaveLayerFlags,
                                       intersection: *mut root::SkIRect,
                                       imageFilter:
                                           *const root::SkImageFilter)
         -> bool;
    }
    extern "C" {
        /**
     *  Creates an empty canvas with no backing device/pixels, and zero
     *  dimensions.
     */
        #[link_name = "??0SkCanvas@@QEAA@XZ"]
        pub fn SkCanvas_SkCanvas(this: *mut root::SkCanvas);
    }
    extern "C" {
        /**
     *  Creates a canvas of the specified dimensions, but explicitly not backed
     *  by any device/pixels. Typically this use used by subclasses who handle
     *  the draw calls in some other way.
     */
        #[link_name = "??0SkCanvas@@QEAA@HHPEBVSkSurfaceProps@@@Z"]
        pub fn SkCanvas_SkCanvas1(this: *mut root::SkCanvas,
                                  width: ::std::os::raw::c_int,
                                  height: ::std::os::raw::c_int,
                                  arg1: *const root::SkSurfaceProps);
    }
    extern "C" {
        /** Construct a canvas with the specified device to draw into.

        @param device   Specifies a device for the canvas to draw into.
    */
        #[link_name = "??0SkCanvas@@QEAA@PEAVSkBaseDevice@@@Z"]
        pub fn SkCanvas_SkCanvas2(this: *mut root::SkCanvas,
                                  device: *mut root::SkBaseDevice);
    }
    extern "C" {
        /** Construct a canvas with the specified bitmap to draw into.
        @param bitmap   Specifies a bitmap for the canvas to draw into. Its
                        structure are copied to the canvas.
    */
        #[link_name = "??0SkCanvas@@QEAA@AEBVSkBitmap@@@Z"]
        pub fn SkCanvas_SkCanvas3(this: *mut root::SkCanvas,
                                  bitmap: *const root::SkBitmap);
    }
    extern "C" {
        /** Construct a canvas with the specified bitmap to draw into.
        @param bitmap   Specifies a bitmap for the canvas to draw into. Its
                        structure are copied to the canvas.
        @param props    New canvas surface properties.
    */
        #[link_name =
              "??0SkCanvas@@QEAA@AEBVSkBitmap@@AEBVSkSurfaceProps@@@Z"]
        pub fn SkCanvas_SkCanvas4(this: *mut root::SkCanvas,
                                  bitmap: *const root::SkBitmap,
                                  props: *const root::SkSurfaceProps);
    }
    impl SkCanvas {
        #[inline]
        pub unsafe fn MakeRasterDirect(arg1: *const root::SkImageInfo,
                                       arg2: *mut ::std::os::raw::c_void,
                                       arg3: usize)
         ->
             root::std::unique_ptr<root::SkCanvas,
                                   root::std::default_delete<root::SkCanvas>> {
            SkCanvas_MakeRasterDirect(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn getMetaData(&mut self) -> *mut root::SkMetaData {
            SkCanvas_getMetaData(&mut *self)
        }
        #[inline]
        pub unsafe fn imageInfo(&self) -> root::SkImageInfo {
            SkCanvas_imageInfo(&*self)
        }
        #[inline]
        pub unsafe fn getProps(&self, arg1: *mut root::SkSurfaceProps)
         -> bool {
            SkCanvas_getProps(&*self, arg1)
        }
        #[inline]
        pub unsafe fn flush(&mut self) { SkCanvas_flush(&mut *self) }
        #[inline]
        pub unsafe fn getDevice(&self) -> *mut root::SkBaseDevice {
            SkCanvas_getDevice(&*self)
        }
        #[inline]
        pub unsafe fn makeSurface(&mut self, arg1: *const root::SkImageInfo,
                                  arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkCanvas_makeSurface(&mut *self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn getGrContext(&mut self) -> *mut root::GrContext {
            SkCanvas_getGrContext(&mut *self)
        }
        #[inline]
        pub unsafe fn accessTopLayerPixels(&mut self,
                                           info: *mut root::SkImageInfo,
                                           rowBytes: *mut usize,
                                           origin: *mut root::SkIPoint)
         -> *mut ::std::os::raw::c_void {
            SkCanvas_accessTopLayerPixels(&mut *self, info, rowBytes, origin)
        }
        #[inline]
        pub unsafe fn peekPixels(&mut self, arg1: *mut root::SkPixmap)
         -> bool {
            SkCanvas_peekPixels(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn readPixels(&mut self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int) -> bool {
            SkCanvas_readPixels(&mut *self, dstInfo, dstPixels, dstRowBytes,
                                srcX, srcY)
        }
        #[inline]
        pub unsafe fn readPixels1(&mut self, bitmap: *mut root::SkBitmap,
                                  srcX: ::std::os::raw::c_int,
                                  srcY: ::std::os::raw::c_int) -> bool {
            SkCanvas_readPixels1(&mut *self, bitmap, srcX, srcY)
        }
        #[inline]
        pub unsafe fn readPixels2(&mut self, srcRect: *const root::SkIRect,
                                  bitmap: *mut root::SkBitmap) -> bool {
            SkCanvas_readPixels2(&mut *self, srcRect, bitmap)
        }
        #[inline]
        pub unsafe fn writePixels(&mut self, arg1: *const root::SkImageInfo,
                                  pixels: *const ::std::os::raw::c_void,
                                  rowBytes: usize, x: ::std::os::raw::c_int,
                                  y: ::std::os::raw::c_int) -> bool {
            SkCanvas_writePixels(&mut *self, arg1, pixels, rowBytes, x, y)
        }
        #[inline]
        pub unsafe fn writePixels1(&mut self, bitmap: *const root::SkBitmap,
                                   x: ::std::os::raw::c_int,
                                   y: ::std::os::raw::c_int) -> bool {
            SkCanvas_writePixels1(&mut *self, bitmap, x, y)
        }
        #[inline]
        pub unsafe fn save(&mut self) -> ::std::os::raw::c_int {
            SkCanvas_save(&mut *self)
        }
        #[inline]
        pub unsafe fn saveLayer(&mut self, bounds: *const root::SkRect,
                                paint: *const root::SkPaint)
         -> ::std::os::raw::c_int {
            SkCanvas_saveLayer(&mut *self, bounds, paint)
        }
        #[inline]
        pub unsafe fn saveLayerPreserveLCDTextRequests(&mut self,
                                                       bounds:
                                                           *const root::SkRect,
                                                       paint:
                                                           *const root::SkPaint)
         -> ::std::os::raw::c_int {
            SkCanvas_saveLayerPreserveLCDTextRequests(&mut *self, bounds,
                                                      paint)
        }
        #[inline]
        pub unsafe fn saveLayerAlpha(&mut self, bounds: *const root::SkRect,
                                     alpha: root::U8CPU)
         -> ::std::os::raw::c_int {
            SkCanvas_saveLayerAlpha(&mut *self, bounds, alpha)
        }
        #[inline]
        pub unsafe fn saveLayer1(&mut self,
                                 arg1: *const root::SkCanvas_SaveLayerRec)
         -> ::std::os::raw::c_int {
            SkCanvas_saveLayer1(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn restore(&mut self) { SkCanvas_restore(&mut *self) }
        #[inline]
        pub unsafe fn getSaveCount(&self) -> ::std::os::raw::c_int {
            SkCanvas_getSaveCount(&*self)
        }
        #[inline]
        pub unsafe fn restoreToCount(&mut self,
                                     saveCount: ::std::os::raw::c_int) {
            SkCanvas_restoreToCount(&mut *self, saveCount)
        }
        #[inline]
        pub unsafe fn translate(&mut self, dx: root::SkScalar,
                                dy: root::SkScalar) {
            SkCanvas_translate(&mut *self, dx, dy)
        }
        #[inline]
        pub unsafe fn scale(&mut self, sx: root::SkScalar,
                            sy: root::SkScalar) {
            SkCanvas_scale(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn rotate(&mut self, degrees: root::SkScalar) {
            SkCanvas_rotate(&mut *self, degrees)
        }
        #[inline]
        pub unsafe fn rotate1(&mut self, degrees: root::SkScalar,
                              px: root::SkScalar, py: root::SkScalar) {
            SkCanvas_rotate1(&mut *self, degrees, px, py)
        }
        #[inline]
        pub unsafe fn skew(&mut self, sx: root::SkScalar,
                           sy: root::SkScalar) {
            SkCanvas_skew(&mut *self, sx, sy)
        }
        #[inline]
        pub unsafe fn concat(&mut self, matrix: *const root::SkMatrix) {
            SkCanvas_concat(&mut *self, matrix)
        }
        #[inline]
        pub unsafe fn setMatrix(&mut self, matrix: *const root::SkMatrix) {
            SkCanvas_setMatrix(&mut *self, matrix)
        }
        #[inline]
        pub unsafe fn resetMatrix(&mut self) {
            SkCanvas_resetMatrix(&mut *self)
        }
        #[inline]
        pub unsafe fn clipRect(&mut self, rect: *const root::SkRect,
                               arg1: root::SkClipOp, doAntiAlias: bool) {
            SkCanvas_clipRect(&mut *self, rect, arg1, doAntiAlias)
        }
        #[inline]
        pub unsafe fn clipRRect(&mut self, rrect: *const root::SkRRect,
                                op: root::SkClipOp, doAntiAlias: bool) {
            SkCanvas_clipRRect(&mut *self, rrect, op, doAntiAlias)
        }
        #[inline]
        pub unsafe fn clipPath(&mut self, path: *const root::SkPath,
                               op: root::SkClipOp, doAntiAlias: bool) {
            SkCanvas_clipPath(&mut *self, path, op, doAntiAlias)
        }
        #[inline]
        pub unsafe fn clipRegion(&mut self, deviceRgn: *const root::SkRegion,
                                 op: root::SkClipOp) {
            SkCanvas_clipRegion(&mut *self, deviceRgn, op)
        }
        #[inline]
        pub unsafe fn quickReject(&self, rect: *const root::SkRect) -> bool {
            SkCanvas_quickReject(&*self, rect)
        }
        #[inline]
        pub unsafe fn quickReject1(&self, path: *const root::SkPath) -> bool {
            SkCanvas_quickReject1(&*self, path)
        }
        #[inline]
        pub unsafe fn drawARGB(&mut self, a: root::U8CPU, r: root::U8CPU,
                               g: root::U8CPU, b: root::U8CPU,
                               mode: root::SkBlendMode) {
            SkCanvas_drawARGB(&mut *self, a, r, g, b, mode)
        }
        #[inline]
        pub unsafe fn drawColor(&mut self, color: root::SkColor,
                                mode: root::SkBlendMode) {
            SkCanvas_drawColor(&mut *self, color, mode)
        }
        #[inline]
        pub unsafe fn drawPaint(&mut self, paint: *const root::SkPaint) {
            SkCanvas_drawPaint(&mut *self, paint)
        }
        #[inline]
        pub unsafe fn drawPoints(&mut self, mode: root::SkCanvas_PointMode,
                                 count: usize, pts: *const root::SkPoint,
                                 paint: *const root::SkPaint) {
            SkCanvas_drawPoints(&mut *self, mode, count, pts, paint)
        }
        #[inline]
        pub unsafe fn drawPoint(&mut self, x: root::SkScalar,
                                y: root::SkScalar,
                                paint: *const root::SkPaint) {
            SkCanvas_drawPoint(&mut *self, x, y, paint)
        }
        #[inline]
        pub unsafe fn drawPoint1(&mut self, x: root::SkScalar,
                                 y: root::SkScalar, color: root::SkColor) {
            SkCanvas_drawPoint1(&mut *self, x, y, color)
        }
        #[inline]
        pub unsafe fn drawLine(&mut self, x0: root::SkScalar,
                               y0: root::SkScalar, x1: root::SkScalar,
                               y1: root::SkScalar,
                               paint: *const root::SkPaint) {
            SkCanvas_drawLine(&mut *self, x0, y0, x1, y1, paint)
        }
        #[inline]
        pub unsafe fn drawRect(&mut self, rect: *const root::SkRect,
                               paint: *const root::SkPaint) {
            SkCanvas_drawRect(&mut *self, rect, paint)
        }
        #[inline]
        pub unsafe fn drawRectCoords(&mut self, left: root::SkScalar,
                                     top: root::SkScalar,
                                     right: root::SkScalar,
                                     bottom: root::SkScalar,
                                     paint: *const root::SkPaint) {
            SkCanvas_drawRectCoords(&mut *self, left, top, right, bottom,
                                    paint)
        }
        #[inline]
        pub unsafe fn drawRegion(&mut self, region: *const root::SkRegion,
                                 paint: *const root::SkPaint) {
            SkCanvas_drawRegion(&mut *self, region, paint)
        }
        #[inline]
        pub unsafe fn drawOval(&mut self, oval: *const root::SkRect,
                               arg1: *const root::SkPaint) {
            SkCanvas_drawOval(&mut *self, oval, arg1)
        }
        #[inline]
        pub unsafe fn drawRRect(&mut self, rrect: *const root::SkRRect,
                                paint: *const root::SkPaint) {
            SkCanvas_drawRRect(&mut *self, rrect, paint)
        }
        #[inline]
        pub unsafe fn drawDRRect(&mut self, outer: *const root::SkRRect,
                                 inner: *const root::SkRRect,
                                 arg1: *const root::SkPaint) {
            SkCanvas_drawDRRect(&mut *self, outer, inner, arg1)
        }
        #[inline]
        pub unsafe fn drawCircle(&mut self, cx: root::SkScalar,
                                 cy: root::SkScalar, radius: root::SkScalar,
                                 paint: *const root::SkPaint) {
            SkCanvas_drawCircle(&mut *self, cx, cy, radius, paint)
        }
        #[inline]
        pub unsafe fn drawArc(&mut self, oval: *const root::SkRect,
                              startAngle: root::SkScalar,
                              sweepAngle: root::SkScalar, useCenter: bool,
                              paint: *const root::SkPaint) {
            SkCanvas_drawArc(&mut *self, oval, startAngle, sweepAngle,
                             useCenter, paint)
        }
        #[inline]
        pub unsafe fn drawRoundRect(&mut self, rect: *const root::SkRect,
                                    rx: root::SkScalar, ry: root::SkScalar,
                                    paint: *const root::SkPaint) {
            SkCanvas_drawRoundRect(&mut *self, rect, rx, ry, paint)
        }
        #[inline]
        pub unsafe fn drawPath(&mut self, path: *const root::SkPath,
                               paint: *const root::SkPaint) {
            SkCanvas_drawPath(&mut *self, path, paint)
        }
        #[inline]
        pub unsafe fn drawImage(&mut self, image: *const root::SkImage,
                                left: root::SkScalar, top: root::SkScalar,
                                paint: *const root::SkPaint) {
            SkCanvas_drawImage(&mut *self, image, left, top, paint)
        }
        #[inline]
        pub unsafe fn drawImageRect(&mut self, image: *const root::SkImage,
                                    src: *const root::SkRect,
                                    dst: *const root::SkRect,
                                    paint: *const root::SkPaint,
                                    constraint:
                                        root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawImageRect(&mut *self, image, src, dst, paint,
                                   constraint)
        }
        #[inline]
        pub unsafe fn drawImageRect1(&mut self, image: *const root::SkImage,
                                     isrc: *const root::SkIRect,
                                     dst: *const root::SkRect,
                                     paint: *const root::SkPaint,
                                     arg1: root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawImageRect1(&mut *self, image, isrc, dst, paint, arg1)
        }
        #[inline]
        pub unsafe fn drawImageRect2(&mut self, image: *const root::SkImage,
                                     dst: *const root::SkRect,
                                     paint: *const root::SkPaint,
                                     arg1: root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawImageRect2(&mut *self, image, dst, paint, arg1)
        }
        #[inline]
        pub unsafe fn drawImageNine(&mut self, arg1: *const root::SkImage,
                                    center: *const root::SkIRect,
                                    dst: *const root::SkRect,
                                    paint: *const root::SkPaint) {
            SkCanvas_drawImageNine(&mut *self, arg1, center, dst, paint)
        }
        #[inline]
        pub unsafe fn drawBitmap(&mut self, bitmap: *const root::SkBitmap,
                                 left: root::SkScalar, top: root::SkScalar,
                                 paint: *const root::SkPaint) {
            SkCanvas_drawBitmap(&mut *self, bitmap, left, top, paint)
        }
        #[inline]
        pub unsafe fn drawBitmapRect(&mut self, bitmap: *const root::SkBitmap,
                                     src: *const root::SkRect,
                                     dst: *const root::SkRect,
                                     paint: *const root::SkPaint,
                                     arg1: root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawBitmapRect(&mut *self, bitmap, src, dst, paint, arg1)
        }
        #[inline]
        pub unsafe fn drawBitmapRect1(&mut self,
                                      bitmap: *const root::SkBitmap,
                                      isrc: *const root::SkIRect,
                                      dst: *const root::SkRect,
                                      paint: *const root::SkPaint,
                                      arg1:
                                          root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawBitmapRect1(&mut *self, bitmap, isrc, dst, paint,
                                     arg1)
        }
        #[inline]
        pub unsafe fn drawBitmapRect2(&mut self,
                                      bitmap: *const root::SkBitmap,
                                      dst: *const root::SkRect,
                                      paint: *const root::SkPaint,
                                      arg1:
                                          root::SkCanvas_SrcRectConstraint) {
            SkCanvas_drawBitmapRect2(&mut *self, bitmap, dst, paint, arg1)
        }
        #[inline]
        pub unsafe fn drawBitmapNine(&mut self, bitmap: *const root::SkBitmap,
                                     center: *const root::SkIRect,
                                     dst: *const root::SkRect,
                                     paint: *const root::SkPaint) {
            SkCanvas_drawBitmapNine(&mut *self, bitmap, center, dst, paint)
        }
        #[inline]
        pub unsafe fn drawBitmapLattice(&mut self,
                                        bitmap: *const root::SkBitmap,
                                        lattice:
                                            *const root::SkCanvas_Lattice,
                                        dst: *const root::SkRect,
                                        paint: *const root::SkPaint) {
            SkCanvas_drawBitmapLattice(&mut *self, bitmap, lattice, dst,
                                       paint)
        }
        #[inline]
        pub unsafe fn drawImageLattice(&mut self, image: *const root::SkImage,
                                       lattice: *const root::SkCanvas_Lattice,
                                       dst: *const root::SkRect,
                                       paint: *const root::SkPaint) {
            SkCanvas_drawImageLattice(&mut *self, image, lattice, dst, paint)
        }
        #[inline]
        pub unsafe fn drawText(&mut self, text: *const ::std::os::raw::c_void,
                               byteLength: usize, x: root::SkScalar,
                               y: root::SkScalar,
                               paint: *const root::SkPaint) {
            SkCanvas_drawText(&mut *self, text, byteLength, x, y, paint)
        }
        #[inline]
        pub unsafe fn drawPosText(&mut self,
                                  text: *const ::std::os::raw::c_void,
                                  byteLength: usize,
                                  pos: *const root::SkPoint,
                                  paint: *const root::SkPaint) {
            SkCanvas_drawPosText(&mut *self, text, byteLength, pos, paint)
        }
        #[inline]
        pub unsafe fn drawPosTextH(&mut self,
                                   text: *const ::std::os::raw::c_void,
                                   byteLength: usize,
                                   xpos: *const root::SkScalar,
                                   constY: root::SkScalar,
                                   paint: *const root::SkPaint) {
            SkCanvas_drawPosTextH(&mut *self, text, byteLength, xpos, constY,
                                  paint)
        }
        #[inline]
        pub unsafe fn drawTextOnPathHV(&mut self,
                                       text: *const ::std::os::raw::c_void,
                                       byteLength: usize,
                                       path: *const root::SkPath,
                                       hOffset: root::SkScalar,
                                       vOffset: root::SkScalar,
                                       paint: *const root::SkPaint) {
            SkCanvas_drawTextOnPathHV(&mut *self, text, byteLength, path,
                                      hOffset, vOffset, paint)
        }
        #[inline]
        pub unsafe fn drawTextOnPath(&mut self,
                                     text: *const ::std::os::raw::c_void,
                                     byteLength: usize,
                                     path: *const root::SkPath,
                                     matrix: *const root::SkMatrix,
                                     paint: *const root::SkPaint) {
            SkCanvas_drawTextOnPath(&mut *self, text, byteLength, path,
                                    matrix, paint)
        }
        #[inline]
        pub unsafe fn drawTextRSXform(&mut self,
                                      text: *const ::std::os::raw::c_void,
                                      byteLength: usize,
                                      arg1: *const root::SkRSXform,
                                      cullRect: *const root::SkRect,
                                      paint: *const root::SkPaint) {
            SkCanvas_drawTextRSXform(&mut *self, text, byteLength, arg1,
                                     cullRect, paint)
        }
        #[inline]
        pub unsafe fn drawTextBlob(&mut self, blob: *const root::SkTextBlob,
                                   x: root::SkScalar, y: root::SkScalar,
                                   paint: *const root::SkPaint) {
            SkCanvas_drawTextBlob(&mut *self, blob, x, y, paint)
        }
        #[inline]
        pub unsafe fn drawPicture(&mut self, arg1: *const root::SkPicture,
                                  matrix: *const root::SkMatrix,
                                  paint: *const root::SkPaint) {
            SkCanvas_drawPicture(&mut *self, arg1, matrix, paint)
        }
        #[inline]
        pub unsafe fn drawVertices(&mut self,
                                   vmode: root::SkCanvas_VertexMode,
                                   vertexCount: ::std::os::raw::c_int,
                                   vertices: *const root::SkPoint,
                                   texs: *const root::SkPoint,
                                   colors: *const root::SkColor,
                                   mode: root::SkBlendMode,
                                   indices: *const u16,
                                   indexCount: ::std::os::raw::c_int,
                                   paint: *const root::SkPaint) {
            SkCanvas_drawVertices(&mut *self, vmode, vertexCount, vertices,
                                  texs, colors, mode, indices, indexCount,
                                  paint)
        }
        #[inline]
        pub unsafe fn drawPatch(&mut self, cubics: *mut root::SkPoint,
                                colors: *mut root::SkColor,
                                texCoords: *mut root::SkPoint,
                                mode: root::SkBlendMode,
                                paint: *const root::SkPaint) {
            SkCanvas_drawPatch(&mut *self, cubics, colors, texCoords, mode,
                               paint)
        }
        #[inline]
        pub unsafe fn drawAtlas(&mut self, atlas: *const root::SkImage,
                                xform: *const root::SkRSXform,
                                tex: *const root::SkRect,
                                colors: *const root::SkColor,
                                count: ::std::os::raw::c_int,
                                arg1: root::SkBlendMode,
                                cullRect: *const root::SkRect,
                                paint: *const root::SkPaint) {
            SkCanvas_drawAtlas(&mut *self, atlas, xform, tex, colors, count,
                               arg1, cullRect, paint)
        }
        #[inline]
        pub unsafe fn drawDrawable(&mut self, drawable: *mut root::SkDrawable,
                                   arg1: *const root::SkMatrix) {
            SkCanvas_drawDrawable(&mut *self, drawable, arg1)
        }
        #[inline]
        pub unsafe fn drawDrawable1(&mut self, arg1: *mut root::SkDrawable,
                                    x: root::SkScalar, y: root::SkScalar) {
            SkCanvas_drawDrawable1(&mut *self, arg1, x, y)
        }
        #[inline]
        pub unsafe fn drawAnnotation(&mut self, arg1: *const root::SkRect,
                                     key: *const ::std::os::raw::c_char,
                                     value: *mut root::SkData) {
            SkCanvas_drawAnnotation(&mut *self, arg1, key, value)
        }
        #[inline]
        pub unsafe fn getTotalMatrix(&self) -> *const root::SkMatrix {
            SkCanvas_getTotalMatrix(&*self)
        }
        #[inline]
        pub unsafe fn replayClips(&self,
                                  arg1: *mut root::SkCanvas_ClipVisitor) {
            SkCanvas_replayClips(&*self, arg1)
        }
        #[inline]
        pub unsafe fn internal_private_accessTopLayerRenderTargetContext(&mut self)
         -> *mut root::GrRenderTargetContext {
            SkCanvas_internal_private_accessTopLayerRenderTargetContext(&mut *self)
        }
        #[inline]
        pub unsafe fn Internal_Private_SetIgnoreSaveLayerBounds(arg1: bool) {
            SkCanvas_Internal_Private_SetIgnoreSaveLayerBounds(arg1)
        }
        #[inline]
        pub unsafe fn Internal_Private_GetIgnoreSaveLayerBounds() -> bool {
            SkCanvas_Internal_Private_GetIgnoreSaveLayerBounds()
        }
        #[inline]
        pub unsafe fn Internal_Private_SetTreatSpriteAsBitmap(arg1: bool) {
            SkCanvas_Internal_Private_SetTreatSpriteAsBitmap(arg1)
        }
        #[inline]
        pub unsafe fn Internal_Private_GetTreatSpriteAsBitmap() -> bool {
            SkCanvas_Internal_Private_GetTreatSpriteAsBitmap()
        }
        #[inline]
        pub unsafe fn legacy_drawImageRect(&mut self,
                                           image: *const root::SkImage,
                                           src: *const root::SkRect,
                                           dst: *const root::SkRect,
                                           paint: *const root::SkPaint,
                                           constraint:
                                               root::SkCanvas_SrcRectConstraint) {
            SkCanvas_legacy_drawImageRect(&mut *self, image, src, dst, paint,
                                          constraint)
        }
        #[inline]
        pub unsafe fn legacy_drawBitmapRect(&mut self,
                                            bitmap: *const root::SkBitmap,
                                            src: *const root::SkRect,
                                            dst: *const root::SkRect,
                                            paint: *const root::SkPaint,
                                            constraint:
                                                root::SkCanvas_SrcRectConstraint) {
            SkCanvas_legacy_drawBitmapRect(&mut *self, bitmap, src, dst,
                                           paint, constraint)
        }
        #[inline]
        pub unsafe fn temporary_internal_describeTopLayer(&mut self,
                                                          matrix:
                                                              *mut root::SkMatrix,
                                                          clip_bounds:
                                                              *mut root::SkIRect) {
            SkCanvas_temporary_internal_describeTopLayer(&mut *self, matrix,
                                                         clip_bounds)
        }
        #[inline]
        pub unsafe fn clipRectBounds(&mut self, bounds: *const root::SkRect,
                                     arg1: root::SkCanvas_SaveLayerFlags,
                                     intersection: *mut root::SkIRect,
                                     imageFilter: *const root::SkImageFilter)
         -> bool {
            SkCanvas_clipRectBounds(&mut *self, bounds, arg1, intersection,
                                    imageFilter)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkCanvas_SkCanvas(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(width: ::std::os::raw::c_int,
                           height: ::std::os::raw::c_int,
                           arg1: *const root::SkSurfaceProps) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkCanvas_SkCanvas1(&mut __bindgen_tmp, width, height, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(device: *mut root::SkBaseDevice) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkCanvas_SkCanvas2(&mut __bindgen_tmp, device);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(bitmap: *const root::SkBitmap) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkCanvas_SkCanvas3(&mut __bindgen_tmp, bitmap);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(bitmap: *const root::SkBitmap,
                           props: *const root::SkSurfaceProps) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkCanvas_SkCanvas4(&mut __bindgen_tmp, bitmap, props);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    pub struct SkImageGenerator__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkImageGenerator {
        pub vtable_: *const SkImageGenerator__bindgen_vtable,
        pub fInfo: root::SkImageInfo,
        pub fUniqueID: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImageGenerator_SupportedSizes {
        pub fSizes: [root::SkISize; 2usize],
    }
    #[test]
    fn bindgen_test_layout_SkImageGenerator_SupportedSizes() {
        assert_eq!(::std::mem::size_of::<SkImageGenerator_SupportedSizes>() ,
                   16usize);
        assert_eq!(::std::mem::align_of::<SkImageGenerator_SupportedSizes>() ,
                   4usize);
    }
    impl Clone for SkImageGenerator_SupportedSizes {
        fn clone(&self) -> Self { *self }
    }
    /**
     *  External generator API: provides efficient access to externally-managed image data.
     *
     *  Skia calls accessScaledPixels() during rasterization, to gain temporary access to
     *  the external pixel data.  When done, the provided callback is invoked to release the
     *  associated resources.
     *
     *  @param srcRect     the source rect in use for the current draw
     *  @param totalMatrix full matrix in effect (mapping srcRect -> device space)
     *  @param quality     the SkFilterQuality requested for rasterization.
     *  @param rec         out param, expected to be set when the call succeeds:
     *
     *                       - fPixmap      external pixel data
     *                       - fSrcRect     is an adjusted srcRect
     *                       - fQuality     is the adjusted filter quality
     *                       - fReleaseProc pixmap release callback, same signature as the
     *                                      SkBitmap::installPixels() callback
     *                       - fReleaseCtx  opaque release context argument
     *
     *  @return            true on success, false otherwise (error or if this API is not supported;
     *                     in this case Skia will fall back to its internal scaling and caching
     *                     heuristics)
     *
     *  Implementors can return pixmaps with a different size than requested, by adjusting the
     *  src rect.  The contract is that Skia will observe the adjusted src rect, and will map it
     *  to the same dest as the original draw (the impl doesn't get to control the destination).
     *
     */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkImageGenerator_ScaledImageRec {
        pub fPixmap: root::SkPixmap,
        pub fSrcRect: root::SkRect,
        pub fQuality: root::SkFilterQuality,
        pub fReleaseProc: root::SkImageGenerator_ScaledImageRec_ReleaseProcT,
        pub fReleaseCtx: *mut ::std::os::raw::c_void,
    }
    pub type SkImageGenerator_ScaledImageRec_ReleaseProcT =
        ::std::option::Option<unsafe extern "C" fn(pixels:
                                                       *mut ::std::os::raw::c_void,
                                                   releaseCtx:
                                                       *mut ::std::os::raw::c_void)>;
    #[test]
    fn bindgen_test_layout_SkImageGenerator_ScaledImageRec() {
        assert_eq!(::std::mem::size_of::<SkImageGenerator_ScaledImageRec>() ,
                   88usize);
        assert_eq!(::std::mem::align_of::<SkImageGenerator_ScaledImageRec>() ,
                   8usize);
    }
    pub const SkImageGenerator_kNeedNewImageUniqueID:
              root::SkImageGenerator__bindgen_ty_1 =
        SkImageGenerator__bindgen_ty_1::kNeedNewImageUniqueID;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkImageGenerator__bindgen_ty_1 { kNeedNewImageUniqueID = 0, }
    #[test]
    fn bindgen_test_layout_SkImageGenerator() {
        assert_eq!(::std::mem::size_of::<SkImageGenerator>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkImageGenerator>() , 8usize);
    }
    extern "C" {
        /**
     *  Decode into the given pixels, a block of memory of size at
     *  least (info.fHeight - 1) * rowBytes + (info.fWidth *
     *  bytesPerPixel)
     *
     *  Repeated calls to this function should give the same results,
     *  allowing the PixelRef to be immutable.
     *
     *  @param info A description of the format (config, size)
     *         expected by the caller.  This can simply be identical
     *         to the info returned by getInfo().
     *
     *         This contract also allows the caller to specify
     *         different output-configs, which the implementation can
     *         decide to support or not.
     *
     *         A size that does not match getInfo() implies a request
     *         to scale. If the generator cannot perform this scale,
     *         it will return kInvalidScale.
     *
     *  If info is kIndex8_SkColorType, then the caller must provide storage for up to 256
     *  SkPMColor values in ctable. On success the generator must copy N colors into that storage,
     *  (where N is the logical number of table entries) and set ctableCount to N.
     *
     *  If info is not kIndex8_SkColorType, then the last two parameters may be NULL. If ctableCount
     *  is not null, it will be set to 0.
     *
     *  @return true on success.
     */
        #[link_name =
              "?getPixels@SkImageGenerator@@QEAA_NAEBUSkImageInfo@@PEAX_KQEAIPEAH@Z"]
        pub fn SkImageGenerator_getPixels(this: *mut root::SkImageGenerator,
                                          info: *const root::SkImageInfo,
                                          pixels: *mut ::std::os::raw::c_void,
                                          rowBytes: usize,
                                          ctable: *mut root::SkPMColor,
                                          ctableCount:
                                              *mut ::std::os::raw::c_int)
         -> bool;
    }
    extern "C" {
        /**
     *  Simplified version of getPixels() that asserts that info is NOT kIndex8_SkColorType and
     *  uses the default Options.
     */
        #[link_name =
              "?getPixels@SkImageGenerator@@QEAA_NAEBUSkImageInfo@@PEAX_K@Z"]
        pub fn SkImageGenerator_getPixels1(this: *mut root::SkImageGenerator,
                                           info: *const root::SkImageInfo,
                                           pixels:
                                               *mut ::std::os::raw::c_void,
                                           rowBytes: usize) -> bool;
    }
    extern "C" {
        /**
     *  If decoding to YUV is supported, this returns true.  Otherwise, this
     *  returns false and does not modify any of the parameters.
     *
     *  @param sizeInfo   Output parameter indicating the sizes and required
     *                    allocation widths of the Y, U, and V planes.
     *  @param colorSpace Output parameter.
     */
        #[link_name =
              "?queryYUV8@SkImageGenerator@@QEBA_NPEAUSkYUVSizeInfo@@PEAW4SkYUVColorSpace@@@Z"]
        pub fn SkImageGenerator_queryYUV8(this: *const root::SkImageGenerator,
                                          sizeInfo: *mut root::SkYUVSizeInfo,
                                          colorSpace:
                                              *mut root::SkYUVColorSpace)
         -> bool;
    }
    extern "C" {
        /**
     *  Returns true on success and false on failure.
     *  This always attempts to perform a full decode.  If the client only
     *  wants size, it should call queryYUV8().
     *
     *  @param sizeInfo   Needs to exactly match the values returned by the
     *                    query, except the WidthBytes may be larger than the
     *                    recommendation (but not smaller).
     *  @param planes     Memory for each of the Y, U, and V planes.
     */
        #[link_name =
              "?getYUV8Planes@SkImageGenerator@@QEAA_NAEBUSkYUVSizeInfo@@QEAPEAX@Z"]
        pub fn SkImageGenerator_getYUV8Planes(this:
                                                  *mut root::SkImageGenerator,
                                              sizeInfo:
                                                  *const root::SkYUVSizeInfo,
                                              planes:
                                                  *mut *mut ::std::os::raw::c_void)
         -> bool;
    }
    extern "C" {
        /**
     *  If the generator can natively/efficiently return its pixels as a GPU image (backed by a
     *  texture) this will return that image. If not, this will return NULL.
     *
     *  Regarding the GrContext parameter:
     *
     *  The caller may pass NULL for the context. In that case the generator may assume that its
     *  internal context is current. If it has no internal context, then it should just return
     *  null.
     *
     *  If the caller passes a non-null context, then the generator should only succeed if:
     *  - it has no intrinsic context, and will use the caller's
     *  - its internal context is the same
     *  - it can somehow convert its texture into one that is valid for the provided context.
     */
        #[link_name =
              "?generateTexture@SkImageGenerator@@QEAAPEAVGrTexture@@PEAVGrContext@@PEBUSkIRect@@@Z"]
        pub fn SkImageGenerator_generateTexture(this:
                                                    *mut root::SkImageGenerator,
                                                arg1: *mut root::GrContext,
                                                subset: *const root::SkIRect)
         -> *mut root::GrTexture;
    }
    extern "C" {
        /**
     *  Some generators can efficiently scale their contents. If this is supported, the generator
     *  may only support certain scaled dimensions. Call this with the desired scale factor,
     *  and it will return true if scaling is supported, and in supportedSizes[] it will return
     *  the nearest supported dimensions.
     *
     *  If no native scaling is supported, or scale is invalid (e.g. scale <= 0 || scale > 1)
     *  this will return false, and the supportedsizes will be undefined.
     */
        #[link_name =
              "?computeScaledDimensions@SkImageGenerator@@QEAA_NMPEAUSupportedSizes@1@@Z"]
        pub fn SkImageGenerator_computeScaledDimensions(this:
                                                            *mut root::SkImageGenerator,
                                                        scale: root::SkScalar,
                                                        arg1:
                                                            *mut root::SkImageGenerator_SupportedSizes)
         -> bool;
    }
    extern "C" {
        /**
     *  Scale the generator's pixels to fit into scaledSize.
     *  This routine also support retrieving only a subset of the pixels. That subset is specified
     *  by the following rectangle (in the scaled space):
     *
     *      subset = SkIRect::MakeXYWH(subsetOrigin.x(), subsetOrigin.y(),
     *                                 subsetPixels.width(), subsetPixels.height())
     *
     *  If subset is not contained inside the scaledSize, this returns false.
     *
     *      whole = SkIRect::MakeWH(scaledSize.width(), scaledSize.height())
     *      if (!whole.contains(subset)) {
     *          return false;
     *      }
     *
     *  If the requested colortype/alphatype in pixels is not supported,
     *  or the requested scaledSize is not supported, or the generator encounters an error,
     *  this returns false.
     */
        #[link_name =
              "?generateScaledPixels@SkImageGenerator@@QEAA_NAEBU?$SkTSize@H@@AEBUSkIPoint@@AEBVSkPixmap@@@Z"]
        pub fn SkImageGenerator_generateScaledPixels(this:
                                                         *mut root::SkImageGenerator,
                                                     scaledSize:
                                                         *const root::SkISize,
                                                     subsetOrigin:
                                                         *const root::SkIPoint,
                                                     subsetPixels:
                                                         *const root::SkPixmap)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?accessScaledImage@SkImageGenerator@@QEAA_NAEBUSkRect@@AEBVSkMatrix@@W4SkFilterQuality@@PEAUScaledImageRec@1@@Z"]
        pub fn SkImageGenerator_accessScaledImage(this:
                                                      *mut root::SkImageGenerator,
                                                  srcRect:
                                                      *const root::SkRect,
                                                  totalMatrix:
                                                      *const root::SkMatrix,
                                                  quality:
                                                      root::SkFilterQuality,
                                                  rec:
                                                      *mut root::SkImageGenerator_ScaledImageRec)
         -> bool;
    }
    extern "C" {
        /**
     *  If the default image decoder system can interpret the specified (encoded) data, then
     *  this returns a new ImageGenerator for it. Otherwise this returns NULL. Either way
     *  the caller is still responsible for managing their ownership of the data.
     */
        #[link_name =
              "?NewFromEncoded@SkImageGenerator@@SAPEAV1@PEAVSkData@@@Z"]
        pub fn SkImageGenerator_NewFromEncoded(arg1: *mut root::SkData)
         -> *mut root::SkImageGenerator;
    }
    extern "C" {
        /** Return a new image generator backed by the specified picture.  If the size is empty or
     *  the picture is NULL, this returns NULL.
     *  The optional matrix and paint arguments are passed to drawPicture() at rasterization
     *  time.
     */
        #[link_name =
              "?NewFromPicture@SkImageGenerator@@SAPEAV1@AEBU?$SkTSize@H@@PEBVSkPicture@@PEBVSkMatrix@@PEBVSkPaint@@@Z"]
        pub fn SkImageGenerator_NewFromPicture(arg1: *const root::SkISize,
                                               arg2: *const root::SkPicture,
                                               arg3: *const root::SkMatrix,
                                               arg4: *const root::SkPaint)
         -> *mut root::SkImageGenerator;
    }
    extern "C" {
        #[link_name =
              "?tryGenerateBitmap@SkImageGenerator@@IEAA_NPEAVSkBitmap@@PEBUSkImageInfo@@PEAVAllocator@2@@Z"]
        pub fn SkImageGenerator_tryGenerateBitmap(this:
                                                      *mut root::SkImageGenerator,
                                                  bm: *mut root::SkBitmap,
                                                  optionalInfo:
                                                      *const root::SkImageInfo,
                                                  arg1:
                                                      *mut root::SkBitmap_Allocator)
         -> bool;
    }
    extern "C" {
        #[link_name = "??0SkImageGenerator@@IEAA@AEBUSkImageInfo@@I@Z"]
        pub fn SkImageGenerator_SkImageGenerator(this:
                                                     *mut root::SkImageGenerator,
                                                 info:
                                                     *const root::SkImageInfo,
                                                 uniqueId: u32);
    }
    impl SkImageGenerator {
        #[inline]
        pub unsafe fn getPixels(&mut self, info: *const root::SkImageInfo,
                                pixels: *mut ::std::os::raw::c_void,
                                rowBytes: usize, ctable: *mut root::SkPMColor,
                                ctableCount: *mut ::std::os::raw::c_int)
         -> bool {
            SkImageGenerator_getPixels(&mut *self, info, pixels, rowBytes,
                                       ctable, ctableCount)
        }
        #[inline]
        pub unsafe fn getPixels1(&mut self, info: *const root::SkImageInfo,
                                 pixels: *mut ::std::os::raw::c_void,
                                 rowBytes: usize) -> bool {
            SkImageGenerator_getPixels1(&mut *self, info, pixels, rowBytes)
        }
        #[inline]
        pub unsafe fn queryYUV8(&self, sizeInfo: *mut root::SkYUVSizeInfo,
                                colorSpace: *mut root::SkYUVColorSpace)
         -> bool {
            SkImageGenerator_queryYUV8(&*self, sizeInfo, colorSpace)
        }
        #[inline]
        pub unsafe fn getYUV8Planes(&mut self,
                                    sizeInfo: *const root::SkYUVSizeInfo,
                                    planes: *mut *mut ::std::os::raw::c_void)
         -> bool {
            SkImageGenerator_getYUV8Planes(&mut *self, sizeInfo, planes)
        }
        #[inline]
        pub unsafe fn generateTexture(&mut self, arg1: *mut root::GrContext,
                                      subset: *const root::SkIRect)
         -> *mut root::GrTexture {
            SkImageGenerator_generateTexture(&mut *self, arg1, subset)
        }
        #[inline]
        pub unsafe fn computeScaledDimensions(&mut self,
                                              scale: root::SkScalar,
                                              arg1:
                                                  *mut root::SkImageGenerator_SupportedSizes)
         -> bool {
            SkImageGenerator_computeScaledDimensions(&mut *self, scale, arg1)
        }
        #[inline]
        pub unsafe fn generateScaledPixels(&mut self,
                                           scaledSize: *const root::SkISize,
                                           subsetOrigin:
                                               *const root::SkIPoint,
                                           subsetPixels:
                                               *const root::SkPixmap)
         -> bool {
            SkImageGenerator_generateScaledPixels(&mut *self, scaledSize,
                                                  subsetOrigin, subsetPixels)
        }
        #[inline]
        pub unsafe fn accessScaledImage(&mut self,
                                        srcRect: *const root::SkRect,
                                        totalMatrix: *const root::SkMatrix,
                                        quality: root::SkFilterQuality,
                                        rec:
                                            *mut root::SkImageGenerator_ScaledImageRec)
         -> bool {
            SkImageGenerator_accessScaledImage(&mut *self, srcRect,
                                               totalMatrix, quality, rec)
        }
        #[inline]
        pub unsafe fn NewFromEncoded(arg1: *mut root::SkData)
         -> *mut root::SkImageGenerator {
            SkImageGenerator_NewFromEncoded(arg1)
        }
        #[inline]
        pub unsafe fn NewFromPicture(arg1: *const root::SkISize,
                                     arg2: *const root::SkPicture,
                                     arg3: *const root::SkMatrix,
                                     arg4: *const root::SkPaint)
         -> *mut root::SkImageGenerator {
            SkImageGenerator_NewFromPicture(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn tryGenerateBitmap(&mut self, bm: *mut root::SkBitmap,
                                        optionalInfo:
                                            *const root::SkImageInfo,
                                        arg1: *mut root::SkBitmap_Allocator)
         -> bool {
            SkImageGenerator_tryGenerateBitmap(&mut *self, bm, optionalInfo,
                                               arg1)
        }
        #[inline]
        pub unsafe fn new(info: *const root::SkImageInfo, uniqueId: u32)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkImageGenerator_SkImageGenerator(&mut __bindgen_tmp, info,
                                              uniqueId);
            __bindgen_tmp
        }
    }
    /**
 *  Interface for serializing pixels, e.g. SkBitmaps in an SkPicture.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPixelSerializer {
        pub _base: root::SkRefCnt,
    }
    #[test]
    fn bindgen_test_layout_SkPixelSerializer() {
        assert_eq!(::std::mem::size_of::<SkPixelSerializer>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkPixelSerializer>() , 8usize);
    }
    /**
 *  SkSurface represents the backend/results of drawing to a canvas. For raster
 *  drawing, the surface will be pixels, but (for example) when drawing into
 *  a PDF or Picture canvas, the surface stores the recorded commands.
 *
 *  To draw into a canvas, first create the appropriate type of Surface, and
 *  then request the canvas from the surface.
 *
 *  SkSurface always has non-zero dimensions. If there is a request for a new surface, and either
 *  of the requested dimensions are zero, then NULL will be returned.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkSurface {
        pub _base: root::SkRefCnt,
        pub fProps: root::SkSurfaceProps,
        pub fWidth: ::std::os::raw::c_int,
        pub fHeight: ::std::os::raw::c_int,
        pub fGenerationID: u32,
    }
    #[repr(i32)]
    /**
     *  Modes that can be passed to notifyContentWillChange
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkSurface_ContentChangeMode {
        kDiscard_ContentChangeMode = 0,
        kRetain_ContentChangeMode = 1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkSurface_BackendHandleAccess {
        kFlushRead_BackendHandleAccess = 0,
        kFlushWrite_BackendHandleAccess = 1,
        kDiscardWrite_BackendHandleAccess = 2,
    }
    #[repr(i32)]
    /**
     * In rare instances a client may want a unique copy of the SkSurface's contents in an image
     * snapshot. This enum can be used to enforce that the image snapshot's backing store is not
     * shared with another image snapshot or the surface's backing store. This is generally more
     * expensive. This was added for Chromium bug 585250.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkSurface_ForceUnique {
        kNo_ForceUnique = 0,
        kYes_ForceUnique = 1,
    }
    pub type SkSurface_INHERITED = root::SkRefCnt;
    extern "C" {
        #[link_name =
              "?kFlushRead_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"]
        pub static SkSurface_kFlushRead_TextureHandleAccess:
                   root::SkSurface_BackendHandleAccess;
    }
    extern "C" {
        #[link_name =
              "?kFlushWrite_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"]
        pub static SkSurface_kFlushWrite_TextureHandleAccess:
                   root::SkSurface_BackendHandleAccess;
    }
    extern "C" {
        #[link_name =
              "?kDiscardWrite_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"]
        pub static SkSurface_kDiscardWrite_TextureHandleAccess:
                   root::SkSurface_BackendHandleAccess;
    }
    #[test]
    fn bindgen_test_layout_SkSurface() {
        assert_eq!(::std::mem::size_of::<SkSurface>() , 40usize);
        assert_eq!(::std::mem::align_of::<SkSurface>() , 8usize);
    }
    extern "C" {
        /**
     *  Create a new surface, using the specified pixels/rowbytes as its
     *  backend.
     *
     *  If the requested surface cannot be created, or the request is not a
     *  supported configuration, NULL will be returned.
     *
     *  Callers are responsible for initialiazing the surface pixels.
     */
        #[link_name =
              "?MakeRasterDirect@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEAX_KPEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeRasterDirect(arg1: *const root::SkImageInfo,
                                          pixels: *mut ::std::os::raw::c_void,
                                          rowBytes: usize,
                                          arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  The same as NewRasterDirect, but also accepts a call-back routine, which is invoked
     *  when the surface is deleted, and is passed the pixel memory and the specified context.
     */
        #[link_name =
              "?MakeRasterDirectReleaseProc@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEAX_KP6AX11@Z1PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeRasterDirectReleaseProc(arg1:
                                                         *const root::SkImageInfo,
                                                     pixels:
                                                         *mut ::std::os::raw::c_void,
                                                     rowBytes: usize,
                                                     releaseProc:
                                                         ::std::option::Option<unsafe extern "C" fn(pixels:
                                                                                                        *mut ::std::os::raw::c_void,
                                                                                                    context:
                                                                                                        *mut ::std::os::raw::c_void)>,
                                                     context:
                                                         *mut ::std::os::raw::c_void,
                                                     arg2:
                                                         *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Return a new surface, with the memory for the pixels automatically allocated and
     *  zero-initialized, but respecting the specified rowBytes. If rowBytes==0, then a default
     *  value will be chosen. If a non-zero rowBytes is specified, then any images snapped off of
     *  this surface (via makeImageSnapshot()) are guaranteed to have the same rowBytes.
     *
     *  If the requested surface cannot be created, or the request is not a
     *  supported configuration, NULL will be returned.
     */
        #[link_name =
              "?MakeRaster@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@_KPEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeRaster(arg1: *const root::SkImageInfo,
                                    rowBytes: usize,
                                    arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Used to wrap a pre-existing backend 3D API texture as a SkSurface. The kRenderTarget flag
     *  must be set on GrBackendTextureDesc for this to succeed. Skia will not assume ownership
     *  of the texture and the client must ensure the texture is valid for the lifetime of the
     *  SkSurface.
     */
        #[link_name =
              "?MakeFromBackendTexture@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeFromBackendTexture(arg1: *mut root::GrContext,
                                                arg2:
                                                    *const root::GrBackendTextureDesc,
                                                arg3:
                                                    root::sk_sp<root::SkColorSpace>,
                                                arg4:
                                                    *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Used to wrap a pre-existing 3D API rendering target as a SkSurface. Skia will not assume
     *  ownership of the render target and the client must ensure the render target is valid for the
     *  lifetime of the SkSurface.
     */
        #[link_name =
              "?MakeFromBackendRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@AEBUGrBackendRenderTargetDesc@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeFromBackendRenderTarget(arg1:
                                                         *mut root::GrContext,
                                                     arg2:
                                                         *const root::GrBackendRenderTargetDesc,
                                                     arg3:
                                                         root::sk_sp<root::SkColorSpace>,
                                                     arg4:
                                                         *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Used to wrap a pre-existing 3D API texture as a SkSurface. Skia will treat the texture as
     *  a rendering target only, but unlike NewFromBackendRenderTarget, Skia will manage and own
     *  the associated render target objects (but not the provided texture). The kRenderTarget flag
     *  must be set on GrBackendTextureDesc for this to succeed. Skia will not assume ownership
     *  of the texture and the client must ensure the texture is valid for the lifetime of the
     *  SkSurface.
     */
        #[link_name =
              "?MakeFromBackendTextureAsRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@AEBUGrBackendTextureDesc@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeFromBackendTextureAsRenderTarget(arg1:
                                                                  *mut root::GrContext,
                                                              arg2:
                                                                  *const root::GrBackendTextureDesc,
                                                              arg3:
                                                                  root::sk_sp<root::SkColorSpace>,
                                                              arg4:
                                                                  *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Return a new surface whose contents will be drawn to an offscreen
     *  render target, allocated by the surface.
     */
        #[link_name =
              "?MakeRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrContext@@W4SkBudgeted@@AEBUSkImageInfo@@HW4GrSurfaceOrigin@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_MakeRenderTarget(arg1: *mut root::GrContext,
                                          arg2: root::SkBudgeted,
                                          arg3: *const root::SkImageInfo,
                                          sampleCount: ::std::os::raw::c_int,
                                          arg4: root::GrSurfaceOrigin,
                                          arg5: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Returns a unique non-zero, unique value identifying the content of this
     *  surface. Each time the content is changed changed, either by drawing
     *  into this surface, or explicitly calling notifyContentChanged()) this
     *  method will return a new value.
     *
     *  If this surface is empty (i.e. has a zero-dimention), this will return
     *  0.
     */
        #[link_name = "?generationID@SkSurface@@QEAAIXZ"]
        pub fn SkSurface_generationID(this: *mut root::SkSurface) -> u32;
    }
    extern "C" {
        /**
     *  Call this if the contents are about to change. This will (lazily) force a new
     *  value to be returned from generationID() when it is called next.
     *
     *  CAN WE DEPRECATE THIS?
     */
        #[link_name =
              "?notifyContentWillChange@SkSurface@@QEAAXW4ContentChangeMode@1@@Z"]
        pub fn SkSurface_notifyContentWillChange(this: *mut root::SkSurface,
                                                 mode:
                                                     root::SkSurface_ContentChangeMode);
    }
    extern "C" {
        /**
     *  Retrieves the backend API handle of the texture used by this surface, or 0 if the surface
     *  is not backed by a GPU texture.
     *
     *  The returned texture-handle is only valid until the next draw-call into the surface,
     *  or the surface is deleted.
     */
        #[link_name =
              "?getTextureHandle@SkSurface@@QEAA_JW4BackendHandleAccess@1@@Z"]
        pub fn SkSurface_getTextureHandle(this: *mut root::SkSurface,
                                          arg1:
                                              root::SkSurface_BackendHandleAccess)
         -> root::GrBackendObject;
    }
    extern "C" {
        /**
     *  Retrieves the backend API handle of the RenderTarget backing this surface.  Callers must
     *  ensure this function returns 'true' or else the GrBackendObject will be invalid
     *
     *  In OpenGL this will return the FramebufferObject ID.
     */
        #[link_name =
              "?getRenderTargetHandle@SkSurface@@QEAA_NPEA_JW4BackendHandleAccess@1@@Z"]
        pub fn SkSurface_getRenderTargetHandle(this: *mut root::SkSurface,
                                               arg1:
                                                   *mut root::GrBackendObject,
                                               arg2:
                                                   root::SkSurface_BackendHandleAccess)
         -> bool;
    }
    extern "C" {
        /**
     *  Return a canvas that will draw into this surface. This will always
     *  return the same canvas for a given surface, and is manged/owned by the
     *  surface. It should not be used when its parent surface has gone out of
     *  scope.
     */
        #[link_name = "?getCanvas@SkSurface@@QEAAPEAVSkCanvas@@XZ"]
        pub fn SkSurface_getCanvas(this: *mut root::SkSurface)
         -> *mut root::SkCanvas;
    }
    extern "C" {
        /**
     *  Return a new surface that is "compatible" with this one, in that it will
     *  efficiently be able to be drawn into this surface. Typical calling
     *  pattern:
     *
     *  SkSurface* A = SkSurface::New...();
     *  SkCanvas* canvasA = surfaceA->newCanvas();
     *  ...
     *  SkSurface* surfaceB = surfaceA->newSurface(...);
     *  SkCanvas* canvasB = surfaceB->newCanvas();
     *  ... // draw using canvasB
     *  canvasA->drawSurface(surfaceB); // <--- this will always be optimal!
     */
        #[link_name =
              "?makeSurface@SkSurface@@QEAA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@@Z"]
        pub fn SkSurface_makeSurface(this: *mut root::SkSurface,
                                     arg1: *const root::SkImageInfo)
         -> root::sk_sp<root::SkSurface>;
    }
    extern "C" {
        /**
     *  Returns an image of the current state of the surface pixels up to this
     *  point. Subsequent changes to the surface (by drawing into its canvas)
     *  will not be reflected in this image. If a copy must be made the Budgeted
     *  parameter controls whether it counts against the resource budget
     *  (currently for the gpu backend only).
     */
        #[link_name =
              "?makeImageSnapshot@SkSurface@@QEAA?AV?$sk_sp@VSkImage@@@@W4SkBudgeted@@@Z"]
        pub fn SkSurface_makeImageSnapshot(this: *mut root::SkSurface,
                                           arg1: root::SkBudgeted)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        #[link_name =
              "?makeImageSnapshot@SkSurface@@QEAA?AV?$sk_sp@VSkImage@@@@W4SkBudgeted@@W4ForceUnique@1@@Z"]
        pub fn SkSurface_makeImageSnapshot1(this: *mut root::SkSurface,
                                            arg1: root::SkBudgeted,
                                            arg2: root::SkSurface_ForceUnique)
         -> root::sk_sp<root::SkImage>;
    }
    extern "C" {
        /**
     *  Though the caller could get a snapshot image explicitly, and draw that,
     *  it seems that directly drawing a surface into another canvas might be
     *  a common pattern, and that we could possibly be more efficient, since
     *  we'd know that the "snapshot" need only live until we've handed it off
     *  to the canvas.
     */
        #[link_name = "?draw@SkSurface@@QEAAXPEAVSkCanvas@@MMPEBVSkPaint@@@Z"]
        pub fn SkSurface_draw(this: *mut root::SkSurface,
                              arg1: *mut root::SkCanvas, x: root::SkScalar,
                              y: root::SkScalar, arg2: *const root::SkPaint);
    }
    extern "C" {
        /**
     *  If the surface has direct access to its pixels (i.e. they are in local
     *  RAM) return true, and if not null, set the pixmap parameter to point to the information
     *  about the surface's pixels. The pixel address in the pixmap is only valid while
     *  the surface object is in scope, and no API call is made on the surface
     *  or its canvas.
     *
     *  On failure, returns false and the pixmap parameter is ignored.
     */
        #[link_name = "?peekPixels@SkSurface@@QEAA_NPEAVSkPixmap@@@Z"]
        pub fn SkSurface_peekPixels(this: *mut root::SkSurface,
                                    arg1: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Copy the pixels from the surface into the specified buffer (pixels + rowBytes),
     *  converting them into the requested format (dstInfo). The surface pixels are read
     *  starting at the specified (srcX,srcY) location.
     *
     *  The specified ImageInfo and (srcX,srcY) offset specifies a source rectangle
     *
     *      srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
     *
     *  srcR is intersected with the bounds of the base-layer. If this intersection is not empty,
     *  then we have two sets of pixels (of equal size). Replace the dst pixels with the
     *  corresponding src pixels, performing any colortype/alphatype transformations needed
     *  (in the case where the src and dst have different colortypes or alphatypes).
     *
     *  This call can fail, returning false, for several reasons:
     *  - If srcR does not intersect the surface bounds.
     *  - If the requested colortype/alphatype cannot be converted from the surface's types.
     */
        #[link_name =
              "?readPixels@SkSurface@@QEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
        pub fn SkSurface_readPixels(this: *mut root::SkSurface,
                                    dstInfo: *const root::SkImageInfo,
                                    dstPixels: *mut ::std::os::raw::c_void,
                                    dstRowBytes: usize,
                                    srcX: ::std::os::raw::c_int,
                                    srcY: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     * Issue any pending surface IO to the current backend 3D API and resolve any surface MSAA.
     */
        #[link_name = "?prepareForExternalIO@SkSurface@@QEAAXXZ"]
        pub fn SkSurface_prepareForExternalIO(this: *mut root::SkSurface);
    }
    extern "C" {
        #[link_name = "??0SkSurface@@IEAA@HHPEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_SkSurface(this: *mut root::SkSurface,
                                   width: ::std::os::raw::c_int,
                                   height: ::std::os::raw::c_int,
                                   arg1: *const root::SkSurfaceProps);
    }
    extern "C" {
        #[link_name =
              "??0SkSurface@@IEAA@AEBUSkImageInfo@@PEBVSkSurfaceProps@@@Z"]
        pub fn SkSurface_SkSurface1(this: *mut root::SkSurface,
                                    arg1: *const root::SkImageInfo,
                                    arg2: *const root::SkSurfaceProps);
    }
    impl SkSurface {
        #[inline]
        pub unsafe fn MakeRasterDirect(arg1: *const root::SkImageInfo,
                                       pixels: *mut ::std::os::raw::c_void,
                                       rowBytes: usize,
                                       arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeRasterDirect(arg1, pixels, rowBytes, arg2)
        }
        #[inline]
        pub unsafe fn MakeRasterDirectReleaseProc(arg1:
                                                      *const root::SkImageInfo,
                                                  pixels:
                                                      *mut ::std::os::raw::c_void,
                                                  rowBytes: usize,
                                                  releaseProc:
                                                      ::std::option::Option<unsafe extern "C" fn(pixels:
                                                                                                     *mut ::std::os::raw::c_void,
                                                                                                 context:
                                                                                                     *mut ::std::os::raw::c_void)>,
                                                  context:
                                                      *mut ::std::os::raw::c_void,
                                                  arg2:
                                                      *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeRasterDirectReleaseProc(arg1, pixels, rowBytes,
                                                  releaseProc, context, arg2)
        }
        #[inline]
        pub unsafe fn MakeRaster(arg1: *const root::SkImageInfo,
                                 rowBytes: usize,
                                 arg2: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeRaster(arg1, rowBytes, arg2)
        }
        #[inline]
        pub unsafe fn MakeFromBackendTexture(arg1: *mut root::GrContext,
                                             arg2:
                                                 *const root::GrBackendTextureDesc,
                                             arg3:
                                                 root::sk_sp<root::SkColorSpace>,
                                             arg4:
                                                 *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeFromBackendTexture(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromBackendRenderTarget(arg1: *mut root::GrContext,
                                                  arg2:
                                                      *const root::GrBackendRenderTargetDesc,
                                                  arg3:
                                                      root::sk_sp<root::SkColorSpace>,
                                                  arg4:
                                                      *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeFromBackendRenderTarget(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn MakeFromBackendTextureAsRenderTarget(arg1:
                                                               *mut root::GrContext,
                                                           arg2:
                                                               *const root::GrBackendTextureDesc,
                                                           arg3:
                                                               root::sk_sp<root::SkColorSpace>,
                                                           arg4:
                                                               *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeFromBackendTextureAsRenderTarget(arg1, arg2, arg3,
                                                           arg4)
        }
        #[inline]
        pub unsafe fn MakeRenderTarget(arg1: *mut root::GrContext,
                                       arg2: root::SkBudgeted,
                                       arg3: *const root::SkImageInfo,
                                       sampleCount: ::std::os::raw::c_int,
                                       arg4: root::GrSurfaceOrigin,
                                       arg5: *const root::SkSurfaceProps)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_MakeRenderTarget(arg1, arg2, arg3, sampleCount, arg4,
                                       arg5)
        }
        #[inline]
        pub unsafe fn generationID(&mut self) -> u32 {
            SkSurface_generationID(&mut *self)
        }
        #[inline]
        pub unsafe fn notifyContentWillChange(&mut self,
                                              mode:
                                                  root::SkSurface_ContentChangeMode) {
            SkSurface_notifyContentWillChange(&mut *self, mode)
        }
        #[inline]
        pub unsafe fn getTextureHandle(&mut self,
                                       arg1:
                                           root::SkSurface_BackendHandleAccess)
         -> root::GrBackendObject {
            SkSurface_getTextureHandle(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn getRenderTargetHandle(&mut self,
                                            arg1: *mut root::GrBackendObject,
                                            arg2:
                                                root::SkSurface_BackendHandleAccess)
         -> bool {
            SkSurface_getRenderTargetHandle(&mut *self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn getCanvas(&mut self) -> *mut root::SkCanvas {
            SkSurface_getCanvas(&mut *self)
        }
        #[inline]
        pub unsafe fn makeSurface(&mut self, arg1: *const root::SkImageInfo)
         -> root::sk_sp<root::SkSurface> {
            SkSurface_makeSurface(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn makeImageSnapshot(&mut self, arg1: root::SkBudgeted)
         -> root::sk_sp<root::SkImage> {
            SkSurface_makeImageSnapshot(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn makeImageSnapshot1(&mut self, arg1: root::SkBudgeted,
                                         arg2: root::SkSurface_ForceUnique)
         -> root::sk_sp<root::SkImage> {
            SkSurface_makeImageSnapshot1(&mut *self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn draw(&mut self, arg1: *mut root::SkCanvas,
                           x: root::SkScalar, y: root::SkScalar,
                           arg2: *const root::SkPaint) {
            SkSurface_draw(&mut *self, arg1, x, y, arg2)
        }
        #[inline]
        pub unsafe fn peekPixels(&mut self, arg1: *mut root::SkPixmap)
         -> bool {
            SkSurface_peekPixels(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn readPixels(&mut self, dstInfo: *const root::SkImageInfo,
                                 dstPixels: *mut ::std::os::raw::c_void,
                                 dstRowBytes: usize,
                                 srcX: ::std::os::raw::c_int,
                                 srcY: ::std::os::raw::c_int) -> bool {
            SkSurface_readPixels(&mut *self, dstInfo, dstPixels, dstRowBytes,
                                 srcX, srcY)
        }
        #[inline]
        pub unsafe fn prepareForExternalIO(&mut self) {
            SkSurface_prepareForExternalIO(&mut *self)
        }
        #[inline]
        pub unsafe fn new(width: ::std::os::raw::c_int,
                          height: ::std::os::raw::c_int,
                          arg1: *const root::SkSurfaceProps) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkSurface_SkSurface(&mut __bindgen_tmp, width, height, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::SkImageInfo,
                           arg2: *const root::SkSurfaceProps) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkSurface_SkSurface1(&mut __bindgen_tmp, arg1, arg2);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrContextThreadSafeProxy {
        pub _address: u8,
    }
    impl Clone for GrContextThreadSafeProxy {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrTexture {
        pub _address: u8,
    }
    impl Clone for GrTexture {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkDeque {
        pub fFront: *mut ::std::os::raw::c_void,
        pub fBack: *mut ::std::os::raw::c_void,
        pub fFrontBlock: *mut root::SkDeque_Block,
        pub fBackBlock: *mut root::SkDeque_Block,
        pub fElemSize: usize,
        pub fInitialStorage: *mut ::std::os::raw::c_void,
        pub fCount: ::std::os::raw::c_int,
        pub fAllocCount: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDeque_Block {
        pub _address: u8,
    }
    impl Clone for SkDeque_Block {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDeque_Iter {
        pub fCurBlock: *mut root::SkDeque_Block,
        pub fPos: *mut ::std::os::raw::c_char,
        pub fElemSize: usize,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkDeque_Iter_IterStart {
        kFront_IterStart = 0,
        kBack_IterStart = 1,
    }
    #[test]
    fn bindgen_test_layout_SkDeque_Iter() {
        assert_eq!(::std::mem::size_of::<SkDeque_Iter>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkDeque_Iter>() , 8usize);
    }
    extern "C" {
        #[link_name = "?next@Iter@SkDeque@@QEAAPEAXXZ"]
        pub fn SkDeque_Iter_next(this: *mut root::SkDeque_Iter)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?prev@Iter@SkDeque@@QEAAPEAXXZ"]
        pub fn SkDeque_Iter_prev(this: *mut root::SkDeque_Iter)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?reset@Iter@SkDeque@@QEAAXAEBV2@W4IterStart@12@@Z"]
        pub fn SkDeque_Iter_reset(this: *mut root::SkDeque_Iter,
                                  d: *const root::SkDeque,
                                  startLoc: root::SkDeque_Iter_IterStart);
    }
    extern "C" {
        /**
         * Creates an uninitialized iterator. Must be reset()
         */
        #[link_name = "??0Iter@SkDeque@@QEAA@XZ"]
        pub fn SkDeque_Iter_Iter(this: *mut root::SkDeque_Iter);
    }
    extern "C" {
        #[link_name = "??0Iter@SkDeque@@QEAA@AEBV1@W4IterStart@01@@Z"]
        pub fn SkDeque_Iter_Iter1(this: *mut root::SkDeque_Iter,
                                  d: *const root::SkDeque,
                                  startLoc: root::SkDeque_Iter_IterStart);
    }
    impl Clone for SkDeque_Iter {
        fn clone(&self) -> Self { *self }
    }
    impl SkDeque_Iter {
        #[inline]
        pub unsafe fn next(&mut self) -> *mut ::std::os::raw::c_void {
            SkDeque_Iter_next(&mut *self)
        }
        #[inline]
        pub unsafe fn prev(&mut self) -> *mut ::std::os::raw::c_void {
            SkDeque_Iter_prev(&mut *self)
        }
        #[inline]
        pub unsafe fn reset(&mut self, d: *const root::SkDeque,
                            startLoc: root::SkDeque_Iter_IterStart) {
            SkDeque_Iter_reset(&mut *self, d, startLoc)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkDeque_Iter_Iter(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(d: *const root::SkDeque,
                           startLoc: root::SkDeque_Iter_IterStart) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkDeque_Iter_Iter1(&mut __bindgen_tmp, d, startLoc);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDeque_F2BIter {
        pub _base: root::SkDeque_Iter,
    }
    pub type SkDeque_F2BIter_INHERITED = root::SkDeque_Iter;
    #[test]
    fn bindgen_test_layout_SkDeque_F2BIter() {
        assert_eq!(::std::mem::size_of::<SkDeque_F2BIter>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkDeque_F2BIter>() , 8usize);
    }
    impl Clone for SkDeque_F2BIter {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_SkDeque() {
        assert_eq!(::std::mem::size_of::<SkDeque>() , 56usize);
        assert_eq!(::std::mem::align_of::<SkDeque>() , 8usize);
    }
    extern "C" {
        /**
     * push_front and push_back return a pointer to the memory space
     * for the new element
     */
        #[link_name = "?push_front@SkDeque@@QEAAPEAXXZ"]
        pub fn SkDeque_push_front(this: *mut root::SkDeque)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?push_back@SkDeque@@QEAAPEAXXZ"]
        pub fn SkDeque_push_back(this: *mut root::SkDeque)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?pop_front@SkDeque@@QEAAXXZ"]
        pub fn SkDeque_pop_front(this: *mut root::SkDeque);
    }
    extern "C" {
        #[link_name = "?pop_back@SkDeque@@QEAAXXZ"]
        pub fn SkDeque_pop_back(this: *mut root::SkDeque);
    }
    extern "C" {
        /**
     * elemSize specifies the size of each individual element in the deque
     * allocCount specifies how many elements are to be allocated as a block
     */
        #[link_name = "??0SkDeque@@QEAA@_KH@Z"]
        pub fn SkDeque_SkDeque(this: *mut root::SkDeque, elemSize: usize,
                               allocCount: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "??0SkDeque@@QEAA@_KPEAX0H@Z"]
        pub fn SkDeque_SkDeque1(this: *mut root::SkDeque, elemSize: usize,
                                storage: *mut ::std::os::raw::c_void,
                                storageSize: usize,
                                allocCount: ::std::os::raw::c_int);
    }
    impl SkDeque {
        #[inline]
        pub unsafe fn push_front(&mut self) -> *mut ::std::os::raw::c_void {
            SkDeque_push_front(&mut *self)
        }
        #[inline]
        pub unsafe fn push_back(&mut self) -> *mut ::std::os::raw::c_void {
            SkDeque_push_back(&mut *self)
        }
        #[inline]
        pub unsafe fn pop_front(&mut self) { SkDeque_pop_front(&mut *self) }
        #[inline]
        pub unsafe fn pop_back(&mut self) { SkDeque_pop_back(&mut *self) }
        #[inline]
        pub unsafe fn new(elemSize: usize, allocCount: ::std::os::raw::c_int)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkDeque_SkDeque(&mut __bindgen_tmp, elemSize, allocCount);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(elemSize: usize,
                           storage: *mut ::std::os::raw::c_void,
                           storageSize: usize,
                           allocCount: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkDeque_SkDeque1(&mut __bindgen_tmp, elemSize, storage,
                             storageSize, allocCount);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrRenderTargetContext {
        pub _address: u8,
    }
    impl Clone for GrRenderTargetContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBaseDevice {
        pub _base: root::SkRefCnt,
        pub fOrigin: root::SkIPoint,
        pub fMetaData: *mut root::SkMetaData,
        pub fInfo: root::SkImageInfo,
        pub fSurfaceProps: root::SkSurfaceProps,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkBaseDevice_TileUsage {
        kPossible_TileUsage = 0,
        kNever_TileUsage = 1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkBaseDevice_TextFlags {
        pub fFlags: u32,
    }
    #[test]
    fn bindgen_test_layout_SkBaseDevice_TextFlags() {
        assert_eq!(::std::mem::size_of::<SkBaseDevice_TextFlags>() , 4usize);
        assert_eq!(::std::mem::align_of::<SkBaseDevice_TextFlags>() , 4usize);
    }
    impl Clone for SkBaseDevice_TextFlags {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkBaseDevice_CreateInfo {
        pub fInfo: root::SkImageInfo,
        pub fTileUsage: root::SkBaseDevice_TileUsage,
        pub fPixelGeometry: root::SkPixelGeometry,
    }
    #[test]
    fn bindgen_test_layout_SkBaseDevice_CreateInfo() {
        assert_eq!(::std::mem::size_of::<SkBaseDevice_CreateInfo>() ,
                   32usize);
        assert_eq!(::std::mem::align_of::<SkBaseDevice_CreateInfo>() ,
                   8usize);
    }
    extern "C" {
        #[link_name =
              "?AdjustGeometry@CreateInfo@SkBaseDevice@@SA?AW4SkPixelGeometry@@AEBUSkImageInfo@@W4TileUsage@2@W43@_N@Z"]
        pub fn SkBaseDevice_CreateInfo_AdjustGeometry(arg1:
                                                          *const root::SkImageInfo,
                                                      arg2:
                                                          root::SkBaseDevice_TileUsage,
                                                      arg3:
                                                          root::SkPixelGeometry,
                                                      preserveLCDText: bool)
         -> root::SkPixelGeometry;
    }
    impl SkBaseDevice_CreateInfo {
        #[inline]
        pub unsafe fn AdjustGeometry(arg1: *const root::SkImageInfo,
                                     arg2: root::SkBaseDevice_TileUsage,
                                     arg3: root::SkPixelGeometry,
                                     preserveLCDText: bool)
         -> root::SkPixelGeometry {
            SkBaseDevice_CreateInfo_AdjustGeometry(arg1, arg2, arg3,
                                                   preserveLCDText)
        }
    }
    pub type SkBaseDevice_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkBaseDevice() {
        assert_eq!(::std::mem::size_of::<SkBaseDevice>() , 64usize);
        assert_eq!(::std::mem::align_of::<SkBaseDevice>() , 8usize);
    }
    extern "C" {
        #[link_name = "?getMetaData@SkBaseDevice@@QEAAAEAVSkMetaData@@XZ"]
        pub fn SkBaseDevice_getMetaData(this: *mut root::SkBaseDevice)
         -> *mut root::SkMetaData;
    }
    extern "C" {
        #[link_name =
              "?writePixels@SkBaseDevice@@QEAA_NAEBUSkImageInfo@@PEBX_KHH@Z"]
        pub fn SkBaseDevice_writePixels(this: *mut root::SkBaseDevice,
                                        arg1: *const root::SkImageInfo,
                                        arg2: *const ::std::os::raw::c_void,
                                        rowBytes: usize,
                                        x: ::std::os::raw::c_int,
                                        y: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /**
     *  Try to get write-access to the pixels behind the device. If successful, this returns true
     *  and fills-out the pixmap parameter. On success it also bumps the genID of the underlying
     *  bitmap.
     *
     *  On failure, returns false and ignores the pixmap parameter.
     */
        #[link_name = "?accessPixels@SkBaseDevice@@QEAA_NPEAVSkPixmap@@@Z"]
        pub fn SkBaseDevice_accessPixels(this: *mut root::SkBaseDevice,
                                         pmap: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     *  Try to get read-only-access to the pixels behind the device. If successful, this returns
     *  true and fills-out the pixmap parameter.
     *
     *  On failure, returns false and ignores the pixmap parameter.
     */
        #[link_name = "?peekPixels@SkBaseDevice@@QEAA_NPEAVSkPixmap@@@Z"]
        pub fn SkBaseDevice_peekPixels(this: *mut root::SkBaseDevice,
                                       arg1: *mut root::SkPixmap) -> bool;
    }
    extern "C" {
        /**
     * Returns the text-related flags, possibly modified based on the state of the
     * device (e.g. support for LCD).
     */
        #[link_name = "?filterTextFlags@SkBaseDevice@@IEBAIAEBVSkPaint@@@Z"]
        pub fn SkBaseDevice_filterTextFlags(this: *const root::SkBaseDevice,
                                            arg1: *const root::SkPaint)
         -> u32;
    }
    extern "C" {
        #[link_name =
              "?readPixels@SkBaseDevice@@IEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"]
        pub fn SkBaseDevice_readPixels(this: *mut root::SkBaseDevice,
                                       arg1: *const root::SkImageInfo,
                                       dst: *mut ::std::os::raw::c_void,
                                       rowBytes: usize,
                                       x: ::std::os::raw::c_int,
                                       y: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        #[link_name =
              "?LogDrawScaleFactor@SkBaseDevice@@KAXAEBVSkMatrix@@W4SkFilterQuality@@@Z"]
        pub fn SkBaseDevice_LogDrawScaleFactor(arg1: *const root::SkMatrix,
                                               arg2: root::SkFilterQuality);
    }
    extern "C" {
        /**
     *  Construct a new device.
    */
        #[link_name =
              "??0SkBaseDevice@@QEAA@AEBUSkImageInfo@@AEBVSkSurfaceProps@@@Z"]
        pub fn SkBaseDevice_SkBaseDevice(this: *mut root::SkBaseDevice,
                                         arg1: *const root::SkImageInfo,
                                         arg2: *const root::SkSurfaceProps);
    }
    impl SkBaseDevice {
        #[inline]
        pub unsafe fn getMetaData(&mut self) -> *mut root::SkMetaData {
            SkBaseDevice_getMetaData(&mut *self)
        }
        #[inline]
        pub unsafe fn writePixels(&mut self, arg1: *const root::SkImageInfo,
                                  arg2: *const ::std::os::raw::c_void,
                                  rowBytes: usize, x: ::std::os::raw::c_int,
                                  y: ::std::os::raw::c_int) -> bool {
            SkBaseDevice_writePixels(&mut *self, arg1, arg2, rowBytes, x, y)
        }
        #[inline]
        pub unsafe fn accessPixels(&mut self, pmap: *mut root::SkPixmap)
         -> bool {
            SkBaseDevice_accessPixels(&mut *self, pmap)
        }
        #[inline]
        pub unsafe fn peekPixels(&mut self, arg1: *mut root::SkPixmap)
         -> bool {
            SkBaseDevice_peekPixels(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn filterTextFlags(&self, arg1: *const root::SkPaint)
         -> u32 {
            SkBaseDevice_filterTextFlags(&*self, arg1)
        }
        #[inline]
        pub unsafe fn readPixels(&mut self, arg1: *const root::SkImageInfo,
                                 dst: *mut ::std::os::raw::c_void,
                                 rowBytes: usize, x: ::std::os::raw::c_int,
                                 y: ::std::os::raw::c_int) -> bool {
            SkBaseDevice_readPixels(&mut *self, arg1, dst, rowBytes, x, y)
        }
        #[inline]
        pub unsafe fn LogDrawScaleFactor(arg1: *const root::SkMatrix,
                                         arg2: root::SkFilterQuality) {
            SkBaseDevice_LogDrawScaleFactor(arg1, arg2)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::SkImageInfo,
                          arg2: *const root::SkSurfaceProps) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkBaseDevice_SkBaseDevice(&mut __bindgen_tmp, arg1, arg2);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    pub struct SkCanvasClipVisitor__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkCanvasClipVisitor {
        pub vtable_: *const SkCanvasClipVisitor__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkCanvasClipVisitor() {
        assert_eq!(::std::mem::size_of::<SkCanvasClipVisitor>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkCanvasClipVisitor>() , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_19() {
        assert_eq!(::std::mem::size_of::<root::SkNVRefCnt<root::SkClipStack>>()
                   , 4usize);
        assert_eq!(::std::mem::align_of::<root::SkNVRefCnt<root::SkClipStack>>()
                   , 4usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkClipStack {
        pub _base: root::SkNVRefCnt<root::SkClipStack>,
        pub fDeque: root::SkDeque,
        pub fSaveCount: ::std::os::raw::c_int,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkClipStack_BoundsType {
        kNormal_BoundsType = 0,
        kInsideOut_BoundsType = 1,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkClipStack_Element {
        pub fPath: root::SkTLazy<root::SkPath>,
        pub fRRect: root::SkRRect,
        pub fSaveCount: ::std::os::raw::c_int,
        pub fOp: root::SkClipOp,
        pub fType: root::SkClipStack_Element_Type,
        pub fDoAA: bool,
        pub fFiniteBoundType: root::SkClipStack_BoundsType,
        pub fFiniteBound: root::SkRect,
        pub fIsIntersectionOfRects: bool,
        pub fGenID: ::std::os::raw::c_int,
    }
    pub const SkClipStack_Element_Type_kLastType:
              root::SkClipStack_Element_Type =
        SkClipStack_Element_Type::kPath_Type;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkClipStack_Element_Type {
        kEmpty_Type = 0,
        kRect_Type = 1,
        kRRect_Type = 2,
        kPath_Type = 3,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkClipStack_Element_FillCombo {
        kPrev_Cur_FillCombo = 0,
        kPrev_InvCur_FillCombo = 1,
        kInvPrev_Cur_FillCombo = 2,
        kInvPrev_InvCur_FillCombo = 3,
    }
    pub const SkClipStack_Element_kTypeCnt: ::std::os::raw::c_int = 4;
    #[test]
    fn bindgen_test_layout_SkClipStack_Element() {
        assert_eq!(::std::mem::size_of::<SkClipStack_Element>() , 120usize);
        assert_eq!(::std::mem::align_of::<SkClipStack_Element>() , 8usize);
    }
    extern "C" {
        #[link_name = "?asPath@Element@SkClipStack@@QEBAXPEAVSkPath@@@Z"]
        pub fn SkClipStack_Element_asPath(this:
                                              *const root::SkClipStack_Element,
                                          path: *mut root::SkPath);
    }
    extern "C" {
        #[link_name = "?invertShapeFillType@Element@SkClipStack@@QEAAXXZ"]
        pub fn SkClipStack_Element_invertShapeFillType(this:
                                                           *mut root::SkClipStack_Element);
    }
    extern "C" {
        /**
        * Replay this clip into the visitor.
        */
        #[link_name =
              "?replay@Element@SkClipStack@@QEBAXPEAVSkCanvasClipVisitor@@@Z"]
        pub fn SkClipStack_Element_replay(this:
                                              *const root::SkClipStack_Element,
                                          arg1:
                                              *mut root::SkCanvasClipVisitor);
    }
    extern "C" {
        /**
         * Dumps the element to SkDebugf. This is intended for Skia development debugging
         * Don't rely on the existence of this function or the formatting of its output.
         */
        #[link_name = "?dump@Element@SkClipStack@@QEBAXXZ"]
        pub fn SkClipStack_Element_dump(this:
                                            *const root::SkClipStack_Element);
    }
    extern "C" {
        #[link_name = "??0Element@SkClipStack@@QEAA@AEBV01@@Z"]
        pub fn SkClipStack_Element_Element(this:
                                               *mut root::SkClipStack_Element,
                                           arg1:
                                               *const root::SkClipStack_Element);
    }
    impl SkClipStack_Element {
        #[inline]
        pub unsafe fn asPath(&self, path: *mut root::SkPath) {
            SkClipStack_Element_asPath(&*self, path)
        }
        #[inline]
        pub unsafe fn invertShapeFillType(&mut self) {
            SkClipStack_Element_invertShapeFillType(&mut *self)
        }
        #[inline]
        pub unsafe fn replay(&self, arg1: *mut root::SkCanvasClipVisitor) {
            SkClipStack_Element_replay(&*self, arg1)
        }
        #[inline]
        pub unsafe fn dump(&self) { SkClipStack_Element_dump(&*self) }
        #[inline]
        pub unsafe fn new(arg1: *const root::SkClipStack_Element) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkClipStack_Element_Element(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkClipStack_Iter {
        pub fStack: *const root::SkClipStack,
        pub fIter: root::SkDeque_Iter,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkClipStack_Iter_IterStart {
        kBottom_IterStart = 0,
        kTop_IterStart = 1,
    }
    #[test]
    fn bindgen_test_layout_SkClipStack_Iter() {
        assert_eq!(::std::mem::size_of::<SkClipStack_Iter>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkClipStack_Iter>() , 8usize);
    }
    extern "C" {
        /**
         *  Return the clip element for this iterator. If next()/prev() returns NULL, then the
         *  iterator is done.
         */
        #[link_name = "?next@Iter@SkClipStack@@QEAAPEBVElement@2@XZ"]
        pub fn SkClipStack_Iter_next(this: *mut root::SkClipStack_Iter)
         -> *const root::SkClipStack_Element;
    }
    extern "C" {
        #[link_name = "?prev@Iter@SkClipStack@@QEAAPEBVElement@2@XZ"]
        pub fn SkClipStack_Iter_prev(this: *mut root::SkClipStack_Iter)
         -> *const root::SkClipStack_Element;
    }
    extern "C" {
        /**
         * Moves the iterator to the topmost element with the specified RegionOp and returns that
         * element. If no clip element with that op is found, the first element is returned.
         */
        #[link_name =
              "?skipToTopmost@Iter@SkClipStack@@QEAAPEBVElement@2@W4SkClipOp@@@Z"]
        pub fn SkClipStack_Iter_skipToTopmost(this:
                                                  *mut root::SkClipStack_Iter,
                                              op: root::SkClipOp)
         -> *const root::SkClipStack_Element;
    }
    extern "C" {
        /**
         * Restarts the iterator on a clip stack.
         */
        #[link_name = "?reset@Iter@SkClipStack@@QEAAXAEBV2@W4IterStart@12@@Z"]
        pub fn SkClipStack_Iter_reset(this: *mut root::SkClipStack_Iter,
                                      stack: *const root::SkClipStack,
                                      startLoc:
                                          root::SkClipStack_Iter_IterStart);
    }
    extern "C" {
        /**
         * Creates an uninitialized iterator. Must be reset()
         */
        #[link_name = "??0Iter@SkClipStack@@QEAA@XZ"]
        pub fn SkClipStack_Iter_Iter(this: *mut root::SkClipStack_Iter);
    }
    extern "C" {
        #[link_name = "??0Iter@SkClipStack@@QEAA@AEBV1@W4IterStart@01@@Z"]
        pub fn SkClipStack_Iter_Iter1(this: *mut root::SkClipStack_Iter,
                                      stack: *const root::SkClipStack,
                                      startLoc:
                                          root::SkClipStack_Iter_IterStart);
    }
    impl Clone for SkClipStack_Iter {
        fn clone(&self) -> Self { *self }
    }
    impl SkClipStack_Iter {
        #[inline]
        pub unsafe fn next(&mut self) -> *const root::SkClipStack_Element {
            SkClipStack_Iter_next(&mut *self)
        }
        #[inline]
        pub unsafe fn prev(&mut self) -> *const root::SkClipStack_Element {
            SkClipStack_Iter_prev(&mut *self)
        }
        #[inline]
        pub unsafe fn skipToTopmost(&mut self, op: root::SkClipOp)
         -> *const root::SkClipStack_Element {
            SkClipStack_Iter_skipToTopmost(&mut *self, op)
        }
        #[inline]
        pub unsafe fn reset(&mut self, stack: *const root::SkClipStack,
                            startLoc: root::SkClipStack_Iter_IterStart) {
            SkClipStack_Iter_reset(&mut *self, stack, startLoc)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkClipStack_Iter_Iter(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(stack: *const root::SkClipStack,
                           startLoc: root::SkClipStack_Iter_IterStart)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkClipStack_Iter_Iter1(&mut __bindgen_tmp, stack, startLoc);
            __bindgen_tmp
        }
    }
    /**
     * The B2TIter iterates from the bottom of the stack to the top.
     * It inherits privately from Iter to prevent access to reverse iteration.
     */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkClipStack_B2TIter {
        pub _base: root::SkClipStack_Iter,
    }
    pub type SkClipStack_B2TIter_INHERITED = root::SkClipStack_Iter;
    #[test]
    fn bindgen_test_layout_SkClipStack_B2TIter() {
        assert_eq!(::std::mem::size_of::<SkClipStack_B2TIter>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkClipStack_B2TIter>() , 8usize);
    }
    impl Clone for SkClipStack_B2TIter {
        fn clone(&self) -> Self { *self }
    }
    pub const SkClipStack_kInvalidGenID: i32 = 0;
    pub const SkClipStack_kEmptyGenID: i32 = 1;
    pub const SkClipStack_kWideOpenGenID: i32 = 2;
    extern "C" {
        #[link_name = "?gGenID@SkClipStack@@0HA"]
        pub static mut SkClipStack_gGenID: i32;
    }
    #[test]
    fn bindgen_test_layout_SkClipStack() {
        assert_eq!(::std::mem::size_of::<SkClipStack>() , 72usize);
        assert_eq!(::std::mem::align_of::<SkClipStack>() , 8usize);
    }
    extern "C" {
        #[link_name = "?reset@SkClipStack@@QEAAXXZ"]
        pub fn SkClipStack_reset(this: *mut root::SkClipStack);
    }
    extern "C" {
        #[link_name = "?save@SkClipStack@@QEAAXXZ"]
        pub fn SkClipStack_save(this: *mut root::SkClipStack);
    }
    extern "C" {
        #[link_name = "?restore@SkClipStack@@QEAAXXZ"]
        pub fn SkClipStack_restore(this: *mut root::SkClipStack);
    }
    extern "C" {
        /**
     * getBounds places the current finite bound in its first parameter. In its
     * second, it indicates which kind of bound is being returned. If
     * 'canvFiniteBound' is a normal bounding box then it encloses all writeable
     * pixels. If 'canvFiniteBound' is an inside out bounding box then it
     * encloses all the un-writeable pixels and the true/normal bound is the
     * infinite plane. isIntersectionOfRects is an optional parameter
     * that is true if 'canvFiniteBound' resulted from an intersection of rects.
     */
        #[link_name =
              "?getBounds@SkClipStack@@QEBAXPEAUSkRect@@PEAW4BoundsType@1@PEA_N@Z"]
        pub fn SkClipStack_getBounds(this: *const root::SkClipStack,
                                     canvFiniteBound: *mut root::SkRect,
                                     boundType:
                                         *mut root::SkClipStack_BoundsType,
                                     isIntersectionOfRects: *mut bool);
    }
    extern "C" {
        /**
     * Flattens the clip stack into a single SkPath. Returns true if any of
     * the clip stack components requires anti-aliasing.
     */
        #[link_name = "?asPath@SkClipStack@@QEBA_NPEAVSkPath@@@Z"]
        pub fn SkClipStack_asPath(this: *const root::SkClipStack,
                                  path: *mut root::SkPath) -> bool;
    }
    extern "C" {
        #[link_name =
              "?clipRect@SkClipStack@@QEAAXAEBUSkRect@@AEBVSkMatrix@@W4SkClipOp@@_N@Z"]
        pub fn SkClipStack_clipRect(this: *mut root::SkClipStack,
                                    arg1: *const root::SkRect,
                                    matrix: *const root::SkMatrix,
                                    arg2: root::SkClipOp, doAA: bool);
    }
    extern "C" {
        #[link_name =
              "?clipRRect@SkClipStack@@QEAAXAEBVSkRRect@@AEBVSkMatrix@@W4SkClipOp@@_N@Z"]
        pub fn SkClipStack_clipRRect(this: *mut root::SkClipStack,
                                     arg1: *const root::SkRRect,
                                     matrix: *const root::SkMatrix,
                                     arg2: root::SkClipOp, doAA: bool);
    }
    extern "C" {
        #[link_name =
              "?clipPath@SkClipStack@@QEAAXAEBVSkPath@@AEBVSkMatrix@@W4SkClipOp@@_N@Z"]
        pub fn SkClipStack_clipPath(this: *mut root::SkClipStack,
                                    arg1: *const root::SkPath,
                                    matrix: *const root::SkMatrix,
                                    arg2: root::SkClipOp, doAA: bool);
    }
    extern "C" {
        #[link_name = "?clipEmpty@SkClipStack@@QEAAXXZ"]
        pub fn SkClipStack_clipEmpty(this: *mut root::SkClipStack);
    }
    extern "C" {
        /**
     * This method quickly and conservatively determines whether the entire stack is equivalent to
     * intersection with a rrect given a bounds, where the rrect must not contain the entire bounds.
     *
     * @param bounds   A bounds on what will be drawn through the clip. The clip only need be
     *                 equivalent to a intersection with a rrect for draws within the bounds. The
     *                 returned rrect must intersect the bounds but need not be contained by the
     *                 bounds.
     * @param rrect    If return is true rrect will contain the rrect equivalent to the stack.
     * @param aa       If return is true aa will indicate whether the equivalent rrect clip is
     *                 antialiased.
     * @return true if the stack is equivalent to a single rrect intersect clip, false otherwise.
     */
        #[link_name =
              "?isRRect@SkClipStack@@QEBA_NAEBUSkRect@@PEAVSkRRect@@PEA_N@Z"]
        pub fn SkClipStack_isRRect(this: *const root::SkClipStack,
                                   bounds: *const root::SkRect,
                                   rrect: *mut root::SkRRect, aa: *mut bool)
         -> bool;
    }
    extern "C" {
        #[link_name = "?getTopmostGenID@SkClipStack@@QEBAHXZ"]
        pub fn SkClipStack_getTopmostGenID(this: *const root::SkClipStack)
         -> i32;
    }
    extern "C" {
        /**
     * Dumps the contents of the clip stack to SkDebugf. This is intended for Skia development
     * debugging. Don't rely on the existence of this function or the formatting of its output.
     */
        #[link_name = "?dump@SkClipStack@@QEBAXXZ"]
        pub fn SkClipStack_dump(this: *const root::SkClipStack);
    }
    extern "C" {
        /**
     * GetConservativeBounds returns a conservative bound of the current clip.
     * Since this could be the infinite plane (if inverse fills were involved) the
     * maxWidth and maxHeight parameters can be used to limit the returned bound
     * to the expected drawing area. Similarly, the offsetX and offsetY parameters
     * allow the caller to offset the returned bound to account for translated
     * drawing areas (i.e., those resulting from a saveLayer). For finite bounds,
     * the translation (+offsetX, +offsetY) is applied before the clamp to the
     * maximum rectangle: [0,maxWidth) x [0,maxHeight).
     * isIntersectionOfRects is an optional parameter that is true when
     * 'devBounds' is the result of an intersection of rects. In this case
     * 'devBounds' is the exact answer/clip.
     */
        #[link_name =
              "?getConservativeBounds@SkClipStack@@QEBAXHHHHPEAUSkRect@@PEA_N@Z"]
        pub fn SkClipStack_getConservativeBounds(this:
                                                     *const root::SkClipStack,
                                                 offsetX:
                                                     ::std::os::raw::c_int,
                                                 offsetY:
                                                     ::std::os::raw::c_int,
                                                 maxWidth:
                                                     ::std::os::raw::c_int,
                                                 maxHeight:
                                                     ::std::os::raw::c_int,
                                                 devBounds: *mut root::SkRect,
                                                 isIntersectionOfRects:
                                                     *mut bool);
    }
    extern "C" {
        #[link_name = "??0SkClipStack@@QEAA@XZ"]
        pub fn SkClipStack_SkClipStack(this: *mut root::SkClipStack);
    }
    extern "C" {
        #[link_name = "??0SkClipStack@@QEAA@AEBV0@@Z"]
        pub fn SkClipStack_SkClipStack1(this: *mut root::SkClipStack,
                                        b: *const root::SkClipStack);
    }
    impl SkClipStack {
        #[inline]
        pub unsafe fn reset(&mut self) { SkClipStack_reset(&mut *self) }
        #[inline]
        pub unsafe fn save(&mut self) { SkClipStack_save(&mut *self) }
        #[inline]
        pub unsafe fn restore(&mut self) { SkClipStack_restore(&mut *self) }
        #[inline]
        pub unsafe fn getBounds(&self, canvFiniteBound: *mut root::SkRect,
                                boundType: *mut root::SkClipStack_BoundsType,
                                isIntersectionOfRects: *mut bool) {
            SkClipStack_getBounds(&*self, canvFiniteBound, boundType,
                                  isIntersectionOfRects)
        }
        #[inline]
        pub unsafe fn asPath(&self, path: *mut root::SkPath) -> bool {
            SkClipStack_asPath(&*self, path)
        }
        #[inline]
        pub unsafe fn clipRect(&mut self, arg1: *const root::SkRect,
                               matrix: *const root::SkMatrix,
                               arg2: root::SkClipOp, doAA: bool) {
            SkClipStack_clipRect(&mut *self, arg1, matrix, arg2, doAA)
        }
        #[inline]
        pub unsafe fn clipRRect(&mut self, arg1: *const root::SkRRect,
                                matrix: *const root::SkMatrix,
                                arg2: root::SkClipOp, doAA: bool) {
            SkClipStack_clipRRect(&mut *self, arg1, matrix, arg2, doAA)
        }
        #[inline]
        pub unsafe fn clipPath(&mut self, arg1: *const root::SkPath,
                               matrix: *const root::SkMatrix,
                               arg2: root::SkClipOp, doAA: bool) {
            SkClipStack_clipPath(&mut *self, arg1, matrix, arg2, doAA)
        }
        #[inline]
        pub unsafe fn clipEmpty(&mut self) {
            SkClipStack_clipEmpty(&mut *self)
        }
        #[inline]
        pub unsafe fn isRRect(&self, bounds: *const root::SkRect,
                              rrect: *mut root::SkRRect, aa: *mut bool)
         -> bool {
            SkClipStack_isRRect(&*self, bounds, rrect, aa)
        }
        #[inline]
        pub unsafe fn getTopmostGenID(&self) -> i32 {
            SkClipStack_getTopmostGenID(&*self)
        }
        #[inline]
        pub unsafe fn dump(&self) { SkClipStack_dump(&*self) }
        #[inline]
        pub unsafe fn getConservativeBounds(&self,
                                            offsetX: ::std::os::raw::c_int,
                                            offsetY: ::std::os::raw::c_int,
                                            maxWidth: ::std::os::raw::c_int,
                                            maxHeight: ::std::os::raw::c_int,
                                            devBounds: *mut root::SkRect,
                                            isIntersectionOfRects:
                                                *mut bool) {
            SkClipStack_getConservativeBounds(&*self, offsetX, offsetY,
                                              maxWidth, maxHeight, devBounds,
                                              isIntersectionOfRects)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkClipStack_SkClipStack(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(b: *const root::SkClipStack) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkClipStack_SkClipStack1(&mut __bindgen_tmp, b);
            __bindgen_tmp
        }
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum InitStyle { kHairline_InitStyle = 0, kFill_InitStyle = 1, }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkDraw {
        pub fDst: root::SkPixmap,
        pub fMatrix: *const root::SkMatrix,
        pub fRC: *const root::SkRasterClip,
        pub fClipStack: *const root::SkClipStack,
        pub fDevice: *mut root::SkBaseDevice,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkDraw_RectType {
        kHair_RectType = 0,
        kFill_RectType = 1,
        kStroke_RectType = 2,
        kPath_RectType = 3,
    }
    #[test]
    fn bindgen_test_layout_SkDraw() {
        assert_eq!(::std::mem::size_of::<SkDraw>() , 80usize);
        assert_eq!(::std::mem::align_of::<SkDraw>() , 8usize);
    }
    extern "C" {
        #[link_name = "?drawPaint@SkDraw@@QEBAXAEBVSkPaint@@@Z"]
        pub fn SkDraw_drawPaint(this: *const root::SkDraw,
                                arg1: *const root::SkPaint);
    }
    extern "C" {
        #[link_name =
              "?drawPoints@SkDraw@@QEBAXW4PointMode@SkCanvas@@_KQEBUSkPoint@@AEBVSkPaint@@_N@Z"]
        pub fn SkDraw_drawPoints(this: *const root::SkDraw,
                                 arg1: root::SkCanvas_PointMode, count: usize,
                                 arg2: *const root::SkPoint,
                                 arg3: *const root::SkPaint,
                                 forceUseDevice: bool);
    }
    extern "C" {
        #[link_name =
              "?drawRect@SkDraw@@QEBAXAEBUSkRect@@AEBVSkPaint@@PEBVSkMatrix@@PEBU2@@Z"]
        pub fn SkDraw_drawRect(this: *const root::SkDraw,
                               prePaintRect: *const root::SkRect,
                               arg1: *const root::SkPaint,
                               paintMatrix: *const root::SkMatrix,
                               postPaintRect: *const root::SkRect);
    }
    extern "C" {
        #[link_name = "?drawRRect@SkDraw@@QEBAXAEBVSkRRect@@AEBVSkPaint@@@Z"]
        pub fn SkDraw_drawRRect(this: *const root::SkDraw,
                                arg1: *const root::SkRRect,
                                arg2: *const root::SkPaint);
    }
    extern "C" {
        #[link_name =
              "?drawBitmap@SkDraw@@QEBAXAEBVSkBitmap@@AEBVSkMatrix@@PEBUSkRect@@AEBVSkPaint@@@Z"]
        pub fn SkDraw_drawBitmap(this: *const root::SkDraw,
                                 arg1: *const root::SkBitmap,
                                 arg2: *const root::SkMatrix,
                                 dstOrNull: *const root::SkRect,
                                 arg3: *const root::SkPaint);
    }
    extern "C" {
        #[link_name =
              "?drawSprite@SkDraw@@QEBAXAEBVSkBitmap@@HHAEBVSkPaint@@@Z"]
        pub fn SkDraw_drawSprite(this: *const root::SkDraw,
                                 arg1: *const root::SkBitmap,
                                 x: ::std::os::raw::c_int,
                                 y: ::std::os::raw::c_int,
                                 arg2: *const root::SkPaint);
    }
    extern "C" {
        #[link_name = "?drawText@SkDraw@@QEBAXQEBD_KMMAEBVSkPaint@@@Z"]
        pub fn SkDraw_drawText(this: *const root::SkDraw,
                               text: *const ::std::os::raw::c_char,
                               byteLength: usize, x: root::SkScalar,
                               y: root::SkScalar,
                               paint: *const root::SkPaint);
    }
    extern "C" {
        #[link_name =
              "?drawPosText@SkDraw@@QEBAXQEBD_KQEBMHAEBUSkPoint@@AEBVSkPaint@@@Z"]
        pub fn SkDraw_drawPosText(this: *const root::SkDraw,
                                  text: *const ::std::os::raw::c_char,
                                  byteLength: usize,
                                  pos: *const root::SkScalar,
                                  scalarsPerPosition: ::std::os::raw::c_int,
                                  offset: *const root::SkPoint,
                                  paint: *const root::SkPaint);
    }
    extern "C" {
        #[link_name =
              "?drawVertices@SkDraw@@QEBAXW4VertexMode@SkCanvas@@HQEBUSkPoint@@1QEBIW4SkBlendMode@@QEBGHAEBVSkPaint@@@Z"]
        pub fn SkDraw_drawVertices(this: *const root::SkDraw,
                                   mode: root::SkCanvas_VertexMode,
                                   count: ::std::os::raw::c_int,
                                   vertices: *const root::SkPoint,
                                   textures: *const root::SkPoint,
                                   colors: *const root::SkColor,
                                   bmode: root::SkBlendMode,
                                   indices: *const u16,
                                   ptCount: ::std::os::raw::c_int,
                                   paint: *const root::SkPaint);
    }
    extern "C" {
        /** Helper function that creates a mask from a path and an optional maskfilter.
        Note however, that the resulting mask will not have been actually filtered,
        that must be done afterwards (by calling filterMask). The maskfilter is provided
        solely to assist in computing the mask's bounds (if the mode requests that).
    */
        #[link_name =
              "?DrawToMask@SkDraw@@SA_NAEBVSkPath@@PEBUSkIRect@@PEBVSkMaskFilter@@PEBVSkMatrix@@PEAUSkMask@@W4CreateMode@6@W4InitStyle@SkStrokeRec@@@Z"]
        pub fn SkDraw_DrawToMask(devPath: *const root::SkPath,
                                 clipBounds: *const root::SkIRect,
                                 arg1: *const root::SkMaskFilter,
                                 filterMatrix: *const root::SkMatrix,
                                 mask: *mut root::SkMask,
                                 mode: root::SkMask_CreateMode,
                                 style: root::InitStyle) -> bool;
    }
    extern "C" {
        /**
     *  Based on the paint's style, strokeWidth, and the matrix, classify how
     *  to draw the rect. If no special-case is available, returns
     *  kPath_RectType.
     *
     *  Iff RectType == kStroke_RectType, then strokeSize is set to the device
     *  width and height of the stroke.
     */
        #[link_name =
              "?ComputeRectType@SkDraw@@SA?AW4RectType@1@AEBVSkPaint@@AEBVSkMatrix@@PEAUSkPoint@@@Z"]
        pub fn SkDraw_ComputeRectType(arg1: *const root::SkPaint,
                                      arg2: *const root::SkMatrix,
                                      strokeSize: *mut root::SkPoint)
         -> root::SkDraw_RectType;
    }
    extern "C" {
        #[link_name =
              "?ShouldDrawTextAsPaths@SkDraw@@SA_NAEBVSkPaint@@AEBVSkMatrix@@@Z"]
        pub fn SkDraw_ShouldDrawTextAsPaths(arg1: *const root::SkPaint,
                                            arg2: *const root::SkMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "?drawText_asPaths@SkDraw@@QEBAXQEBD_KMMAEBVSkPaint@@@Z"]
        pub fn SkDraw_drawText_asPaths(this: *const root::SkDraw,
                                       text: *const ::std::os::raw::c_char,
                                       byteLength: usize, x: root::SkScalar,
                                       y: root::SkScalar,
                                       arg1: *const root::SkPaint);
    }
    extern "C" {
        #[link_name =
              "?drawPosText_asPaths@SkDraw@@QEBAXQEBD_KQEBMHAEBUSkPoint@@AEBVSkPaint@@@Z"]
        pub fn SkDraw_drawPosText_asPaths(this: *const root::SkDraw,
                                          text: *const ::std::os::raw::c_char,
                                          byteLength: usize,
                                          pos: *const root::SkScalar,
                                          scalarsPerPosition:
                                              ::std::os::raw::c_int,
                                          offset: *const root::SkPoint,
                                          arg1: *const root::SkPaint);
    }
    extern "C" {
        #[link_name =
              "?ComputeResScaleForStroking@SkDraw@@SAMAEBVSkMatrix@@@Z"]
        pub fn SkDraw_ComputeResScaleForStroking(arg1: *const root::SkMatrix)
         -> root::SkScalar;
    }
    extern "C" {
        #[link_name = "?validate@SkDraw@@QEBAXXZ"]
        pub fn SkDraw_validate(this: *const root::SkDraw);
    }
    extern "C" {
        #[link_name = "??0SkDraw@@QEAA@XZ"]
        pub fn SkDraw_SkDraw(this: *mut root::SkDraw);
    }
    impl SkDraw {
        #[inline]
        pub unsafe fn drawPaint(&self, arg1: *const root::SkPaint) {
            SkDraw_drawPaint(&*self, arg1)
        }
        #[inline]
        pub unsafe fn drawPoints(&self, arg1: root::SkCanvas_PointMode,
                                 count: usize, arg2: *const root::SkPoint,
                                 arg3: *const root::SkPaint,
                                 forceUseDevice: bool) {
            SkDraw_drawPoints(&*self, arg1, count, arg2, arg3, forceUseDevice)
        }
        #[inline]
        pub unsafe fn drawRect(&self, prePaintRect: *const root::SkRect,
                               arg1: *const root::SkPaint,
                               paintMatrix: *const root::SkMatrix,
                               postPaintRect: *const root::SkRect) {
            SkDraw_drawRect(&*self, prePaintRect, arg1, paintMatrix,
                            postPaintRect)
        }
        #[inline]
        pub unsafe fn drawRRect(&self, arg1: *const root::SkRRect,
                                arg2: *const root::SkPaint) {
            SkDraw_drawRRect(&*self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn drawBitmap(&self, arg1: *const root::SkBitmap,
                                 arg2: *const root::SkMatrix,
                                 dstOrNull: *const root::SkRect,
                                 arg3: *const root::SkPaint) {
            SkDraw_drawBitmap(&*self, arg1, arg2, dstOrNull, arg3)
        }
        #[inline]
        pub unsafe fn drawSprite(&self, arg1: *const root::SkBitmap,
                                 x: ::std::os::raw::c_int,
                                 y: ::std::os::raw::c_int,
                                 arg2: *const root::SkPaint) {
            SkDraw_drawSprite(&*self, arg1, x, y, arg2)
        }
        #[inline]
        pub unsafe fn drawText(&self, text: *const ::std::os::raw::c_char,
                               byteLength: usize, x: root::SkScalar,
                               y: root::SkScalar,
                               paint: *const root::SkPaint) {
            SkDraw_drawText(&*self, text, byteLength, x, y, paint)
        }
        #[inline]
        pub unsafe fn drawPosText(&self, text: *const ::std::os::raw::c_char,
                                  byteLength: usize,
                                  pos: *const root::SkScalar,
                                  scalarsPerPosition: ::std::os::raw::c_int,
                                  offset: *const root::SkPoint,
                                  paint: *const root::SkPaint) {
            SkDraw_drawPosText(&*self, text, byteLength, pos,
                               scalarsPerPosition, offset, paint)
        }
        #[inline]
        pub unsafe fn drawVertices(&self, mode: root::SkCanvas_VertexMode,
                                   count: ::std::os::raw::c_int,
                                   vertices: *const root::SkPoint,
                                   textures: *const root::SkPoint,
                                   colors: *const root::SkColor,
                                   bmode: root::SkBlendMode,
                                   indices: *const u16,
                                   ptCount: ::std::os::raw::c_int,
                                   paint: *const root::SkPaint) {
            SkDraw_drawVertices(&*self, mode, count, vertices, textures,
                                colors, bmode, indices, ptCount, paint)
        }
        #[inline]
        pub unsafe fn DrawToMask(devPath: *const root::SkPath,
                                 clipBounds: *const root::SkIRect,
                                 arg1: *const root::SkMaskFilter,
                                 filterMatrix: *const root::SkMatrix,
                                 mask: *mut root::SkMask,
                                 mode: root::SkMask_CreateMode,
                                 style: root::InitStyle) -> bool {
            SkDraw_DrawToMask(devPath, clipBounds, arg1, filterMatrix, mask,
                              mode, style)
        }
        #[inline]
        pub unsafe fn ComputeRectType(arg1: *const root::SkPaint,
                                      arg2: *const root::SkMatrix,
                                      strokeSize: *mut root::SkPoint)
         -> root::SkDraw_RectType {
            SkDraw_ComputeRectType(arg1, arg2, strokeSize)
        }
        #[inline]
        pub unsafe fn ShouldDrawTextAsPaths(arg1: *const root::SkPaint,
                                            arg2: *const root::SkMatrix)
         -> bool {
            SkDraw_ShouldDrawTextAsPaths(arg1, arg2)
        }
        #[inline]
        pub unsafe fn drawText_asPaths(&self,
                                       text: *const ::std::os::raw::c_char,
                                       byteLength: usize, x: root::SkScalar,
                                       y: root::SkScalar,
                                       arg1: *const root::SkPaint) {
            SkDraw_drawText_asPaths(&*self, text, byteLength, x, y, arg1)
        }
        #[inline]
        pub unsafe fn drawPosText_asPaths(&self,
                                          text: *const ::std::os::raw::c_char,
                                          byteLength: usize,
                                          pos: *const root::SkScalar,
                                          scalarsPerPosition:
                                              ::std::os::raw::c_int,
                                          offset: *const root::SkPoint,
                                          arg1: *const root::SkPaint) {
            SkDraw_drawPosText_asPaths(&*self, text, byteLength, pos,
                                       scalarsPerPosition, offset, arg1)
        }
        #[inline]
        pub unsafe fn ComputeResScaleForStroking(arg1: *const root::SkMatrix)
         -> root::SkScalar {
            SkDraw_ComputeResScaleForStroking(arg1)
        }
        #[inline]
        pub unsafe fn validate(&self) { SkDraw_validate(&*self) }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkDraw_SkDraw(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    /**
 *  Base-class for objects that draw into SkCanvas.
 *
 *  The object has a generation ID, which is guaranteed to be unique across all drawables. To
 *  allow for clients of the drawable that may want to cache the results, the drawable must
 *  change its generation ID whenever its internal state changes such that it will draw differently.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkDrawable {
        pub _base: root::SkFlattenable,
        pub fGenerationID: i32,
    }
    #[test]
    fn bindgen_test_layout_SkDrawable() {
        assert_eq!(::std::mem::size_of::<SkDrawable>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkDrawable>() , 8usize);
    }
    extern "C" {
        /**
     *  Draws into the specified content. The drawing sequence will be balanced upon return
     *  (i.e. the saveLevel() on the canvas will match what it was when draw() was called,
     *  and the current matrix and clip settings will not be changed.
     */
        #[link_name = "?draw@SkDrawable@@QEAAXPEAVSkCanvas@@PEBVSkMatrix@@@Z"]
        pub fn SkDrawable_draw(this: *mut root::SkDrawable,
                               arg1: *mut root::SkCanvas,
                               arg2: *const root::SkMatrix);
    }
    extern "C" {
        #[link_name = "?draw@SkDrawable@@QEAAXPEAVSkCanvas@@MM@Z"]
        pub fn SkDrawable_draw1(this: *mut root::SkDrawable,
                                arg1: *mut root::SkCanvas, x: root::SkScalar,
                                y: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?newPictureSnapshot@SkDrawable@@QEAAPEAVSkPicture@@XZ"]
        pub fn SkDrawable_newPictureSnapshot(this: *mut root::SkDrawable)
         -> *mut root::SkPicture;
    }
    extern "C" {
        /**
     *  Return a unique value for this instance. If two calls to this return the same value,
     *  it is presumed that calling the draw() method will render the same thing as well.
     *
     *  Subclasses that change their state should call notifyDrawingChanged() to ensure that
     *  a new value will be returned the next time it is called.
     */
        #[link_name = "?getGenerationID@SkDrawable@@QEAAIXZ"]
        pub fn SkDrawable_getGenerationID(this: *mut root::SkDrawable) -> u32;
    }
    extern "C" {
        /**
     *  Return the (conservative) bounds of what the drawable will draw. If the drawable can
     *  change what it draws (e.g. animation or in response to some external change), then this
     *  must return a bounds that is always valid for all possible states.
     */
        #[link_name = "?getBounds@SkDrawable@@QEAA?AUSkRect@@XZ"]
        pub fn SkDrawable_getBounds(this: *mut root::SkDrawable)
         -> root::SkRect;
    }
    extern "C" {
        /**
     *  Calling this invalidates the previous generation ID, and causes a new one to be computed
     *  the next time getGenerationID() is called. Typically this is called by the object itself,
     *  in response to its internal state changing.
     */
        #[link_name = "?notifyDrawingChanged@SkDrawable@@QEAAXXZ"]
        pub fn SkDrawable_notifyDrawingChanged(this: *mut root::SkDrawable);
    }
    extern "C" {
        #[link_name = "??0SkDrawable@@QEAA@XZ"]
        pub fn SkDrawable_SkDrawable(this: *mut root::SkDrawable);
    }
    impl SkDrawable {
        #[inline]
        pub unsafe fn draw(&mut self, arg1: *mut root::SkCanvas,
                           arg2: *const root::SkMatrix) {
            SkDrawable_draw(&mut *self, arg1, arg2)
        }
        #[inline]
        pub unsafe fn draw1(&mut self, arg1: *mut root::SkCanvas,
                            x: root::SkScalar, y: root::SkScalar) {
            SkDrawable_draw1(&mut *self, arg1, x, y)
        }
        #[inline]
        pub unsafe fn newPictureSnapshot(&mut self) -> *mut root::SkPicture {
            SkDrawable_newPictureSnapshot(&mut *self)
        }
        #[inline]
        pub unsafe fn getGenerationID(&mut self) -> u32 {
            SkDrawable_getGenerationID(&mut *self)
        }
        #[inline]
        pub unsafe fn getBounds(&mut self) -> root::SkRect {
            SkDrawable_getBounds(&mut *self)
        }
        #[inline]
        pub unsafe fn notifyDrawingChanged(&mut self) {
            SkDrawable_notifyDrawingChanged(&mut *self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkDrawable_SkDrawable(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    /**
 *  DEPRECATED - use SkPaintFilterCanvas instead.
 *
 *  Right before something is being draw, filter() is called with the
 *  paint. The filter may modify the paint as it wishes, which will then be
 *  used for the actual drawing. Note: this modification only lasts for the
 *  current draw, as a temporary copy of the paint is used.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkDrawFilter {
        pub _base: root::SkRefCnt,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkDrawFilter_Type {
        kPaint_Type = 0,
        kPoint_Type = 1,
        kLine_Type = 2,
        kBitmap_Type = 3,
        kRect_Type = 4,
        kRRect_Type = 5,
        kOval_Type = 6,
        kPath_Type = 7,
        kText_Type = 8,
    }
    pub const SkDrawFilter_kTypeCount: root::SkDrawFilter__bindgen_ty_1 =
        SkDrawFilter__bindgen_ty_1::kTypeCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkDrawFilter__bindgen_ty_1 { kTypeCount = 9, }
    pub type SkDrawFilter_INHERITED = root::SkRefCnt;
    #[test]
    fn bindgen_test_layout_SkDrawFilter() {
        assert_eq!(::std::mem::size_of::<SkDrawFilter>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkDrawFilter>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkMetaData {
        pub fRec: *mut root::SkMetaData_Rec,
    }
    /**
     *  Used to manage the life-cycle of a ptr in the metadata. This is option
     *  in setPtr, and is only invoked when either copying one metadata to
     *  another, or when the metadata is destroyed.
     *
     *  setPtr(name, ptr, proc) {
     *      fPtr = proc(ptr, true);
     *  }
     *
     *  copy: A = B {
     *      A.fPtr = B.fProc(B.fPtr, true);
     *  }
     *
     *  ~SkMetaData {
     *      fProc(fPtr, false);
     *  }
     */
    pub type SkMetaData_PtrProc =
        ::std::option::Option<unsafe extern "C" fn(ptr:
                                                       *mut ::std::os::raw::c_void,
                                                   doRef: bool)
                                  -> *mut ::std::os::raw::c_void>;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkMetaData_Type {
        kS32_Type = 0,
        kScalar_Type = 1,
        kString_Type = 2,
        kPtr_Type = 3,
        kBool_Type = 4,
        kData_Type = 5,
        kTypeCount = 6,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMetaData_Rec {
        pub fNext: *mut root::SkMetaData_Rec,
        pub fDataCount: u16,
        pub fDataLen: u8,
        pub fType: u8,
    }
    #[test]
    fn bindgen_test_layout_SkMetaData_Rec() {
        assert_eq!(::std::mem::size_of::<SkMetaData_Rec>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkMetaData_Rec>() , 8usize);
    }
    extern "C" {
        #[link_name = "?Alloc@Rec@SkMetaData@@SAPEAU12@_K@Z"]
        pub fn SkMetaData_Rec_Alloc(arg1: usize) -> *mut root::SkMetaData_Rec;
    }
    extern "C" {
        #[link_name = "?Free@Rec@SkMetaData@@SAXPEAU12@@Z"]
        pub fn SkMetaData_Rec_Free(arg1: *mut root::SkMetaData_Rec);
    }
    impl Clone for SkMetaData_Rec {
        fn clone(&self) -> Self { *self }
    }
    impl SkMetaData_Rec {
        #[inline]
        pub unsafe fn Alloc(arg1: usize) -> *mut root::SkMetaData_Rec {
            SkMetaData_Rec_Alloc(arg1)
        }
        #[inline]
        pub unsafe fn Free(arg1: *mut root::SkMetaData_Rec) {
            SkMetaData_Rec_Free(arg1)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkMetaData_Iter {
        pub fRec: *mut root::SkMetaData_Rec,
    }
    #[test]
    fn bindgen_test_layout_SkMetaData_Iter() {
        assert_eq!(::std::mem::size_of::<SkMetaData_Iter>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkMetaData_Iter>() , 8usize);
    }
    extern "C" {
        /** Reset the iterator, so that calling next() will return the first
            data element. This is done implicitly in the constructor.
        */
        #[link_name = "?reset@Iter@SkMetaData@@QEAAXAEBV2@@Z"]
        pub fn SkMetaData_Iter_reset(this: *mut root::SkMetaData_Iter,
                                     arg1: *const root::SkMetaData);
    }
    extern "C" {
        /** Each time next is called, it returns the name of the next data element,
            or null when there are no more elements. If non-null is returned, then the
            element's type is returned (if not null), and the number of data values
            is returned in count (if not null).
        */
        #[link_name = "?next@Iter@SkMetaData@@QEAAPEBDPEAW4Type@2@PEAH@Z"]
        pub fn SkMetaData_Iter_next(this: *mut root::SkMetaData_Iter,
                                    arg1: *mut root::SkMetaData_Type,
                                    count: *mut ::std::os::raw::c_int)
         -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "??0Iter@SkMetaData@@QEAA@AEBV1@@Z"]
        pub fn SkMetaData_Iter_Iter(this: *mut root::SkMetaData_Iter,
                                    arg1: *const root::SkMetaData);
    }
    impl Clone for SkMetaData_Iter {
        fn clone(&self) -> Self { *self }
    }
    impl SkMetaData_Iter {
        #[inline]
        pub unsafe fn reset(&mut self, arg1: *const root::SkMetaData) {
            SkMetaData_Iter_reset(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn next(&mut self, arg1: *mut root::SkMetaData_Type,
                           count: *mut ::std::os::raw::c_int)
         -> *const ::std::os::raw::c_char {
            SkMetaData_Iter_next(&mut *self, arg1, count)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::SkMetaData) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkMetaData_Iter_Iter(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[test]
    fn bindgen_test_layout_SkMetaData() {
        assert_eq!(::std::mem::size_of::<SkMetaData>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkMetaData>() , 8usize);
    }
    extern "C" {
        /**
     *  Implements PtrProc for SkRefCnt pointers
     */
        #[link_name = "?RefCntProc@SkMetaData@@SAPEAXPEAX_N@Z"]
        pub fn SkMetaData_RefCntProc(ptr: *mut ::std::os::raw::c_void,
                                     doRef: bool)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?reset@SkMetaData@@QEAAXXZ"]
        pub fn SkMetaData_reset(this: *mut root::SkMetaData);
    }
    extern "C" {
        #[link_name = "?findS32@SkMetaData@@QEBA_NQEBDPEAH@Z"]
        pub fn SkMetaData_findS32(this: *const root::SkMetaData,
                                  name: *const ::std::os::raw::c_char,
                                  value: *mut i32) -> bool;
    }
    extern "C" {
        #[link_name = "?findScalar@SkMetaData@@QEBA_NQEBDPEAM@Z"]
        pub fn SkMetaData_findScalar(this: *const root::SkMetaData,
                                     name: *const ::std::os::raw::c_char,
                                     value: *mut root::SkScalar) -> bool;
    }
    extern "C" {
        #[link_name = "?findScalars@SkMetaData@@QEBAPEBMQEBDPEAHQEAM@Z"]
        pub fn SkMetaData_findScalars(this: *const root::SkMetaData,
                                      name: *const ::std::os::raw::c_char,
                                      count: *mut ::std::os::raw::c_int,
                                      values: *mut root::SkScalar)
         -> *const root::SkScalar;
    }
    extern "C" {
        #[link_name = "?findString@SkMetaData@@QEBAPEBDQEBD@Z"]
        pub fn SkMetaData_findString(this: *const root::SkMetaData,
                                     name: *const ::std::os::raw::c_char)
         -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name =
              "?findPtr@SkMetaData@@QEBA_NQEBDPEAPEAXPEAP6APEAXPEAX_N@Z@Z"]
        pub fn SkMetaData_findPtr(this: *const root::SkMetaData,
                                  name: *const ::std::os::raw::c_char,
                                  value: *mut *mut ::std::os::raw::c_void,
                                  arg1: *mut root::SkMetaData_PtrProc)
         -> bool;
    }
    extern "C" {
        #[link_name = "?findBool@SkMetaData@@QEBA_NQEBDPEA_N@Z"]
        pub fn SkMetaData_findBool(this: *const root::SkMetaData,
                                   name: *const ::std::os::raw::c_char,
                                   value: *mut bool) -> bool;
    }
    extern "C" {
        #[link_name = "?findData@SkMetaData@@QEBAPEBXQEBDPEA_K@Z"]
        pub fn SkMetaData_findData(this: *const root::SkMetaData,
                                   name: *const ::std::os::raw::c_char,
                                   byteCount: *mut usize)
         -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?setS32@SkMetaData@@QEAAXQEBDH@Z"]
        pub fn SkMetaData_setS32(this: *mut root::SkMetaData,
                                 name: *const ::std::os::raw::c_char,
                                 value: i32);
    }
    extern "C" {
        #[link_name = "?setScalar@SkMetaData@@QEAAXQEBDM@Z"]
        pub fn SkMetaData_setScalar(this: *mut root::SkMetaData,
                                    name: *const ::std::os::raw::c_char,
                                    value: root::SkScalar);
    }
    extern "C" {
        #[link_name = "?setScalars@SkMetaData@@QEAAPEAMQEBDHQEBM@Z"]
        pub fn SkMetaData_setScalars(this: *mut root::SkMetaData,
                                     name: *const ::std::os::raw::c_char,
                                     count: ::std::os::raw::c_int,
                                     values: *const root::SkScalar)
         -> *mut root::SkScalar;
    }
    extern "C" {
        #[link_name = "?setString@SkMetaData@@QEAAXQEBD0@Z"]
        pub fn SkMetaData_setString(this: *mut root::SkMetaData,
                                    name: *const ::std::os::raw::c_char,
                                    value: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "?setPtr@SkMetaData@@QEAAXQEBDPEAXP6APEAX1_N@Z@Z"]
        pub fn SkMetaData_setPtr(this: *mut root::SkMetaData,
                                 name: *const ::std::os::raw::c_char,
                                 value: *mut ::std::os::raw::c_void,
                                 proc_: root::SkMetaData_PtrProc);
    }
    extern "C" {
        #[link_name = "?setBool@SkMetaData@@QEAAXQEBD_N@Z"]
        pub fn SkMetaData_setBool(this: *mut root::SkMetaData,
                                  name: *const ::std::os::raw::c_char,
                                  value: bool);
    }
    extern "C" {
        #[link_name = "?setData@SkMetaData@@QEAAXQEBDPEBX_K@Z"]
        pub fn SkMetaData_setData(this: *mut root::SkMetaData,
                                  name: *const ::std::os::raw::c_char,
                                  data: *const ::std::os::raw::c_void,
                                  byteCount: usize);
    }
    extern "C" {
        #[link_name = "?removeS32@SkMetaData@@QEAA_NQEBD@Z"]
        pub fn SkMetaData_removeS32(this: *mut root::SkMetaData,
                                    name: *const ::std::os::raw::c_char)
         -> bool;
    }
    extern "C" {
        #[link_name = "?removeScalar@SkMetaData@@QEAA_NQEBD@Z"]
        pub fn SkMetaData_removeScalar(this: *mut root::SkMetaData,
                                       name: *const ::std::os::raw::c_char)
         -> bool;
    }
    extern "C" {
        #[link_name = "?removeString@SkMetaData@@QEAA_NQEBD@Z"]
        pub fn SkMetaData_removeString(this: *mut root::SkMetaData,
                                       name: *const ::std::os::raw::c_char)
         -> bool;
    }
    extern "C" {
        #[link_name = "?removePtr@SkMetaData@@QEAA_NQEBD@Z"]
        pub fn SkMetaData_removePtr(this: *mut root::SkMetaData,
                                    name: *const ::std::os::raw::c_char)
         -> bool;
    }
    extern "C" {
        #[link_name = "?removeBool@SkMetaData@@QEAA_NQEBD@Z"]
        pub fn SkMetaData_removeBool(this: *mut root::SkMetaData,
                                     name: *const ::std::os::raw::c_char)
         -> bool;
    }
    extern "C" {
        #[link_name = "?removeData@SkMetaData@@QEAA_NQEBD@Z"]
        pub fn SkMetaData_removeData(this: *mut root::SkMetaData,
                                     name: *const ::std::os::raw::c_char)
         -> bool;
    }
    extern "C" {
        #[link_name = "?find@SkMetaData@@QEBAPEBURec@1@QEBDW4Type@1@@Z"]
        pub fn SkMetaData_find(this: *const root::SkMetaData,
                               name: *const ::std::os::raw::c_char,
                               arg1: root::SkMetaData_Type)
         -> *const root::SkMetaData_Rec;
    }
    extern "C" {
        #[link_name = "?set@SkMetaData@@QEAAPEAXQEBDPEBX_KW4Type@1@H@Z"]
        pub fn SkMetaData_set(this: *mut root::SkMetaData,
                              name: *const ::std::os::raw::c_char,
                              data: *const ::std::os::raw::c_void, len: usize,
                              arg1: root::SkMetaData_Type,
                              count: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "?remove@SkMetaData@@QEAA_NQEBDW4Type@1@@Z"]
        pub fn SkMetaData_remove(this: *mut root::SkMetaData,
                                 name: *const ::std::os::raw::c_char,
                                 arg1: root::SkMetaData_Type) -> bool;
    }
    extern "C" {
        #[link_name = "??0SkMetaData@@QEAA@XZ"]
        pub fn SkMetaData_SkMetaData(this: *mut root::SkMetaData);
    }
    extern "C" {
        #[link_name = "??0SkMetaData@@QEAA@AEBV0@@Z"]
        pub fn SkMetaData_SkMetaData1(this: *mut root::SkMetaData,
                                      src: *const root::SkMetaData);
    }
    impl SkMetaData {
        #[inline]
        pub unsafe fn RefCntProc(ptr: *mut ::std::os::raw::c_void,
                                 doRef: bool) -> *mut ::std::os::raw::c_void {
            SkMetaData_RefCntProc(ptr, doRef)
        }
        #[inline]
        pub unsafe fn reset(&mut self) { SkMetaData_reset(&mut *self) }
        #[inline]
        pub unsafe fn findS32(&self, name: *const ::std::os::raw::c_char,
                              value: *mut i32) -> bool {
            SkMetaData_findS32(&*self, name, value)
        }
        #[inline]
        pub unsafe fn findScalar(&self, name: *const ::std::os::raw::c_char,
                                 value: *mut root::SkScalar) -> bool {
            SkMetaData_findScalar(&*self, name, value)
        }
        #[inline]
        pub unsafe fn findScalars(&self, name: *const ::std::os::raw::c_char,
                                  count: *mut ::std::os::raw::c_int,
                                  values: *mut root::SkScalar)
         -> *const root::SkScalar {
            SkMetaData_findScalars(&*self, name, count, values)
        }
        #[inline]
        pub unsafe fn findString(&self, name: *const ::std::os::raw::c_char)
         -> *const ::std::os::raw::c_char {
            SkMetaData_findString(&*self, name)
        }
        #[inline]
        pub unsafe fn findPtr(&self, name: *const ::std::os::raw::c_char,
                              value: *mut *mut ::std::os::raw::c_void,
                              arg1: *mut root::SkMetaData_PtrProc) -> bool {
            SkMetaData_findPtr(&*self, name, value, arg1)
        }
        #[inline]
        pub unsafe fn findBool(&self, name: *const ::std::os::raw::c_char,
                               value: *mut bool) -> bool {
            SkMetaData_findBool(&*self, name, value)
        }
        #[inline]
        pub unsafe fn findData(&self, name: *const ::std::os::raw::c_char,
                               byteCount: *mut usize)
         -> *const ::std::os::raw::c_void {
            SkMetaData_findData(&*self, name, byteCount)
        }
        #[inline]
        pub unsafe fn setS32(&mut self, name: *const ::std::os::raw::c_char,
                             value: i32) {
            SkMetaData_setS32(&mut *self, name, value)
        }
        #[inline]
        pub unsafe fn setScalar(&mut self,
                                name: *const ::std::os::raw::c_char,
                                value: root::SkScalar) {
            SkMetaData_setScalar(&mut *self, name, value)
        }
        #[inline]
        pub unsafe fn setScalars(&mut self,
                                 name: *const ::std::os::raw::c_char,
                                 count: ::std::os::raw::c_int,
                                 values: *const root::SkScalar)
         -> *mut root::SkScalar {
            SkMetaData_setScalars(&mut *self, name, count, values)
        }
        #[inline]
        pub unsafe fn setString(&mut self,
                                name: *const ::std::os::raw::c_char,
                                value: *const ::std::os::raw::c_char) {
            SkMetaData_setString(&mut *self, name, value)
        }
        #[inline]
        pub unsafe fn setPtr(&mut self, name: *const ::std::os::raw::c_char,
                             value: *mut ::std::os::raw::c_void,
                             proc_: root::SkMetaData_PtrProc) {
            SkMetaData_setPtr(&mut *self, name, value, proc_)
        }
        #[inline]
        pub unsafe fn setBool(&mut self, name: *const ::std::os::raw::c_char,
                              value: bool) {
            SkMetaData_setBool(&mut *self, name, value)
        }
        #[inline]
        pub unsafe fn setData(&mut self, name: *const ::std::os::raw::c_char,
                              data: *const ::std::os::raw::c_void,
                              byteCount: usize) {
            SkMetaData_setData(&mut *self, name, data, byteCount)
        }
        #[inline]
        pub unsafe fn removeS32(&mut self,
                                name: *const ::std::os::raw::c_char) -> bool {
            SkMetaData_removeS32(&mut *self, name)
        }
        #[inline]
        pub unsafe fn removeScalar(&mut self,
                                   name: *const ::std::os::raw::c_char)
         -> bool {
            SkMetaData_removeScalar(&mut *self, name)
        }
        #[inline]
        pub unsafe fn removeString(&mut self,
                                   name: *const ::std::os::raw::c_char)
         -> bool {
            SkMetaData_removeString(&mut *self, name)
        }
        #[inline]
        pub unsafe fn removePtr(&mut self,
                                name: *const ::std::os::raw::c_char) -> bool {
            SkMetaData_removePtr(&mut *self, name)
        }
        #[inline]
        pub unsafe fn removeBool(&mut self,
                                 name: *const ::std::os::raw::c_char)
         -> bool {
            SkMetaData_removeBool(&mut *self, name)
        }
        #[inline]
        pub unsafe fn removeData(&mut self,
                                 name: *const ::std::os::raw::c_char)
         -> bool {
            SkMetaData_removeData(&mut *self, name)
        }
        #[inline]
        pub unsafe fn find(&self, name: *const ::std::os::raw::c_char,
                           arg1: root::SkMetaData_Type)
         -> *const root::SkMetaData_Rec {
            SkMetaData_find(&*self, name, arg1)
        }
        #[inline]
        pub unsafe fn set(&mut self, name: *const ::std::os::raw::c_char,
                          data: *const ::std::os::raw::c_void, len: usize,
                          arg1: root::SkMetaData_Type,
                          count: ::std::os::raw::c_int)
         -> *mut ::std::os::raw::c_void {
            SkMetaData_set(&mut *self, name, data, len, arg1, count)
        }
        #[inline]
        pub unsafe fn remove(&mut self, name: *const ::std::os::raw::c_char,
                             arg1: root::SkMetaData_Type) -> bool {
            SkMetaData_remove(&mut *self, name, arg1)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkMetaData_SkMetaData(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(src: *const root::SkMetaData) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkMetaData_SkMetaData1(&mut __bindgen_tmp, src);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRasterClip {
        pub _address: u8,
    }
    impl Clone for SkRasterClip {
        fn clone(&self) -> Self { *self }
    }
    /** \class SkRRect

    The SkRRect class represents a rounded rect with a potentially different
    radii for each corner. It does not have a constructor so must be
    initialized with one of the initialization functions (e.g., setEmpty,
    setRectRadii, etc.)

    This class is intended to roughly match CSS' border-*-*-radius capabilities.
    This means:
        If either of a corner's radii are 0 the corner will be square.
        Negative radii are not allowed (they are clamped to zero).
        If the corner curves overlap they will be proportionally reduced to fit.
*/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRRect {
        pub fRect: root::SkRect,
        pub fRadii: [root::SkVector; 4usize],
        pub fType: i32,
    }
    #[repr(i32)]
    /**
     * Enum to capture the various possible subtypes of RR. Accessed
     * by type(). The subtypes become progressively less restrictive.
     */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRRect_Type {
        kEmpty_Type = 0,
        kRect_Type = 1,
        kOval_Type = 2,
        kSimple_Type = 3,
        kNinePatch_Type = 4,
        kComplex_Type = 5,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRRect_Corner {
        kUpperLeft_Corner = 0,
        kUpperRight_Corner = 1,
        kLowerRight_Corner = 2,
        kLowerLeft_Corner = 3,
    }
    pub const SkRRect_kSizeInMemory: root::SkRRect__bindgen_ty_1 =
        SkRRect__bindgen_ty_1::kSizeInMemory;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkRRect__bindgen_ty_1 { kSizeInMemory = 48, }
    #[test]
    fn bindgen_test_layout_SkRRect() {
        assert_eq!(::std::mem::size_of::<SkRRect>() , 52usize);
        assert_eq!(::std::mem::align_of::<SkRRect>() , 4usize);
    }
    extern "C" {
        #[link_name = "?allCornersCircular@SkRRect@@QEBA_NXZ"]
        pub fn SkRRect_allCornersCircular(this: *const root::SkRRect) -> bool;
    }
    extern "C" {
        /**
     * Initialize the RR with the same radii for all four corners.
     */
        #[link_name = "?setRectXY@SkRRect@@QEAAXAEBUSkRect@@MM@Z"]
        pub fn SkRRect_setRectXY(this: *mut root::SkRRect,
                                 rect: *const root::SkRect,
                                 xRad: root::SkScalar, yRad: root::SkScalar);
    }
    extern "C" {
        /**
     * Initialize the rr with one radius per-side.
     */
        #[link_name = "?setNinePatch@SkRRect@@QEAAXAEBUSkRect@@MMMM@Z"]
        pub fn SkRRect_setNinePatch(this: *mut root::SkRRect,
                                    rect: *const root::SkRect,
                                    leftRad: root::SkScalar,
                                    topRad: root::SkScalar,
                                    rightRad: root::SkScalar,
                                    bottomRad: root::SkScalar);
    }
    extern "C" {
        /**
     * Initialize the RR with potentially different radii for all four corners.
     */
        #[link_name =
              "?setRectRadii@SkRRect@@QEAAXAEBUSkRect@@QEBUSkPoint@@@Z"]
        pub fn SkRRect_setRectRadii(this: *mut root::SkRRect,
                                    rect: *const root::SkRect,
                                    radii: *mut root::SkVector);
    }
    extern "C" {
        /**
     *  Call inset on the bounds, and adjust the radii to reflect what happens
     *  in stroking: If the corner is sharp (no curvature), leave it alone,
     *  otherwise we grow/shrink the radii by the amount of the inset. If a
     *  given radius becomes negative, it is pinned to 0.
     *
     *  It is valid for dst == this.
     */
        #[link_name = "?inset@SkRRect@@QEBAXMMPEAV1@@Z"]
        pub fn SkRRect_inset(this: *const root::SkRRect, dx: root::SkScalar,
                             dy: root::SkScalar, dst: *mut root::SkRRect);
    }
    extern "C" {
        /**
     *  Returns true if 'rect' is wholy inside the RR, and both
     *  are not empty.
     */
        #[link_name = "?contains@SkRRect@@QEBA_NAEBUSkRect@@@Z"]
        pub fn SkRRect_contains(this: *const root::SkRRect,
                                rect: *const root::SkRect) -> bool;
    }
    extern "C" {
        #[link_name = "?isValid@SkRRect@@QEBA_NXZ"]
        pub fn SkRRect_isValid(this: *const root::SkRRect) -> bool;
    }
    extern "C" {
        /**
     *  Write the rrect into the specified buffer. This is guaranteed to always
     *  write kSizeInMemory bytes, and that value is guaranteed to always be
     *  a multiple of 4. Return kSizeInMemory.
     */
        #[link_name = "?writeToMemory@SkRRect@@QEBA_KPEAX@Z"]
        pub fn SkRRect_writeToMemory(this: *const root::SkRRect,
                                     buffer: *mut ::std::os::raw::c_void)
         -> usize;
    }
    extern "C" {
        /**
     * Reads the rrect from the specified buffer
     *
     * If the specified buffer is large enough, this will read kSizeInMemory bytes,
     * and that value is guaranteed to always be a multiple of 4.
     *
     * @param buffer Memory to read from
     * @param length Amount of memory available in the buffer
     * @return number of bytes read (must be a multiple of 4) or
     *         0 if there was not enough memory available
     */
        #[link_name = "?readFromMemory@SkRRect@@QEAA_KPEBX_K@Z"]
        pub fn SkRRect_readFromMemory(this: *mut root::SkRRect,
                                      buffer: *const ::std::os::raw::c_void,
                                      length: usize) -> usize;
    }
    extern "C" {
        /**
     *  Transform by the specified matrix, and put the result in dst.
     *
     *  @param matrix SkMatrix specifying the transform. Must only contain
     *      scale and/or translate, or this call will fail.
     *  @param dst SkRRect to store the result. It is an error to use this,
     *      which would make this function no longer const.
     *  @return true on success, false on failure. If false, dst is unmodified.
     */
        #[link_name = "?transform@SkRRect@@QEBA_NAEBVSkMatrix@@PEAV1@@Z"]
        pub fn SkRRect_transform(this: *const root::SkRRect,
                                 matrix: *const root::SkMatrix,
                                 dst: *mut root::SkRRect) -> bool;
    }
    extern "C" {
        #[link_name = "?dump@SkRRect@@QEBAX_N@Z"]
        pub fn SkRRect_dump(this: *const root::SkRRect, asHex: bool);
    }
    impl Clone for SkRRect {
        fn clone(&self) -> Self { *self }
    }
    impl SkRRect {
        #[inline]
        pub unsafe fn allCornersCircular(&self) -> bool {
            SkRRect_allCornersCircular(&*self)
        }
        #[inline]
        pub unsafe fn setRectXY(&mut self, rect: *const root::SkRect,
                                xRad: root::SkScalar, yRad: root::SkScalar) {
            SkRRect_setRectXY(&mut *self, rect, xRad, yRad)
        }
        #[inline]
        pub unsafe fn setNinePatch(&mut self, rect: *const root::SkRect,
                                   leftRad: root::SkScalar,
                                   topRad: root::SkScalar,
                                   rightRad: root::SkScalar,
                                   bottomRad: root::SkScalar) {
            SkRRect_setNinePatch(&mut *self, rect, leftRad, topRad, rightRad,
                                 bottomRad)
        }
        #[inline]
        pub unsafe fn setRectRadii(&mut self, rect: *const root::SkRect,
                                   radii: *mut root::SkVector) {
            SkRRect_setRectRadii(&mut *self, rect, radii)
        }
        #[inline]
        pub unsafe fn inset(&self, dx: root::SkScalar, dy: root::SkScalar,
                            dst: *mut root::SkRRect) {
            SkRRect_inset(&*self, dx, dy, dst)
        }
        #[inline]
        pub unsafe fn contains(&self, rect: *const root::SkRect) -> bool {
            SkRRect_contains(&*self, rect)
        }
        #[inline]
        pub unsafe fn isValid(&self) -> bool { SkRRect_isValid(&*self) }
        #[inline]
        pub unsafe fn writeToMemory(&self,
                                    buffer: *mut ::std::os::raw::c_void)
         -> usize {
            SkRRect_writeToMemory(&*self, buffer)
        }
        #[inline]
        pub unsafe fn readFromMemory(&mut self,
                                     buffer: *const ::std::os::raw::c_void,
                                     length: usize) -> usize {
            SkRRect_readFromMemory(&mut *self, buffer, length)
        }
        #[inline]
        pub unsafe fn transform(&self, matrix: *const root::SkMatrix,
                                dst: *mut root::SkRRect) -> bool {
            SkRRect_transform(&*self, matrix, dst)
        }
        #[inline]
        pub unsafe fn dump(&self, asHex: bool) { SkRRect_dump(&*self, asHex) }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkSurface_Base {
        pub _address: u8,
    }
    impl Clone for SkSurface_Base {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImageFilterCache {
        pub _address: u8,
    }
    impl Clone for SkImageFilterCache {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkSpecialImage {
        pub _address: u8,
    }
    impl Clone for SkSpecialImage {
        fn clone(&self) -> Self { *self }
    }
    pub const SkBlurStyle_kLastEnum_SkBlurStyle: root::SkBlurStyle =
        SkBlurStyle::kInner_SkBlurStyle;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkBlurStyle {
        kNormal_SkBlurStyle = 0,
        kSolid_SkBlurStyle = 1,
        kOuter_SkBlurStyle = 2,
        kInner_SkBlurStyle = 3,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkBlurQuality {
        kLow_SkBlurQuality = 0,
        kHigh_SkBlurQuality = 1,
        kLastEnum_SkBlurQuality = 2,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkTDArray<T> {
        pub fArray: *mut T,
        pub fReserve: ::std::os::raw::c_int,
        pub fCount: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkRBuffer {
        pub _address: u8,
    }
    impl Clone for SkRBuffer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkWBuffer {
        pub _address: u8,
    }
    impl Clone for SkWBuffer {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_20() {
        assert_eq!(::std::mem::size_of::<root::SkNVRefCnt<root::SkPathRef>>()
                   , 4usize);
        assert_eq!(::std::mem::align_of::<root::SkNVRefCnt<root::SkPathRef>>()
                   , 4usize);
    }
    /**
 * Holds the path verbs and points. It is versioned by a generation ID. None of its public methods
 * modify the contents. To modify or append to the verbs/points wrap the SkPathRef in an
 * SkPathRef::Editor object. Installing the editor resets the generation ID. It also performs
 * copy-on-write if the SkPathRef is shared by multiple SkPaths. The caller passes the Editor's
 * constructor a pointer to a sk_sp<SkPathRef>, which may be updated to point to a new SkPathRef
 * after the editor's constructor returns.
 *
 * The points and verbs are stored in a single allocation. The points are at the begining of the
 * allocation while the verbs are stored at end of the allocation, in reverse order. Thus the points
 * and verbs both grow into the middle of the allocation until the meet. To access verb i in the
 * verb array use ref.verbs()[~i] (because verbs() returns a pointer just beyond the first
 * logical verb or the last verb in memory).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPathRef {
        pub _base: root::SkNVRefCnt<root::SkPathRef>,
        pub fBounds: root::SkRect,
        pub fPoints: *mut root::SkPoint,
        pub fVerbs: *mut u8,
        pub fVerbCnt: ::std::os::raw::c_int,
        pub fPointCnt: ::std::os::raw::c_int,
        pub fFreeSpace: usize,
        pub fConicWeights: root::SkTDArray<f32>,
        pub fGenerationID: u32,
        pub fEditorsAttached: i32,
        pub fGenIDChangeListeners: root::SkTDArray<*mut root::SkPathRef_GenIDChangeListener>,
        pub fBoundsIsDirty: u8,
        pub fIsFinite: root::SkBool8,
        pub fIsOval: root::SkBool8,
        pub fIsRRect: root::SkBool8,
        pub fRRectOrOvalIsCCW: root::SkBool8,
        pub fRRectOrOvalStartIdx: u8,
        pub fSegmentMask: u8,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPathRef_Editor {
        pub fPathRef: *mut root::SkPathRef,
    }
    #[test]
    fn bindgen_test_layout_SkPathRef_Editor() {
        assert_eq!(::std::mem::size_of::<SkPathRef_Editor>() , 8usize);
        assert_eq!(::std::mem::align_of::<SkPathRef_Editor>() , 8usize);
    }
    extern "C" {
        #[link_name =
              "??0Editor@SkPathRef@@QEAA@PEAV?$sk_sp@VSkPathRef@@@@HH@Z"]
        pub fn SkPathRef_Editor_Editor(this: *mut root::SkPathRef_Editor,
                                       pathRef:
                                           *mut root::sk_sp<root::SkPathRef>,
                                       incReserveVerbs: ::std::os::raw::c_int,
                                       incReservePoints:
                                           ::std::os::raw::c_int);
    }
    impl SkPathRef_Editor {
        #[inline]
        pub unsafe fn new(pathRef: *mut root::sk_sp<root::SkPathRef>,
                          incReserveVerbs: ::std::os::raw::c_int,
                          incReservePoints: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPathRef_Editor_Editor(&mut __bindgen_tmp, pathRef,
                                    incReserveVerbs, incReservePoints);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPathRef_Iter {
        pub fPts: *const root::SkPoint,
        pub fVerbs: *const u8,
        pub fVerbStop: *const u8,
        pub fConicWeights: *const root::SkScalar,
    }
    #[test]
    fn bindgen_test_layout_SkPathRef_Iter() {
        assert_eq!(::std::mem::size_of::<SkPathRef_Iter>() , 32usize);
        assert_eq!(::std::mem::align_of::<SkPathRef_Iter>() , 8usize);
    }
    extern "C" {
        #[link_name = "?setPathRef@Iter@SkPathRef@@QEAAXAEBV2@@Z"]
        pub fn SkPathRef_Iter_setPathRef(this: *mut root::SkPathRef_Iter,
                                         arg1: *const root::SkPathRef);
    }
    extern "C" {
        /** Return the next verb in this iteration of the path. When all
            segments have been visited, return kDone_Verb.

            @param  pts The points representing the current verb and/or segment
                        This must not be NULL.
            @return The verb for the current segment
        */
        #[link_name = "?next@Iter@SkPathRef@@QEAAEQEAUSkPoint@@@Z"]
        pub fn SkPathRef_Iter_next(this: *mut root::SkPathRef_Iter,
                                   pts: *mut root::SkPoint) -> u8;
    }
    extern "C" {
        #[link_name = "?peek@Iter@SkPathRef@@QEBAEXZ"]
        pub fn SkPathRef_Iter_peek(this: *const root::SkPathRef_Iter) -> u8;
    }
    extern "C" {
        #[link_name = "??0Iter@SkPathRef@@QEAA@XZ"]
        pub fn SkPathRef_Iter_Iter(this: *mut root::SkPathRef_Iter);
    }
    extern "C" {
        #[link_name = "??0Iter@SkPathRef@@QEAA@AEBV1@@Z"]
        pub fn SkPathRef_Iter_Iter1(this: *mut root::SkPathRef_Iter,
                                    arg1: *const root::SkPathRef);
    }
    impl Clone for SkPathRef_Iter {
        fn clone(&self) -> Self { *self }
    }
    impl SkPathRef_Iter {
        #[inline]
        pub unsafe fn setPathRef(&mut self, arg1: *const root::SkPathRef) {
            SkPathRef_Iter_setPathRef(&mut *self, arg1)
        }
        #[inline]
        pub unsafe fn next(&mut self, pts: *mut root::SkPoint) -> u8 {
            SkPathRef_Iter_next(&mut *self, pts)
        }
        #[inline]
        pub unsafe fn peek(&self) -> u8 { SkPathRef_Iter_peek(&*self) }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPathRef_Iter_Iter(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::SkPathRef) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkPathRef_Iter_Iter1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    pub struct SkPathRef_GenIDChangeListener__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkPathRef_GenIDChangeListener {
        pub vtable_: *const SkPathRef_GenIDChangeListener__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SkPathRef_GenIDChangeListener() {
        assert_eq!(::std::mem::size_of::<SkPathRef_GenIDChangeListener>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<SkPathRef_GenIDChangeListener>() ,
                   8usize);
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPathRef_SerializationOffsets {
        kRRectOrOvalStartIdx_SerializationShift = 28,
        kRRectOrOvalIsCCW_SerializationShift = 27,
        kIsRRect_SerializationShift = 26,
        kIsFinite_SerializationShift = 25,
        kIsOval_SerializationShift = 24,
        kSegmentMask_SerializationShift = 0,
    }
    pub const SkPathRef_kMinSize: root::SkPathRef__bindgen_ty_1 =
        SkPathRef__bindgen_ty_1::kMinSize;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPathRef__bindgen_ty_1 { kMinSize = 256, }
    pub const SkPathRef_kEmptyGenID: root::SkPathRef__bindgen_ty_2 =
        SkPathRef__bindgen_ty_2::kEmptyGenID;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkPathRef__bindgen_ty_2 { kEmptyGenID = 1, }
    #[test]
    fn bindgen_test_layout_SkPathRef() {
        assert_eq!(::std::mem::size_of::<SkPathRef>() , 104usize);
        assert_eq!(::std::mem::align_of::<SkPathRef>() , 8usize);
    }
    extern "C" {
        /**
     * Gets a path ref with no verbs or points.
     */
        #[link_name = "?CreateEmpty@SkPathRef@@SAPEAV1@XZ"]
        pub fn SkPathRef_CreateEmpty() -> *mut root::SkPathRef;
    }
    extern "C" {
        #[link_name = "?getRRect@SkPathRef@@QEBA?AVSkRRect@@XZ"]
        pub fn SkPathRef_getRRect(this: *const root::SkPathRef)
         -> root::SkRRect;
    }
    extern "C" {
        /**
     * Transforms a path ref by a matrix, allocating a new one only if necessary.
     */
        #[link_name =
              "?CreateTransformedCopy@SkPathRef@@SAXPEAV?$sk_sp@VSkPathRef@@@@AEBV1@AEBVSkMatrix@@@Z"]
        pub fn SkPathRef_CreateTransformedCopy(dst:
                                                   *mut root::sk_sp<root::SkPathRef>,
                                               src: *const root::SkPathRef,
                                               matrix: *const root::SkMatrix);
    }
    extern "C" {
        #[link_name =
              "?CreateFromBuffer@SkPathRef@@SAPEAV1@PEAVSkRBuffer@@@Z"]
        pub fn SkPathRef_CreateFromBuffer(buffer: *mut root::SkRBuffer)
         -> *mut root::SkPathRef;
    }
    extern "C" {
        /**
     * Rollsback a path ref to zero verbs and points with the assumption that the path ref will be
     * repopulated with approximately the same number of verbs and points. A new path ref is created
     * only if necessary.
     */
        #[link_name = "?Rewind@SkPathRef@@SAXPEAV?$sk_sp@VSkPathRef@@@@@Z"]
        pub fn SkPathRef_Rewind(pathRef: *mut root::sk_sp<root::SkPathRef>);
    }
    extern "C" {
        /**
     * Writes the path points and verbs to a buffer.
     */
        #[link_name = "?writeToBuffer@SkPathRef@@QEBAXPEAVSkWBuffer@@@Z"]
        pub fn SkPathRef_writeToBuffer(this: *const root::SkPathRef,
                                       buffer: *mut root::SkWBuffer);
    }
    extern "C" {
        /**
     * Gets the number of bytes that would be written in writeBuffer()
     */
        #[link_name = "?writeSize@SkPathRef@@QEBAIXZ"]
        pub fn SkPathRef_writeSize(this: *const root::SkPathRef) -> u32;
    }
    extern "C" {
        #[link_name = "?interpolate@SkPathRef@@QEBAXAEBV1@MPEAV1@@Z"]
        pub fn SkPathRef_interpolate(this: *const root::SkPathRef,
                                     ending: *const root::SkPathRef,
                                     weight: root::SkScalar,
                                     out: *mut root::SkPathRef);
    }
    extern "C" {
        /**
     * Gets an ID that uniquely identifies the contents of the path ref. If two path refs have the
     * same ID then they have the same verbs and points. However, two path refs may have the same
     * contents but different genIDs.
     */
        #[link_name = "?genID@SkPathRef@@QEBAIXZ"]
        pub fn SkPathRef_genID(this: *const root::SkPathRef) -> u32;
    }
    extern "C" {
        #[link_name =
              "?addGenIDChangeListener@SkPathRef@@QEAAXPEAUGenIDChangeListener@1@@Z"]
        pub fn SkPathRef_addGenIDChangeListener(this: *mut root::SkPathRef,
                                                listener:
                                                    *mut root::SkPathRef_GenIDChangeListener);
    }
    extern "C" {
        #[link_name = "?validate@SkPathRef@@QEBAXXZ"]
        pub fn SkPathRef_validate(this: *const root::SkPathRef);
    }
    impl SkPathRef {
        #[inline]
        pub unsafe fn CreateEmpty() -> *mut root::SkPathRef {
            SkPathRef_CreateEmpty()
        }
        #[inline]
        pub unsafe fn getRRect(&self) -> root::SkRRect {
            SkPathRef_getRRect(&*self)
        }
        #[inline]
        pub unsafe fn CreateTransformedCopy(dst:
                                                *mut root::sk_sp<root::SkPathRef>,
                                            src: *const root::SkPathRef,
                                            matrix: *const root::SkMatrix) {
            SkPathRef_CreateTransformedCopy(dst, src, matrix)
        }
        #[inline]
        pub unsafe fn CreateFromBuffer(buffer: *mut root::SkRBuffer)
         -> *mut root::SkPathRef {
            SkPathRef_CreateFromBuffer(buffer)
        }
        #[inline]
        pub unsafe fn Rewind(pathRef: *mut root::sk_sp<root::SkPathRef>) {
            SkPathRef_Rewind(pathRef)
        }
        #[inline]
        pub unsafe fn writeToBuffer(&self, buffer: *mut root::SkWBuffer) {
            SkPathRef_writeToBuffer(&*self, buffer)
        }
        #[inline]
        pub unsafe fn writeSize(&self) -> u32 { SkPathRef_writeSize(&*self) }
        #[inline]
        pub unsafe fn interpolate(&self, ending: *const root::SkPathRef,
                                  weight: root::SkScalar,
                                  out: *mut root::SkPathRef) {
            SkPathRef_interpolate(&*self, ending, weight, out)
        }
        #[inline]
        pub unsafe fn genID(&self) -> u32 { SkPathRef_genID(&*self) }
        #[inline]
        pub unsafe fn addGenIDChangeListener(&mut self,
                                             listener:
                                                 *mut root::SkPathRef_GenIDChangeListener) {
            SkPathRef_addGenIDChangeListener(&mut *self, listener)
        }
        #[inline]
        pub unsafe fn validate(&self) { SkPathRef_validate(&*self) }
    }
    /**
 *  Efficient way to defer allocating/initializing a class until it is needed
 *  (if ever).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkTLazy<T> {
        pub fStorage: (),
        pub fPtr: *mut T,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImageDeserializer {
        pub _address: u8,
    }
    impl Clone for SkImageDeserializer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkPictInfo {
        pub _address: u8,
    }
    impl Clone for SkPictInfo {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkStrokeRec {
        pub fResScale: root::SkScalar,
        pub fWidth: root::SkScalar,
        pub fMiterLimit: root::SkScalar,
        pub _bitfield_1: u32,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkStrokeRec_Style {
        kHairline_Style = 0,
        kFill_Style = 1,
        kStroke_Style = 2,
        kStrokeAndFill_Style = 3,
    }
    pub const SkStrokeRec_kStyleCount: root::SkStrokeRec__bindgen_ty_1 =
        SkStrokeRec__bindgen_ty_1::kStyleCount;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkStrokeRec__bindgen_ty_1 { kStyleCount = 4, }
    #[test]
    fn bindgen_test_layout_SkStrokeRec() {
        assert_eq!(::std::mem::size_of::<SkStrokeRec>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkStrokeRec>() , 4usize);
    }
    extern "C" {
        #[link_name = "?getStyle@SkStrokeRec@@QEBA?AW4Style@1@XZ"]
        pub fn SkStrokeRec_getStyle(this: *const root::SkStrokeRec)
         -> root::SkStrokeRec_Style;
    }
    extern "C" {
        #[link_name = "?setFillStyle@SkStrokeRec@@QEAAXXZ"]
        pub fn SkStrokeRec_setFillStyle(this: *mut root::SkStrokeRec);
    }
    extern "C" {
        #[link_name = "?setHairlineStyle@SkStrokeRec@@QEAAXXZ"]
        pub fn SkStrokeRec_setHairlineStyle(this: *mut root::SkStrokeRec);
    }
    extern "C" {
        /**
     *  Specify the strokewidth, and optionally if you want stroke + fill.
     *  Note, if width==0, then this request is taken to mean:
     *      strokeAndFill==true -> new style will be Fill
     *      strokeAndFill==false -> new style will be Hairline
     */
        #[link_name = "?setStrokeStyle@SkStrokeRec@@QEAAXM_N@Z"]
        pub fn SkStrokeRec_setStrokeStyle(this: *mut root::SkStrokeRec,
                                          width: root::SkScalar,
                                          strokeAndFill: bool);
    }
    extern "C" {
        /**
     *  Apply these stroke parameters to the src path, returning the result
     *  in dst.
     *
     *  If there was no change (i.e. style == hairline or fill) this returns
     *  false and dst is unchanged. Otherwise returns true and the result is
     *  stored in dst.
     *
     *  src and dst may be the same path.
     */
        #[link_name = "?applyToPath@SkStrokeRec@@QEBA_NPEAVSkPath@@AEBV2@@Z"]
        pub fn SkStrokeRec_applyToPath(this: *const root::SkStrokeRec,
                                       dst: *mut root::SkPath,
                                       src: *const root::SkPath) -> bool;
    }
    extern "C" {
        /**
     *  Apply these stroke parameters to a paint.
     */
        #[link_name = "?applyToPaint@SkStrokeRec@@QEBAXPEAVSkPaint@@@Z"]
        pub fn SkStrokeRec_applyToPaint(this: *const root::SkStrokeRec,
                                        paint: *mut root::SkPaint);
    }
    extern "C" {
        /**
     * Gives a conservative value for the outset that should applied to a
     * geometries bounds to account for any inflation due to applying this
     * strokeRec to the geometry.
     */
        #[link_name = "?getInflationRadius@SkStrokeRec@@QEBAMXZ"]
        pub fn SkStrokeRec_getInflationRadius(this: *const root::SkStrokeRec)
         -> root::SkScalar;
    }
    extern "C" {
        /**
     * Equivalent to:
     *   SkStrokeRec rec(paint, style);
     *   rec.getInflationRadius();
     * This does not account for other effects on the paint (i.e. path
     * effect).
     */
        #[link_name =
              "?GetInflationRadius@SkStrokeRec@@SAMAEBVSkPaint@@W4Style@2@@Z"]
        pub fn SkStrokeRec_GetInflationRadius(arg1: *const root::SkPaint,
                                              arg2: root::SkPaint_Style)
         -> root::SkScalar;
    }
    extern "C" {
        #[link_name = "??0SkStrokeRec@@QEAA@W4InitStyle@0@@Z"]
        pub fn SkStrokeRec_SkStrokeRec(this: *mut root::SkStrokeRec,
                                       style: root::InitStyle);
    }
    extern "C" {
        #[link_name = "??0SkStrokeRec@@QEAA@AEBVSkPaint@@W4Style@1@M@Z"]
        pub fn SkStrokeRec_SkStrokeRec1(this: *mut root::SkStrokeRec,
                                        arg1: *const root::SkPaint,
                                        arg2: root::SkPaint_Style,
                                        resScale: root::SkScalar);
    }
    extern "C" {
        #[link_name = "??0SkStrokeRec@@QEAA@AEBVSkPaint@@M@Z"]
        pub fn SkStrokeRec_SkStrokeRec2(this: *mut root::SkStrokeRec,
                                        arg1: *const root::SkPaint,
                                        resScale: root::SkScalar);
    }
    impl Clone for SkStrokeRec {
        fn clone(&self) -> Self { *self }
    }
    impl SkStrokeRec {
        #[inline]
        pub fn fCap(&self) -> u32 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (65535usize as u32)) >> 0u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_fCap(&mut self, val: u32) {
            self._bitfield_1 &= !(65535usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 0u32) & (65535usize as u32);
        }
        #[inline]
        pub fn fJoin(&self) -> u32 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2147418112usize as u32)) >>
                                           16u32) as u32)
            }
        }
        #[inline]
        pub fn set_fJoin(&mut self, val: u32) {
            self._bitfield_1 &= !(2147418112usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 16u32) & (2147418112usize as u32);
        }
        #[inline]
        pub fn fStrokeAndFill(&self) -> u32 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2147483648usize as u32)) >>
                                           31u32) as u32)
            }
        }
        #[inline]
        pub fn set_fStrokeAndFill(&mut self, val: u32) {
            self._bitfield_1 &= !(2147483648usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
        }
        #[inline]
        pub unsafe fn getStyle(&self) -> root::SkStrokeRec_Style {
            SkStrokeRec_getStyle(&*self)
        }
        #[inline]
        pub unsafe fn setFillStyle(&mut self) {
            SkStrokeRec_setFillStyle(&mut *self)
        }
        #[inline]
        pub unsafe fn setHairlineStyle(&mut self) {
            SkStrokeRec_setHairlineStyle(&mut *self)
        }
        #[inline]
        pub unsafe fn setStrokeStyle(&mut self, width: root::SkScalar,
                                     strokeAndFill: bool) {
            SkStrokeRec_setStrokeStyle(&mut *self, width, strokeAndFill)
        }
        #[inline]
        pub unsafe fn applyToPath(&self, dst: *mut root::SkPath,
                                  src: *const root::SkPath) -> bool {
            SkStrokeRec_applyToPath(&*self, dst, src)
        }
        #[inline]
        pub unsafe fn applyToPaint(&self, paint: *mut root::SkPaint) {
            SkStrokeRec_applyToPaint(&*self, paint)
        }
        #[inline]
        pub unsafe fn getInflationRadius(&self) -> root::SkScalar {
            SkStrokeRec_getInflationRadius(&*self)
        }
        #[inline]
        pub unsafe fn GetInflationRadius(arg1: *const root::SkPaint,
                                         arg2: root::SkPaint_Style)
         -> root::SkScalar {
            SkStrokeRec_GetInflationRadius(arg1, arg2)
        }
        #[inline]
        pub unsafe fn new(style: root::InitStyle) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkStrokeRec_SkStrokeRec(&mut __bindgen_tmp, style);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::SkPaint,
                           arg2: root::SkPaint_Style,
                           resScale: root::SkScalar) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkStrokeRec_SkStrokeRec1(&mut __bindgen_tmp, arg1, arg2,
                                     resScale);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(arg1: *const root::SkPaint,
                           resScale: root::SkScalar) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SkStrokeRec_SkStrokeRec2(&mut __bindgen_tmp, arg1, resScale);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkBaseSemaphore {
        pub fCount: u32,
        pub fOSSemaphoreOnce: root::SkOnce,
        pub fOSSemaphore: *mut root::SkBaseSemaphore_OSSemaphore,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkBaseSemaphore_OSSemaphore {
        pub _address: u8,
    }
    impl Clone for SkBaseSemaphore_OSSemaphore {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_SkBaseSemaphore() {
        assert_eq!(::std::mem::size_of::<SkBaseSemaphore>() , 16usize);
        assert_eq!(::std::mem::align_of::<SkBaseSemaphore>() , 8usize);
    }
    extern "C" {
        #[link_name = "?signal@SkBaseSemaphore@@QEAAXH@Z"]
        pub fn SkBaseSemaphore_signal(this: *mut root::SkBaseSemaphore,
                                      n: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "?wait@SkBaseSemaphore@@QEAAXXZ"]
        pub fn SkBaseSemaphore_wait(this: *mut root::SkBaseSemaphore);
    }
    extern "C" {
        #[link_name = "?cleanup@SkBaseSemaphore@@QEAAXXZ"]
        pub fn SkBaseSemaphore_cleanup(this: *mut root::SkBaseSemaphore);
    }
    impl Clone for SkBaseSemaphore {
        fn clone(&self) -> Self { *self }
    }
    impl SkBaseSemaphore {
        #[inline]
        pub unsafe fn signal(&mut self, n: ::std::os::raw::c_int) {
            SkBaseSemaphore_signal(&mut *self, n)
        }
        #[inline]
        pub unsafe fn wait(&mut self) { SkBaseSemaphore_wait(&mut *self) }
        #[inline]
        pub unsafe fn cleanup(&mut self) {
            SkBaseSemaphore_cleanup(&mut *self)
        }
    }
    pub type SkThreadID = i64;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkBaseMutex {
        pub fSemaphore: root::SkBaseSemaphore,
        pub fOwner: root::SkThreadID,
    }
    #[test]
    fn bindgen_test_layout_SkBaseMutex() {
        assert_eq!(::std::mem::size_of::<SkBaseMutex>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkBaseMutex>() , 8usize);
    }
    impl Clone for SkBaseMutex {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SkMutex {
        pub _base: root::SkBaseMutex,
    }
    #[test]
    fn bindgen_test_layout_SkMutex() {
        assert_eq!(::std::mem::size_of::<SkMutex>() , 24usize);
        assert_eq!(::std::mem::align_of::<SkMutex>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkImageFilterCacheKey {
        pub _address: u8,
    }
    impl Clone for SkImageFilterCacheKey {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkYUVSizeInfo {
        pub fSizes: [root::SkISize; 3usize],
        /**
     * While the widths of the Y, U, and V planes are not restricted, the
     * implementation often requires that the width of the memory allocated
     * for each plane be a multiple of 8.
     *
     * This struct allows us to inform the client how many "widthBytes"
     * that we need.  Note that we use the new idea of "widthBytes"
     * because this idea is distinct from "rowBytes" (used elsewhere in
     * Skia).  "rowBytes" allow the last row of the allocation to not
     * include any extra padding, while, in this case, every single row of
     * the allocation must be at least "widthBytes".
     */
        pub fWidthBytes: [usize; 3usize],
    }
    pub const SkYUVSizeInfo_kY: root::SkYUVSizeInfo__bindgen_ty_1 =
        SkYUVSizeInfo__bindgen_ty_1::kY;
    pub const SkYUVSizeInfo_kU: root::SkYUVSizeInfo__bindgen_ty_1 =
        SkYUVSizeInfo__bindgen_ty_1::kU;
    pub const SkYUVSizeInfo_kV: root::SkYUVSizeInfo__bindgen_ty_1 =
        SkYUVSizeInfo__bindgen_ty_1::kV;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum SkYUVSizeInfo__bindgen_ty_1 { kY = 0, kU = 1, kV = 2, }
    #[test]
    fn bindgen_test_layout_SkYUVSizeInfo() {
        assert_eq!(::std::mem::size_of::<SkYUVSizeInfo>() , 48usize);
        assert_eq!(::std::mem::align_of::<SkYUVSizeInfo>() , 8usize);
    }
    impl Clone for SkYUVSizeInfo {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrClip {
        pub _address: u8,
    }
    impl Clone for GrClip {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrPaint {
        pub _address: u8,
    }
    impl Clone for GrPaint {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GrTextureProvider {
        pub _address: u8,
    }
    impl Clone for GrTextureProvider {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkCachedData {
        pub _address: u8,
    }
    impl Clone for SkCachedData {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkFontData {
        pub _address: u8,
    }
    impl Clone for SkFontData {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkFontDescriptor {
        pub _address: u8,
    }
    impl Clone for SkFontDescriptor {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkScalerContext {
        pub _address: u8,
    }
    impl Clone for SkScalerContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkScalerContextRec {
        pub _address: u8,
    }
    impl Clone for SkScalerContextRec {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkAdvancedTypefaceMetrics {
        pub _address: u8,
    }
    impl Clone for SkAdvancedTypefaceMetrics {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct SkDeduper {
        pub _address: u8,
    }
    impl Clone for SkDeduper {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn __bindgen_test_layout_template_21() {
        assert_eq!(::std::mem::size_of::<root::SkTSize<::std::os::raw::c_int>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::SkTSize<::std::os::raw::c_int>>()
                   , 4usize);
    }
    #[test]
    fn __bindgen_test_layout_template_22() {
        assert_eq!(::std::mem::size_of::<root::std::default_delete<root::SkCanvas>>()
                   , 1usize);
        assert_eq!(::std::mem::align_of::<root::std::default_delete<root::SkCanvas>>()
                   , 1usize);
    }
}
